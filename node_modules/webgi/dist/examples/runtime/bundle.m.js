/*! For license information please see bundle.m.js.LICENSE.txt */
var __webpackgi_modules__ = {
        987: function(e, t, n) {
            var r = n(445),
                i = n.n(r),
                s = n(352),
                o = n.n(s)()(i());
            o.push([e.id, "#assetManagerPopup{z-index:300;position:absolute;bottom:2rem;right:2rem;-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);color:#fff;background-blend-mode:luminosity;background-color:#28223CAA;padding:1.5rem;font-size:1rem;width:-webkit-max-content;width:-moz-max-content;width:max-content;max-width:80vw;max-height:80vh;overflow-y:scroll;border-radius:.5rem;height:-webkit-max-content;height:-moz-max-content;height:max-content}#assetManagerPopupClose{position:absolute;top:0;right:0;padding:.5rem;cursor:pointer}#assetManagerPopupContent{padding-top:.5rem}.processState{font-weight:bold}", "", {
                version: 3,
                sources: ["webpack://./src/extras/asset_manager/styles/popup.scss"],
                names: [],
                mappings: "AAAA,mBACE,WAAA,CACA,iBAAA,CACA,WAAA,CACA,UAAA,CACA,kCAAA,CAAA,0BAAA,CACA,UAAA,CACA,gCAAA,CACA,0BAAA,CACA,cAAA,CACA,cAAA,CACA,yBAAA,CAAA,sBAAA,CAAA,iBAAA,CACA,cAAA,CACA,eAAA,CACA,iBAAA,CACA,mBAAA,CACA,0BAAA,CAAA,uBAAA,CAAA,kBAAA,CAEF,wBACE,iBAAA,CACA,KAAA,CACA,OAAA,CACA,aAAA,CACA,cAAA,CAGF,0BACE,iBAAA,CAEF,cACE,gBAAA",
                sourcesContent: ["#assetManagerPopup{\n  z-index: 300;\n  position: absolute;\n  bottom: 2rem;\n  right: 2rem;\n  backdrop-filter: blur(16px);\n  color: white;\n  background-blend-mode: luminosity;\n  background-color: #28223CAA;\n  padding: 1.5rem;\n  font-size: 1rem;\n  width: max-content;\n  max-width: 80vw;\n  max-height: 80vh;\n  overflow-y: scroll;\n  border-radius: 0.5rem;\n  height: max-content;\n}\n#assetManagerPopupClose{\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 0.5rem;\n  cursor: pointer;\n\n}\n#assetManagerPopupContent{\n  padding-top: 0.5rem;\n}\n.processState{\n  font-weight: bold;\n}\n"],
                sourceRoot: ""
            }]), t.Z = o
        },
        532: function(e, t, n) {
            var r = n(445),
                i = n.n(r),
                s = n(352),
                o = n.n(s)()(i());
            o.push([e.id, "#tweakpaneUiContainer {\n    /*padding-right: 0.25rem;*/\n}\n\n:root {\n    --tp-blade-unit-size: 24px;\n\n    /*\n    --tp-base-shadow-color: #00000000;\n    --tp-base-background-color: #00000000;\n    --tp-container-background-color: rgba(32, 32, 32, 0.8);\n    --tp-container-background-color-hover: rgba(32, 32, 32, 0.9);\n    --tp-container-background-color-active: rgba(32, 32, 32, 1.0);\n    --tp-container-background-color-focus: rgba(32, 32, 32, 1.0);\n    --tp-base-border-radius: 0.4rem;\n\n    --tp-button-background-color: hsla(0, 0%, 70%, 1.00);\n    --tp-button-background-color-active: hsla(0, 0%, 85%, 1.00);\n    --tp-button-background-color-focus: hsla(0, 0%, 80%, 1.00);\n    --tp-button-background-color-hover: hsla(0, 0%, 75%, 1.00);\n    --tp-button-foreground-color: hsla(0, 0%, 5%, 1.00);\n    --tp-container-foreground-color: hsla(0, 0%, 95%, 1.00);\n    --tp-groove-foreground-color: hsla(0, 0%, 10%, 1.00);\n    --tp-input-background-color: hsla(0, 0%, 10%, 1.00);\n    --tp-input-background-color-active: hsla(0, 0%, 25%, 1.00);\n    --tp-input-background-color-focus: hsla(0, 0%, 20%, 1.00);\n    --tp-input-background-color-hover: hsla(0, 0%, 15%, 1.00);\n    --tp-input-foreground-color: hsla(0, 0%, 90%, 1.00);\n    --tp-label-foreground-color: hsla(0, 0%, 85%, 1.00);\n    --tp-monitor-background-color: hsla(0, 0%, 8%, 1.00);\n    --tp-monitor-foreground-color: hsla(0, 0%, 48%, 1.00);\n    */\n    --tp-element-border-radius: 0.25rem;\n\n    --tp-base-background-color: #28223C;\n\n    /*--tp-base-background-color: hsla(235, 21%, 31%, 0.5);*/\n    --tp-base-shadow-color: hsla(0, 0%, 0%, 0.2);\n    --tp-button-background-color: hsla(230, 10%, 80%, 1.00);\n    --tp-button-background-color-active: hsla(230, 10%, 95%, 1.00);\n    --tp-button-background-color-focus: hsla(230, 10%, 90%, 1.00);\n    --tp-button-background-color-hover: hsla(230, 10%, 85%, 1.00);\n    --tp-button-foreground-color: hsla(230, 20%, 11%, 1.00);\n    --tp-container-background-color: hsla(230, 25%, 16%, 0.65);\n    --tp-container-background-color-active: hsla(230, 25%, 31%, 0.65);\n    --tp-container-background-color-focus: hsla(230, 25%, 26%, 0.65);\n    --tp-container-background-color-hover: hsla(230, 25%, 21%, 0.65);\n    --tp-container-foreground-color: hsl(240, 10%, 92%);\n    --tp-groove-foreground-color: hsla(230, 20%, 8%, 1.00);\n    --tp-input-background-color: hsla(230, 20%, 8%, 1.00);\n    --tp-input-background-color-active: hsla(230, 28%, 23%, 1.00);\n    --tp-input-background-color-focus: hsla(230, 28%, 18%, 1.00);\n    --tp-input-background-color-hover: hsla(230, 20%, 13%, 1.00);\n    --tp-input-foreground-color: hsla(230, 10%, 80%, 1.00);\n    /*--tp-label-foreground-color: hsl(229, 100%, 97%);*/\n    --tp-monitor-background-color: hsla(230, 20%, 8%, 1.00);\n    --tp-monitor-foreground-color: hsla(230, 12%, 48%, 1.00);\n\n    --tp-label-foreground-color: #E4E2ED;\n\n    --tp-font-family: 'Inter';\n}\n\n.tp-fldv {\n    margin-top: 0.25rem;\n    margin-bottom: 0.25rem;\n    background-blend-mode: luminosity;\n    position: relative;\n}\n\n.tp-fldv .tp-fldv {\n    margin-top: 0.5rem;\n    margin-bottom: 0.5rem;\n}\n\n.tp-fldv .tp-brkv {\n    background-color: rgba(32, 32, 50, 0.85);\n}\n\n.tp-fldv .tp-fldv .tp-brkv {\n    background-color: rgba(32, 32, 50, 0.25) !important;\n}\n\n.tp-fldv-expanded > .tp-fldv_b {\n    background-color: rgba(32, 32, 50, 0.80) !important;\n}\n\n.tp-fldv_b {\n    height: calc(var(--bld-us) * 1.5 + 4px) !important;\n    font-size: 0.85rem !important;\n}\n\n.tp-fldv_b + .tp-brkv .tp-fldv_b {\n    height: calc(var(--bld-us) * 1.1 + 4px) !important;\n    font-size: 0.65rem !important;\n}\n\n.tp-fldv_b + .tp-brkv .tp-fldv-expanded > .tp-fldv_b {\n}\n\n.tp-lblv_l {\n    font-size: 0.7rem !important;\n    font-weight: 400 !important;\n}\n\n.tp-txtv_i {\n    font-size: 0.7rem !important;\n    font-weight: 400 !important;\n}\n\n.tp-fldv_t {\n    font-weight: 400 !important;\n    padding-left: 1.5rem !important;\n}\n\n.tp-fldv_m {\n    right: auto !important;\n    left: 0.75rem;\n    opacity: 1.0 !important;\n}\n\n.pluginOptionsButton{\n    position: absolute;\n    right: 0;\n    top: 0.75rem;\n    padding-left: 0.5rem;\n    padding-right: 0.5rem;\n    height: -webkit-min-content;\n    height: -moz-min-content;\n    height: min-content;\n    background: transparent;\n    color: #eeeeee;\n    border: none;\n}\n", "", {
                version: 3,
                sources: ["webpack://./src/ui/tpTheme.css"],
                names: [],
                mappings: "AAAA;IACI,0BAA0B;AAC9B;;AAEA;IACI,0BAA0B;;IAE1B;;;;;;;;;;;;;;;;;;;;;;;;KAwBC;IACD,mCAAmC;;IAEnC,mCAAmC;;IAEnC,wDAAwD;IACxD,4CAA4C;IAC5C,uDAAuD;IACvD,8DAA8D;IAC9D,6DAA6D;IAC7D,6DAA6D;IAC7D,uDAAuD;IACvD,0DAA0D;IAC1D,iEAAiE;IACjE,gEAAgE;IAChE,gEAAgE;IAChE,mDAAmD;IACnD,sDAAsD;IACtD,qDAAqD;IACrD,6DAA6D;IAC7D,4DAA4D;IAC5D,4DAA4D;IAC5D,sDAAsD;IACtD,oDAAoD;IACpD,uDAAuD;IACvD,wDAAwD;;IAExD,oCAAoC;;IAEpC,yBAAyB;AAC7B;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,iCAAiC;IACjC,kBAAkB;AACtB;;AAEA;IACI,kBAAkB;IAClB,qBAAqB;AACzB;;AAEA;IACI,wCAAwC;AAC5C;;AAEA;IACI,mDAAmD;AACvD;;AAEA;IACI,mDAAmD;AACvD;;AAEA;IACI,kDAAkD;IAClD,6BAA6B;AACjC;;AAEA;IACI,kDAAkD;IAClD,6BAA6B;AACjC;;AAEA;AACA;;AAEA;IACI,4BAA4B;IAC5B,2BAA2B;AAC/B;;AAEA;IACI,4BAA4B;IAC5B,2BAA2B;AAC/B;;AAEA;IACI,2BAA2B;IAC3B,+BAA+B;AACnC;;AAEA;IACI,sBAAsB;IACtB,aAAa;IACb,uBAAuB;AAC3B;;AAEA;IACI,kBAAkB;IAClB,QAAQ;IACR,YAAY;IACZ,oBAAoB;IACpB,qBAAqB;IACrB,2BAAmB;IAAnB,wBAAmB;IAAnB,mBAAmB;IACnB,uBAAuB;IACvB,cAAc;IACd,YAAY;AAChB",
                sourcesContent: ["#tweakpaneUiContainer {\n    /*padding-right: 0.25rem;*/\n}\n\n:root {\n    --tp-blade-unit-size: 24px;\n\n    /*\n    --tp-base-shadow-color: #00000000;\n    --tp-base-background-color: #00000000;\n    --tp-container-background-color: rgba(32, 32, 32, 0.8);\n    --tp-container-background-color-hover: rgba(32, 32, 32, 0.9);\n    --tp-container-background-color-active: rgba(32, 32, 32, 1.0);\n    --tp-container-background-color-focus: rgba(32, 32, 32, 1.0);\n    --tp-base-border-radius: 0.4rem;\n\n    --tp-button-background-color: hsla(0, 0%, 70%, 1.00);\n    --tp-button-background-color-active: hsla(0, 0%, 85%, 1.00);\n    --tp-button-background-color-focus: hsla(0, 0%, 80%, 1.00);\n    --tp-button-background-color-hover: hsla(0, 0%, 75%, 1.00);\n    --tp-button-foreground-color: hsla(0, 0%, 5%, 1.00);\n    --tp-container-foreground-color: hsla(0, 0%, 95%, 1.00);\n    --tp-groove-foreground-color: hsla(0, 0%, 10%, 1.00);\n    --tp-input-background-color: hsla(0, 0%, 10%, 1.00);\n    --tp-input-background-color-active: hsla(0, 0%, 25%, 1.00);\n    --tp-input-background-color-focus: hsla(0, 0%, 20%, 1.00);\n    --tp-input-background-color-hover: hsla(0, 0%, 15%, 1.00);\n    --tp-input-foreground-color: hsla(0, 0%, 90%, 1.00);\n    --tp-label-foreground-color: hsla(0, 0%, 85%, 1.00);\n    --tp-monitor-background-color: hsla(0, 0%, 8%, 1.00);\n    --tp-monitor-foreground-color: hsla(0, 0%, 48%, 1.00);\n    */\n    --tp-element-border-radius: 0.25rem;\n\n    --tp-base-background-color: #28223C;\n\n    /*--tp-base-background-color: hsla(235, 21%, 31%, 0.5);*/\n    --tp-base-shadow-color: hsla(0, 0%, 0%, 0.2);\n    --tp-button-background-color: hsla(230, 10%, 80%, 1.00);\n    --tp-button-background-color-active: hsla(230, 10%, 95%, 1.00);\n    --tp-button-background-color-focus: hsla(230, 10%, 90%, 1.00);\n    --tp-button-background-color-hover: hsla(230, 10%, 85%, 1.00);\n    --tp-button-foreground-color: hsla(230, 20%, 11%, 1.00);\n    --tp-container-background-color: hsla(230, 25%, 16%, 0.65);\n    --tp-container-background-color-active: hsla(230, 25%, 31%, 0.65);\n    --tp-container-background-color-focus: hsla(230, 25%, 26%, 0.65);\n    --tp-container-background-color-hover: hsla(230, 25%, 21%, 0.65);\n    --tp-container-foreground-color: hsl(240, 10%, 92%);\n    --tp-groove-foreground-color: hsla(230, 20%, 8%, 1.00);\n    --tp-input-background-color: hsla(230, 20%, 8%, 1.00);\n    --tp-input-background-color-active: hsla(230, 28%, 23%, 1.00);\n    --tp-input-background-color-focus: hsla(230, 28%, 18%, 1.00);\n    --tp-input-background-color-hover: hsla(230, 20%, 13%, 1.00);\n    --tp-input-foreground-color: hsla(230, 10%, 80%, 1.00);\n    /*--tp-label-foreground-color: hsl(229, 100%, 97%);*/\n    --tp-monitor-background-color: hsla(230, 20%, 8%, 1.00);\n    --tp-monitor-foreground-color: hsla(230, 12%, 48%, 1.00);\n\n    --tp-label-foreground-color: #E4E2ED;\n\n    --tp-font-family: 'Inter';\n}\n\n.tp-fldv {\n    margin-top: 0.25rem;\n    margin-bottom: 0.25rem;\n    background-blend-mode: luminosity;\n    position: relative;\n}\n\n.tp-fldv .tp-fldv {\n    margin-top: 0.5rem;\n    margin-bottom: 0.5rem;\n}\n\n.tp-fldv .tp-brkv {\n    background-color: rgba(32, 32, 50, 0.85);\n}\n\n.tp-fldv .tp-fldv .tp-brkv {\n    background-color: rgba(32, 32, 50, 0.25) !important;\n}\n\n.tp-fldv-expanded > .tp-fldv_b {\n    background-color: rgba(32, 32, 50, 0.80) !important;\n}\n\n.tp-fldv_b {\n    height: calc(var(--bld-us) * 1.5 + 4px) !important;\n    font-size: 0.85rem !important;\n}\n\n.tp-fldv_b + .tp-brkv .tp-fldv_b {\n    height: calc(var(--bld-us) * 1.1 + 4px) !important;\n    font-size: 0.65rem !important;\n}\n\n.tp-fldv_b + .tp-brkv .tp-fldv-expanded > .tp-fldv_b {\n}\n\n.tp-lblv_l {\n    font-size: 0.7rem !important;\n    font-weight: 400 !important;\n}\n\n.tp-txtv_i {\n    font-size: 0.7rem !important;\n    font-weight: 400 !important;\n}\n\n.tp-fldv_t {\n    font-weight: 400 !important;\n    padding-left: 1.5rem !important;\n}\n\n.tp-fldv_m {\n    right: auto !important;\n    left: 0.75rem;\n    opacity: 1.0 !important;\n}\n\n.pluginOptionsButton{\n    position: absolute;\n    right: 0;\n    top: 0.75rem;\n    padding-left: 0.5rem;\n    padding-right: 0.5rem;\n    height: min-content;\n    background: transparent;\n    color: #eeeeee;\n    border: none;\n}\n"],
                sourceRoot: ""
            }]), t.Z = o
        },
        927: function(e, t, n) {
            n.d(t, {
                LY2: function() {
                    return ne
                },
                bGH: function() {
                    return T
                },
                NDo: function() {
                    return J
                },
                gSk: function() {
                    return Ct
                },
                WMw: function() {
                    return y
                },
                OTo: function() {
                    return Le
                },
                Se2: function() {
                    return V
                },
                cum: function() {
                    return sn
                },
                Mig: function() {
                    return qp
                },
                i_9: function() {
                    return ph
                },
                m7l: function() {
                    return bp
                },
                sYA: function() {
                    return Ap
                },
                Xcj: function() {
                    return jh
                },
                mzJ: function() {
                    return Nh
                },
                ZZA: function() {
                    return op
                },
                T__: function() {
                    return Mc
                },
                HkE: function() {
                    return nl
                },
                tGC: function() {
                    return Pd
                },
                BbS: function() {
                    return Sh
                },
                kqm: function() {
                    return Rh
                },
                Hmr: function() {
                    return lh
                },
                SJI: function() {
                    return wh
                },
                mTL: function() {
                    return ch
                },
                y8_: function() {
                    return Dd
                },
                _Li: function() {
                    return _
                },
                z81: function() {
                    return Ft
                },
                _MY: function() {
                    return u
                },
                N$j: function() {
                    return Gl
                },
                _YM: function() {
                    return hp
                },
                TUj: function() {
                    return $h
                },
                ZzF: function() {
                    return pr
                },
                GQ: function() {
                    return Ed
                },
                nvb: function() {
                    return ps
                },
                DvJ: function() {
                    return ps
                },
                fQA: function() {
                    return Td
                },
                TlE: function() {
                    return Ai
                },
                u9r: function() {
                    return Wi
                },
                s4_: function() {
                    return th
                },
                T95: function() {
                    return Me
                },
                CtF: function() {
                    return yp
                },
                V1s: function() {
                    return ms
                },
                Rki: function() {
                    return wd
                },
                ROQ: function() {
                    return yc
                },
                YN5: function() {
                    return Wc
                },
                BVQ: function() {
                    return Wc
                },
                YT8: function() {
                    return kc
                },
                YGz: function() {
                    return te
                },
                trn: function() {
                    return Kc
                },
                zf8: function() {
                    return Kc
                },
                uWy: function() {
                    return pe
                },
                SUY: function() {
                    return mh
                },
                Ilk: function() {
                    return Xn
                },
                R2R: function() {
                    return dp
                },
                epp: function() {
                    return jn
                },
                EB7: function() {
                    return xc
                },
                DqL: function() {
                    return Cp
                },
                _3: function() {
                    return qc
                },
                b_z: function() {
                    return qc
                },
                _am: function() {
                    return bs
                },
                fY$: function() {
                    return se
                },
                vxC: function() {
                    return oe
                },
                BtG: function() {
                    return xs
                },
                cBK: function() {
                    return kp
                },
                g8_: function() {
                    return ce
                },
                AXT: function() {
                    return Lc
                },
                yj7: function() {
                    return Ic
                },
                dYG: function() {
                    return lp
                },
                tm_: function() {
                    return a
                },
                S2y: function() {
                    return l
                },
                B02: function() {
                    return c
                },
                PeU: function() {
                    return o
                },
                Hyl: function() {
                    return wc
                },
                Wqd: function() {
                    return Vc
                },
                Xaj: function() {
                    return M
                },
                dZ3: function() {
                    return re
                },
                m_w: function() {
                    return Xc
                },
                fHI: function() {
                    return Xc
                },
                LBq: function() {
                    return Zh
                },
                JUT: function() {
                    return ir
                },
                p3g: function() {
                    return nr
                },
                IEO: function() {
                    return Hl
                },
                CN8: function() {
                    return Yd
                },
                zob: function() {
                    return Zd
                },
                yxD: function() {
                    return Pp
                },
                A5E: function() {
                    return Vd
                },
                jfJ: function() {
                    return Xt
                },
                T_J: function() {
                    return Yt
                },
                tEQ: function() {
                    return Sp
                },
                qkB: function() {
                    return Be
                },
                brP: function() {
                    return je
                },
                $YQ: function() {
                    return ol
                },
                Ox3: function() {
                    return Xp
                },
                cBI: function() {
                    return bd
                },
                cU9: function() {
                    return up
                },
                DT1: function() {
                    return Zc
                },
                Kgo: function() {
                    return Zc
                },
                ehD: function() {
                    return m
                },
                fSK: function() {
                    return F
                },
                Vdb: function() {
                    return U
                },
                l8J: function() {
                    return dn
                },
                dj0: function() {
                    return an
                },
                QM0: function() {
                    return un
                },
                TOt: function() {
                    return tu
                },
                Ny0: function() {
                    return Sc
                },
                eD: function() {
                    return W
                },
                jwo: function() {
                    return Qt
                },
                dSO: function() {
                    return ae
                },
                Bf4: function() {
                    return le
                },
                USm: function() {
                    return Yr
                },
                pBf: function() {
                    return vn
                },
                $Vf: function() {
                    return ku
                },
                O7d: function() {
                    return ku
                },
                hH6: function() {
                    return Ep
                },
                esl: function() {
                    return g
                },
                e62: function() {
                    return Ii
                },
                a$l: function() {
                    return Fi
                },
                OM3: function() {
                    return Ni
                },
                VzW: function() {
                    return Re
                },
                ybr: function() {
                    return dl
                },
                yo9: function() {
                    return hl
                },
                Zxw: function() {
                    return Kd
                },
                JfN: function() {
                    return Wd
                },
                Wzm: function() {
                    return bc
                },
                Wl3: function() {
                    return f
                },
                iWj: function() {
                    return Cs
                },
                ylh: function() {
                    return Wh
                },
                v9Y: function() {
                    return _n
                },
                LSk: function() {
                    return mn
                },
                w$m: function() {
                    return X
                },
                ksN: function() {
                    return K
                },
                j4z: function() {
                    return rn
                },
                OAl: function() {
                    return tn
                },
                VLJ: function() {
                    return fd
                },
                ZAu: function() {
                    return rl
                },
                cLu: function() {
                    return ke
                },
                vmT: function() {
                    return Lp
                },
                Qpg: function() {
                    return dd
                },
                So8: function() {
                    return uh
                },
                Wjw: function() {
                    return Du
                },
                cJO: function() {
                    return Du
                },
                QRU: function() {
                    return oh
                },
                S3k: function() {
                    return Rp
                },
                PpQ: function() {
                    return Yn
                },
                AHu: function() {
                    return Xd
                },
                ZRs: function() {
                    return Kt
                },
                oqc: function() {
                    return qt
                },
                lb7: function() {
                    return ql
                },
                L5s: function() {
                    return eh
                },
                $TI: function() {
                    return Hh
                },
                SPe: function() {
                    return Ql
                },
                aVm: function() {
                    return Pi
                },
                j87: function() {
                    return Oi
                },
                RNb: function() {
                    return Ci
                },
                Kz5: function() {
                    return Ae
                },
                vpT: function() {
                    return _l
                },
                kB5: function() {
                    return gl
                },
                _C8: function() {
                    return ap
                },
                Syv: function() {
                    return yt
                },
                NMF: function() {
                    return wt
                },
                pIN: function() {
                    return St
                },
                eMJ: function() {
                    return Zt
                },
                x5V: function() {
                    return Ht
                },
                tUh: function() {
                    return pp
                },
                z8B: function() {
                    return Fl
                },
                GZb: function() {
                    return Hc
                },
                p7y: function() {
                    return Hc
                },
                S9g: function() {
                    return Zr
                },
                Zr5: function() {
                    return G
                },
                vCF: function() {
                    return H
                },
                yt0: function() {
                    return en
                },
                uXU: function() {
                    return $t
                },
                _kC: function() {
                    return Op
                },
                lk7: function() {
                    return Jp
                },
                x12: function() {
                    return oc
                },
                Zzh: function() {
                    return td
                },
                nls: function() {
                    return ec
                },
                g_z: function() {
                    return Fc
                },
                U7: function() {
                    return Nc
                },
                FT0: function() {
                    return Qu
                },
                blk: function() {
                    return uc
                },
                ejS: function() {
                    return cc
                },
                rnI: function() {
                    return Dt
                },
                wem: function() {
                    return ve
                },
                lfu: function() {
                    return cp
                },
                FDw: function() {
                    return we
                },
                lRj: function() {
                    return xe
                },
                D1R: function() {
                    return ye
                },
                qyh: function() {
                    return be
                },
                GUF: function() {
                    return Vt
                },
                EoG: function() {
                    return Q
                },
                aNw: function() {
                    return Mp
                },
                Zp0: function() {
                    return Qp
                },
                lLk: function() {
                    return wp
                },
                jAl: function() {
                    return vt
                },
                uEv: function() {
                    return xt
                },
                YKA: function() {
                    return bt
                },
                cRx: function() {
                    return Ue
                },
                Y8D: function() {
                    return Ne
                },
                RsA: function() {
                    return i
                },
                F5T: function() {
                    return Si
                },
                u7G: function() {
                    return $p
                },
                M8C: function() {
                    return kn
                },
                Vkp: function() {
                    return Dn
                },
                yGw: function() {
                    return Br
                },
                Sm8: function() {
                    return R
                },
                Kj0: function() {
                    return cs
                },
                vBJ: function() {
                    return Mi
                },
                lRF: function() {
                    return Za
                },
                Lun: function() {
                    return Ja
                },
                YBo: function() {
                    return Ju
                },
                kaV: function() {
                    return $u
                },
                RSm: function() {
                    return Zu
                },
                xoR: function() {
                    return qu
                },
                EJi: function() {
                    return Xu
                },
                Wid: function() {
                    return Ku
                },
                IKL: function() {
                    return Yu
                },
                r_: function() {
                    return C
                },
                OoA: function() {
                    return he
                },
                qhX: function() {
                    return Z
                },
                M5h: function() {
                    return S
                },
                Ns1: function() {
                    return Y
                },
                TyD: function() {
                    return de
                },
                vZf: function() {
                    return ge
                },
                HTd: function() {
                    return _e
                },
                aH4: function() {
                    return me
                },
                YLQ: function() {
                    return fe
                },
                BVF: function() {
                    return z
                },
                MyG: function() {
                    return Jt
                },
                jFi: function() {
                    return b
                },
                aCh: function() {
                    return jt
                },
                uL9: function() {
                    return $
                },
                IFH: function() {
                    return At
                },
                bdR: function() {
                    return x
                },
                M6v: function() {
                    return q
                },
                RvT: function() {
                    return nn
                },
                dUE: function() {
                    return fp
                },
                Tme: function() {
                    return ui
                },
                Gql: function() {
                    return nh
                },
                PA7: function() {
                    return Bt
                },
                REq: function() {
                    return Ou
                },
                pQR: function() {
                    return Ou
                },
                ghN: function() {
                    return P
                },
                Hy8: function() {
                    return N
                },
                Wpd: function() {
                    return B
                },
                LgZ: function() {
                    return I
                },
                iWC: function() {
                    return O
                },
                iKG: function() {
                    return zs
                },
                _iA: function() {
                    return p
                },
                ntZ: function() {
                    return h
                },
                anP: function() {
                    return Ys
                },
                jjw: function() {
                    return Gd
                },
                y$t: function() {
                    return Gc
                },
                cPb: function() {
                    return gs
                },
                JOQ: function() {
                    return Ts
                },
                BKK: function() {
                    return Ps
                },
                _12: function() {
                    return Ps
                },
                tJx: function() {
                    return Ad
                },
                cek: function() {
                    return Wp
                },
                xG9: function() {
                    return cd
                },
                woe: function() {
                    return mc
                },
                UY4: function() {
                    return pc
                },
                aq0: function() {
                    return _d
                },
                ujx: function() {
                    return Yc
                },
                Uol: function() {
                    return Yc
                },
                VYz: function() {
                    return Ch
                },
                iUV: function() {
                    return Fh
                },
                tf: function() {
                    return kh
                },
                ZQ6: function() {
                    return Uc
                },
                mXe: function() {
                    return Bc
                },
                _fP: function() {
                    return ar
                },
                iLg: function() {
                    return mp
                },
                zbs: function() {
                    return _p
                },
                UZH: function() {
                    return r
                },
                mSO: function() {
                    return Nt
                },
                wk1: function() {
                    return Fe
                },
                E2K: function() {
                    return We
                },
                FUD: function() {
                    return ft
                },
                pKu: function() {
                    return pt
                },
                GG6: function() {
                    return ht
                },
                Gih: function() {
                    return dt
                },
                iiP: function() {
                    return _t
                },
                SvJ: function() {
                    return mt
                },
                ptH: function() {
                    return rt
                },
                jZA: function() {
                    return it
                },
                y2t: function() {
                    return st
                },
                gi4: function() {
                    return ot
                },
                Djp: function() {
                    return at
                },
                BG$: function() {
                    return lt
                },
                NYV: function() {
                    return ct
                },
                xJs: function() {
                    return ut
                },
                bsb: function() {
                    return gt
                },
                ekQ: function() {
                    return nt
                },
                CaW: function() {
                    return Qe
                },
                eaV: function() {
                    return $e
                },
                BFQ: function() {
                    return Xe
                },
                v3W: function() {
                    return qe
                },
                ILR: function() {
                    return Ye
                },
                UCm: function() {
                    return Ie
                },
                Inb: function() {
                    return It
                },
                LgE: function() {
                    return Lt
                },
                fto: function() {
                    return et
                },
                l0P: function() {
                    return tt
                },
                vCx: function() {
                    return Je
                },
                _AM: function() {
                    return Ze
                },
                wuA: function() {
                    return Ke
                },
                av9: function() {
                    return Ge
                },
                CtA: function() {
                    return He
                },
                FIo: function() {
                    return Wu
                },
                zHn: function() {
                    return Ur
                },
                iMs: function() {
                    return Kh
                },
                T_f: function() {
                    return Yp
                },
                hEm: function() {
                    return ze
                },
                D9w: function() {
                    return Ve
                },
                CdI: function() {
                    return ee
                },
                rpg: function() {
                    return ue
                },
                ce8: function() {
                    return Wt
                },
                rOj: function() {
                    return A
                },
                V4E: function() {
                    return Lu
                },
                o8S: function() {
                    return Lu
                },
                KI_: function() {
                    return zt
                },
                xsS: function() {
                    return fl
                },
                WdD: function() {
                    return Ds
                },
                Vj0: function() {
                    return Ls
                },
                jyz: function() {
                    return _s
                },
                Tn7: function() {
                    return Hu
                },
                bnF: function() {
                    return nu
                },
                HW6: function() {
                    return Iu
                },
                oa8: function() {
                    return Iu
                },
                T_1: function() {
                    return Od
                },
                iDF: function() {
                    return Au
                },
                iAb: function() {
                    return Te
                },
                OdW: function() {
                    return Xl
                },
                _YX: function() {
                    return ad
                },
                TUv: function() {
                    return Vl
                },
                wcA: function() {
                    return v
                },
                Hw6: function() {
                    return Zn
                },
                aLr: function() {
                    return kr
                },
                Aip: function() {
                    return Fu
                },
                xo$: function() {
                    return Fu
                },
                $V: function() {
                    return Yh
                },
                lDi: function() {
                    return Zp
                },
                gti: function() {
                    return jc
                },
                PMe: function() {
                    return jp
                },
                FvO: function() {
                    return rd
                },
                jyi: function() {
                    return Dl
                },
                xeV: function() {
                    return vl
                },
                k74: function() {
                    return L
                },
                RlZ: function() {
                    return j
                },
                KhW: function() {
                    return D
                },
                HgB: function() {
                    return hn
                },
                W2J: function() {
                    return on
                },
                JWc: function() {
                    return cn
                },
                u37: function() {
                    return _h
                },
                Z6B: function() {
                    return fn
                },
                QZ1: function() {
                    return ln
                },
                Ir4: function() {
                    return pn
                },
                NwF: function() {
                    return gp
                },
                Wbm: function() {
                    return E
                },
                N4l: function() {
                    return w
                },
                QmN: function() {
                    return s
                },
                IOt: function() {
                    return Ut
                },
                L5g: function() {
                    return Nu
                },
                H$k: function() {
                    return Nu
                },
                MP$: function() {
                    return Hd
                },
                xEZ: function() {
                    return Qn
                },
                dpR: function() {
                    return Dp
                },
                Cne: function() {
                    return Uu
                },
                XvJ: function() {
                    return Uu
                },
                XZw: function() {
                    return Bu
                },
                FE5: function() {
                    return Bu
                },
                CJI: function() {
                    return yi
                },
                z$h: function() {
                    return Pt
                },
                UlW: function() {
                    return kt
                },
                WwZ: function() {
                    return Rt
                },
                Lcc: function() {
                    return ju
                },
                WXh: function() {
                    return ju
                },
                xfE: function() {
                    return ie
                },
                qlB: function() {
                    return Di
                },
                lCJ: function() {
                    return Li
                },
                WTc: function() {
                    return Ri
                },
                rAo: function() {
                    return ki
                },
                xWb: function() {
                    return zh
                },
                gH0: function() {
                    return Gh
                },
                rBU: function() {
                    return Os
                },
                rDY: function() {
                    return fs
                },
                ywz: function() {
                    return Se
                },
                wJv: function() {
                    return Oe
                },
                JQ4: function() {
                    return Ce
                },
                k0A: function() {
                    return Pe
                },
                irR: function() {
                    return De
                },
                LsT: function() {
                    return Ee
                },
                dwk: function() {
                    return d
                },
                FM8: function() {
                    return Pn
                },
                Pa4: function() {
                    return lr
                },
                Ltg: function() {
                    return er
                },
                yC1: function() {
                    return vp
                },
                fO1: function() {
                    return vc
                },
                b5g: function() {
                    return pl
                },
                Ywn: function() {
                    return sr
                },
                GVz: function() {
                    return rr
                },
                oAp: function() {
                    return ys
                },
                kFz: function() {
                    return or
                },
                p7A: function() {
                    return qd
                },
                dd2: function() {
                    return tr
                },
                CP7: function() {
                    return ul
                },
                fQK: function() {
                    return tl
                },
                Uk6: function() {
                    return zu
                },
                _sL: function() {
                    return Et
                },
                Pnf: function() {
                    return Mt
                },
                c8b: function() {
                    return k
                },
                _lf: function() {
                    return Tt
                },
                ad5: function() {
                    return Gt
                },
                L_r: function() {
                    return gn
                },
                knz: function() {
                    return Ot
                }
            });
            const r = "143dev",
                i = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                },
                s = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                },
                o = 0,
                a = 1,
                l = 2,
                c = 3,
                u = 0,
                p = 1,
                h = 2,
                d = 3,
                f = 0,
                _ = 1,
                m = 2,
                g = 1,
                v = 2,
                b = 0,
                x = 1,
                y = 2,
                w = 3,
                S = 4,
                M = 5,
                T = 100,
                E = 101,
                A = 102,
                C = 103,
                R = 104,
                k = 200,
                P = 201,
                D = 202,
                O = 203,
                L = 204,
                I = 205,
                F = 206,
                N = 207,
                U = 208,
                B = 209,
                j = 210,
                z = 0,
                V = 1,
                G = 2,
                H = 3,
                W = 4,
                K = 5,
                X = 6,
                q = 7,
                Y = 0,
                Z = 1,
                J = 2,
                $ = 0,
                Q = 1,
                ee = 2,
                te = 3,
                ne = 4,
                re = 5,
                ie = 300,
                se = 301,
                oe = 302,
                ae = 303,
                le = 304,
                ce = 306,
                ue = 1e3,
                pe = 1001,
                he = 1002,
                de = 1003,
                fe = 1004,
                _e = 1004,
                me = 1005,
                ge = 1005,
                ve = 1006,
                be = 1007,
                xe = 1007,
                ye = 1008,
                we = 1008,
                Se = 1009,
                Me = 1010,
                Te = 1011,
                Ee = 1012,
                Ae = 1013,
                Ce = 1014,
                Re = 1015,
                ke = 1016,
                Pe = 1017,
                De = 1018,
                Oe = 1020,
                Le = 1021,
                Ie = 1022,
                Fe = 1023,
                Ne = 1024,
                Ue = 1025,
                Be = 1026,
                je = 1027,
                ze = 1028,
                Ve = 1029,
                Ge = 1030,
                He = 1031,
                We = 1033,
                Ke = 33776,
                Xe = 33777,
                qe = 33778,
                Ye = 33779,
                Ze = 35840,
                Je = 35841,
                $e = 35842,
                Qe = 35843,
                et = 36196,
                tt = 37492,
                nt = 37496,
                rt = 37808,
                it = 37809,
                st = 37810,
                ot = 37811,
                at = 37812,
                lt = 37813,
                ct = 37814,
                ut = 37815,
                pt = 37816,
                ht = 37817,
                dt = 37818,
                ft = 37819,
                _t = 37820,
                mt = 37821,
                gt = 36492,
                vt = 2200,
                bt = 2201,
                xt = 2202,
                yt = 2300,
                wt = 2301,
                St = 2302,
                Mt = 2400,
                Tt = 2401,
                Et = 2402,
                At = 2500,
                Ct = 2501,
                Rt = 0,
                kt = 1,
                Pt = 2,
                Dt = 3e3,
                Ot = 3001,
                Lt = 3004,
                It = 3005,
                Ft = 3200,
                Nt = 3201,
                Ut = 0,
                Bt = 1,
                jt = "",
                zt = "srgb",
                Vt = "srgb-linear",
                Gt = 0,
                Ht = 7680,
                Wt = 7681,
                Kt = 7682,
                Xt = 7683,
                qt = 34055,
                Yt = 34056,
                Zt = 5386,
                Jt = 512,
                $t = 513,
                Qt = 514,
                en = 515,
                tn = 516,
                nn = 517,
                rn = 518,
                sn = 519,
                on = 35044,
                an = 35048,
                ln = 35040,
                cn = 35045,
                un = 35049,
                pn = 35041,
                hn = 35046,
                dn = 35050,
                fn = 35042,
                _n = "100",
                mn = "300 es",
                gn = 1035;
            class vn {
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                }
                hasEventListener(e, t) {
                    if (void 0 === this._listeners) return !1;
                    const n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                }
                removeEventListener(e, t) {
                    if (void 0 === this._listeners) return;
                    const n = this._listeners[e];
                    if (void 0 !== n) {
                        const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                    }
                }
                dispatchEvent(e) {
                    if (void 0 === this._listeners) return;
                    const t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        const n = t.slice(0);
                        for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
                        e.target = null
                    }
                }
            }
            const bn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
            let xn = 1234567;
            const yn = Math.PI / 180,
                wn = 180 / Math.PI;

            function Sn() {
                const e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0;
                return (bn[255 & e] + bn[e >> 8 & 255] + bn[e >> 16 & 255] + bn[e >> 24 & 255] + "-" + bn[255 & t] + bn[t >> 8 & 255] + "-" + bn[t >> 16 & 15 | 64] + bn[t >> 24 & 255] + "-" + bn[63 & n | 128] + bn[n >> 8 & 255] + "-" + bn[n >> 16 & 255] + bn[n >> 24 & 255] + bn[255 & r] + bn[r >> 8 & 255] + bn[r >> 16 & 255] + bn[r >> 24 & 255]).toLowerCase()
            }

            function Mn(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }

            function Tn(e, t) {
                return (e % t + t) % t
            }

            function En(e, t, n) {
                return (1 - n) * e + n * t
            }

            function An(e) {
                return 0 == (e & e - 1) && 0 !== e
            }

            function Cn(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }

            function Rn(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }
            var kn = Object.freeze({
                __proto__: null,
                DEG2RAD: yn,
                RAD2DEG: wn,
                generateUUID: Sn,
                clamp: Mn,
                euclideanModulo: Tn,
                mapLinear: function(e, t, n, r, i) {
                    return r + (e - t) * (i - r) / (n - t)
                },
                inverseLerp: function(e, t, n) {
                    return e !== t ? (n - e) / (t - e) : 0
                },
                lerp: En,
                damp: function(e, t, n, r) {
                    return En(e, t, 1 - Math.exp(-n * r))
                },
                pingpong: function(e, t = 1) {
                    return t - Math.abs(Tn(e, 2 * t) - t)
                },
                smoothstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                },
                smootherstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                seededRandom: function(e) {
                    void 0 !== e && (xn = e);
                    let t = xn += 1831565813;
                    return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296
                },
                degToRad: function(e) {
                    return e * yn
                },
                radToDeg: function(e) {
                    return e * wn
                },
                isPowerOfTwo: An,
                ceilPowerOfTwo: Cn,
                floorPowerOfTwo: Rn,
                setQuaternionFromProperEuler: function(e, t, n, r, i) {
                    const s = Math.cos,
                        o = Math.sin,
                        a = s(n / 2),
                        l = o(n / 2),
                        c = s((t + r) / 2),
                        u = o((t + r) / 2),
                        p = s((t - r) / 2),
                        h = o((t - r) / 2),
                        d = s((r - t) / 2),
                        f = o((r - t) / 2);
                    switch (i) {
                        case "XYX":
                            e.set(a * u, l * p, l * h, a * c);
                            break;
                        case "YZY":
                            e.set(l * h, a * u, l * p, a * c);
                            break;
                        case "ZXZ":
                            e.set(l * p, l * h, a * u, a * c);
                            break;
                        case "XZX":
                            e.set(a * u, l * f, l * d, a * c);
                            break;
                        case "YXY":
                            e.set(l * d, a * u, l * f, a * c);
                            break;
                        case "ZYZ":
                            e.set(l * f, l * d, a * u, a * c);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                    }
                },
                normalize: function(e, t) {
                    switch (t.constructor) {
                        case Float32Array:
                            return e;
                        case Uint16Array:
                            return Math.round(65535 * e);
                        case Uint8Array:
                            return Math.round(255 * e);
                        case Int16Array:
                            return Math.round(32767 * e);
                        case Int8Array:
                            return Math.round(127 * e);
                        default:
                            throw new Error("Invalid component type.")
                    }
                },
                denormalize: function(e, t) {
                    switch (t.constructor) {
                        case Float32Array:
                            return e;
                        case Uint16Array:
                            return e / 65535;
                        case Uint8Array:
                            return e / 255;
                        case Int16Array:
                            return Math.max(e / 32767, -1);
                        case Int8Array:
                            return Math.max(e / 127, -1);
                        default:
                            throw new Error("Invalid component type.")
                    }
                }
            });
            class Pn {
                constructor(e = 0, t = 0) {
                    Pn.prototype.isVector2 = !0, this.x = e, this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e, this.y = t, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    const t = this.x,
                        n = this.y,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this
                }
                rotateAround(e, t) {
                    const n = Math.cos(t),
                        r = Math.sin(t),
                        i = this.x - e.x,
                        s = this.y - e.y;
                    return this.x = i * n - s * r + e.x, this.y = i * r + s * n + e.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            class Dn {
                constructor() {
                    Dn.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
                }
                set(e, t, n, r, i, s, o, a, l) {
                    const c = this.elements;
                    return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = i, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(e) {
                    const t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        s = n[0],
                        o = n[3],
                        a = n[6],
                        l = n[1],
                        c = n[4],
                        u = n[7],
                        p = n[2],
                        h = n[5],
                        d = n[8],
                        f = r[0],
                        _ = r[3],
                        m = r[6],
                        g = r[1],
                        v = r[4],
                        b = r[7],
                        x = r[2],
                        y = r[5],
                        w = r[8];
                    return i[0] = s * f + o * g + a * x, i[3] = s * _ + o * v + a * y, i[6] = s * m + o * b + a * w, i[1] = l * f + c * g + u * x, i[4] = l * _ + c * v + u * y, i[7] = l * m + c * b + u * w, i[2] = p * f + h * g + d * x, i[5] = p * _ + h * v + d * y, i[8] = p * m + h * b + d * w, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        s = e[4],
                        o = e[5],
                        a = e[6],
                        l = e[7],
                        c = e[8];
                    return t * s * c - t * o * l - n * i * c + n * o * a + r * i * l - r * s * a
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        s = e[4],
                        o = e[5],
                        a = e[6],
                        l = e[7],
                        c = e[8],
                        u = c * s - o * l,
                        p = o * a - c * i,
                        h = l * i - s * a,
                        d = t * u + n * p + r * h;
                    if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const f = 1 / d;
                    return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (o * n - r * s) * f, e[3] = p * f, e[4] = (c * t - r * a) * f, e[5] = (r * i - o * t) * f, e[6] = h * f, e[7] = (n * a - l * t) * f, e[8] = (s * t - n * i) * f, this
                }
                transpose() {
                    let e;
                    const t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).invert().transpose()
                }
                transposeIntoArray(e) {
                    const t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                }
                setUvTransform(e, t, n, r, i, s, o) {
                    const a = Math.cos(i),
                        l = Math.sin(i);
                    return this.set(n * a, n * l, -n * (a * s + l * o) + s + e, -r * l, r * a, -r * (-l * s + a * o) + o + t, 0, 0, 1), this
                }
                scale(e, t) {
                    const n = this.elements;
                    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
                }
                rotate(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e),
                        r = this.elements,
                        i = r[0],
                        s = r[3],
                        o = r[6],
                        a = r[1],
                        l = r[4],
                        c = r[7];
                    return r[0] = t * i + n * a, r[3] = t * s + n * l, r[6] = t * o + n * c, r[1] = -n * i + t * a, r[4] = -n * s + t * l, r[7] = -n * o + t * c, this
                }
                translate(e, t) {
                    const n = this.elements;
                    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
                }
                equals(e) {
                    const t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 9; e++)
                        if (t[e] !== n[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }

            function On(e) {
                for (let t = e.length - 1; t >= 0; --t)
                    if (e[t] > 65535) return !0;
                return !1
            }
            const Ln = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: Uint8ClampedArray,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function In(e, t) {
                return new Ln[e](t)
            }

            function Fn(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }

            function Nn(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function Un(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            const Bn = {
                    [zt]: {
                        [Vt]: Nn
                    },
                    [Vt]: {
                        [zt]: Un
                    }
                },
                jn = {
                    legacyMode: !0,
                    get workingColorSpace() {
                        return Vt
                    },
                    set workingColorSpace(e) {
                        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                    },
                    convert: function(e, t, n) {
                        if (this.legacyMode || t === n || !t || !n) return e;
                        if (Bn[t] && void 0 !== Bn[t][n]) {
                            const r = Bn[t][n];
                            return e.r = r(e.r), e.g = r(e.g), e.b = r(e.b), e
                        }
                        throw new Error("Unsupported color space conversion.")
                    },
                    fromWorkingColorSpace: function(e, t) {
                        return this.convert(e, this.workingColorSpace, t)
                    },
                    toWorkingColorSpace: function(e, t) {
                        return this.convert(e, t, this.workingColorSpace)
                    }
                },
                zn = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                Vn = {
                    r: 0,
                    g: 0,
                    b: 0
                },
                Gn = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                Hn = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function Wn(e, t, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }

            function Kn(e, t) {
                return t.r = e.r, t.g = e.g, t.b = e.b, t
            }
            class Xn {
                constructor(e, t, n) {
                    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
                }
                set(e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                }
                setScalar(e) {
                    return this.r = e, this.g = e, this.b = e, this
                }
                setHex(e, t = zt) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, jn.toWorkingColorSpace(this, t), this
                }
                setRGB(e, t, n, r = Vt) {
                    return this.r = e, this.g = t, this.b = n, jn.toWorkingColorSpace(this, r), this
                }
                setHSL(e, t, n, r = Vt) {
                    if (e = Tn(e, 1), t = Mn(t, 0, 1), n = Mn(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                    else {
                        const r = n <= .5 ? n * (1 + t) : n + t - n * t,
                            i = 2 * n - r;
                        this.r = Wn(i, r, e + 1 / 3), this.g = Wn(i, r, e), this.b = Wn(i, r, e - 1 / 3)
                    }
                    return jn.toWorkingColorSpace(this, r), this
                }
                setStyle(e, t = zt) {
                    function n(t) {
                        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    let r;
                    if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                        let e;
                        const i = r[1],
                            s = r[2];
                        switch (i) {
                            case "rgb":
                            case "rgba":
                                if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, jn.toWorkingColorSpace(this, t), n(e[4]), this;
                                if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, jn.toWorkingColorSpace(this, t), n(e[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                                    const r = parseFloat(e[1]) / 360,
                                        i = parseInt(e[2], 10) / 100,
                                        s = parseInt(e[3], 10) / 100;
                                    return n(e[4]), this.setHSL(r, i, s, t)
                                }
                        }
                    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        const e = r[1],
                            n = e.length;
                        if (3 === n) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, jn.toWorkingColorSpace(this, t), this;
                        if (6 === n) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, jn.toWorkingColorSpace(this, t), this
                    }
                    return e && e.length > 0 ? this.setColorName(e, t) : this
                }
                setColorName(e, t = zt) {
                    const n = zn[e.toLowerCase()];
                    return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                }
                copySRGBToLinear(e) {
                    return this.r = Nn(e.r), this.g = Nn(e.g), this.b = Nn(e.b), this
                }
                copyLinearToSRGB(e) {
                    return this.r = Un(e.r), this.g = Un(e.g), this.b = Un(e.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex(e = zt) {
                    return jn.fromWorkingColorSpace(Kn(this, Vn), e), Mn(255 * Vn.r, 0, 255) << 16 ^ Mn(255 * Vn.g, 0, 255) << 8 ^ Mn(255 * Vn.b, 0, 255) << 0
                }
                getHexString(e = zt) {
                    return ("000000" + this.getHex(e).toString(16)).slice(-6)
                }
                getHSL(e, t = Vt) {
                    jn.fromWorkingColorSpace(Kn(this, Vn), t);
                    const n = Vn.r,
                        r = Vn.g,
                        i = Vn.b,
                        s = Math.max(n, r, i),
                        o = Math.min(n, r, i);
                    let a, l;
                    const c = (o + s) / 2;
                    if (o === s) a = 0, l = 0;
                    else {
                        const e = s - o;
                        switch (l = c <= .5 ? e / (s + o) : e / (2 - s - o), s) {
                            case n:
                                a = (r - i) / e + (r < i ? 6 : 0);
                                break;
                            case r:
                                a = (i - n) / e + 2;
                                break;
                            case i:
                                a = (n - r) / e + 4
                        }
                        a /= 6
                    }
                    return e.h = a, e.s = l, e.l = c, e
                }
                getRGB(e, t = Vt) {
                    return jn.fromWorkingColorSpace(Kn(this, Vn), t), e.r = Vn.r, e.g = Vn.g, e.b = Vn.b, e
                }
                getStyle(e = zt) {
                    return jn.fromWorkingColorSpace(Kn(this, Vn), e), e !== zt ? `color(${e} ${Vn.r} ${Vn.g} ${Vn.b})` : `rgb(${255*Vn.r|0},${255*Vn.g|0},${255*Vn.b|0})`
                }
                offsetHSL(e, t, n) {
                    return this.getHSL(Gn), Gn.h += e, Gn.s += t, Gn.l += n, this.setHSL(Gn.h, Gn.s, Gn.l), this
                }
                add(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                }
                addScalar(e) {
                    return this.r += e, this.g += e, this.b += e, this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                }
                multiply(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                }
                multiplyScalar(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                }
                lerpColors(e, t, n) {
                    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
                }
                lerpHSL(e, t) {
                    this.getHSL(Gn), e.getHSL(Hn);
                    const n = En(Gn.h, Hn.h, t),
                        r = En(Gn.s, Hn.s, t),
                        i = En(Gn.l, Hn.l, t);
                    return this.setHSL(n, r, i), this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t = 0) {
                    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }*[Symbol.iterator]() {
                    yield this.r, yield this.g, yield this.b
                }
            }
            let qn;
            Xn.NAMES = zn;
            class Yn {
                static getDataURL(e) {
                    if (/^data:/i.test(e.src)) return e.src;
                    if ("undefined" == typeof HTMLCanvasElement) return e.src;
                    let t;
                    if (e instanceof HTMLCanvasElement) t = e;
                    else {
                        void 0 === qn && (qn = Fn("canvas")), qn.width = e.width, qn.height = e.height;
                        const n = qn.getContext("2d");
                        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = qn
                    }
                    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
                }
                static sRGBToLinear(e) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        const t = Fn("canvas");
                        t.width = e.width, t.height = e.height;
                        const n = t.getContext("2d");
                        n.drawImage(e, 0, 0, e.width, e.height);
                        const r = n.getImageData(0, 0, e.width, e.height),
                            i = r.data;
                        for (let e = 0; e < i.length; e++) i[e] = 255 * Nn(i[e] / 255);
                        return n.putImageData(r, 0, 0), t
                    }
                    if (e.data) {
                        const t = e.data.slice(0);
                        for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Nn(t[e] / 255)) : t[e] = Nn(t[e]);
                        return {
                            data: t,
                            width: e.width,
                            height: e.height
                        }
                    }
                    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
                }
            }
            class Zn {
                constructor(e = null) {
                    this.isSource = !0, this.uuid = Sn(), this.data = e, this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
                    const n = {
                            uuid: this.uuid,
                            url: ""
                        },
                        r = this.data;
                    if (null !== r) {
                        let e;
                        if (Array.isArray(r)) {
                            e = [];
                            for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(Jn(r[t].image)) : e.push(Jn(r[t]))
                        } else e = Jn(r);
                        n.url = e
                    }
                    return t || (e.images[this.uuid] = n), n
                }
            }

            function Jn(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Yn.getDataURL(e) : e.data ? {
                    data: Array.from(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            let $n = 0;
            class Qn extends vn {
                constructor(e = Qn.DEFAULT_IMAGE, t = Qn.DEFAULT_MAPPING, n = pe, r = pe, i = ve, s = ye, o = Fe, a = Se, l = 1, c = Dt) {
                    super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                        value: $n++
                    }), this.uuid = Sn(), this.name = "", this.source = new Zn(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new Pn(0, 0), this.repeat = new Pn(1, 1), this.center = new Pn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Dn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
                }
                get image() {
                    return this.source.data
                }
                set image(e) {
                    this.source.data = e
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(e).uuid,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(e) {
                    if (this.mapping !== ie) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case ue:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case pe:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case he:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case ue:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case pe:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case he:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
                set needsUpdate(e) {
                    !0 === e && (this.version++, this.source.needsUpdate = !0)
                }
            }
            Qn.DEFAULT_IMAGE = null, Qn.DEFAULT_MAPPING = ie;
            class er {
                constructor(e = 0, t = 0, n = 0, r = 1) {
                    er.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, n, r) {
                    return this.x = e, this.y = t, this.z = n, this.w = r, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setW(e) {
                    return this.w = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                }
                applyMatrix4(e) {
                    const t = this.x,
                        n = this.y,
                        r = this.z,
                        i = this.w,
                        s = e.elements;
                    return this.x = s[0] * t + s[4] * n + s[8] * r + s[12] * i, this.y = s[1] * t + s[5] * n + s[9] * r + s[13] * i, this.z = s[2] * t + s[6] * n + s[10] * r + s[14] * i, this.w = s[3] * t + s[7] * n + s[11] * r + s[15] * i, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    const t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, n, r, i;
                    const s = .01,
                        o = .1,
                        a = e.elements,
                        l = a[0],
                        c = a[4],
                        u = a[8],
                        p = a[1],
                        h = a[5],
                        d = a[9],
                        f = a[2],
                        _ = a[6],
                        m = a[10];
                    if (Math.abs(c - p) < s && Math.abs(u - f) < s && Math.abs(d - _) < s) {
                        if (Math.abs(c + p) < o && Math.abs(u + f) < o && Math.abs(d + _) < o && Math.abs(l + h + m - 3) < o) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        const e = (l + 1) / 2,
                            a = (h + 1) / 2,
                            g = (m + 1) / 2,
                            v = (c + p) / 4,
                            b = (u + f) / 4,
                            x = (d + _) / 4;
                        return e > a && e > g ? e < s ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(e), r = v / n, i = b / n) : a > g ? a < s ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(a), n = v / r, i = x / r) : g < s ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(g), n = b / i, r = x / i), this.set(n, r, i, t), this
                    }
                    let g = Math.sqrt((_ - d) * (_ - d) + (u - f) * (u - f) + (p - c) * (p - c));
                    return Math.abs(g) < .001 && (g = 1), this.x = (_ - d) / g, this.y = (u - f) / g, this.z = (p - c) / g, this.w = Math.acos((l + h + m - 1) / 2), this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            class tr extends vn {
                constructor(e, t, n = {}) {
                    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new er(0, 0, e, t), this.scissorTest = !1, this.viewport = new er(0, 0, e, t);
                    const r = {
                        width: e,
                        height: t,
                        depth: 1
                    };
                    this.texture = new Qn(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : ve, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0
                }
                setSize(e, t, n = 1) {
                    this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
                    const t = Object.assign({}, e.texture.image);
                    return this.texture.source = new Zn(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class nr extends Qn {
                constructor(e = null, t = 1, n = 1, r = 1) {
                    super(null), this.isDataArrayTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    }, this.magFilter = de, this.minFilter = de, this.wrapR = pe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            class rr extends tr {
                constructor(e, t, n) {
                    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new nr(null, e, t, n), this.texture.isRenderTargetTexture = !0
                }
            }
            class ir extends Qn {
                constructor(e = null, t = 1, n = 1, r = 1) {
                    super(null), this.isData3DTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: r
                    }, this.magFilter = de, this.minFilter = de, this.wrapR = pe, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            class sr extends tr {
                constructor(e, t, n) {
                    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new ir(null, e, t, n), this.texture.isRenderTargetTexture = !0
                }
            }
            class or extends tr {
                constructor(e, t, n, r = {}) {
                    super(e, t, r), this.isWebGLMultipleRenderTargets = !0;
                    const i = this.texture;
                    this.texture = [];
                    for (let e = 0; e < n; e++) this.texture[e] = i.clone(), this.texture[e].isRenderTargetTexture = !0
                }
                setSize(e, t, n = 1) {
                    if (this.width !== e || this.height !== t || this.depth !== n) {
                        this.width = e, this.height = t, this.depth = n;
                        for (let r = 0, i = this.texture.length; r < i; r++) this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = n;
                        this.dispose()
                    }
                    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
                }
                copy(e) {
                    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
                    for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
                    return this
                }
            }
            class ar {
                constructor(e = 0, t = 0, n = 0, r = 1) {
                    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r
                }
                static slerpFlat(e, t, n, r, i, s, o) {
                    let a = n[r + 0],
                        l = n[r + 1],
                        c = n[r + 2],
                        u = n[r + 3];
                    const p = i[s + 0],
                        h = i[s + 1],
                        d = i[s + 2],
                        f = i[s + 3];
                    if (0 === o) return e[t + 0] = a, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = u);
                    if (1 === o) return e[t + 0] = p, e[t + 1] = h, e[t + 2] = d, void(e[t + 3] = f);
                    if (u !== f || a !== p || l !== h || c !== d) {
                        let e = 1 - o;
                        const t = a * p + l * h + c * d + u * f,
                            n = t >= 0 ? 1 : -1,
                            r = 1 - t * t;
                        if (r > Number.EPSILON) {
                            const i = Math.sqrt(r),
                                s = Math.atan2(i, t * n);
                            e = Math.sin(e * s) / i, o = Math.sin(o * s) / i
                        }
                        const i = o * n;
                        if (a = a * e + p * i, l = l * e + h * i, c = c * e + d * i, u = u * e + f * i, e === 1 - o) {
                            const e = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
                            a *= e, l *= e, c *= e, u *= e
                        }
                    }
                    e[t] = a, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
                }
                static multiplyQuaternionsFlat(e, t, n, r, i, s) {
                    const o = n[r],
                        a = n[r + 1],
                        l = n[r + 2],
                        c = n[r + 3],
                        u = i[s],
                        p = i[s + 1],
                        h = i[s + 2],
                        d = i[s + 3];
                    return e[t] = o * d + c * u + a * h - l * p, e[t + 1] = a * d + c * p + l * u - o * h, e[t + 2] = l * d + c * h + o * p - a * u, e[t + 3] = c * d - o * u - a * p - l * h, e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e, this._onChangeCallback()
                }
                set(e, t, n, r) {
                    return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                }
                setFromEuler(e, t) {
                    if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const n = e._x,
                        r = e._y,
                        i = e._z,
                        s = e._order,
                        o = Math.cos,
                        a = Math.sin,
                        l = o(n / 2),
                        c = o(r / 2),
                        u = o(i / 2),
                        p = a(n / 2),
                        h = a(r / 2),
                        d = a(i / 2);
                    switch (s) {
                        case "XYZ":
                            this._x = p * c * u + l * h * d, this._y = l * h * u - p * c * d, this._z = l * c * d + p * h * u, this._w = l * c * u - p * h * d;
                            break;
                        case "YXZ":
                            this._x = p * c * u + l * h * d, this._y = l * h * u - p * c * d, this._z = l * c * d - p * h * u, this._w = l * c * u + p * h * d;
                            break;
                        case "ZXY":
                            this._x = p * c * u - l * h * d, this._y = l * h * u + p * c * d, this._z = l * c * d + p * h * u, this._w = l * c * u - p * h * d;
                            break;
                        case "ZYX":
                            this._x = p * c * u - l * h * d, this._y = l * h * u + p * c * d, this._z = l * c * d - p * h * u, this._w = l * c * u + p * h * d;
                            break;
                        case "YZX":
                            this._x = p * c * u + l * h * d, this._y = l * h * u + p * c * d, this._z = l * c * d - p * h * u, this._w = l * c * u - p * h * d;
                            break;
                        case "XZY":
                            this._x = p * c * u - l * h * d, this._y = l * h * u - p * c * d, this._z = l * c * d + p * h * u, this._w = l * c * u + p * h * d;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                    }
                    return !1 !== t && this._onChangeCallback(), this
                }
                setFromAxisAngle(e, t) {
                    const n = t / 2,
                        r = Math.sin(n);
                    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                }
                setFromRotationMatrix(e) {
                    const t = e.elements,
                        n = t[0],
                        r = t[4],
                        i = t[8],
                        s = t[1],
                        o = t[5],
                        a = t[9],
                        l = t[2],
                        c = t[6],
                        u = t[10],
                        p = n + o + u;
                    if (p > 0) {
                        const e = .5 / Math.sqrt(p + 1);
                        this._w = .25 / e, this._x = (c - a) * e, this._y = (i - l) * e, this._z = (s - r) * e
                    } else if (n > o && n > u) {
                        const e = 2 * Math.sqrt(1 + n - o - u);
                        this._w = (c - a) / e, this._x = .25 * e, this._y = (r + s) / e, this._z = (i + l) / e
                    } else if (o > u) {
                        const e = 2 * Math.sqrt(1 + o - n - u);
                        this._w = (i - l) / e, this._x = (r + s) / e, this._y = .25 * e, this._z = (a + c) / e
                    } else {
                        const e = 2 * Math.sqrt(1 + u - n - o);
                        this._w = (s - r) / e, this._x = (i + l) / e, this._y = (a + c) / e, this._z = .25 * e
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(e, t) {
                    let n = e.dot(t) + 1;
                    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(Mn(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    const n = this.angleTo(e);
                    if (0 === n) return this;
                    const r = Math.min(1, t / n);
                    return this.slerp(e, r), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                }
                multiply(e) {
                    return this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    const n = e._x,
                        r = e._y,
                        i = e._z,
                        s = e._w,
                        o = t._x,
                        a = t._y,
                        l = t._z,
                        c = t._w;
                    return this._x = n * c + s * o + r * l - i * a, this._y = r * c + s * a + i * o - n * l, this._z = i * c + s * l + n * a - r * o, this._w = s * c - n * o - r * a - i * l, this._onChangeCallback(), this
                }
                slerp(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    const n = this._x,
                        r = this._y,
                        i = this._z,
                        s = this._w;
                    let o = s * e._w + n * e._x + r * e._y + i * e._z;
                    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = s, this._x = n, this._y = r, this._z = i, this;
                    const a = 1 - o * o;
                    if (a <= Number.EPSILON) {
                        const e = 1 - t;
                        return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * r + t * this._y, this._z = e * i + t * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const l = Math.sqrt(a),
                        c = Math.atan2(l, o),
                        u = Math.sin((1 - t) * c) / l,
                        p = Math.sin(t * c) / l;
                    return this._w = s * u + this._w * p, this._x = n * u + this._x * p, this._y = r * u + this._y * p, this._z = i * u + this._z * p, this._onChangeCallback(), this
                }
                slerpQuaternions(e, t, n) {
                    return this.copy(e).slerp(t, n)
                }
                random() {
                    const e = Math.random(),
                        t = Math.sqrt(1 - e),
                        n = Math.sqrt(e),
                        r = 2 * Math.PI * Math.random(),
                        i = 2 * Math.PI * Math.random();
                    return this.set(t * Math.cos(r), n * Math.sin(i), n * Math.cos(i), t * Math.sin(r))
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t = 0) {
                    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._w
                }
            }
            class lr {
                constructor(e = 0, t = 0, n = 0) {
                    lr.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
                }
                set(e, t, n) {
                    return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
                add(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                }
                sub(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                }
                applyEuler(e) {
                    return this.applyQuaternion(ur.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(ur.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    const t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    const t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements,
                        s = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * s, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * s, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * s, this
                }
                applyQuaternion(e) {
                    const t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.x,
                        s = e.y,
                        o = e.z,
                        a = e.w,
                        l = a * t + s * r - o * n,
                        c = a * n + o * t - i * r,
                        u = a * r + i * n - s * t,
                        p = -i * t - s * n - o * r;
                    return this.x = l * a + p * -i + c * -o - u * -s, this.y = c * a + p * -s + u * -i - l * -o, this.z = u * a + p * -o + l * -s - c * -i, this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    const t = this.x,
                        n = this.y,
                        r = this.z,
                        i = e.elements;
                    return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
                }
                cross(e) {
                    return this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    const n = e.x,
                        r = e.y,
                        i = e.z,
                        s = t.x,
                        o = t.y,
                        a = t.z;
                    return this.x = r * a - i * o, this.y = i * s - n * a, this.z = n * o - r * s, this
                }
                projectOnVector(e) {
                    const t = e.lengthSq();
                    if (0 === t) return this.set(0, 0, 0);
                    const n = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(n)
                }
                projectOnPlane(e) {
                    return cr.copy(this).projectOnVector(e), this.sub(cr)
                }
                reflect(e) {
                    return this.sub(cr.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t) return Math.PI / 2;
                    const n = this.dot(e) / t;
                    return Math.acos(Mn(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        n = this.y - e.y,
                        r = this.z - e.z;
                    return t * t + n * n + r * r
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, n) {
                    const r = Math.sin(t) * e;
                    return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                }
                setFromMatrixPosition(e) {
                    const t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                }
                setFromMatrixScale(e) {
                    const t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        r = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = r, this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                setFromEuler(e) {
                    return this.x = e._x, this.y = e._y, this.z = e._z, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    const e = 2 * (Math.random() - .5),
                        t = Math.random() * Math.PI * 2,
                        n = Math.sqrt(1 - e ** 2);
                    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            const cr = new lr,
                ur = new ar;
            class pr {
                constructor(e = new lr(1 / 0, 1 / 0, 1 / 0), t = new lr(-1 / 0, -1 / 0, -1 / 0)) {
                    this.isBox3 = !0, this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromArray(e) {
                    let t = 1 / 0,
                        n = 1 / 0,
                        r = 1 / 0,
                        i = -1 / 0,
                        s = -1 / 0,
                        o = -1 / 0;
                    for (let a = 0, l = e.length; a < l; a += 3) {
                        const l = e[a],
                            c = e[a + 1],
                            u = e[a + 2];
                        l < t && (t = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > s && (s = c), u > o && (o = u)
                    }
                    return this.min.set(t, n, r), this.max.set(i, s, o), this
                }
                setFromBufferAttribute(e) {
                    let t = 1 / 0,
                        n = 1 / 0,
                        r = 1 / 0,
                        i = -1 / 0,
                        s = -1 / 0,
                        o = -1 / 0;
                    for (let a = 0, l = e.count; a < l; a++) {
                        const l = e.getX(a),
                            c = e.getY(a),
                            u = e.getZ(a);
                        l < t && (t = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > s && (s = c), u > o && (o = u)
                    }
                    return this.min.set(t, n, r), this.max.set(i, s, o), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const n = dr.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                setFromObject(e, t = !1) {
                    return this.makeEmpty(), this.expandByObject(e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                expandByObject(e, t = !1) {
                    e.updateWorldMatrix(!1, !1);
                    const n = e.geometry;
                    if (void 0 !== n)
                        if (t && null != n.attributes && void 0 !== n.attributes.position) {
                            const t = n.attributes.position;
                            for (let n = 0, r = t.count; n < r; n++) dr.fromBufferAttribute(t, n).applyMatrix4(e.matrixWorld), this.expandByPoint(dr)
                        } else null === n.boundingBox && n.computeBoundingBox(), fr.copy(n.boundingBox), fr.applyMatrix4(e.matrixWorld), this.union(fr);
                    const r = e.children;
                    for (let e = 0, n = r.length; e < n; e++) this.expandByObject(r[e], t);
                    return this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, dr), dr.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(yr), wr.subVectors(this.max, yr), _r.subVectors(e.a, yr), mr.subVectors(e.b, yr), gr.subVectors(e.c, yr), vr.subVectors(mr, _r), br.subVectors(gr, mr), xr.subVectors(_r, gr);
                    let t = [0, -vr.z, vr.y, 0, -br.z, br.y, 0, -xr.z, xr.y, vr.z, 0, -vr.x, br.z, 0, -br.x, xr.z, 0, -xr.x, -vr.y, vr.x, 0, -br.y, br.x, 0, -xr.y, xr.x, 0];
                    return !!Tr(t, _r, mr, gr, wr) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Tr(t, _r, mr, gr, wr) && (Sr.crossVectors(vr, br), t = [Sr.x, Sr.y, Sr.z], Tr(t, _r, mr, gr, wr)))
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return dr.copy(e).clamp(this.min, this.max).sub(e).length()
                }
                getBoundingSphere(e) {
                    return this.getCenter(e.center), e.radius = .5 * this.getSize(dr).length(), e
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (hr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), hr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), hr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), hr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), hr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), hr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), hr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), hr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(hr)), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            const hr = [new lr, new lr, new lr, new lr, new lr, new lr, new lr, new lr],
                dr = new lr,
                fr = new pr,
                _r = new lr,
                mr = new lr,
                gr = new lr,
                vr = new lr,
                br = new lr,
                xr = new lr,
                yr = new lr,
                wr = new lr,
                Sr = new lr,
                Mr = new lr;

            function Tr(e, t, n, r, i) {
                for (let s = 0, o = e.length - 3; s <= o; s += 3) {
                    Mr.fromArray(e, s);
                    const o = i.x * Math.abs(Mr.x) + i.y * Math.abs(Mr.y) + i.z * Math.abs(Mr.z),
                        a = t.dot(Mr),
                        l = n.dot(Mr),
                        c = r.dot(Mr);
                    if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
                }
                return !0
            }
            const Er = new pr,
                Ar = new lr,
                Cr = new lr,
                Rr = new lr;
            class kr {
                constructor(e = new lr, t = -1) {
                    this.center = e, this.radius = t
                }
                set(e, t) {
                    return this.center.copy(e), this.radius = t, this
                }
                setFromPoints(e, t) {
                    const n = this.center;
                    void 0 !== t ? n.copy(t) : Er.setFromPoints(e).getCenter(n);
                    let r = 0;
                    for (let t = 0, i = e.length; t < i; t++) r = Math.max(r, n.distanceToSquared(e[t]));
                    return this.radius = Math.sqrt(r), this
                }
                copy(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    const t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    const n = this.center.distanceToSquared(e);
                    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                }
                getBoundingBox(e) {
                    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                }
                translate(e) {
                    return this.center.add(e), this
                }
                expandByPoint(e) {
                    Rr.subVectors(e, this.center);
                    const t = Rr.lengthSq();
                    if (t > this.radius * this.radius) {
                        const e = Math.sqrt(t),
                            n = .5 * (e - this.radius);
                        this.center.add(Rr.multiplyScalar(n / e)), this.radius += n
                    }
                    return this
                }
                union(e) {
                    return !0 === this.center.equals(e.center) ? Cr.set(0, 0, 1).multiplyScalar(e.radius) : Cr.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Ar.copy(e.center).add(Cr)), this.expandByPoint(Ar.copy(e.center).sub(Cr)), this
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Pr = new lr,
                Dr = new lr,
                Or = new lr,
                Lr = new lr,
                Ir = new lr,
                Fr = new lr,
                Nr = new lr;
            class Ur {
                constructor(e = new lr, t = new lr(0, 0, -1)) {
                    this.origin = e, this.direction = t
                }
                set(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                }
                copy(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                }
                at(e, t) {
                    return t.copy(this.direction).multiplyScalar(e).add(this.origin)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, Pr)), this
                }
                closestPointToPoint(e, t) {
                    t.subVectors(e, this.origin);
                    const n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    const t = Pr.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (Pr.copy(this.direction).multiplyScalar(t).add(this.origin), Pr.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, n, r) {
                    Dr.copy(e).add(t).multiplyScalar(.5), Or.copy(t).sub(e).normalize(), Lr.copy(this.origin).sub(Dr);
                    const i = .5 * e.distanceTo(t),
                        s = -this.direction.dot(Or),
                        o = Lr.dot(this.direction),
                        a = -Lr.dot(Or),
                        l = Lr.lengthSq(),
                        c = Math.abs(1 - s * s);
                    let u, p, h, d;
                    if (c > 0)
                        if (u = s * a - o, p = s * o - a, d = i * c, u >= 0)
                            if (p >= -d)
                                if (p <= d) {
                                    const e = 1 / c;
                                    u *= e, p *= e, h = u * (u + s * p + 2 * o) + p * (s * u + p + 2 * a) + l
                                } else p = i, u = Math.max(0, -(s * p + o)), h = -u * u + p * (p + 2 * a) + l;
                    else p = -i, u = Math.max(0, -(s * p + o)), h = -u * u + p * (p + 2 * a) + l;
                    else p <= -d ? (u = Math.max(0, -(-s * i + o)), p = u > 0 ? -i : Math.min(Math.max(-i, -a), i), h = -u * u + p * (p + 2 * a) + l) : p <= d ? (u = 0, p = Math.min(Math.max(-i, -a), i), h = p * (p + 2 * a) + l) : (u = Math.max(0, -(s * i + o)), p = u > 0 ? i : Math.min(Math.max(-i, -a), i), h = -u * u + p * (p + 2 * a) + l);
                    else p = s > 0 ? -i : i, u = Math.max(0, -(s * p + o)), h = -u * u + p * (p + 2 * a) + l;
                    return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(Or).multiplyScalar(p).add(Dr), h
                }
                intersectSphere(e, t) {
                    Pr.subVectors(e.center, this.origin);
                    const n = Pr.dot(this.direction),
                        r = Pr.dot(Pr) - n * n,
                        i = e.radius * e.radius;
                    if (r > i) return null;
                    const s = Math.sqrt(i - r),
                        o = n - s,
                        a = n + s;
                    return o < 0 && a < 0 ? null : o < 0 ? this.at(a, t) : this.at(o, t)
                }
                intersectsSphere(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    const t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                }
                intersectPlane(e, t) {
                    const n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                }
                intersectsPlane(e) {
                    const t = e.distanceToPoint(this.origin);
                    return 0 === t || e.normal.dot(this.direction) * t < 0
                }
                intersectBox(e, t) {
                    let n, r, i, s, o, a;
                    const l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        p = this.origin;
                    return l >= 0 ? (n = (e.min.x - p.x) * l, r = (e.max.x - p.x) * l) : (n = (e.max.x - p.x) * l, r = (e.min.x - p.x) * l), c >= 0 ? (i = (e.min.y - p.y) * c, s = (e.max.y - p.y) * c) : (i = (e.max.y - p.y) * c, s = (e.min.y - p.y) * c), n > s || i > r ? null : ((i > n || n != n) && (n = i), (s < r || r != r) && (r = s), u >= 0 ? (o = (e.min.z - p.z) * u, a = (e.max.z - p.z) * u) : (o = (e.max.z - p.z) * u, a = (e.min.z - p.z) * u), n > a || o > r ? null : ((o > n || n != n) && (n = o), (a < r || r != r) && (r = a), r < 0 ? null : this.at(n >= 0 ? n : r, t)))
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, Pr)
                }
                intersectTriangle(e, t, n, r, i) {
                    Ir.subVectors(t, e), Fr.subVectors(n, e), Nr.crossVectors(Ir, Fr);
                    let s, o = this.direction.dot(Nr);
                    if (o > 0) {
                        if (r) return null;
                        s = 1
                    } else {
                        if (!(o < 0)) return null;
                        s = -1, o = -o
                    }
                    Lr.subVectors(this.origin, e);
                    const a = s * this.direction.dot(Fr.crossVectors(Lr, Fr));
                    if (a < 0) return null;
                    const l = s * this.direction.dot(Ir.cross(Lr));
                    if (l < 0) return null;
                    if (a + l > o) return null;
                    const c = -s * Lr.dot(Nr);
                    return c < 0 ? null : this.at(c / o, i)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class Br {
                constructor() {
                    Br.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
                }
                set(e, t, n, r, i, s, o, a, l, c, u, p, h, d, f, _) {
                    const m = this.elements;
                    return m[0] = e, m[4] = t, m[8] = n, m[12] = r, m[1] = i, m[5] = s, m[9] = o, m[13] = a, m[2] = l, m[6] = c, m[10] = u, m[14] = p, m[3] = h, m[7] = d, m[11] = f, m[15] = _, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new Br).fromArray(this.elements)
                }
                copy(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                }
                copyPosition(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                }
                setFromMatrix3(e) {
                    const t = e.elements;
                    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
                makeBasis(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(e) {
                    const t = this.elements,
                        n = e.elements,
                        r = 1 / jr.setFromMatrixColumn(e, 0).length(),
                        i = 1 / jr.setFromMatrixColumn(e, 1).length(),
                        s = 1 / jr.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromEuler(e) {
                    const t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z,
                        s = Math.cos(n),
                        o = Math.sin(n),
                        a = Math.cos(r),
                        l = Math.sin(r),
                        c = Math.cos(i),
                        u = Math.sin(i);
                    if ("XYZ" === e.order) {
                        const e = s * c,
                            n = s * u,
                            r = o * c,
                            i = o * u;
                        t[0] = a * c, t[4] = -a * u, t[8] = l, t[1] = n + r * l, t[5] = e - i * l, t[9] = -o * a, t[2] = i - e * l, t[6] = r + n * l, t[10] = s * a
                    } else if ("YXZ" === e.order) {
                        const e = a * c,
                            n = a * u,
                            r = l * c,
                            i = l * u;
                        t[0] = e + i * o, t[4] = r * o - n, t[8] = s * l, t[1] = s * u, t[5] = s * c, t[9] = -o, t[2] = n * o - r, t[6] = i + e * o, t[10] = s * a
                    } else if ("ZXY" === e.order) {
                        const e = a * c,
                            n = a * u,
                            r = l * c,
                            i = l * u;
                        t[0] = e - i * o, t[4] = -s * u, t[8] = r + n * o, t[1] = n + r * o, t[5] = s * c, t[9] = i - e * o, t[2] = -s * l, t[6] = o, t[10] = s * a
                    } else if ("ZYX" === e.order) {
                        const e = s * c,
                            n = s * u,
                            r = o * c,
                            i = o * u;
                        t[0] = a * c, t[4] = r * l - n, t[8] = e * l + i, t[1] = a * u, t[5] = i * l + e, t[9] = n * l - r, t[2] = -l, t[6] = o * a, t[10] = s * a
                    } else if ("YZX" === e.order) {
                        const e = s * a,
                            n = s * l,
                            r = o * a,
                            i = o * l;
                        t[0] = a * c, t[4] = i - e * u, t[8] = r * u + n, t[1] = u, t[5] = s * c, t[9] = -o * c, t[2] = -l * c, t[6] = n * u + r, t[10] = e - i * u
                    } else if ("XZY" === e.order) {
                        const e = s * a,
                            n = s * l,
                            r = o * a,
                            i = o * l;
                        t[0] = a * c, t[4] = -u, t[8] = l * c, t[1] = e * u + i, t[5] = s * c, t[9] = n * u - r, t[2] = r * u - n, t[6] = o * c, t[10] = i * u + e
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(Vr, e, Gr)
                }
                lookAt(e, t, n) {
                    const r = this.elements;
                    return Kr.subVectors(e, t), 0 === Kr.lengthSq() && (Kr.z = 1), Kr.normalize(), Hr.crossVectors(n, Kr), 0 === Hr.lengthSq() && (1 === Math.abs(n.z) ? Kr.x += 1e-4 : Kr.z += 1e-4, Kr.normalize(), Hr.crossVectors(n, Kr)), Hr.normalize(), Wr.crossVectors(Kr, Hr), r[0] = Hr.x, r[4] = Wr.x, r[8] = Kr.x, r[1] = Hr.y, r[5] = Wr.y, r[9] = Kr.y, r[2] = Hr.z, r[6] = Wr.z, r[10] = Kr.z, this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements,
                        r = t.elements,
                        i = this.elements,
                        s = n[0],
                        o = n[4],
                        a = n[8],
                        l = n[12],
                        c = n[1],
                        u = n[5],
                        p = n[9],
                        h = n[13],
                        d = n[2],
                        f = n[6],
                        _ = n[10],
                        m = n[14],
                        g = n[3],
                        v = n[7],
                        b = n[11],
                        x = n[15],
                        y = r[0],
                        w = r[4],
                        S = r[8],
                        M = r[12],
                        T = r[1],
                        E = r[5],
                        A = r[9],
                        C = r[13],
                        R = r[2],
                        k = r[6],
                        P = r[10],
                        D = r[14],
                        O = r[3],
                        L = r[7],
                        I = r[11],
                        F = r[15];
                    return i[0] = s * y + o * T + a * R + l * O, i[4] = s * w + o * E + a * k + l * L, i[8] = s * S + o * A + a * P + l * I, i[12] = s * M + o * C + a * D + l * F, i[1] = c * y + u * T + p * R + h * O, i[5] = c * w + u * E + p * k + h * L, i[9] = c * S + u * A + p * P + h * I, i[13] = c * M + u * C + p * D + h * F, i[2] = d * y + f * T + _ * R + m * O, i[6] = d * w + f * E + _ * k + m * L, i[10] = d * S + f * A + _ * P + m * I, i[14] = d * M + f * C + _ * D + m * F, i[3] = g * y + v * T + b * R + x * O, i[7] = g * w + v * E + b * k + x * L, i[11] = g * S + v * A + b * P + x * I, i[15] = g * M + v * C + b * D + x * F, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        n = e[4],
                        r = e[8],
                        i = e[12],
                        s = e[1],
                        o = e[5],
                        a = e[9],
                        l = e[13],
                        c = e[2],
                        u = e[6],
                        p = e[10],
                        h = e[14];
                    return e[3] * (+i * a * u - r * l * u - i * o * p + n * l * p + r * o * h - n * a * h) + e[7] * (+t * a * h - t * l * p + i * s * p - r * s * h + r * l * c - i * a * c) + e[11] * (+t * l * u - t * o * h - i * s * u + n * s * h + i * o * c - n * l * c) + e[15] * (-r * o * c - t * a * u + t * o * p + r * s * u - n * s * p + n * a * c)
                }
                transpose() {
                    const e = this.elements;
                    let t;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                }
                setPosition(e, t, n) {
                    const r = this.elements;
                    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        r = e[2],
                        i = e[3],
                        s = e[4],
                        o = e[5],
                        a = e[6],
                        l = e[7],
                        c = e[8],
                        u = e[9],
                        p = e[10],
                        h = e[11],
                        d = e[12],
                        f = e[13],
                        _ = e[14],
                        m = e[15],
                        g = u * _ * l - f * p * l + f * a * h - o * _ * h - u * a * m + o * p * m,
                        v = d * p * l - c * _ * l - d * a * h + s * _ * h + c * a * m - s * p * m,
                        b = c * f * l - d * u * l + d * o * h - s * f * h - c * o * m + s * u * m,
                        x = d * u * a - c * f * a - d * o * p + s * f * p + c * o * _ - s * u * _,
                        y = t * g + n * v + r * b + i * x;
                    if (0 === y) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const w = 1 / y;
                    return e[0] = g * w, e[1] = (f * p * i - u * _ * i - f * r * h + n * _ * h + u * r * m - n * p * m) * w, e[2] = (o * _ * i - f * a * i + f * r * l - n * _ * l - o * r * m + n * a * m) * w, e[3] = (u * a * i - o * p * i - u * r * l + n * p * l + o * r * h - n * a * h) * w, e[4] = v * w, e[5] = (c * _ * i - d * p * i + d * r * h - t * _ * h - c * r * m + t * p * m) * w, e[6] = (d * a * i - s * _ * i - d * r * l + t * _ * l + s * r * m - t * a * m) * w, e[7] = (s * p * i - c * a * i + c * r * l - t * p * l - s * r * h + t * a * h) * w, e[8] = b * w, e[9] = (d * u * i - c * f * i - d * n * h + t * f * h + c * n * m - t * u * m) * w, e[10] = (s * f * i - d * o * i + d * n * l - t * f * l - s * n * m + t * o * m) * w, e[11] = (c * o * i - s * u * i - c * n * l + t * u * l + s * n * h - t * o * h) * w, e[12] = x * w, e[13] = (c * f * r - d * u * r + d * n * p - t * f * p - c * n * _ + t * u * _) * w, e[14] = (d * o * r - s * f * r - d * n * a + t * f * a + s * n * _ - t * o * _) * w, e[15] = (s * u * r - c * o * r + c * n * a - t * u * a - s * n * p + t * o * p) * w, this
                }
                scale(e) {
                    const t = this.elements,
                        n = e.x,
                        r = e.y,
                        i = e.z;
                    return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
                }
                getMaxScaleOnAxis() {
                    const e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, r))
                }
                makeTranslation(e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                }
                makeRotationX(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                }
                makeRotationY(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(e, t) {
                    const n = Math.cos(t),
                        r = Math.sin(t),
                        i = 1 - n,
                        s = e.x,
                        o = e.y,
                        a = e.z,
                        l = i * s,
                        c = i * o;
                    return this.set(l * s + n, l * o - r * a, l * a + r * o, 0, l * o + r * a, c * o + n, c * a - r * s, 0, l * a - r * o, c * a + r * s, i * a * a + n, 0, 0, 0, 0, 1), this
                }
                makeScale(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
                makeShear(e, t, n, r, i, s) {
                    return this.set(1, n, i, 0, e, 1, s, 0, t, r, 1, 0, 0, 0, 0, 1), this
                }
                compose(e, t, n) {
                    const r = this.elements,
                        i = t._x,
                        s = t._y,
                        o = t._z,
                        a = t._w,
                        l = i + i,
                        c = s + s,
                        u = o + o,
                        p = i * l,
                        h = i * c,
                        d = i * u,
                        f = s * c,
                        _ = s * u,
                        m = o * u,
                        g = a * l,
                        v = a * c,
                        b = a * u,
                        x = n.x,
                        y = n.y,
                        w = n.z;
                    return r[0] = (1 - (f + m)) * x, r[1] = (h + b) * x, r[2] = (d - v) * x, r[3] = 0, r[4] = (h - b) * y, r[5] = (1 - (p + m)) * y, r[6] = (_ + g) * y, r[7] = 0, r[8] = (d + v) * w, r[9] = (_ - g) * w, r[10] = (1 - (p + f)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
                }
                decompose(e, t, n) {
                    const r = this.elements;
                    let i = jr.set(r[0], r[1], r[2]).length();
                    const s = jr.set(r[4], r[5], r[6]).length(),
                        o = jr.set(r[8], r[9], r[10]).length();
                    this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], zr.copy(this);
                    const a = 1 / i,
                        l = 1 / s,
                        c = 1 / o;
                    return zr.elements[0] *= a, zr.elements[1] *= a, zr.elements[2] *= a, zr.elements[4] *= l, zr.elements[5] *= l, zr.elements[6] *= l, zr.elements[8] *= c, zr.elements[9] *= c, zr.elements[10] *= c, t.setFromRotationMatrix(zr), n.x = i, n.y = s, n.z = o, this
                }
                makePerspective(e, t, n, r, i, s) {
                    const o = this.elements,
                        a = 2 * i / (t - e),
                        l = 2 * i / (n - r),
                        c = (t + e) / (t - e),
                        u = (n + r) / (n - r),
                        p = -(s + i) / (s - i),
                        h = -2 * s * i / (s - i);
                    return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = p, o[14] = h, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                }
                makeOrthographic(e, t, n, r, i, s) {
                    const o = this.elements,
                        a = 1 / (t - e),
                        l = 1 / (n - r),
                        c = 1 / (s - i),
                        u = (t + e) * a,
                        p = (n + r) * l,
                        h = (s + i) * c;
                    return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -p, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -h, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                }
                equals(e) {
                    const t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 16; e++)
                        if (t[e] !== n[e]) return !1;
                    return !0
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }
            const jr = new lr,
                zr = new Br,
                Vr = new lr(0, 0, 0),
                Gr = new lr(1, 1, 1),
                Hr = new lr,
                Wr = new lr,
                Kr = new lr,
                Xr = new Br,
                qr = new ar;
            class Yr {
                constructor(e = 0, t = 0, n = 0, r = Yr.DefaultOrder) {
                    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e, this._onChangeCallback()
                }
                set(e, t, n, r = this._order) {
                    return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(e, t = this._order, n = !0) {
                    const r = e.elements,
                        i = r[0],
                        s = r[4],
                        o = r[8],
                        a = r[1],
                        l = r[5],
                        c = r[9],
                        u = r[2],
                        p = r[6],
                        h = r[10];
                    switch (t) {
                        case "XYZ":
                            this._y = Math.asin(Mn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, h), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(p, l), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-Mn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, h), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, i), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(Mn(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-u, h), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, i));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-Mn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(p, h), this._z = Math.atan2(a, i)) : (this._x = 0, this._z = Math.atan2(-s, l));
                            break;
                        case "YZX":
                            this._z = Math.asin(Mn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(o, h));
                            break;
                        case "XZY":
                            this._z = Math.asin(-Mn(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(p, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-c, h), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                    }
                    return this._order = t, !0 === n && this._onChangeCallback(), this
                }
                setFromQuaternion(e, t, n) {
                    return Xr.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Xr, t, n)
                }
                setFromVector3(e, t = this._order) {
                    return this.set(e.x, e.y, e.z, t)
                }
                reorder(e) {
                    return qr.setFromEuler(this), this.setFromQuaternion(qr, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}*[Symbol.iterator]() {
                    yield this._x, yield this._y, yield this._z, yield this._order
                }
                toVector3() {
                    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
                }
            }
            Yr.DefaultOrder = "XYZ", Yr.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            class Zr {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = (1 << e | 0) >>> 0
                }
                enable(e) {
                    this.mask |= 1 << e | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e | 0
                }
                disable(e) {
                    this.mask &= ~(1 << e | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return 0 != (this.mask & e.mask)
                }
                isEnabled(e) {
                    return 0 != (this.mask & (1 << e | 0))
                }
            }
            let Jr = 0;
            const $r = new lr,
                Qr = new ar,
                ei = new Br,
                ti = new lr,
                ni = new lr,
                ri = new lr,
                ii = new ar,
                si = new lr(1, 0, 0),
                oi = new lr(0, 1, 0),
                ai = new lr(0, 0, 1),
                li = {
                    type: "added"
                },
                ci = {
                    type: "removed"
                };
            class ui extends vn {
                constructor() {
                    super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                        value: Jr++
                    }), this.uuid = Sn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ui.DefaultUp.clone();
                    const e = new lr,
                        t = new Yr,
                        n = new ar,
                        r = new lr(1, 1, 1);
                    t._onChange((function() {
                        n.setFromEuler(t, !1)
                    })), n._onChange((function() {
                        t.setFromQuaternion(n, void 0, !1)
                    })), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: r
                        },
                        modelViewMatrix: {
                            value: new Br
                        },
                        normalMatrix: {
                            value: new Dn
                        }
                    }), this.matrix = new Br, this.matrixWorld = new Br, this.matrixAutoUpdate = ui.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Zr, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(e) {
                    return this.quaternion.premultiply(e), this
                }
                setRotationFromAxisAngle(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                }
                setRotationFromEuler(e) {
                    this.quaternion.setFromEuler(e, !0)
                }
                setRotationFromMatrix(e) {
                    this.quaternion.setFromRotationMatrix(e)
                }
                setRotationFromQuaternion(e) {
                    this.quaternion.copy(e)
                }
                rotateOnAxis(e, t) {
                    return Qr.setFromAxisAngle(e, t), this.quaternion.multiply(Qr), this
                }
                rotateOnWorldAxis(e, t) {
                    return Qr.setFromAxisAngle(e, t), this.quaternion.premultiply(Qr), this
                }
                rotateX(e) {
                    return this.rotateOnAxis(si, e)
                }
                rotateY(e) {
                    return this.rotateOnAxis(oi, e)
                }
                rotateZ(e) {
                    return this.rotateOnAxis(ai, e)
                }
                translateOnAxis(e, t) {
                    return $r.copy(e).applyQuaternion(this.quaternion), this.position.add($r.multiplyScalar(t)), this
                }
                translateX(e) {
                    return this.translateOnAxis(si, e)
                }
                translateY(e) {
                    return this.translateOnAxis(oi, e)
                }
                translateZ(e) {
                    return this.translateOnAxis(ai, e)
                }
                localToWorld(e) {
                    return e.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(e) {
                    return e.applyMatrix4(ei.copy(this.matrixWorld).invert())
                }
                lookAt(e, t, n) {
                    e.isVector3 ? ti.copy(e) : ti.set(e, t, n);
                    const r = this.parent;
                    this.updateWorldMatrix(!0, !1), ni.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ei.lookAt(ni, ti, this.up) : ei.lookAt(ti, ni, this.up), this.quaternion.setFromRotationMatrix(ei), r && (ei.extractRotation(r.matrixWorld), Qr.setFromRotationMatrix(ei), this.quaternion.premultiply(Qr.invert()))
                }
                add(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(li)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                }
                remove(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    const t = this.children.indexOf(e);
                    return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(ci)), this
                }
                removeFromParent() {
                    const e = this.parent;
                    return null !== e && e.remove(this), this
                }
                clear() {
                    for (let e = 0; e < this.children.length; e++) {
                        const t = this.children[e];
                        t.parent = null, t.dispatchEvent(ci)
                    }
                    return this.children.length = 0, this
                }
                attach(e) {
                    return this.updateWorldMatrix(!0, !1), ei.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), ei.multiply(e.parent.matrixWorld)), e.applyMatrix4(ei), this.add(e), e.updateWorldMatrix(!1, !0), this
                }
                getObjectById(e) {
                    return this.getObjectByProperty("id", e)
                }
                getObjectByName(e) {
                    return this.getObjectByProperty("name", e)
                }
                getObjectByProperty(e, t) {
                    if (this[e] === t) return this;
                    for (let n = 0, r = this.children.length; n < r; n++) {
                        const r = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== r) return r
                    }
                }
                getWorldPosition(e) {
                    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ni, e, ri), e
                }
                getWorldScale(e) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ni, ii, e), e
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    const t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                }
                raycast() {}
                traverse(e) {
                    e(this);
                    const t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) t[n].traverse(e)
                }
                traverseVisible(e) {
                    if (!1 === this.visible) return;
                    e(this);
                    const t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
                }
                traverseAncestors(e) {
                    const t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                    const t = this.children;
                    for (let n = 0, r = t.length; n < r; n++) t[n].updateMatrixWorld(e)
                }
                updateWorldMatrix(e, t) {
                    const n = this.parent;
                    if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                        const e = this.children;
                        for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
                    }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e,
                        n = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const r = {};

                    function i(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                    }
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (r.environment = this.environment.toJSON(e).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        r.geometry = i(e.geometries, this.geometry);
                        const t = this.geometry.parameters;
                        if (void 0 !== t && void 0 !== t.shapes) {
                            const n = t.shapes;
                            if (Array.isArray(n))
                                for (let t = 0, r = n.length; t < r; t++) {
                                    const r = n[t];
                                    i(e.shapes, r)
                                } else i(e.shapes, n)
                        }
                    }
                    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const t = [];
                            for (let n = 0, r = this.material.length; n < r; n++) t.push(i(e.materials, this.material[n]));
                            r.material = t
                        } else r.material = i(e.materials, this.material);
                    if (this.children.length > 0) {
                        r.children = [];
                        for (let t = 0; t < this.children.length; t++) r.children.push(this.children[t].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        r.animations = [];
                        for (let t = 0; t < this.animations.length; t++) {
                            const n = this.animations[t];
                            r.animations.push(i(e.animations, n))
                        }
                    }
                    if (t) {
                        const t = s(e.geometries),
                            r = s(e.materials),
                            i = s(e.textures),
                            o = s(e.images),
                            a = s(e.shapes),
                            l = s(e.skeletons),
                            c = s(e.animations),
                            u = s(e.nodes);
                        t.length > 0 && (n.geometries = t), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u)
                    }
                    return n.object = r, n;

                    function s(e) {
                        const t = [];
                        for (const n in e) {
                            const r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                }
                clone(e) {
                    return (new this.constructor).copy(this, e)
                }
                copy(e, t = !0) {
                    this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = {};
                    for (const [t, n] of Object.entries(e.userData)) this.userData[t] = !n || n && (n.isTexture || n.isObject3D) ? n : JSON.parse(JSON.stringify(n));
                    if (!0 === t)
                        for (let t = 0; t < e.children.length; t++) {
                            const n = e.children[t];
                            this.add(n.clone())
                        }
                    return this
                }
            }
            ui.DefaultUp = new lr(0, 1, 0), ui.DefaultMatrixAutoUpdate = !0;
            const pi = new lr,
                hi = new lr,
                di = new lr,
                fi = new lr,
                _i = new lr,
                mi = new lr,
                gi = new lr,
                vi = new lr,
                bi = new lr,
                xi = new lr;
            class yi {
                constructor(e = new lr, t = new lr, n = new lr) {
                    this.a = e, this.b = t, this.c = n
                }
                static getNormal(e, t, n, r) {
                    r.subVectors(n, t), pi.subVectors(e, t), r.cross(pi);
                    const i = r.lengthSq();
                    return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                }
                static getBarycoord(e, t, n, r, i) {
                    pi.subVectors(r, t), hi.subVectors(n, t), di.subVectors(e, t);
                    const s = pi.dot(pi),
                        o = pi.dot(hi),
                        a = pi.dot(di),
                        l = hi.dot(hi),
                        c = hi.dot(di),
                        u = s * l - o * o;
                    if (0 === u) return i.set(-2, -1, -1);
                    const p = 1 / u,
                        h = (l * a - o * c) * p,
                        d = (s * c - o * a) * p;
                    return i.set(1 - h - d, d, h)
                }
                static containsPoint(e, t, n, r) {
                    return this.getBarycoord(e, t, n, r, fi), fi.x >= 0 && fi.y >= 0 && fi.x + fi.y <= 1
                }
                static getUV(e, t, n, r, i, s, o, a) {
                    return this.getBarycoord(e, t, n, r, fi), a.set(0, 0), a.addScaledVector(i, fi.x), a.addScaledVector(s, fi.y), a.addScaledVector(o, fi.z), a
                }
                static isFrontFacing(e, t, n, r) {
                    return pi.subVectors(n, t), hi.subVectors(e, t), pi.cross(hi).dot(r) < 0
                }
                set(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                }
                setFromPointsAndIndices(e, t, n, r) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
                }
                setFromAttributeAndIndices(e, t, n, r) {
                    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                }
                getArea() {
                    return pi.subVectors(this.c, this.b), hi.subVectors(this.a, this.b), .5 * pi.cross(hi).length()
                }
                getMidpoint(e) {
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return yi.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return yi.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getUV(e, t, n, r, i) {
                    return yi.getUV(e, this.a, this.b, this.c, t, n, r, i)
                }
                containsPoint(e) {
                    return yi.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return yi.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    const n = this.a,
                        r = this.b,
                        i = this.c;
                    let s, o;
                    _i.subVectors(r, n), mi.subVectors(i, n), vi.subVectors(e, n);
                    const a = _i.dot(vi),
                        l = mi.dot(vi);
                    if (a <= 0 && l <= 0) return t.copy(n);
                    bi.subVectors(e, r);
                    const c = _i.dot(bi),
                        u = mi.dot(bi);
                    if (c >= 0 && u <= c) return t.copy(r);
                    const p = a * u - c * l;
                    if (p <= 0 && a >= 0 && c <= 0) return s = a / (a - c), t.copy(n).addScaledVector(_i, s);
                    xi.subVectors(e, i);
                    const h = _i.dot(xi),
                        d = mi.dot(xi);
                    if (d >= 0 && h <= d) return t.copy(i);
                    const f = h * l - a * d;
                    if (f <= 0 && l >= 0 && d <= 0) return o = l / (l - d), t.copy(n).addScaledVector(mi, o);
                    const _ = c * d - h * u;
                    if (_ <= 0 && u - c >= 0 && h - d >= 0) return gi.subVectors(i, r), o = (u - c) / (u - c + (h - d)), t.copy(r).addScaledVector(gi, o);
                    const m = 1 / (_ + f + p);
                    return s = f * m, o = p * m, t.copy(n).addScaledVector(_i, s).addScaledVector(mi, o)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            let wi = 0;
            class Si extends vn {
                constructor() {
                    super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                        value: wi++
                    }), this.uuid = Sn(), this.name = "", this.type = "Material", this.blending = x, this.side = f, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = L, this.blendDst = I, this.blendEquation = T, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = H, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = sn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ht, this.stencilZFail = Ht, this.stencilZPass = Ht, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(e) {
                    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                }
                onBuild() {}
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(e) {
                    if (void 0 !== e)
                        for (const t in e) {
                            const n = e[t];
                            if (void 0 === n) {
                                console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                                continue
                            }
                            if ("shading" === t) {
                                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === g;
                                continue
                            }
                            const r = this[t];
                            void 0 !== r && (r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n)
                        }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function r(e) {
                        const t = [];
                        for (const n in e) {
                            const r = e[n];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== x && (n.blending = this.blending), this.side !== f && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                        const t = r(e.textures),
                            i = r(e.images);
                        t.length > 0 && (n.textures = t), i.length > 0 && (n.images = i)
                    }
                    return n
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                    const t = e.clippingPlanes;
                    let n = null;
                    if (null !== t) {
                        const e = t.length;
                        n = new Array(e);
                        for (let r = 0; r !== e; ++r) n[r] = t[r].clone()
                    }
                    this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = {};
                    for (const [t, n] of Object.entries(e.userData)) this.userData[t] = !n || n && (n.isTexture || n.isObject3D) ? n : JSON.parse(JSON.stringify(n));
                    return this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
            }
            class Mi extends Si {
                constructor(e) {
                    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Xn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Y, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                }
            }
            const Ti = new lr,
                Ei = new Pn;
            class Ai {
                constructor(e, t, n) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = on, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
                }
                copyAt(e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (let r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                }
                copyArray(e) {
                    return this.array.set(e), this
                }
                copyColorsArray(e) {
                    const t = this.array;
                    let n = 0;
                    for (let r = 0, i = e.length; r < i; r++) {
                        let i = e[r];
                        void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new Xn), t[n++] = i.r, t[n++] = i.g, t[n++] = i.b
                    }
                    return this
                }
                copyVector2sArray(e) {
                    const t = this.array;
                    let n = 0;
                    for (let r = 0, i = e.length; r < i; r++) {
                        let i = e[r];
                        void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new Pn), t[n++] = i.x, t[n++] = i.y
                    }
                    return this
                }
                copyVector3sArray(e) {
                    const t = this.array;
                    let n = 0;
                    for (let r = 0, i = e.length; r < i; r++) {
                        let i = e[r];
                        void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new lr), t[n++] = i.x, t[n++] = i.y, t[n++] = i.z
                    }
                    return this
                }
                copyVector4sArray(e) {
                    const t = this.array;
                    let n = 0;
                    for (let r = 0, i = e.length; r < i; r++) {
                        let i = e[r];
                        void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new er), t[n++] = i.x, t[n++] = i.y, t[n++] = i.z, t[n++] = i.w
                    }
                    return this
                }
                applyMatrix3(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) Ei.fromBufferAttribute(this, t), Ei.applyMatrix3(e), this.setXY(t, Ei.x, Ei.y);
                    else if (3 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.applyMatrix3(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
                    return this
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.applyMatrix4(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.applyNormalMatrix(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.transformDirection(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                getX(e) {
                    return this.array[e * this.itemSize]
                }
                setX(e, t) {
                    return this.array[e * this.itemSize] = t, this
                }
                getY(e) {
                    return this.array[e * this.itemSize + 1]
                }
                setY(e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                }
                getZ(e) {
                    return this.array[e * this.itemSize + 2]
                }
                setZ(e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                }
                getW(e) {
                    return this.array[e * this.itemSize + 3]
                }
                setW(e, t) {
                    return this.array[e * this.itemSize + 3] = t, this
                }
                setXY(e, t, n) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
                }
                setXYZ(e, t, n, r) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
                }
                setXYZW(e, t, n, r, i) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    const e = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.from(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (e.name = this.name), this.usage !== on && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
                }
            }
            class Ci extends Ai {
                constructor(e, t, n) {
                    super(new Int8Array(e), t, n)
                }
            }
            class Ri extends Ai {
                constructor(e, t, n) {
                    super(new Uint8Array(e), t, n)
                }
            }
            class ki extends Ai {
                constructor(e, t, n) {
                    super(new Uint8ClampedArray(e), t, n)
                }
            }
            class Pi extends Ai {
                constructor(e, t, n) {
                    super(new Int16Array(e), t, n)
                }
            }
            class Di extends Ai {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n)
                }
            }
            class Oi extends Ai {
                constructor(e, t, n) {
                    super(new Int32Array(e), t, n)
                }
            }
            class Li extends Ai {
                constructor(e, t, n) {
                    super(new Uint32Array(e), t, n)
                }
            }
            class Ii extends Ai {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0
                }
            }
            class Fi extends Ai {
                constructor(e, t, n) {
                    super(new Float32Array(e), t, n)
                }
            }
            class Ni extends Ai {
                constructor(e, t, n) {
                    super(new Float64Array(e), t, n)
                }
            }
            let Ui = 0;
            const Bi = new Br,
                ji = new ui,
                zi = new lr,
                Vi = new pr,
                Gi = new pr,
                Hi = new lr;
            class Wi extends vn {
                constructor() {
                    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                        value: Ui++
                    }), this.uuid = Sn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(e) {
                    return Array.isArray(e) ? this.index = new(On(e) ? Li : Di)(e, 1) : this.index = e, this
                }
                getAttribute(e) {
                    return this.attributes[e]
                }
                setAttribute(e, t) {
                    return this.attributes[e] = t, this
                }
                deleteAttribute(e) {
                    return delete this.attributes[e], this
                }
                hasAttribute(e) {
                    return void 0 !== this.attributes[e]
                }
                addGroup(e, t, n = 0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: n
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                }
                applyMatrix4(e) {
                    const t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const t = (new Dn).getNormalMatrix(e);
                        n.applyNormalMatrix(t), n.needsUpdate = !0
                    }
                    const r = this.attributes.tangent;
                    return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(e) {
                    return Bi.makeRotationFromQuaternion(e), this.applyMatrix4(Bi), this
                }
                rotateX(e) {
                    return Bi.makeRotationX(e), this.applyMatrix4(Bi), this
                }
                rotateY(e) {
                    return Bi.makeRotationY(e), this.applyMatrix4(Bi), this
                }
                rotateZ(e) {
                    return Bi.makeRotationZ(e), this.applyMatrix4(Bi), this
                }
                translate(e, t, n) {
                    return Bi.makeTranslation(e, t, n), this.applyMatrix4(Bi), this
                }
                scale(e, t, n) {
                    return Bi.makeScale(e, t, n), this.applyMatrix4(Bi), this
                }
                lookAt(e) {
                    return ji.lookAt(e), ji.updateMatrix(), this.applyMatrix4(ji.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(zi).negate(), this.translate(zi.x, zi.y, zi.z), this
                }
                setFromPoints(e) {
                    const t = [];
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = e[n];
                        t.push(r.x, r.y, r.z || 0)
                    }
                    return this.setAttribute("position", new Fi(t, 3)), this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new pr);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new lr(-1 / 0, -1 / 0, -1 / 0), new lr(1 / 0, 1 / 0, 1 / 0));
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e), t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                Vi.setFromBufferAttribute(n), this.morphTargetsRelative ? (Hi.addVectors(this.boundingBox.min, Vi.min), this.boundingBox.expandByPoint(Hi), Hi.addVectors(this.boundingBox.max, Vi.max), this.boundingBox.expandByPoint(Hi)) : (this.boundingBox.expandByPoint(Vi.min), this.boundingBox.expandByPoint(Vi.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new kr);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new lr, 1 / 0);
                    if (e) {
                        const n = this.boundingSphere.center;
                        if (Vi.setFromBufferAttribute(e), t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                Gi.setFromBufferAttribute(n), this.morphTargetsRelative ? (Hi.addVectors(Vi.min, Gi.min), Vi.expandByPoint(Hi), Hi.addVectors(Vi.max, Gi.max), Vi.expandByPoint(Hi)) : (Vi.expandByPoint(Gi.min), Vi.expandByPoint(Gi.max))
                            }
                        Vi.getCenter(n);
                        let r = 0;
                        for (let t = 0, i = e.count; t < i; t++) Hi.fromBufferAttribute(e, t), r = Math.max(r, n.distanceToSquared(Hi));
                        if (t)
                            for (let i = 0, s = t.length; i < s; i++) {
                                const s = t[i],
                                    o = this.morphTargetsRelative;
                                for (let t = 0, i = s.count; t < i; t++) Hi.fromBufferAttribute(s, t), o && (zi.fromBufferAttribute(e, t), Hi.add(zi)), r = Math.max(r, n.distanceToSquared(Hi))
                            }
                        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    const e = this.index,
                        t = this.attributes;
                    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    const n = e.array,
                        r = t.position.array,
                        i = t.normal.array,
                        s = t.uv.array,
                        o = r.length / 3;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ai(new Float32Array(4 * o), 4));
                    const a = this.getAttribute("tangent").array,
                        l = [],
                        c = [];
                    for (let e = 0; e < o; e++) l[e] = new lr, c[e] = new lr;
                    const u = new lr,
                        p = new lr,
                        h = new lr,
                        d = new Pn,
                        f = new Pn,
                        _ = new Pn,
                        m = new lr,
                        g = new lr;

                    function v(e, t, n) {
                        u.fromArray(r, 3 * e), p.fromArray(r, 3 * t), h.fromArray(r, 3 * n), d.fromArray(s, 2 * e), f.fromArray(s, 2 * t), _.fromArray(s, 2 * n), p.sub(u), h.sub(u), f.sub(d), _.sub(d);
                        const i = 1 / (f.x * _.y - _.x * f.y);
                        isFinite(i) && (m.copy(p).multiplyScalar(_.y).addScaledVector(h, -f.y).multiplyScalar(i), g.copy(h).multiplyScalar(f.x).addScaledVector(p, -_.x).multiplyScalar(i), l[e].add(m), l[t].add(m), l[n].add(m), c[e].add(g), c[t].add(g), c[n].add(g))
                    }
                    let b = this.groups;
                    0 === b.length && (b = [{
                        start: 0,
                        count: n.length
                    }]);
                    for (let e = 0, t = b.length; e < t; ++e) {
                        const t = b[e],
                            r = t.start;
                        for (let e = r, i = r + t.count; e < i; e += 3) v(n[e + 0], n[e + 1], n[e + 2])
                    }
                    const x = new lr,
                        y = new lr,
                        w = new lr,
                        S = new lr;

                    function M(e) {
                        w.fromArray(i, 3 * e), S.copy(w);
                        const t = l[e];
                        x.copy(t), x.sub(w.multiplyScalar(w.dot(t))).normalize(), y.crossVectors(S, t);
                        const n = y.dot(c[e]) < 0 ? -1 : 1;
                        a[4 * e] = x.x, a[4 * e + 1] = x.y, a[4 * e + 2] = x.z, a[4 * e + 3] = n
                    }
                    for (let e = 0, t = b.length; e < t; ++e) {
                        const t = b[e],
                            r = t.start;
                        for (let e = r, i = r + t.count; e < i; e += 3) M(n[e + 0]), M(n[e + 1]), M(n[e + 2])
                    }
                }
                computeVertexNormals() {
                    const e = this.index,
                        t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n) n = new Ai(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                        else
                            for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                        const r = new lr,
                            i = new lr,
                            s = new lr,
                            o = new lr,
                            a = new lr,
                            l = new lr,
                            c = new lr,
                            u = new lr;
                        if (e)
                            for (let p = 0, h = e.count; p < h; p += 3) {
                                const h = e.getX(p + 0),
                                    d = e.getX(p + 1),
                                    f = e.getX(p + 2);
                                r.fromBufferAttribute(t, h), i.fromBufferAttribute(t, d), s.fromBufferAttribute(t, f), c.subVectors(s, i), u.subVectors(r, i), c.cross(u), o.fromBufferAttribute(n, h), a.fromBufferAttribute(n, d), l.fromBufferAttribute(n, f), o.add(c), a.add(c), l.add(c), n.setXYZ(h, o.x, o.y, o.z), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(f, l.x, l.y, l.z)
                            } else
                                for (let e = 0, o = t.count; e < o; e += 3) r.fromBufferAttribute(t, e + 0), i.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, i), u.subVectors(r, i), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), n.needsUpdate = !0
                    }
                }
                merge(e, t) {
                    if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                    void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    const n = this.attributes;
                    for (const r in n) {
                        if (void 0 === e.attributes[r]) continue;
                        const i = n[r].array,
                            s = e.attributes[r],
                            o = s.array,
                            a = s.itemSize * t,
                            l = Math.min(o.length, i.length - a);
                        for (let e = 0, t = a; e < l; e++, t++) i[t] = o[e]
                    }
                    return this
                }
                normalizeNormals() {
                    const e = this.attributes.normal;
                    for (let t = 0, n = e.count; t < n; t++) Hi.fromBufferAttribute(e, t), Hi.normalize(), e.setXYZ(t, Hi.x, Hi.y, Hi.z)
                }
                toNonIndexed() {
                    function e(e, t) {
                        const n = e.array,
                            r = e.itemSize,
                            i = e.normalized,
                            s = new n.constructor(t.length * r);
                        let o = 0,
                            a = 0;
                        for (let i = 0, l = t.length; i < l; i++) {
                            o = e.isInterleavedBufferAttribute ? t[i] * e.data.stride + e.offset : t[i] * r;
                            for (let e = 0; e < r; e++) s[a++] = n[o++]
                        }
                        return new Ai(s, r, i)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    const t = new Wi,
                        n = this.index.array,
                        r = this.attributes;
                    for (const i in r) {
                        const s = e(r[i], n);
                        t.setAttribute(i, s)
                    }
                    const i = this.morphAttributes;
                    for (const r in i) {
                        const s = [],
                            o = i[r];
                        for (let t = 0, r = o.length; t < r; t++) {
                            const r = e(o[t], n);
                            s.push(r)
                        }
                        t.morphAttributes[r] = s
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    const s = this.groups;
                    for (let e = 0, n = s.length; e < n; e++) {
                        const n = s[e];
                        t.addGroup(n.start, n.count, n.materialIndex)
                    }
                    return t
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        const t = this.parameters;
                        for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    const t = this.index;
                    null !== t && (e.data.index = {
                        type: t.array.constructor.name,
                        array: Array.prototype.slice.call(t.array)
                    });
                    const n = this.attributes;
                    for (const t in n) {
                        const r = n[t];
                        e.data.attributes[t] = r.toJSON(e.data)
                    }
                    const r = {};
                    let i = !1;
                    for (const t in this.morphAttributes) {
                        const n = this.morphAttributes[t],
                            s = [];
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = n[t];
                            s.push(r.toJSON(e.data))
                        }
                        s.length > 0 && (r[t] = s, i = !0)
                    }
                    i && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
                    const s = this.groups;
                    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                    const o = this.boundingSphere;
                    return null !== o && (e.data.boundingSphere = {
                        center: o.center.toArray(),
                        radius: o.radius
                    }), e
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const t = {};
                    this.name = e.name;
                    const n = e.index;
                    null !== n && this.setIndex(n.clone(t));
                    const r = e.attributes;
                    for (const e in r) {
                        const n = r[e];
                        this.setAttribute(e, n.clone(t))
                    }
                    const i = e.morphAttributes;
                    for (const e in i) {
                        const n = [],
                            r = i[e];
                        for (let e = 0, i = r.length; e < i; e++) n.push(r[e].clone(t));
                        this.morphAttributes[e] = n
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    const s = e.groups;
                    for (let e = 0, t = s.length; e < t; e++) {
                        const t = s[e];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const o = e.boundingBox;
                    null !== o && (this.boundingBox = o.clone());
                    const a = e.boundingSphere;
                    return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            const Ki = new Br,
                Xi = new Ur,
                qi = new kr,
                Yi = new lr,
                Zi = new lr,
                Ji = new lr,
                $i = new lr,
                Qi = new lr,
                es = new lr,
                ts = new lr,
                ns = new lr,
                rs = new lr,
                is = new Pn,
                ss = new Pn,
                os = new Pn,
                as = new lr,
                ls = new lr;
            class cs extends ui {
                constructor(e = new Wi, t = new Mi) {
                    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes,
                        t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
                raycast(e, t) {
                    const n = this.geometry,
                        r = this.material,
                        i = this.matrixWorld;
                    if (void 0 === r) return;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), qi.copy(n.boundingSphere), qi.applyMatrix4(i), !1 === e.ray.intersectsSphere(qi)) return;
                    if (Ki.copy(i).invert(), Xi.copy(e.ray).applyMatrix4(Ki), null !== n.boundingBox && !1 === Xi.intersectsBox(n.boundingBox)) return;
                    let s;
                    const o = n.index,
                        a = n.attributes.position,
                        l = n.morphAttributes.position,
                        c = n.morphTargetsRelative,
                        u = n.attributes.uv,
                        p = n.attributes.uv2,
                        h = n.groups,
                        d = n.drawRange;
                    if (null !== o)
                        if (Array.isArray(r))
                            for (let n = 0, i = h.length; n < i; n++) {
                                const i = h[n],
                                    f = r[i.materialIndex];
                                for (let n = Math.max(i.start, d.start), r = Math.min(o.count, Math.min(i.start + i.count, d.start + d.count)); n < r; n += 3) {
                                    const r = o.getX(n),
                                        h = o.getX(n + 1),
                                        d = o.getX(n + 2);
                                    s = us(this, f, e, Xi, a, l, c, u, p, r, h, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, t.push(s))
                                }
                            } else
                                for (let n = Math.max(0, d.start), i = Math.min(o.count, d.start + d.count); n < i; n += 3) {
                                    const i = o.getX(n),
                                        h = o.getX(n + 1),
                                        d = o.getX(n + 2);
                                    s = us(this, r, e, Xi, a, l, c, u, p, i, h, d), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
                                } else if (void 0 !== a)
                                    if (Array.isArray(r))
                                        for (let n = 0, i = h.length; n < i; n++) {
                                            const i = h[n],
                                                o = r[i.materialIndex];
                                            for (let n = Math.max(i.start, d.start), r = Math.min(a.count, Math.min(i.start + i.count, d.start + d.count)); n < r; n += 3) s = us(this, o, e, Xi, a, l, c, u, p, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, t.push(s))
                                        } else
                                            for (let n = Math.max(0, d.start), i = Math.min(a.count, d.start + d.count); n < i; n += 3) s = us(this, r, e, Xi, a, l, c, u, p, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
                }
            }

            function us(e, t, n, r, i, s, o, a, l, c, u, p) {
                Yi.fromBufferAttribute(i, c), Zi.fromBufferAttribute(i, u), Ji.fromBufferAttribute(i, p);
                const h = e.morphTargetInfluences;
                if (s && h) {
                    ts.set(0, 0, 0), ns.set(0, 0, 0), rs.set(0, 0, 0);
                    for (let e = 0, t = s.length; e < t; e++) {
                        const t = h[e],
                            n = s[e];
                        0 !== t && ($i.fromBufferAttribute(n, c), Qi.fromBufferAttribute(n, u), es.fromBufferAttribute(n, p), o ? (ts.addScaledVector($i, t), ns.addScaledVector(Qi, t), rs.addScaledVector(es, t)) : (ts.addScaledVector($i.sub(Yi), t), ns.addScaledVector(Qi.sub(Zi), t), rs.addScaledVector(es.sub(Ji), t)))
                    }
                    Yi.add(ts), Zi.add(ns), Ji.add(rs)
                }
                e.isSkinnedMesh && (e.boneTransform(c, Yi), e.boneTransform(u, Zi), e.boneTransform(p, Ji));
                const d = function(e, t, n, r, i, s, o, a) {
                    let l;
                    if (l = t.side === _ ? r.intersectTriangle(o, s, i, !0, a) : r.intersectTriangle(i, s, o, t.side !== m, a), null === l) return null;
                    ls.copy(a), ls.applyMatrix4(e.matrixWorld);
                    const c = n.ray.origin.distanceTo(ls);
                    return c < n.near || c > n.far ? null : {
                        distance: c,
                        point: ls.clone(),
                        object: e
                    }
                }(e, t, n, r, Yi, Zi, Ji, as);
                if (d) {
                    a && (is.fromBufferAttribute(a, c), ss.fromBufferAttribute(a, u), os.fromBufferAttribute(a, p), d.uv = yi.getUV(as, Yi, Zi, Ji, is, ss, os, new Pn)), l && (is.fromBufferAttribute(l, c), ss.fromBufferAttribute(l, u), os.fromBufferAttribute(l, p), d.uv2 = yi.getUV(as, Yi, Zi, Ji, is, ss, os, new Pn));
                    const e = {
                        a: c,
                        b: u,
                        c: p,
                        normal: new lr,
                        materialIndex: 0
                    };
                    yi.getNormal(Yi, Zi, Ji, e.normal), d.face = e
                }
                return d
            }
            class ps extends Wi {
                constructor(e = 1, t = 1, n = 1, r = 1, i = 1, s = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: r,
                        heightSegments: i,
                        depthSegments: s
                    };
                    const o = this;
                    r = Math.floor(r), i = Math.floor(i), s = Math.floor(s);
                    const a = [],
                        l = [],
                        c = [],
                        u = [];
                    let p = 0,
                        h = 0;

                    function d(e, t, n, r, i, s, d, f, _, m, g) {
                        const v = s / _,
                            b = d / m,
                            x = s / 2,
                            y = d / 2,
                            w = f / 2,
                            S = _ + 1,
                            M = m + 1;
                        let T = 0,
                            E = 0;
                        const A = new lr;
                        for (let s = 0; s < M; s++) {
                            const o = s * b - y;
                            for (let a = 0; a < S; a++) {
                                const p = a * v - x;
                                A[e] = p * r, A[t] = o * i, A[n] = w, l.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = f > 0 ? 1 : -1, c.push(A.x, A.y, A.z), u.push(a / _), u.push(1 - s / m), T += 1
                            }
                        }
                        for (let e = 0; e < m; e++)
                            for (let t = 0; t < _; t++) {
                                const n = p + t + S * e,
                                    r = p + t + S * (e + 1),
                                    i = p + (t + 1) + S * (e + 1),
                                    s = p + (t + 1) + S * e;
                                a.push(n, r, s), a.push(r, i, s), E += 6
                            }
                        o.addGroup(h, E, g), h += E, p += T
                    }
                    d("z", "y", "x", -1, -1, n, t, e, s, i, 0), d("z", "y", "x", 1, -1, n, t, -e, s, i, 1), d("x", "z", "y", 1, 1, e, n, t, r, s, 2), d("x", "z", "y", 1, -1, e, n, -t, r, s, 3), d("x", "y", "z", 1, -1, e, t, n, r, i, 4), d("x", "y", "z", -1, -1, e, t, -n, r, i, 5), this.setIndex(a), this.setAttribute("position", new Fi(l, 3)), this.setAttribute("normal", new Fi(c, 3)), this.setAttribute("uv", new Fi(u, 2))
                }
                static fromJSON(e) {
                    return new ps(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                }
            }

            function hs(e) {
                const t = {};
                for (const n in e) {
                    t[n] = {};
                    for (const r in e[n]) {
                        const i = e[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                    }
                }
                return t
            }

            function ds(e) {
                const t = {};
                for (let n = 0; n < e.length; n++) {
                    const r = hs(e[n]);
                    for (const e in r) t[e] = r[e]
                }
                return t
            }
            const fs = {
                clone: hs,
                merge: ds
            };
            class _s extends Si {
                constructor(e) {
                    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
                }
                copy(e) {
                    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = hs(e.uniforms), this.uniformsGroups = function(e) {
                        const t = [];
                        for (let n = 0; n < e.length; n++) t.push(e[n].clone());
                        return t
                    }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    t.glslVersion = this.glslVersion, t.uniforms = {};
                    for (const n in this.uniforms) {
                        const r = this.uniforms[n].value;
                        r && r.isTexture ? t.uniforms[n] = {
                            type: "t",
                            value: r.toJSON(e).uuid
                        } : r && r.isColor ? t.uniforms[n] = {
                            type: "c",
                            value: r.getHex()
                        } : r && r.isVector2 ? t.uniforms[n] = {
                            type: "v2",
                            value: r.toArray()
                        } : r && r.isVector3 ? t.uniforms[n] = {
                            type: "v3",
                            value: r.toArray()
                        } : r && r.isVector4 ? t.uniforms[n] = {
                            type: "v4",
                            value: r.toArray()
                        } : r && r.isMatrix3 ? t.uniforms[n] = {
                            type: "m3",
                            value: r.toArray()
                        } : r && r.isMatrix4 ? t.uniforms[n] = {
                            type: "m4",
                            value: r.toArray()
                        } : t.uniforms[n] = {
                            value: r
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                    const n = {};
                    for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
                    return Object.keys(n).length > 0 && (t.extensions = n), t
                }
            }
            class ms extends ui {
                constructor() {
                    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Br, this.projectionMatrix = new Br, this.projectionMatrixInverse = new Br
                }
                copy(e, t) {
                    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    const t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize()
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(e, t) {
                    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class gs extends ms {
                constructor(e = 50, t = 1, n = .1, r = 2e3) {
                    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                }
                setFocalLength(e) {
                    const t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * wn * Math.atan(t), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    const e = Math.tan(.5 * yn * this.fov);
                    return .5 * this.getFilmHeight() / e
                }
                getEffectiveFOV() {
                    return 2 * wn * Math.atan(Math.tan(.5 * yn * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                setViewOffset(e, t, n, r, i, s) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = this.near;
                    let t = e * Math.tan(.5 * yn * this.fov) / this.zoom,
                        n = 2 * t,
                        r = this.aspect * n,
                        i = -.5 * r;
                    const s = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const e = s.fullWidth,
                            o = s.fullHeight;
                        i += s.offsetX * r / e, t -= s.offsetY * n / o, r *= s.width / e, n *= s.height / o
                    }
                    const o = this.filmOffset;
                    0 !== o && (i += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }
            const vs = 90;
            class bs extends ui {
                constructor(e, t, n) {
                    if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                    this.renderTarget = n;
                    const r = new gs(vs, 1, e, t);
                    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new lr(1, 0, 0)), this.add(r);
                    const i = new gs(vs, 1, e, t);
                    i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new lr(-1, 0, 0)), this.add(i);
                    const s = new gs(vs, 1, e, t);
                    s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new lr(0, 1, 0)), this.add(s);
                    const o = new gs(vs, 1, e, t);
                    o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new lr(0, -1, 0)), this.add(o);
                    const a = new gs(vs, 1, e, t);
                    a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new lr(0, 0, 1)), this.add(a);
                    const l = new gs(vs, 1, e, t);
                    l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new lr(0, 0, -1)), this.add(l)
                }
                update(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    const n = this.renderTarget,
                        [r, i, s, o, a, l] = this.children,
                        c = e.getRenderTarget(),
                        u = e.toneMapping,
                        p = e.xr.enabled;
                    e.toneMapping = $, e.xr.enabled = !1;
                    const h = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, i), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, o), e.setRenderTarget(n, 4), e.render(t, a), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(c), e.toneMapping = u, e.xr.enabled = p, n.texture.needsPMREMUpdate = !0
                }
            }
            class xs extends Qn {
                constructor(e, t, n, r, i, s, o, a, l, c) {
                    super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : se, n, r, i, s, o, a, l, c), this.isCubeTexture = !0, this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            class ys extends tr {
                constructor(e, t = {}) {
                    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
                    const n = {
                            width: e,
                            height: e,
                            depth: 1
                        },
                        r = [n, n, n, n, n, n];
                    this.texture = new xs(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : ve
                }
                fromEquirectangularTexture(e, t) {
                    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                    const n = {
                            tEquirect: {
                                value: null
                            }
                        },
                        r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                        s = new ps(5, 5, 5),
                        o = new _s({
                            name: "CubemapFromEquirect",
                            uniforms: hs(n),
                            vertexShader: r,
                            fragmentShader: i,
                            side: _,
                            blending: b
                        });
                    o.uniforms.tEquirect.value = t;
                    const a = new cs(s, o),
                        l = t.minFilter;
                    return t.minFilter === ye && (t.minFilter = ve), new bs(1, 10, this).update(e, a), t.minFilter = l, a.geometry.dispose(), a.material.dispose(), this
                }
                clear(e, t, n, r) {
                    const i = e.getRenderTarget();
                    for (let i = 0; i < 6; i++) e.setRenderTarget(this, i), e.clear(t, n, r);
                    e.setRenderTarget(i)
                }
            }
            const ws = new lr,
                Ss = new lr,
                Ms = new Dn;
            class Ts {
                constructor(e = new lr(1, 0, 0), t = 0) {
                    this.isPlane = !0, this.normal = e, this.constant = t
                }
                set(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                }
                setComponents(e, t, n, r) {
                    return this.normal.set(e, t, n), this.constant = r, this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                }
                setFromCoplanarPoints(e, t, n) {
                    const r = ws.subVectors(n, t).cross(Ss.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(r, e), this
                }
                copy(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                }
                normalize() {
                    const e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                }
                intersectLine(e, t) {
                    const n = e.delta(ws),
                        r = this.normal.dot(n);
                    if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                    const i = -(e.start.dot(this.normal) + this.constant) / r;
                    return i < 0 || i > 1 ? null : t.copy(n).multiplyScalar(i).add(e.start)
                }
                intersectsLine(e) {
                    const t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    const n = t || Ms.getNormalMatrix(e),
                        r = this.coplanarPoint(ws).applyMatrix4(e),
                        i = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -r.dot(i), this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal), this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Es = new kr,
                As = new lr;
            class Cs {
                constructor(e = new Ts, t = new Ts, n = new Ts, r = new Ts, i = new Ts, s = new Ts) {
                    this.planes = [e, t, n, r, i, s]
                }
                set(e, t, n, r, i, s) {
                    const o = this.planes;
                    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(s), this
                }
                copy(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                }
                setFromProjectionMatrix(e) {
                    const t = this.planes,
                        n = e.elements,
                        r = n[0],
                        i = n[1],
                        s = n[2],
                        o = n[3],
                        a = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7],
                        p = n[8],
                        h = n[9],
                        d = n[10],
                        f = n[11],
                        _ = n[12],
                        m = n[13],
                        g = n[14],
                        v = n[15];
                    return t[0].setComponents(o - r, u - a, f - p, v - _).normalize(), t[1].setComponents(o + r, u + a, f + p, v + _).normalize(), t[2].setComponents(o + i, u + l, f + h, v + m).normalize(), t[3].setComponents(o - i, u - l, f - h, v - m).normalize(), t[4].setComponents(o - s, u - c, f - d, v - g).normalize(), t[5].setComponents(o + s, u + c, f + d, v + g).normalize(), this
                }
                intersectsObject(e) {
                    const t = e.geometry;
                    return null === t.boundingSphere && t.computeBoundingSphere(), Es.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Es)
                }
                intersectsSprite(e) {
                    return Es.center.set(0, 0, 0), Es.radius = .7071067811865476, Es.applyMatrix4(e.matrixWorld), this.intersectsSphere(Es)
                }
                intersectsSphere(e) {
                    const t = this.planes,
                        n = e.center,
                        r = -e.radius;
                    for (let e = 0; e < 6; e++)
                        if (t[e].distanceToPoint(n) < r) return !1;
                    return !0
                }
                intersectsBox(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const r = t[n];
                        if (As.x = r.normal.x > 0 ? e.max.x : e.min.x, As.y = r.normal.y > 0 ? e.max.y : e.min.y, As.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(As) < 0) return !1
                    }
                    return !0
                }
                containsPoint(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }

            function Rs() {
                let e = null,
                    t = !1,
                    n = null,
                    r = null;

                function i(t, s) {
                    n(t, s), r = e.requestAnimationFrame(i)
                }
                return {
                    start: function() {
                        !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(r), t = !1
                    },
                    setAnimationLoop: function(e) {
                        n = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }

            function ks(e, t) {
                const n = t.isWebGL2,
                    r = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), r.get(e)
                    },
                    remove: function(t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const n = r.get(t);
                        n && (e.deleteBuffer(n.buffer), r.delete(t))
                    },
                    update: function(t, i) {
                        if (t.isGLBufferAttribute) {
                            const e = r.get(t);
                            return void((!e || e.version < t.version) && r.set(t, {
                                buffer: t.buffer,
                                type: t.type,
                                bytesPerElement: t.elementSize,
                                version: t.version
                            }))
                        }
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const s = r.get(t);
                        void 0 === s ? r.set(t, function(t, r) {
                            const i = t.array,
                                s = t.usage,
                                o = e.createBuffer();
                            let a;
                            if (e.bindBuffer(r, o), e.bufferData(r, i, s), t.onUploadCallback(), i instanceof Float32Array) a = 5126;
                            else if (i instanceof Uint16Array)
                                if (t.isFloat16BufferAttribute) {
                                    if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                    a = 5131
                                } else a = 5123;
                            else if (i instanceof Int16Array) a = 5122;
                            else if (i instanceof Uint32Array) a = 5125;
                            else if (i instanceof Int32Array) a = 5124;
                            else if (i instanceof Int8Array) a = 5120;
                            else if (i instanceof Uint8Array) a = 5121;
                            else {
                                if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                                a = 5121
                            }
                            return {
                                buffer: o,
                                type: a,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: t.version
                            }
                        }(t, i)) : s.version < t.version && (function(t, r, i) {
                            const s = r.array,
                                o = r.updateRange;
                            e.bindBuffer(i, t), -1 === o.count ? e.bufferSubData(i, 0, s) : (n ? e.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : e.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(s.buffer, t, i), s.version = t.version)
                    }
                }
            }
            class Ps extends Wi {
                constructor(e = 1, t = 1, n = 1, r = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: n,
                        heightSegments: r
                    };
                    const i = e / 2,
                        s = t / 2,
                        o = Math.floor(n),
                        a = Math.floor(r),
                        l = o + 1,
                        c = a + 1,
                        u = e / o,
                        p = t / a,
                        h = [],
                        d = [],
                        f = [],
                        _ = [];
                    for (let e = 0; e < c; e++) {
                        const t = e * p - s;
                        for (let n = 0; n < l; n++) {
                            const r = n * u - i;
                            d.push(r, -t, 0), f.push(0, 0, 1), _.push(n / o), _.push(1 - e / a)
                        }
                    }
                    for (let e = 0; e < a; e++)
                        for (let t = 0; t < o; t++) {
                            const n = t + l * e,
                                r = t + l * (e + 1),
                                i = t + 1 + l * (e + 1),
                                s = t + 1 + l * e;
                            h.push(n, r, s), h.push(r, i, s)
                        }
                    this.setIndex(h), this.setAttribute("position", new Fi(d, 3)), this.setAttribute("normal", new Fi(f, 3)), this.setAttribute("uv", new Fi(_, 2))
                }
                static fromJSON(e) {
                    return new Ps(e.width, e.height, e.widthSegments, e.heightSegments)
                }
            }
            const Ds = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\t#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1\n\tdiffuseColor.a *= 1.0-texture2D( alphaMap, vUv ).g;\n\t#else\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\t#endif\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
                    iridescence_fragment: "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\treflectVec = transformDirection1(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 transformDirection1( in vec3 dir, in mat4 matrix ) {\n\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\t}\n\tmat4 rotationMatrix(vec3 axis, float angle) {\n\t\taxis = normalize(axis);\n\t\tfloat s = sin(angle);\n\t\tfloat c = cos(angle);\n\t\tfloat oc = 1.0 - c;\n\t\treturn mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n\t\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n\t\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n\t\t\t\t\t0.0,                                0.0,                                0.0,                                1.0);\n\t}\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform float envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tworldNormal = transformDirection1(worldNormal, rotationMatrix(vec3(0,1,0), envMapRotation));\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\treflectVec = transformDirection1(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n\tmaterial.iridescence = 0.0;\n} else {\n\tmaterial.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\ndiffuseColor.a = min(max(diffuseColor.a, 0.), 1.);\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn transmissionSamplerMapTexelToLinear ( texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod ) );\n\t\t#else\n\t\t\treturn transmissionSamplerMapTexelToLinear ( texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod ) );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nuniform bool flipX;\nuniform bool flipY;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    vUv = flipX ? vec2( 1.0 - vUv.x, vUv.y ) : vUv;\n    vUv = flipY ? vec2( vUv.x, 1.0 - vUv.y ) : vUv;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
                },
                Os = {
                    common: {
                        diffuse: {
                            value: new Xn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Dn
                        },
                        uv2Transform: {
                            value: new Dn
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        envMapRotation: {
                            value: 0
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Pn(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new Xn(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Xn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new Dn
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new Xn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Pn(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new Dn
                        }
                    }
                },
                Ls = {
                    basic: {
                        uniforms: ds([Os.common, Os.specularmap, Os.envmap, Os.aomap, Os.lightmap, Os.fog]),
                        vertexShader: Ds.meshbasic_vert,
                        fragmentShader: Ds.meshbasic_frag
                    },
                    lambert: {
                        uniforms: ds([Os.common, Os.specularmap, Os.envmap, Os.aomap, Os.lightmap, Os.emissivemap, Os.fog, Os.lights, {
                            emissive: {
                                value: new Xn(0)
                            }
                        }]),
                        vertexShader: Ds.meshlambert_vert,
                        fragmentShader: Ds.meshlambert_frag
                    },
                    phong: {
                        uniforms: ds([Os.common, Os.specularmap, Os.envmap, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.fog, Os.lights, {
                            emissive: {
                                value: new Xn(0)
                            },
                            specular: {
                                value: new Xn(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Ds.meshphong_vert,
                        fragmentShader: Ds.meshphong_frag
                    },
                    standard: {
                        uniforms: ds([Os.common, Os.envmap, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.roughnessmap, Os.metalnessmap, Os.fog, Os.lights, {
                            emissive: {
                                value: new Xn(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ds.meshphysical_vert,
                        fragmentShader: Ds.meshphysical_frag
                    },
                    toon: {
                        uniforms: ds([Os.common, Os.aomap, Os.lightmap, Os.emissivemap, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.gradientmap, Os.fog, Os.lights, {
                            emissive: {
                                value: new Xn(0)
                            }
                        }]),
                        vertexShader: Ds.meshtoon_vert,
                        fragmentShader: Ds.meshtoon_frag
                    },
                    matcap: {
                        uniforms: ds([Os.common, Os.bumpmap, Os.normalmap, Os.displacementmap, Os.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: Ds.meshmatcap_vert,
                        fragmentShader: Ds.meshmatcap_frag
                    },
                    points: {
                        uniforms: ds([Os.points, Os.fog]),
                        vertexShader: Ds.points_vert,
                        fragmentShader: Ds.points_frag
                    },
                    dashed: {
                        uniforms: ds([Os.common, Os.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Ds.linedashed_vert,
                        fragmentShader: Ds.linedashed_frag
                    },
                    depth: {
                        uniforms: ds([Os.common, Os.displacementmap]),
                        vertexShader: Ds.depth_vert,
                        fragmentShader: Ds.depth_frag
                    },
                    normal: {
                        uniforms: ds([Os.common, Os.bumpmap, Os.normalmap, Os.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ds.meshnormal_vert,
                        fragmentShader: Ds.meshnormal_frag
                    },
                    sprite: {
                        uniforms: ds([Os.sprite, Os.fog]),
                        vertexShader: Ds.sprite_vert,
                        fragmentShader: Ds.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Dn
                            },
                            t2D: {
                                value: null
                            },
                            flipX: {
                                value: !1
                            },
                            flipY: {
                                value: !1
                            }
                        },
                        vertexShader: Ds.background_vert,
                        fragmentShader: Ds.background_frag
                    },
                    cube: {
                        uniforms: ds([Os.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ds.cube_vert,
                        fragmentShader: Ds.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Ds.equirect_vert,
                        fragmentShader: Ds.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: ds([Os.common, Os.displacementmap, {
                            referencePosition: {
                                value: new lr
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Ds.distanceRGBA_vert,
                        fragmentShader: Ds.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: ds([Os.lights, Os.fog, {
                            color: {
                                value: new Xn(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Ds.shadow_vert,
                        fragmentShader: Ds.shadow_frag
                    }
                };

            function Is(e, t, n, r, i, s) {
                const o = new Xn(0);
                let a, l, c = !0 === i ? 0 : 1,
                    u = null,
                    p = 0,
                    h = null;

                function d(e, t) {
                    n.buffers.color.setClear(e.r, e.g, e.b, t, s)
                }
                return {
                    getClearColor: function() {
                        return o
                    },
                    setClearColor: function(e, t = 1) {
                        o.set(e), c = t, d(o, c)
                    },
                    getClearAlpha: function() {
                        return c
                    },
                    setClearAlpha: function(e) {
                        c = e, d(o, c)
                    },
                    getPlaneMesh: function() {
                        return a
                    },
                    getBoxMesh: function() {
                        return l
                    },
                    getBoxMesh2: function() {
                        return void 0 === l && (l = new cs(new ps(1, 1, 1), new _s({
                            name: "BackgroundCubeMaterial",
                            uniforms: hs(Ls.cube.uniforms),
                            vertexShader: Ls.cube.vertexShader,
                            fragmentShader: Ls.cube.fragmentShader,
                            side: _,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(l.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), r.update(l)), l
                    },
                    render: function(n, i) {
                        let s = !1,
                            m = !0 === i.isScene ? i.background : null;
                        m && m.isTexture && (m = t.get(m));
                        const g = e.xr,
                            v = g.getSession && g.getSession();
                        v && "additive" === v.environmentBlendMode && (m = null), null === m ? d(o, c) : m && m.isColor && (d(m, 1), s = !0), (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), m && (m.isCubeTexture || m.mapping === ce) ? (void 0 === l && (l = new cs(new ps(1, 1, 1), new _s({
                            name: "BackgroundCubeMaterial",
                            uniforms: hs(Ls.cube.uniforms),
                            vertexShader: Ls.cube.vertexShader,
                            fragmentShader: Ls.cube.fragmentShader,
                            side: _,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(l.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), r.update(l)), l.material.uniforms.envMap.value = m, l.material.uniforms.envMapRotation.value = m.rotation || 0, l.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1, u === m && p === m.version && h === e.toneMapping || (l.material.needsUpdate = !0, u = m, p = m.version, h = e.toneMapping), l.layers.enableAll(), n.unshift(l, l.geometry, l.material, 0, 0, null)) : m && m.isTexture && (void 0 === a && (a = new cs(new Ps(2, 2), new _s({
                            name: "BackgroundMaterial",
                            uniforms: hs(Ls.background.uniforms),
                            vertexShader: Ls.background.vertexShader,
                            fragmentShader: Ls.background.fragmentShader,
                            side: f,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), r.update(a)), a.material.uniforms.t2D.value = m, a.material.uniforms.flipX.value = m.userData.flipX || !1, a.material.uniforms.flipY.value = m.userData.flipY || !1, !0 === m.matrixAutoUpdate && m.updateMatrix(), a.material.uniforms.uvTransform.value.copy(m.matrix), u === m && p === m.version && h === e.toneMapping || (a.material.needsUpdate = !0, u = m, p = m.version, h = e.toneMapping), a.layers.enableAll(), n.unshift(a, a.geometry, a.material, 0, 0, null))
                    }
                }
            }

            function Fs(e, t, n, r) {
                const i = e.getParameter(34921),
                    s = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                    o = r.isWebGL2 || null !== s,
                    a = {},
                    l = d(null);
                let c = l,
                    u = !1;

                function p(t) {
                    return r.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t)
                }

                function h(t) {
                    return r.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t)
                }

                function d(e) {
                    const t = [],
                        n = [],
                        r = [];
                    for (let e = 0; e < i; e++) t[e] = 0, n[e] = 0, r[e] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: n,
                        attributeDivisors: r,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }

                function f() {
                    const e = c.newAttributes;
                    for (let t = 0, n = e.length; t < n; t++) e[t] = 0
                }

                function _(e) {
                    m(e, 0)
                }

                function m(n, i) {
                    const s = c.newAttributes,
                        o = c.enabledAttributes,
                        a = c.attributeDivisors;
                    s[n] = 1, 0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1), a[n] !== i && ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), a[n] = i)
                }

                function g() {
                    const t = c.newAttributes,
                        n = c.enabledAttributes;
                    for (let r = 0, i = n.length; r < i; r++) n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0)
                }

                function v(t, n, i, s, o, a) {
                    !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t, n, i, s, o, a) : e.vertexAttribIPointer(t, n, i, o, a)
                }

                function b() {
                    x(), u = !0, c !== l && (c = l, p(c.object))
                }

                function x() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                return {
                    setup: function(i, l, h, b, x) {
                        let y = !1;
                        if (o) {
                            const t = function(t, n, i) {
                                const o = !0 === i.wireframe;
                                let l = a[t.id];
                                void 0 === l && (l = {}, a[t.id] = l);
                                let c = l[n.id];
                                void 0 === c && (c = {}, l[n.id] = c);
                                let u = c[o];
                                return void 0 === u && (u = d(r.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[o] = u), u
                            }(b, h, l);
                            c !== t && (c = t, p(c.object)), y = function(e, t, n, r) {
                                const i = c.attributes,
                                    s = t.attributes;
                                let o = 0;
                                const a = n.getAttributes();
                                for (const t in a)
                                    if (a[t].location >= 0) {
                                        const n = i[t];
                                        let r = s[t];
                                        if (void 0 === r && ("instanceMatrix" === t && e.instanceMatrix && (r = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (r = e.instanceColor)), void 0 === n) return !0;
                                        if (n.attribute !== r) return !0;
                                        if (r && n.data !== r.data) return !0;
                                        o++
                                    }
                                return c.attributesNum !== o || c.index !== r
                            }(i, b, h, x), y && function(e, t, n, r) {
                                const i = {},
                                    s = t.attributes;
                                let o = 0;
                                const a = n.getAttributes();
                                for (const t in a)
                                    if (a[t].location >= 0) {
                                        let n = s[t];
                                        void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                        const r = {};
                                        r.attribute = n, n && n.data && (r.data = n.data), i[t] = r, o++
                                    }
                                c.attributes = i, c.attributesNum = o, c.index = r
                            }(i, b, h, x)
                        } else {
                            const e = !0 === l.wireframe;
                            c.geometry === b.id && c.program === h.id && c.wireframe === e || (c.geometry = b.id, c.program = h.id, c.wireframe = e, y = !0)
                        }
                        null !== x && n.update(x, 34963), (y || u) && (u = !1, function(i, s, o, a) {
                            if (!1 === r.isWebGL2 && (i.isInstancedMesh || a.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                            f();
                            const l = a.attributes,
                                c = o.getAttributes(),
                                u = s.defaultAttributeValues;
                            for (const t in c) {
                                const r = c[t];
                                if (r.location >= 0) {
                                    let s = l[t];
                                    if (void 0 === s && ("instanceMatrix" === t && i.instanceMatrix && (s = i.instanceMatrix), "instanceColor" === t && i.instanceColor && (s = i.instanceColor)), void 0 !== s) {
                                        const t = s.normalized,
                                            o = s.itemSize,
                                            l = n.get(s);
                                        if (void 0 === l) continue;
                                        const c = l.buffer,
                                            u = l.type,
                                            p = l.bytesPerElement;
                                        if (s.isInterleavedBufferAttribute) {
                                            const n = s.data,
                                                l = n.stride,
                                                h = s.offset;
                                            if (n.isInstancedInterleavedBuffer) {
                                                for (let e = 0; e < r.locationSize; e++) m(r.location + e, n.meshPerAttribute);
                                                !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)
                                            } else
                                                for (let e = 0; e < r.locationSize; e++) _(r.location + e);
                                            e.bindBuffer(34962, c);
                                            for (let e = 0; e < r.locationSize; e++) v(r.location + e, o / r.locationSize, u, t, l * p, (h + o / r.locationSize * e) * p)
                                        } else {
                                            if (s.isInstancedBufferAttribute) {
                                                for (let e = 0; e < r.locationSize; e++) m(r.location + e, s.meshPerAttribute);
                                                !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)
                                            } else
                                                for (let e = 0; e < r.locationSize; e++) _(r.location + e);
                                            e.bindBuffer(34962, c);
                                            for (let e = 0; e < r.locationSize; e++) v(r.location + e, o / r.locationSize, u, t, o * p, o / r.locationSize * e * p)
                                        }
                                    } else if (void 0 !== u) {
                                        const n = u[t];
                                        if (void 0 !== n) switch (n.length) {
                                            case 2:
                                                e.vertexAttrib2fv(r.location, n);
                                                break;
                                            case 3:
                                                e.vertexAttrib3fv(r.location, n);
                                                break;
                                            case 4:
                                                e.vertexAttrib4fv(r.location, n);
                                                break;
                                            default:
                                                e.vertexAttrib1fv(r.location, n)
                                        }
                                    }
                                }
                            }
                            g()
                        }(i, l, h, b), null !== x && e.bindBuffer(34963, n.get(x).buffer))
                    },
                    reset: b,
                    resetDefaultState: x,
                    dispose: function() {
                        b();
                        for (const e in a) {
                            const t = a[e];
                            for (const e in t) {
                                const n = t[e];
                                for (const e in n) h(n[e].object), delete n[e];
                                delete t[e]
                            }
                            delete a[e]
                        }
                    },
                    releaseStatesOfGeometry: function(e) {
                        if (void 0 === a[e.id]) return;
                        const t = a[e.id];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n) h(n[e].object), delete n[e];
                            delete t[e]
                        }
                        delete a[e.id]
                    },
                    releaseStatesOfProgram: function(e) {
                        for (const t in a) {
                            const n = a[t];
                            if (void 0 === n[e.id]) continue;
                            const r = n[e.id];
                            for (const e in r) h(r[e].object), delete r[e];
                            delete n[e.id]
                        }
                    },
                    initAttributes: f,
                    enableAttribute: _,
                    disableUnusedAttributes: g
                }
            }

            function Ns(e, t, n, r) {
                const i = r.isWebGL2;
                let s;
                this.setMode = function(e) {
                    s = e
                }, this.render = function(t, r) {
                    e.drawArrays(s, t, r), n.update(r, s, 1)
                }, this.renderInstances = function(r, o, a) {
                    if (0 === a) return;
                    let l, c;
                    if (i) l = e, c = "drawArraysInstanced";
                    else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[c](s, r, o, a), n.update(o, s, a)
                }
            }

            function Us(e, t, n) {
                let r;

                function i(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
                let o = void 0 !== n.precision ? n.precision : "highp";
                const a = i(o);
                a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
                const l = s || t.has("WEBGL_draw_buffers"),
                    c = !0 === n.logarithmicDepthBuffer,
                    u = e.getParameter(34930),
                    p = e.getParameter(35660),
                    h = e.getParameter(3379),
                    d = e.getParameter(34076),
                    f = e.getParameter(34921),
                    _ = e.getParameter(36347),
                    m = e.getParameter(36348),
                    g = e.getParameter(36349),
                    v = p > 0,
                    b = s || t.has("OES_texture_float");
                return {
                    isWebGL2: s,
                    drawBuffers: l,
                    getMaxAnisotropy: function() {
                        if (void 0 !== r) return r;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            const n = t.get("EXT_texture_filter_anisotropic");
                            r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else r = 0;
                        return r
                    },
                    getMaxPrecision: i,
                    precision: o,
                    logarithmicDepthBuffer: c,
                    maxTextures: u,
                    maxVertexTextures: p,
                    maxTextureSize: h,
                    maxCubemapSize: d,
                    maxAttributes: f,
                    maxVertexUniforms: _,
                    maxVaryings: m,
                    maxFragmentUniforms: g,
                    vertexTextures: v,
                    floatFragmentTextures: b,
                    floatVertexTextures: v && b,
                    maxSamples: s ? e.getParameter(36183) : 0
                }
            }

            function Bs(e) {
                const t = this;
                let n = null,
                    r = 0,
                    i = !1,
                    s = !1;
                const o = new Ts,
                    a = new Dn,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function c() {
                    l.value !== n && (l.value = n, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0
                }

                function u(e, n, r, i) {
                    const s = null !== e ? e.length : 0;
                    let c = null;
                    if (0 !== s) {
                        if (c = l.value, !0 !== i || null === c) {
                            const t = r + 4 * s,
                                i = n.matrixWorldInverse;
                            a.getNormalMatrix(i), (null === c || c.length < t) && (c = new Float32Array(t));
                            for (let t = 0, n = r; t !== s; ++t, n += 4) o.copy(e[t]).applyMatrix4(i, a), o.normal.toArray(c, n), c[n + 3] = o.constant
                        }
                        l.value = c, l.needsUpdate = !0
                    }
                    return t.numPlanes = s, t.numIntersection = 0, c
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, s) {
                    const o = 0 !== e.length || t || 0 !== r || i;
                    return i = t, n = u(e, s, 0), r = e.length, o
                }, this.beginShadows = function() {
                    s = !0, u(null)
                }, this.endShadows = function() {
                    s = !1, c()
                }, this.setState = function(t, o, a) {
                    const p = t.clippingPlanes,
                        h = t.clipIntersection,
                        d = t.clipShadows,
                        f = e.get(t);
                    if (!i || null === p || 0 === p.length || s && !d) s ? u(null) : c();
                    else {
                        const e = s ? 0 : r,
                            t = 4 * e;
                        let i = f.clippingState || null;
                        l.value = i, i = u(p, o, t, a);
                        for (let e = 0; e !== t; ++e) i[e] = n[e];
                        f.clippingState = i, this.numIntersection = h ? this.numPlanes : 0, this.numPlanes += e
                    }
                }
            }

            function js(e) {
                let t = new WeakMap;

                function n(e, t) {
                    return t === ae ? e.mapping = se : t === le && (e.mapping = oe), e
                }

                function r(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", r);
                    const i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
                            const s = i.mapping;
                            if (s === ae || s === le) {
                                if (t.has(i)) {
                                    const e = t.get(i).texture;
                                    return e.rotation = i.rotation, n(e, i.mapping)
                                } {
                                    const s = i.image;
                                    if (s && s.height > 0) {
                                        const o = new ys(s.height / 2);
                                        return o.fromEquirectangularTexture(e, i), o.texture.rotation = i.rotation, t.set(i, o), i.addEventListener("dispose", r), n(o.texture, i.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            Ls.physical = {
                uniforms: ds([Ls.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new Pn(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    iridescence: {
                        value: 0
                    },
                    iridescenceMap: {
                        value: null
                    },
                    iridescenceIOR: {
                        value: 1.3
                    },
                    iridescenceThicknessMinimum: {
                        value: 100
                    },
                    iridescenceThicknessMaximum: {
                        value: 400
                    },
                    iridescenceThicknessMap: {
                        value: null
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new Xn(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new Pn
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new Xn(0)
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularColor: {
                        value: new Xn(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    }
                }]),
                vertexShader: Ds.meshphysical_vert,
                fragmentShader: Ds.meshphysical_frag
            };
            class zs extends ms {
                constructor(e = -1, t = 1, n = 1, r = -1, i = .1, s = 2e3) {
                    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = i, this.far = s, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                }
                setViewOffset(e, t, n, r, i, s) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        r = (this.top + this.bottom) / 2;
                    let i = n - e,
                        s = n + e,
                        o = r + t,
                        a = r - t;
                    if (null !== this.view && this.view.enabled) {
                        const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        i += e * this.view.offsetX, s = i + e * this.view.width, o -= t * this.view.offsetY, a = o - t * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(i, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }
            const Vs = [.125, .215, .35, .446, .526, .582],
                Gs = new zs,
                Hs = new Xn;
            let Ws = null;
            const Ks = (1 + Math.sqrt(5)) / 2,
                Xs = 1 / Ks,
                qs = [new lr(1, 1, 1), new lr(-1, 1, 1), new lr(1, 1, -1), new lr(-1, 1, -1), new lr(0, Ks, Xs), new lr(0, Ks, -Xs), new lr(Xs, 0, Ks), new lr(-Xs, 0, Ks), new lr(Ks, Xs, 0), new lr(-Ks, Xs, 0)];
            class Ys {
                constructor(e) {
                    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(e, t = 0, n = .1, r = 100) {
                    Ws = this._renderer.getRenderTarget(), this._setSize(256);
                    const i = this._allocateTargets();
                    return i.depthBuffer = !0, this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i
                }
                fromEquirectangular(e, t = null) {
                    return this._fromTexture(e, t)
                }
                fromCubemap(e, t = null) {
                    return this._fromTexture(e, t)
                }
                compileCubemapShader() {
                    null === this._cubemapMaterial && (this._cubemapMaterial = Qs(), this._compileMaterial(this._cubemapMaterial))
                }
                compileEquirectangularShader() {
                    null === this._equirectMaterial && (this._equirectMaterial = $s(), this._compileMaterial(this._equirectMaterial))
                }
                dispose() {
                    this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                }
                _setSize(e) {
                    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
                }
                _dispose() {
                    null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
                }
                _cleanup(e) {
                    this._renderer.setRenderTarget(Ws), e.scissorTest = !1, Js(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e, t) {
                    e.mapping === se || e.mapping === oe ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Ws = this._renderer.getRenderTarget();
                    const n = t || this._allocateTargets();
                    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
                }
                _allocateTargets() {
                    const e = 3 * Math.max(this._cubeSize, 112),
                        t = 4 * this._cubeSize,
                        n = {
                            magFilter: ve,
                            minFilter: ve,
                            generateMipmaps: !1,
                            type: ke,
                            format: Fe,
                            encoding: Dt,
                            depthBuffer: !1
                        },
                        r = Zs(e, t, n);
                    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
                        null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Zs(e, t, n);
                        const {
                            _lodMax: r
                        } = this;
                        ({
                            sizeLods: this._sizeLods,
                            lodPlanes: this._lodPlanes,
                            sigmas: this._sigmas
                        } = function(e) {
                            const t = [],
                                n = [],
                                r = [];
                            let i = e;
                            const s = e - 4 + 1 + Vs.length;
                            for (let o = 0; o < s; o++) {
                                const s = Math.pow(2, i);
                                n.push(s);
                                let a = 1 / s;
                                o > e - 4 ? a = Vs[o - e + 4 - 1] : 0 === o && (a = 0), r.push(a);
                                const l = 1 / (s - 2),
                                    c = -l,
                                    u = 1 + l,
                                    p = [c, c, u, c, u, u, c, c, u, u, c, u],
                                    h = 6,
                                    d = 6,
                                    f = 3,
                                    _ = 2,
                                    m = 1,
                                    g = new Float32Array(f * d * h),
                                    v = new Float32Array(_ * d * h),
                                    b = new Float32Array(m * d * h);
                                for (let e = 0; e < h; e++) {
                                    const t = e % 3 * 2 / 3 - 1,
                                        n = e > 2 ? 0 : -1,
                                        r = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                    g.set(r, f * d * e), v.set(p, _ * d * e);
                                    const i = [e, e, e, e, e, e];
                                    b.set(i, m * d * e)
                                }
                                const x = new Wi;
                                x.setAttribute("position", new Ai(g, f)), x.setAttribute("uv", new Ai(v, _)), x.setAttribute("faceIndex", new Ai(b, m)), t.push(x), i > 4 && i--
                            }
                            return {
                                lodPlanes: t,
                                sizeLods: n,
                                sigmas: r
                            }
                        }(r)), this._blurMaterial = function(e, t, n) {
                            const r = new Float32Array(20),
                                i = new lr(0, 1, 0);
                            return new _s({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: 20,
                                    CUBEUV_TEXEL_WIDTH: 1 / t,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: `${e}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: r
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: i
                                    }
                                },
                                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                blending: b,
                                depthTest: !1,
                                depthWrite: !1
                            })
                        }(r, e, t)
                    }
                    return r
                }
                _compileMaterial(e) {
                    const t = new cs(this._lodPlanes[0], e);
                    this._renderer.compile(t, Gs)
                }
                _sceneToCubeUV(e, t, n, r) {
                    const i = new gs(90, 1, t, n),
                        s = [1, -1, 1, 1, 1, 1],
                        o = [1, 1, 1, -1, -1, -1],
                        a = this._renderer,
                        l = a.autoClear,
                        c = a.toneMapping;
                    a.getClearColor(Hs), a.toneMapping = $, a.autoClear = !1;
                    const u = new Mi({
                            name: "PMREM.Background",
                            side: _,
                            depthWrite: !1,
                            depthTest: !1
                        }),
                        p = new cs(new ps, u);
                    let h = !1;
                    const d = e.background;
                    d ? d.isColor && (u.color.copy(d), e.background = null, h = !0) : (u.color.copy(Hs), h = !0);
                    for (let t = 0; t < 6; t++) {
                        const n = t % 3;
                        0 === n ? (i.up.set(0, s[t], 0), i.lookAt(o[t], 0, 0)) : 1 === n ? (i.up.set(0, 0, s[t]), i.lookAt(0, o[t], 0)) : (i.up.set(0, s[t], 0), i.lookAt(0, 0, o[t]));
                        const l = this._cubeSize;
                        Js(r, n * l, t > 2 ? l : 0, l, l), a.setRenderTarget(r), h && a.render(p, i), a.render(e, i)
                    }
                    p.geometry.dispose(), p.material.dispose(), a.toneMapping = c, a.autoClear = l, e.background = d
                }
                _textureToCubeUV(e, t) {
                    const n = this._renderer,
                        r = e.mapping === se || e.mapping === oe;
                    r ? (null === this._cubemapMaterial && (this._cubemapMaterial = Qs()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = $s());
                    const i = r ? this._cubemapMaterial : this._equirectMaterial,
                        s = new cs(this._lodPlanes[0], i);
                    i.uniforms.envMap.value = e;
                    const o = this._cubeSize;
                    Js(t, 0, 0, 3 * o, 2 * o), n.setRenderTarget(t), n.render(s, Gs)
                }
                _applyPMREM(e) {
                    const t = this._renderer,
                        n = t.autoClear;
                    t.autoClear = !1;
                    for (let t = 1; t < this._lodPlanes.length; t++) {
                        const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]),
                            r = qs[(t - 1) % qs.length];
                        this._blur(e, t - 1, t, n, r)
                    }
                    t.autoClear = n
                }
                _blur(e, t, n, r, i) {
                    const s = this._pingPongRenderTarget;
                    this._halfBlur(e, s, t, n, r, "latitudinal", i), this._halfBlur(s, e, n, n, r, "longitudinal", i)
                }
                _halfBlur(e, t, n, r, i, s, o) {
                    const a = this._renderer,
                        l = this._blurMaterial;
                    "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                    const c = new cs(this._lodPlanes[r], l),
                        u = l.uniforms,
                        p = this._sizeLods[n] - 1,
                        h = isFinite(i) ? Math.PI / (2 * p) : 2 * Math.PI / 39,
                        d = i / h,
                        f = isFinite(i) ? 1 + Math.floor(3 * d) : 20;
                    f > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                    const _ = [];
                    let m = 0;
                    for (let e = 0; e < 20; ++e) {
                        const t = e / d,
                            n = Math.exp(-t * t / 2);
                        _.push(n), 0 === e ? m += n : e < f && (m += 2 * n)
                    }
                    for (let e = 0; e < _.length; e++) _[e] = _[e] / m;
                    u.envMap.value = e.texture, u.samples.value = f, u.weights.value = _, u.latitudinal.value = "latitudinal" === s, o && (u.poleAxis.value = o);
                    const {
                        _lodMax: g
                    } = this;
                    u.dTheta.value = h, u.mipInt.value = g - n;
                    const v = this._sizeLods[r];
                    Js(t, 3 * v * (r > g - 4 ? r - g + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v), a.setRenderTarget(t), a.render(c, Gs)
                }
            }

            function Zs(e, t, n) {
                const r = new tr(e, t, n);
                return r.texture.mapping = ce, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
            }

            function Js(e, t, n, r, i) {
                e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
            }

            function $s() {
                return new _s({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                    blending: b,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function Qs() {
                return new _s({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                    blending: b,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function eo(e) {
                let t = new WeakMap,
                    n = null;

                function r(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", r);
                    const i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture) {
                            const s = i.mapping,
                                o = s === ae || s === le,
                                a = s === se || s === oe;
                            if (o || a) {
                                if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                                    i.needsPMREMUpdate = !1;
                                    let r = t.get(i);
                                    return null === n && (n = new Ys(e)), r = o ? n.fromEquirectangular(i, r) : n.fromCubemap(i, r), t.set(i, r), r.texture
                                }
                                if (t.has(i)) return t.get(i).texture; {
                                    const s = i.image;
                                    if (o && s && s.height > 0 || a && s && function(e) {
                                            let t = 0;
                                            for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                                            return 6 === t
                                        }(s)) {
                                        null === n && (n = new Ys(e));
                                        const s = o ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                        return t.set(i, s), i.addEventListener("dispose", r), s.texture
                                    }
                                    return null
                                }
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        t = new WeakMap, null !== n && (n.dispose(), n = null)
                    }
                }
            }

            function to(e) {
                const t = {};

                function n(n) {
                    if (void 0 !== t[n]) return t[n];
                    let r;
                    switch (n) {
                        case "WEBGL_depth_texture":
                            r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            r = e.getExtension(n)
                    }
                    return t[n] = r, r
                }
                return {
                    has: function(e) {
                        return null !== n(e)
                    },
                    init: function(e) {
                        e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                    },
                    get: function(e) {
                        const t = n(e);
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                    }
                }
            }

            function no(e, t, n, r) {
                const i = {},
                    s = new WeakMap;

                function o(e) {
                    const a = e.target;
                    null !== a.index && t.remove(a.index);
                    for (const e in a.attributes) t.remove(a.attributes[e]);
                    a.removeEventListener("dispose", o), delete i[a.id];
                    const l = s.get(a);
                    l && (t.remove(l), s.delete(a)), r.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
                }

                function a(e) {
                    const n = [],
                        r = e.index,
                        i = e.attributes.position;
                    let o = 0;
                    if (null !== r) {
                        const e = r.array;
                        o = r.version;
                        for (let t = 0, r = e.length; t < r; t += 3) {
                            const r = e[t + 0],
                                i = e[t + 1],
                                s = e[t + 2];
                            n.push(r, i, i, s, s, r)
                        }
                    } else {
                        const e = i.array;
                        o = i.version;
                        for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
                            const e = t + 0,
                                r = t + 1,
                                i = t + 2;
                            n.push(e, r, r, i, i, e)
                        }
                    }
                    const a = new(On(n) ? Li : Di)(n, 1);
                    a.version = o;
                    const l = s.get(e);
                    l && t.remove(l), s.set(e, a)
                }
                return {
                    get: function(e, t) {
                        return !0 === i[t.id] || (t.addEventListener("dispose", o), i[t.id] = !0, n.memory.geometries++), t
                    },
                    update: function(e) {
                        const n = e.attributes;
                        for (const e in n) t.update(n[e], 34962);
                        const r = e.morphAttributes;
                        for (const e in r) {
                            const n = r[e];
                            for (let e = 0, r = n.length; e < r; e++) t.update(n[e], 34962)
                        }
                    },
                    getWireframeAttribute: function(e) {
                        const t = s.get(e);
                        if (t) {
                            const n = e.index;
                            null !== n && t.version < n.version && a(e)
                        } else a(e);
                        return s.get(e)
                    }
                }
            }

            function ro(e, t, n, r) {
                const i = r.isWebGL2;
                let s, o, a;
                this.setMode = function(e) {
                    s = e
                }, this.setIndex = function(e) {
                    o = e.type, a = e.bytesPerElement
                }, this.render = function(t, r) {
                    e.drawElements(s, r, o, t * a), n.update(r, s, 1)
                }, this.renderInstances = function(r, l, c) {
                    if (0 === c) return;
                    let u, p;
                    if (i) u = e, p = "drawElementsInstanced";
                    else if (u = t.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    u[p](s, l, o, r * a, c), n.update(l, s, c)
                }
            }

            function io(e) {
                const t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                    },
                    update: function(e, n, r) {
                        switch (t.calls++, n) {
                            case 4:
                                t.triangles += r * (e / 3);
                                break;
                            case 1:
                                t.lines += r * (e / 2);
                                break;
                            case 3:
                                t.lines += r * (e - 1);
                                break;
                            case 2:
                                t.lines += r * e;
                                break;
                            case 0:
                                t.points += r * e;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                        }
                    }
                }
            }

            function so(e, t) {
                return e[0] - t[0]
            }

            function oo(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function ao(e, t) {
                let n = 1;
                const r = t.isInterleavedBufferAttribute ? t.data.array : t.array;
                r instanceof Int8Array ? n = 127 : r instanceof Uint8Array ? n = 255 : r instanceof Uint16Array ? n = 65535 : r instanceof Int16Array ? n = 32767 : r instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), e.divideScalar(n)
            }

            function lo(e, t, n) {
                const r = {},
                    i = new Float32Array(8),
                    s = new WeakMap,
                    o = new er,
                    a = [];
                for (let e = 0; e < 8; e++) a[e] = [e, 0];
                return {
                    update: function(l, c, u, p) {
                        const h = l.morphTargetInfluences;
                        if (!0 === t.isWebGL2) {
                            const r = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                                i = void 0 !== r ? r.length : 0;
                            let a = s.get(c);
                            if (void 0 === a || a.count !== i) {
                                void 0 !== a && a.texture.dispose();
                                const e = void 0 !== c.morphAttributes.position,
                                    n = void 0 !== c.morphAttributes.normal,
                                    r = void 0 !== c.morphAttributes.color,
                                    l = c.morphAttributes.position || [],
                                    u = c.morphAttributes.normal || [],
                                    p = c.morphAttributes.color || [];
                                let h = 0;
                                !0 === e && (h = 1), !0 === n && (h = 2), !0 === r && (h = 3);
                                let d = c.attributes.position.count * h,
                                    f = 1;
                                d > t.maxTextureSize && (f = Math.ceil(d / t.maxTextureSize), d = t.maxTextureSize);
                                const _ = new Float32Array(d * f * 4 * i),
                                    m = new nr(_, d, f, i);
                                m.type = Re, m.needsUpdate = !0;
                                const g = 4 * h;
                                for (let t = 0; t < i; t++) {
                                    const i = l[t],
                                        s = u[t],
                                        a = p[t],
                                        c = d * f * 4 * t;
                                    for (let t = 0; t < i.count; t++) {
                                        const l = t * g;
                                        !0 === e && (o.fromBufferAttribute(i, t), !0 === i.normalized && ao(o, i), _[c + l + 0] = o.x, _[c + l + 1] = o.y, _[c + l + 2] = o.z, _[c + l + 3] = 0), !0 === n && (o.fromBufferAttribute(s, t), !0 === s.normalized && ao(o, s), _[c + l + 4] = o.x, _[c + l + 5] = o.y, _[c + l + 6] = o.z, _[c + l + 7] = 0), !0 === r && (o.fromBufferAttribute(a, t), !0 === a.normalized && ao(o, a), _[c + l + 8] = o.x, _[c + l + 9] = o.y, _[c + l + 10] = o.z, _[c + l + 11] = 4 === a.itemSize ? o.w : 1)
                                    }
                                }
                                a = {
                                    count: i,
                                    texture: m,
                                    size: new Pn(d, f)
                                }, s.set(c, a), c.addEventListener("dispose", (function e() {
                                    m.dispose(), s.delete(c), c.removeEventListener("dispose", e)
                                }))
                            }
                            let l = 0;
                            for (let e = 0; e < h.length; e++) l += h[e];
                            const u = c.morphTargetsRelative ? 1 : 1 - l;
                            p.getUniforms().setValue(e, "morphTargetBaseInfluence", u), p.getUniforms().setValue(e, "morphTargetInfluences", h), p.getUniforms().setValue(e, "morphTargetsTexture", a.texture, n), p.getUniforms().setValue(e, "morphTargetsTextureSize", a.size)
                        } else {
                            const t = void 0 === h ? 0 : h.length;
                            let n = r[c.id];
                            if (void 0 === n || n.length !== t) {
                                n = [];
                                for (let e = 0; e < t; e++) n[e] = [e, 0];
                                r[c.id] = n
                            }
                            for (let e = 0; e < t; e++) {
                                const t = n[e];
                                t[0] = e, t[1] = h[e]
                            }
                            n.sort(oo);
                            for (let e = 0; e < 8; e++) e < t && n[e][1] ? (a[e][0] = n[e][0], a[e][1] = n[e][1]) : (a[e][0] = Number.MAX_SAFE_INTEGER, a[e][1] = 0);
                            a.sort(so);
                            const s = c.morphAttributes.position,
                                o = c.morphAttributes.normal;
                            let l = 0;
                            for (let e = 0; e < 8; e++) {
                                const t = a[e],
                                    n = t[0],
                                    r = t[1];
                                n !== Number.MAX_SAFE_INTEGER && r ? (s && c.getAttribute("morphTarget" + e) !== s[n] && c.setAttribute("morphTarget" + e, s[n]), o && c.getAttribute("morphNormal" + e) !== o[n] && c.setAttribute("morphNormal" + e, o[n]), i[e] = r, l += r) : (s && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), o && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), i[e] = 0)
                            }
                            const u = c.morphTargetsRelative ? 1 : 1 - l;
                            p.getUniforms().setValue(e, "morphTargetBaseInfluence", u), p.getUniforms().setValue(e, "morphTargetInfluences", i)
                        }
                    }
                }
            }

            function co(e, t, n, r) {
                let i = new WeakMap;

                function s(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
                }
                return {
                    update: function(e) {
                        const o = r.render.frame,
                            a = e.geometry,
                            l = t.get(e, a);
                        return i.get(l) !== o && (t.update(l), i.set(l, o)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l
                    },
                    dispose: function() {
                        i = new WeakMap
                    }
                }
            }
            const uo = new Qn,
                po = new nr,
                ho = new ir,
                fo = new xs,
                _o = [],
                mo = [],
                go = new Float32Array(16),
                vo = new Float32Array(9),
                bo = new Float32Array(4);

            function xo(e, t, n) {
                const r = e[0];
                if (r <= 0 || r > 0) return e;
                const i = t * n;
                let s = _o[i];
                if (void 0 === s && (s = new Float32Array(i), _o[i] = s), 0 !== t) {
                    r.toArray(s, 0);
                    for (let r = 1, i = 0; r !== t; ++r) i += n, e[r].toArray(s, i)
                }
                return s
            }

            function yo(e, t) {
                if (e.length !== t.length) return !1;
                for (let n = 0, r = e.length; n < r; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function wo(e, t) {
                for (let n = 0, r = t.length; n < r; n++) e[n] = t[n]
            }

            function So(e, t) {
                let n = mo[t];
                void 0 === n && (n = new Int32Array(t), mo[t] = n);
                for (let r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
                return n
            }

            function Mo(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function To(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (yo(n, t)) return;
                    e.uniform2fv(this.addr, t), wo(n, t)
                }
            }

            function Eo(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (yo(n, t)) return;
                    e.uniform3fv(this.addr, t), wo(n, t)
                }
            }

            function Ao(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (yo(n, t)) return;
                    e.uniform4fv(this.addr, t), wo(n, t)
                }
            }

            function Co(e, t) {
                const n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (yo(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), wo(n, t)
                } else {
                    if (yo(n, r)) return;
                    bo.set(r), e.uniformMatrix2fv(this.addr, !1, bo), wo(n, r)
                }
            }

            function Ro(e, t) {
                const n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (yo(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), wo(n, t)
                } else {
                    if (yo(n, r)) return;
                    vo.set(r), e.uniformMatrix3fv(this.addr, !1, vo), wo(n, r)
                }
            }

            function ko(e, t) {
                const n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (yo(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), wo(n, t)
                } else {
                    if (yo(n, r)) return;
                    go.set(r), e.uniformMatrix4fv(this.addr, !1, go), wo(n, r)
                }
            }

            function Po(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function Do(e, t) {
                const n = this.cache;
                yo(n, t) || (e.uniform2iv(this.addr, t), wo(n, t))
            }

            function Oo(e, t) {
                const n = this.cache;
                yo(n, t) || (e.uniform3iv(this.addr, t), wo(n, t))
            }

            function Lo(e, t) {
                const n = this.cache;
                yo(n, t) || (e.uniform4iv(this.addr, t), wo(n, t))
            }

            function Io(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
            }

            function Fo(e, t) {
                const n = this.cache;
                yo(n, t) || (e.uniform2uiv(this.addr, t), wo(n, t))
            }

            function No(e, t) {
                const n = this.cache;
                yo(n, t) || (e.uniform3uiv(this.addr, t), wo(n, t))
            }

            function Uo(e, t) {
                const n = this.cache;
                yo(n, t) || (e.uniform4uiv(this.addr, t), wo(n, t))
            }

            function Bo(e, t, n) {
                const r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(t || uo, i)
            }

            function jo(e, t, n) {
                const r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || ho, i)
            }

            function zo(e, t, n) {
                const r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(t || fo, i)
            }

            function Vo(e, t, n) {
                const r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || po, i)
            }

            function Go(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function Ho(e, t) {
                const n = xo(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }

            function Wo(e, t) {
                const n = xo(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }

            function Ko(e, t) {
                const n = xo(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }

            function Xo(e, t) {
                const n = xo(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }

            function qo(e, t) {
                const n = xo(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }

            function Yo(e, t) {
                const n = xo(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }

            function Zo(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function Jo(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function $o(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function Qo(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function ea(e, t) {
                e.uniform1uiv(this.addr, t)
            }

            function ta(e, t) {
                e.uniform2uiv(this.addr, t)
            }

            function na(e, t) {
                e.uniform3uiv(this.addr, t)
            }

            function ra(e, t) {
                e.uniform4uiv(this.addr, t)
            }

            function ia(e, t, n) {
                const r = t.length,
                    i = So(n, r);
                e.uniform1iv(this.addr, i);
                for (let e = 0; e !== r; ++e) n.setTexture2D(t[e] || uo, i[e])
            }

            function sa(e, t, n) {
                const r = t.length,
                    i = So(n, r);
                e.uniform1iv(this.addr, i);
                for (let e = 0; e !== r; ++e) n.setTexture3D(t[e] || ho, i[e])
            }

            function oa(e, t, n) {
                const r = t.length,
                    i = So(n, r);
                e.uniform1iv(this.addr, i);
                for (let e = 0; e !== r; ++e) n.setTextureCube(t[e] || fo, i[e])
            }

            function aa(e, t, n) {
                const r = t.length,
                    i = So(n, r);
                e.uniform1iv(this.addr, i);
                for (let e = 0; e !== r; ++e) n.setTexture2DArray(t[e] || po, i[e])
            }
            class la {
                constructor(e, t, n) {
                    this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return Mo;
                            case 35664:
                                return To;
                            case 35665:
                                return Eo;
                            case 35666:
                                return Ao;
                            case 35674:
                                return Co;
                            case 35675:
                                return Ro;
                            case 35676:
                                return ko;
                            case 5124:
                            case 35670:
                                return Po;
                            case 35667:
                            case 35671:
                                return Do;
                            case 35668:
                            case 35672:
                                return Oo;
                            case 35669:
                            case 35673:
                                return Lo;
                            case 5125:
                                return Io;
                            case 36294:
                                return Fo;
                            case 36295:
                                return No;
                            case 36296:
                                return Uo;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Bo;
                            case 35679:
                            case 36299:
                            case 36307:
                                return jo;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return zo;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return Vo
                        }
                    }(t.type)
                }
            }
            class ca {
                constructor(e, t, n) {
                    this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
                        switch (e) {
                            case 5126:
                                return Go;
                            case 35664:
                                return Ho;
                            case 35665:
                                return Wo;
                            case 35666:
                                return Ko;
                            case 35674:
                                return Xo;
                            case 35675:
                                return qo;
                            case 35676:
                                return Yo;
                            case 5124:
                            case 35670:
                                return Zo;
                            case 35667:
                            case 35671:
                                return Jo;
                            case 35668:
                            case 35672:
                                return $o;
                            case 35669:
                            case 35673:
                                return Qo;
                            case 5125:
                                return ea;
                            case 36294:
                                return ta;
                            case 36295:
                                return na;
                            case 36296:
                                return ra;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return ia;
                            case 35679:
                            case 36299:
                            case 36307:
                                return sa;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return oa;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return aa
                        }
                    }(t.type)
                }
            }
            class ua {
                constructor(e) {
                    this.id = e, this.seq = [], this.map = {}
                }
                setValue(e, t, n) {
                    const r = this.seq;
                    for (let i = 0, s = r.length; i !== s; ++i) {
                        const s = r[i];
                        s.setValue(e, t[s.id], n)
                    }
                }
            }
            const pa = /(\w+)(\])?(\[|\.)?/g;

            function ha(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function da(e, t, n) {
                const r = e.name,
                    i = r.length;
                for (pa.lastIndex = 0;;) {
                    const s = pa.exec(r),
                        o = pa.lastIndex;
                    let a = s[1];
                    const l = "]" === s[2],
                        c = s[3];
                    if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === i) {
                        ha(n, void 0 === c ? new la(a, e, t) : new ca(a, e, t));
                        break
                    } {
                        let e = n.map[a];
                        void 0 === e && (e = new ua(a), ha(n, e)), n = e
                    }
                }
            }
            class fa {
                constructor(e, t) {
                    this.seq = [], this.map = {};
                    const n = e.getProgramParameter(t, 35718);
                    for (let r = 0; r < n; ++r) {
                        const n = e.getActiveUniform(t, r);
                        da(n, e.getUniformLocation(t, n.name), this)
                    }
                }
                setValue(e, t, n, r) {
                    const i = this.map[t];
                    void 0 !== i && i.setValue(e, n, r)
                }
                setOptional(e, t, n) {
                    const r = t[n];
                    void 0 !== r && this.setValue(e, n, r)
                }
                static upload(e, t, n, r) {
                    for (let i = 0, s = t.length; i !== s; ++i) {
                        const s = t[i],
                            o = n[s.id];
                        !1 !== o.needsUpdate && s.setValue(e, o.value, r)
                    }
                }
                static seqWithValue(e, t) {
                    const n = [];
                    for (let r = 0, i = e.length; r !== i; ++r) {
                        const i = e[r];
                        i.id in t && n.push(i)
                    }
                    return n
                }
            }

            function _a(e, t, n) {
                const r = e.createShader(t);
                return e.shaderSource(r, n), e.compileShader(r), r
            }
            let ma = 0;

            function ga(e) {
                switch (e) {
                    case Dt:
                        return ["Linear", "( value )"];
                    case Ot:
                        return ["sRGB", "( value )"];
                    case It:
                        return ["RGBM", "( value, 16.0 )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
                }
            }

            function va(e, t, n) {
                const r = e.getShaderParameter(t, 35713),
                    i = e.getShaderInfoLog(t).trim();
                if (r && "" === i) return "";
                const s = /ERROR: 0:(\d+)/.exec(i);
                if (s) {
                    const r = parseInt(s[1]);
                    return n.toUpperCase() + "\n\n" + i + "\n\n" + function(e, t) {
                        const n = e.split("\n"),
                            r = [],
                            i = Math.max(t - 6, 0),
                            s = Math.min(t + 6, n.length);
                        for (let e = i; e < s; e++) {
                            const i = e + 1;
                            r.push(`${i===t?">":" "} ${i}: ${n[e]}`)
                        }
                        return r.join("\n")
                    }(e.getShaderSource(t), r)
                }
                return i
            }

            function ba(e, t) {
                const n = ga(t);
                return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function xa(e, t) {
                const n = ga(t);
                return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }

            function ya(e, t) {
                let n;
                switch (t) {
                    case Q:
                        n = "Linear";
                        break;
                    case ee:
                        n = "Reinhard";
                        break;
                    case te:
                        n = "OptimizedCineon";
                        break;
                    case ne:
                        n = "ACESFilmic";
                        break;
                    case re:
                        n = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
                }
                return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function wa(e) {
                return "" !== e
            }

            function Sa(e, t) {
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function Ma(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            const Ta = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function Ea(e) {
                return e.replace(Ta, Aa)
            }

            function Aa(e, t) {
                const n = Ds[t];
                if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
                return Ea(n)
            }
            const Ca = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                Ra = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function ka(e) {
                return e.replace(Ra, Da).replace(Ca, Pa)
            }

            function Pa(e, t, n, r) {
                return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Da(0, t, n, r)
            }

            function Da(e, t, n, r) {
                let i = "";
                for (let e = parseInt(t); e < parseInt(n); e++) i += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                return i
            }

            function Oa(e) {
                let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function La(e, t, n, r) {
                const i = e.getContext(),
                    s = n.defines;
                let o = n.vertexShader,
                    a = n.fragmentShader;
                const l = function(e) {
                        let t = "SHADOWMAP_TYPE_BASIC";
                        return e.shadowMapType === p ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === h ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === d && (t = "SHADOWMAP_TYPE_VSM"), t
                    }(n),
                    c = function(e) {
                        let t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case se:
                            case oe:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case ce:
                                t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(n),
                    u = function(e) {
                        let t = "ENVMAP_MODE_REFLECTION";
                        if (e.envMap) switch (e.envMapMode) {
                            case oe:
                                t = "ENVMAP_MODE_REFRACTION"
                        }
                        return t
                    }(n),
                    f = function(e) {
                        let t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case Y:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case Z:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case J:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(n),
                    _ = function(e) {
                        const t = e.envMapCubeUVHeight;
                        if (null === t) return null;
                        const n = Math.log2(t) - 2,
                            r = 1 / t;
                        return {
                            texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                            texelHeight: r,
                            maxMip: n
                        }
                    }(n),
                    m = n.isWebGL2 ? "" : function(e) {
                        return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(wa).join("\n")
                    }(n),
                    g = function(e) {
                        const t = [];
                        for (const n in e) {
                            const r = e[n];
                            !1 !== r && t.push("#define " + n + " " + r)
                        }
                        return t.join("\n")
                    }(s),
                    v = i.createProgram();
                let b, x, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? (b = [g].filter(wa).join("\n"), b.length > 0 && (b += "\n"), x = [m, g].filter(wa).join("\n"), x.length > 0 && (x += "\n")) : (b = [Oa(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(wa).join("\n"), x = [m, Oa(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + f : "", _ ? "#define CUBEUV_TEXEL_WIDTH " + _.texelWidth : "", _ ? "#define CUBEUV_TEXEL_HEIGHT " + _.texelHeight : "", _ ? "#define CUBEUV_MAX_MIP " + _.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== $ ? "#define TONE_MAPPING" : "", n.toneMapping !== $ ? Ds.tonemapping_pars_fragment : "", n.toneMapping !== $ ? ya("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Ds.encodings_pars_fragment, xa("linearToOutputTexel", n.outputEncoding), n.transmissionSamplerMapEncoding ? ba("transmissionSamplerMapTexelToLinear", n.transmissionSamplerMapEncoding) : "", n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(wa).join("\n")), o = Ea(o), o = Sa(o, n), o = Ma(o, n), a = Ea(a), a = Sa(a, n), a = Ma(a, n), o = ka(o), a = ka(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", b = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + b, x = ["#define varying in", n.glslVersion === mn ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === mn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x);
                const w = y + x + a,
                    S = _a(i, 35633, y + b + o),
                    M = _a(i, 35632, w);
                if (i.attachShader(v, S), i.attachShader(v, M), void 0 !== n.index0AttributeName ? i.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(v, 0, "position"), i.linkProgram(v), e.debug.checkShaderErrors) {
                    const e = i.getProgramInfoLog(v).trim(),
                        t = i.getShaderInfoLog(S).trim(),
                        n = i.getShaderInfoLog(M).trim();
                    let r = !0,
                        s = !0;
                    if (!1 === i.getProgramParameter(v, 35714)) {
                        r = !1;
                        const t = va(i, S, "vertex"),
                            n = va(i, M, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
                    } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (s = !1);
                    s && (this.diagnostics = {
                        runnable: r,
                        programLog: e,
                        vertexShader: {
                            log: t,
                            prefix: b
                        },
                        fragmentShader: {
                            log: n,
                            prefix: x
                        }
                    })
                }
                let T, E;
                return i.deleteShader(S), i.deleteShader(M), this.getUniforms = function() {
                    return void 0 === T && (T = new fa(i, v)), T
                }, this.getAttributes = function() {
                    return void 0 === E && (E = function(e, t) {
                        const n = {},
                            r = e.getProgramParameter(t, 35721);
                        for (let i = 0; i < r; i++) {
                            const r = e.getActiveAttrib(t, i),
                                s = r.name;
                            let o = 1;
                            35674 === r.type && (o = 2), 35675 === r.type && (o = 3), 35676 === r.type && (o = 4), n[s] = {
                                type: r.type,
                                location: e.getAttribLocation(t, s),
                                locationSize: o
                            }
                        }
                        return n
                    }(i, v)), E
                }, this.destroy = function() {
                    r.releaseStatesOfProgram(this), i.deleteProgram(v), this.program = void 0
                }, this.name = n.shaderName, this.id = ma++, this.cacheKey = t, this.usedTimes = 1, this.program = v, this.vertexShader = S, this.fragmentShader = M, this
            }
            let Ia = 0;
            class Fa {
                constructor() {
                    this.shaderCache = new Map, this.materialCache = new Map
                }
                update(e) {
                    const t = e.vertexShader,
                        n = e.fragmentShader,
                        r = this._getShaderStage(t),
                        i = this._getShaderStage(n),
                        s = this._getShaderCacheForMaterial(e);
                    return !1 === s.has(r) && (s.add(r), r.usedTimes++), !1 === s.has(i) && (s.add(i), i.usedTimes++), this
                }
                remove(e) {
                    const t = this.materialCache.get(e);
                    for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
                    return this.materialCache.delete(e), this
                }
                getVertexShaderID(e) {
                    return this._getShaderStage(e.vertexShader).id
                }
                getFragmentShaderID(e) {
                    return this._getShaderStage(e.fragmentShader).id
                }
                dispose() {
                    this.shaderCache.clear(), this.materialCache.clear()
                }
                _getShaderCacheForMaterial(e) {
                    const t = this.materialCache;
                    return !1 === t.has(e) && t.set(e, new Set), t.get(e)
                }
                _getShaderStage(e) {
                    const t = this.shaderCache;
                    if (!1 === t.has(e)) {
                        const n = new Na(e);
                        t.set(e, n)
                    }
                    return t.get(e)
                }
            }
            class Na {
                constructor(e) {
                    this.id = Ia++, this.code = e, this.usedTimes = 0
                }
            }

            function Ua(e, t, n, r, i, s, o) {
                const a = new Zr,
                    l = new Fa,
                    c = [],
                    u = i.isWebGL2,
                    p = i.logarithmicDepthBuffer,
                    h = i.vertexTextures;
                let d = i.precision;
                const f = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                };
                return {
                    getParameters: function(s, a, c, g, v) {
                        const b = g.fog,
                            y = v.geometry,
                            w = s.isMeshStandardMaterial ? g.environment : null,
                            S = (s.isMeshStandardMaterial ? n : t).get(s.envMap || w),
                            M = S && S.mapping === ce ? S.image.height : null,
                            T = f[s.type];
                        null !== s.precision && (d = i.getMaxPrecision(s.precision), d !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", d, "instead."));
                        const E = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
                            A = void 0 !== E ? E.length : 0;
                        let C, R, k, P, D = 0;
                        if (void 0 !== y.morphAttributes.position && (D = 1), void 0 !== y.morphAttributes.normal && (D = 2), void 0 !== y.morphAttributes.color && (D = 3), T) {
                            const e = Ls[T];
                            C = e.vertexShader, R = e.fragmentShader
                        } else C = s.vertexShader, R = s.fragmentShader, l.update(s), k = l.getVertexShaderID(s), P = l.getFragmentShaderID(s);
                        const O = e.getRenderTarget(),
                            L = e.userData && e.userData.transmissionRenderTarget,
                            I = s.alphaTest > 0,
                            F = s.clearcoat > 0,
                            N = s.iridescence > 0;
                        return {
                            isWebGL2: u,
                            shaderID: T,
                            shaderName: s.type,
                            vertexShader: C,
                            fragmentShader: R,
                            defines: s.defines,
                            customVertexShaderID: k,
                            customFragmentShaderID: P,
                            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                            glslVersion: s.glslVersion,
                            precision: d,
                            instancing: !0 === v.isInstancedMesh,
                            instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                            supportsVertexTextures: h,
                            outputEncoding: null === O ? e.outputEncoding : !0 === O.isXRRenderTarget || O.texture.encoding !== Ot ? O.texture.encoding : Dt,
                            map: !!s.map,
                            matcap: !!s.matcap,
                            envMap: !!S,
                            envMapMode: S && S.mapping,
                            envMapCubeUVHeight: M,
                            lightMap: !!s.lightMap,
                            aoMap: !!s.aoMap,
                            emissiveMap: !!s.emissiveMap,
                            bumpMap: !!s.bumpMap,
                            normalMap: !!s.normalMap,
                            objectSpaceNormalMap: s.normalMapType === Bt,
                            tangentSpaceNormalMap: s.normalMapType === Ut,
                            decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === Ot,
                            clearcoat: F,
                            clearcoatMap: F && !!s.clearcoatMap,
                            clearcoatRoughnessMap: F && !!s.clearcoatRoughnessMap,
                            clearcoatNormalMap: F && !!s.clearcoatNormalMap,
                            iridescence: N,
                            iridescenceMap: N && !!s.iridescenceMap,
                            iridescenceThicknessMap: N && !!s.iridescenceThicknessMap,
                            displacementMap: !!s.displacementMap,
                            roughnessMap: !!s.roughnessMap,
                            metalnessMap: !!s.metalnessMap,
                            specularMap: !!s.specularMap,
                            specularIntensityMap: !!s.specularIntensityMap,
                            specularColorMap: !!s.specularColorMap,
                            opaque: !1 === s.transparent && s.blending === x && !(s.transmission > 0),
                            alphaMap: !!s.alphaMap,
                            alphaTest: I,
                            gradientMap: !!s.gradientMap,
                            sheen: s.sheen > 0,
                            sheenColorMap: !!s.sheenColorMap,
                            sheenRoughnessMap: !!s.sheenRoughnessMap,
                            transmission: s.transmission > 0,
                            transmissionMap: !!s.transmissionMap,
                            transmissionSamplerMapEncoding: L ? L.texture.encoding : Dt,
                            thicknessMap: !!s.thicknessMap,
                            combine: s.combine,
                            vertexTangents: !!s.normalMap && !!y.attributes.tangent,
                            vertexColors: s.vertexColors,
                            vertexAlphas: !0 === s.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                            vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
                            uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
                            fog: !!b,
                            useFog: !0 === s.fog,
                            fogExp2: b && b.isFogExp2,
                            flatShading: !!s.flatShading,
                            sizeAttenuation: s.sizeAttenuation,
                            logarithmicDepthBuffer: p,
                            skinning: !0 === v.isSkinnedMesh,
                            morphTargets: void 0 !== y.morphAttributes.position,
                            morphNormals: void 0 !== y.morphAttributes.normal,
                            morphColors: void 0 !== y.morphAttributes.color,
                            morphTargetsCount: A,
                            morphTextureStride: D,
                            numDirLights: a.directional.length,
                            numPointLights: a.point.length,
                            numSpotLights: a.spot.length,
                            numRectAreaLights: a.rectArea.length,
                            numHemiLights: a.hemi.length,
                            numDirLightShadows: a.directionalShadowMap.length,
                            numPointLightShadows: a.pointShadowMap.length,
                            numSpotLightShadows: a.spotShadowMap.length,
                            numClippingPlanes: o.numPlanes,
                            numClipIntersection: o.numIntersection,
                            dithering: s.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: s.toneMapped ? e.toneMapping : $,
                            physicallyCorrectLights: e.physicallyCorrectLights,
                            premultipliedAlpha: s.premultipliedAlpha,
                            doubleSided: s.side === m,
                            flipSided: s.side === _,
                            useDepthPacking: !!s.depthPacking,
                            depthPacking: s.depthPacking || 0,
                            index0AttributeName: s.index0AttributeName,
                            extensionDerivatives: s.extensions && s.extensions.derivatives,
                            extensionFragDepth: s.extensions && s.extensions.fragDepth,
                            extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                            extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: u || r.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: u || r.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: u || r.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: s.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function(t) {
                        const n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                            for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                        return !1 === t.isRawShaderMaterial && (function(e, t) {
                            e.push(t.precision), e.push(t.outputEncoding), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.combine), e.push(t.vertexUvs), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking)
                        }(n, t), function(e, t) {
                            a.disableAll(), t.isWebGL2 && a.enable(0), t.supportsVertexTextures && a.enable(1), t.instancing && a.enable(2), t.instancingColor && a.enable(3), t.map && a.enable(4), t.matcap && a.enable(5), t.envMap && a.enable(6), t.lightMap && a.enable(7), t.aoMap && a.enable(8), t.emissiveMap && a.enable(9), t.bumpMap && a.enable(10), t.normalMap && a.enable(11), t.objectSpaceNormalMap && a.enable(12), t.tangentSpaceNormalMap && a.enable(13), t.clearcoat && a.enable(14), t.clearcoatMap && a.enable(15), t.clearcoatRoughnessMap && a.enable(16), t.clearcoatNormalMap && a.enable(17), t.iridescence && a.enable(18), t.iridescenceMap && a.enable(19), t.iridescenceThicknessMap && a.enable(20), t.displacementMap && a.enable(21), t.specularMap && a.enable(22), t.roughnessMap && a.enable(23), t.metalnessMap && a.enable(24), t.gradientMap && a.enable(25), t.alphaMap && a.enable(26), t.alphaTest && a.enable(27), t.vertexColors && a.enable(28), t.vertexAlphas && a.enable(29), t.vertexUvs && a.enable(30), t.vertexTangents && a.enable(31), t.uvsVertexOnly && a.enable(32), t.fog && a.enable(33), e.push(a.mask), a.disableAll(), t.useFog && a.enable(0), t.flatShading && a.enable(1), t.logarithmicDepthBuffer && a.enable(2), t.skinning && a.enable(3), t.morphTargets && a.enable(4), t.morphNormals && a.enable(5), t.morphColors && a.enable(6), t.premultipliedAlpha && a.enable(7), t.shadowMapEnabled && a.enable(8), t.physicallyCorrectLights && a.enable(9), t.doubleSided && a.enable(10), t.flipSided && a.enable(11), t.useDepthPacking && a.enable(12), t.dithering && a.enable(13), t.specularIntensityMap && a.enable(14), t.specularColorMap && a.enable(15), t.transmission && a.enable(16), t.transmissionMap && a.enable(17), t.thicknessMap && a.enable(18), t.sheen && a.enable(19), t.sheenColorMap && a.enable(20), t.sheenRoughnessMap && a.enable(21), t.decodeVideoTexture && a.enable(22), t.opaque && a.enable(23), e.push(a.mask)
                        }(n, t), n.push(e.outputEncoding)), n.push(t.customProgramCacheKey), n.join()
                    },
                    getUniforms: function(e) {
                        const t = f[e.type];
                        let n;
                        if (t) {
                            const e = Ls[t];
                            n = fs.clone(e.uniforms)
                        } else n = e.uniforms;
                        return n
                    },
                    acquireProgram: function(t, n) {
                        let r;
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            if (t.cacheKey === n) {
                                r = t, ++r.usedTimes;
                                break
                            }
                        }
                        return void 0 === r && (r = new La(e, n, t, s), c.push(r)), r
                    },
                    releaseProgram: function(e) {
                        if (0 == --e.usedTimes) {
                            const t = c.indexOf(e);
                            c[t] = c[c.length - 1], c.pop(), e.destroy()
                        }
                    },
                    releaseShaderCache: function(e) {
                        l.remove(e)
                    },
                    programs: c,
                    dispose: function() {
                        l.dispose()
                    }
                }
            }

            function Ba() {
                let e = new WeakMap;
                return {
                    get: function(t) {
                        let n = e.get(t);
                        return void 0 === n && (n = {}, e.set(t, n)), n
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, n, r) {
                        e.get(t)[n] = r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function ja(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function za(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function Va() {
                const e = [];
                let t = 0;
                const n = [],
                    r = [],
                    i = [];

                function s(n, r, i, s, o, a) {
                    let l = e[t];
                    return void 0 === l ? (l = {
                        id: n.id,
                        object: n,
                        geometry: r,
                        material: i,
                        groupOrder: s,
                        renderOrder: n.renderOrder,
                        z: o,
                        group: a
                    }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = o, l.group = a), t++, l
                }
                return {
                    opaque: n,
                    transmissive: r,
                    transparent: i,
                    init: function() {
                        t = 0, n.length = 0, r.length = 0, i.length = 0
                    },
                    push: function(e, t, o, a, l, c) {
                        const u = s(e, t, o, a, l, c);
                        o.transmission > 0 ? r.push(u) : !0 === o.transparent ? i.push(u) : n.push(u)
                    },
                    unshift: function(e, t, o, a, l, c) {
                        const u = s(e, t, o, a, l, c);
                        o.transmission > 0 ? r.unshift(u) : !0 === o.transparent ? i.unshift(u) : n.unshift(u)
                    },
                    finish: function() {
                        for (let n = t, r = e.length; n < r; n++) {
                            const t = e[n];
                            if (null === t.id) break;
                            t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
                        }
                    },
                    sort: function(e, t) {
                        n.length > 1 && n.sort(e || ja), r.length > 1 && r.sort(t || za), i.length > 1 && i.sort(t || za)
                    }
                }
            }

            function Ga() {
                let e = new WeakMap;
                return {
                    get: function(t, n) {
                        let r;
                        return !1 === e.has(t) ? (r = new Va, e.set(t, [r])) : n >= e.get(t).length ? (r = new Va, e.get(t).push(r)) : r = e.get(t)[n], r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function Ha() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        let n;
                        switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new lr,
                                    color: new Xn
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new lr,
                                    direction: new lr,
                                    color: new Xn,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new lr,
                                    color: new Xn,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new lr,
                                    skyColor: new Xn,
                                    groundColor: new Xn
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new Xn,
                                    position: new lr,
                                    halfWidth: new lr,
                                    halfHeight: new lr
                                }
                        }
                        return e[t.id] = n, n
                    }
                }
            }
            let Wa = 0;

            function Ka(e, t) {
                return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
            }

            function Xa(e, t) {
                const n = new Ha,
                    r = function() {
                        const e = {};
                        return {
                            get: function(t) {
                                if (void 0 !== e[t.id]) return e[t.id];
                                let n;
                                switch (t.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Pn
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Pn,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return e[t.id] = n, n
                            }
                        }
                    }(),
                    i = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                for (let e = 0; e < 9; e++) i.probe.push(new lr);
                const s = new lr,
                    o = new Br,
                    a = new Br;
                return {
                    setup: function(s, o) {
                        let a = 0,
                            l = 0,
                            c = 0;
                        for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
                        let u = 0,
                            p = 0,
                            h = 0,
                            d = 0,
                            f = 0,
                            _ = 0,
                            m = 0,
                            g = 0;
                        s.sort(Ka);
                        const v = !0 !== o ? Math.PI : 1;
                        for (let e = 0, t = s.length; e < t; e++) {
                            const t = s[e],
                                o = t.color,
                                b = t.intensity,
                                x = t.distance,
                                y = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                            if (t.isAmbientLight) a += o.r * b * v, l += o.g * b * v, c += o.b * b * v;
                            else if (t.isLightProbe)
                                for (let e = 0; e < 9; e++) i.probe[e].addScaledVector(t.sh.coefficients[e], b);
                            else if (t.isDirectionalLight) {
                                const e = n.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity * v), t.castShadow) {
                                    const e = t.shadow,
                                        n = r.get(t);
                                    n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.directionalShadow[u] = n, i.directionalShadowMap[u] = y, i.directionalShadowMatrix[u] = t.shadow.matrix, _++
                                }
                                i.directional[u] = e, u++
                            } else if (t.isSpotLight) {
                                const e = n.get(t);
                                if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(o).multiplyScalar(b * v), e.distance = x, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
                                    const e = t.shadow,
                                        n = r.get(t);
                                    n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, i.spotShadow[h] = n, i.spotShadowMap[h] = y, i.spotShadowMatrix[h] = t.shadow.matrix, g++
                                }
                                i.spot[h] = e, h++
                            } else if (t.isRectAreaLight) {
                                const e = n.get(t);
                                e.color.copy(o).multiplyScalar(b), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), i.rectArea[d] = e, d++
                            } else if (t.isPointLight) {
                                const e = n.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity * v), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                                    const e = t.shadow,
                                        n = r.get(t);
                                    n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, i.pointShadow[p] = n, i.pointShadowMap[p] = y, i.pointShadowMatrix[p] = t.shadow.matrix, m++
                                }
                                i.point[p] = e, p++
                            } else if (t.isHemisphereLight) {
                                const e = n.get(t);
                                e.skyColor.copy(t.color).multiplyScalar(b * v), e.groundColor.copy(t.groundColor).multiplyScalar(b * v), i.hemi[f] = e, f++
                            }
                        }
                        d > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Os.LTC_FLOAT_1, i.rectAreaLTC2 = Os.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Os.LTC_HALF_1, i.rectAreaLTC2 = Os.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = a, i.ambient[1] = l, i.ambient[2] = c;
                        const b = i.hash;
                        b.directionalLength === u && b.pointLength === p && b.spotLength === h && b.rectAreaLength === d && b.hemiLength === f && b.numDirectionalShadows === _ && b.numPointShadows === m && b.numSpotShadows === g || (i.directional.length = u, i.spot.length = h, i.rectArea.length = d, i.point.length = p, i.hemi.length = f, i.directionalShadow.length = _, i.directionalShadowMap.length = _, i.pointShadow.length = m, i.pointShadowMap.length = m, i.spotShadow.length = g, i.spotShadowMap.length = g, i.directionalShadowMatrix.length = _, i.pointShadowMatrix.length = m, i.spotShadowMatrix.length = g, b.directionalLength = u, b.pointLength = p, b.spotLength = h, b.rectAreaLength = d, b.hemiLength = f, b.numDirectionalShadows = _, b.numPointShadows = m, b.numSpotShadows = g, i.version = Wa++)
                    },
                    setupView: function(e, t) {
                        let n = 0,
                            r = 0,
                            l = 0,
                            c = 0,
                            u = 0;
                        const p = t.matrixWorldInverse;
                        for (let t = 0, h = e.length; t < h; t++) {
                            const h = e[t];
                            if (h.isDirectionalLight) {
                                const e = i.directional[n];
                                e.direction.setFromMatrixPosition(h.matrixWorld), s.setFromMatrixPosition(h.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(p), n++
                            } else if (h.isSpotLight) {
                                const e = i.spot[l];
                                e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(p), e.direction.setFromMatrixPosition(h.matrixWorld), s.setFromMatrixPosition(h.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(p), l++
                            } else if (h.isRectAreaLight) {
                                const e = i.rectArea[c];
                                e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(p), a.identity(), o.copy(h.matrixWorld), o.premultiply(p), a.extractRotation(o), e.halfWidth.set(.5 * h.width, 0, 0), e.halfHeight.set(0, .5 * h.height, 0), e.halfWidth.applyMatrix4(a), e.halfHeight.applyMatrix4(a), c++
                            } else if (h.isPointLight) {
                                const e = i.point[r];
                                e.position.setFromMatrixPosition(h.matrixWorld), e.position.applyMatrix4(p), r++
                            } else if (h.isHemisphereLight) {
                                const e = i.hemi[u];
                                e.direction.setFromMatrixPosition(h.matrixWorld), e.direction.transformDirection(p), u++
                            }
                        }
                    },
                    state: i
                }
            }

            function qa(e, t) {
                const n = new Xa(e, t),
                    r = [],
                    i = [];
                return {
                    init: function() {
                        r.length = 0, i.length = 0
                    },
                    state: {
                        lightsArray: r,
                        shadowsArray: i,
                        lights: n
                    },
                    setupLights: function(e) {
                        n.setup(r, e)
                    },
                    setupLightsView: function(e) {
                        n.setupView(r, e)
                    },
                    pushLight: function(e) {
                        r.push(e)
                    },
                    pushShadow: function(e) {
                        i.push(e)
                    }
                }
            }

            function Ya(e, t) {
                let n = new WeakMap;
                return {
                    get: function(r, i = 0) {
                        let s;
                        return !1 === n.has(r) ? (s = new qa(e, t), n.set(r, [s])) : i >= n.get(r).length ? (s = new qa(e, t), n.get(r).push(s)) : s = n.get(r)[i], s
                    },
                    dispose: function() {
                        n = new WeakMap
                    }
                }
            }
            class Za extends Si {
                constructor(e) {
                    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Ft, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                }
            }
            class Ja extends Si {
                constructor(e) {
                    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new lr, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                }
            }

            function $a(e, t, n) {
                let r = new Cs;
                const i = new Pn,
                    s = new Pn,
                    o = new er,
                    a = new Za({
                        depthPacking: Nt
                    }),
                    l = new Ja,
                    c = {},
                    u = n.maxTextureSize,
                    h = {
                        0: _,
                        1: f,
                        2: m
                    },
                    g = new _s({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Pn
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    v = g.clone();
                v.defines.HORIZONTAL_PASS = 1;
                const x = new Wi;
                x.setAttribute("position", new Ai(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const y = new cs(x, g),
                    w = this;

                function S(n, r) {
                    const s = t.update(y);
                    g.defines.VSM_SAMPLES !== n.blurSamples && (g.defines.VSM_SAMPLES = n.blurSamples, v.defines.VSM_SAMPLES = n.blurSamples, g.needsUpdate = !0, v.needsUpdate = !0), null === n.mapPass && (n.mapPass = new tr(i.x, i.y)), g.uniforms.shadow_pass.value = n.map.texture, g.uniforms.resolution.value = n.mapSize, g.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, s, g, y, null), v.uniforms.shadow_pass.value = n.mapPass.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, s, v, y, null)
                }

                function M(t, n, r, i, s, o) {
                    let u = null;
                    const p = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (u = void 0 !== p ? p : !0 === r.isPointLight ? l : a, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
                        const e = u.uuid,
                            t = n.uuid;
                        let r = c[e];
                        void 0 === r && (r = {}, c[e] = r);
                        let i = r[t];
                        void 0 === i && (i = u.clone(), r[t] = i), u = i
                    }
                    return u.visible = n.visible, u.wireframe = n.wireframe, u.side = o === d ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : h[n.side], u.alphaMap = n.alphaMap, u.alphaTest = n.alphaTest, u.clipShadows = n.clipShadows, u.clippingPlanes = n.clippingPlanes, u.clipIntersection = n.clipIntersection, u.displacementMap = n.displacementMap, u.displacementScale = n.displacementScale, u.displacementBias = n.displacementBias, u.wireframeLinewidth = n.wireframeLinewidth, u.linewidth = n.linewidth, !0 === r.isPointLight && !0 === u.isMeshDistanceMaterial && (u.referencePosition.setFromMatrixPosition(r.matrixWorld), u.nearDistance = i, u.farDistance = s), u
                }

                function T(n, i, s, o, a) {
                    if (!1 === n.visible) return;
                    if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === d) && (!n.frustumCulled || r.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                        const r = t.update(n),
                            i = n.material;
                        if (Array.isArray(i)) {
                            const t = r.groups;
                            for (let l = 0, c = t.length; l < c; l++) {
                                const c = t[l],
                                    u = i[c.materialIndex];
                                if (u && u.visible) {
                                    const t = M(n, u, o, s.near, s.far, a);
                                    e.renderBufferDirect(s, null, r, t, n, c)
                                }
                            }
                        } else if (i.visible) {
                            const t = M(n, i, o, s.near, s.far, a);
                            e.renderBufferDirect(s, null, r, t, n, null)
                        }
                    }
                    const l = n.children;
                    for (let e = 0, t = l.length; e < t; e++) T(l[e], i, s, o, a)
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = p, this.render = function(t, n, a) {
                    if (!1 === w.enabled) return;
                    if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
                    if (0 === t.length) return;
                    const l = e.getRenderTarget(),
                        c = e.getActiveCubeFace(),
                        p = e.getActiveMipmapLevel(),
                        h = e.state;
                    h.setBlending(b), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);
                    for (let l = 0, c = t.length; l < c; l++) {
                        const c = t[l],
                            p = c.shadow;
                        if (void 0 === p) {
                            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                            continue
                        }
                        if (!1 === p.autoUpdate && !1 === p.needsUpdate) continue;
                        i.copy(p.mapSize);
                        const f = p.getFrameExtents();
                        if (i.multiply(f), s.copy(p.mapSize), (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / f.x), i.x = s.x * f.x, p.mapSize.x = s.x), i.y > u && (s.y = Math.floor(u / f.y), i.y = s.y * f.y, p.mapSize.y = s.y)), null === p.map) {
                            const e = this.type !== d ? {
                                minFilter: de,
                                magFilter: de
                            } : {};
                            p.map = new tr(i.x, i.y, e), p.map.texture.name = c.name + ".shadowMap", p.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(p.map), e.clear();
                        const _ = p.getViewportCount();
                        for (let e = 0; e < _; e++) {
                            const t = p.getViewport(e);
                            o.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), h.viewport(o), p.updateMatrices(c, e), r = p.getFrustum(), T(n, a, p.camera, c, this.type)
                        }!0 !== p.isPointLightShadow && this.type === d && S(p, a), p.needsUpdate = !1
                    }
                    w.needsUpdate = !1, e.setRenderTarget(l, c, p)
                }
            }

            function Qa(e, t, n) {
                const r = n.isWebGL2,
                    i = new function() {
                        let t = !1;
                        const n = new er;
                        let r = null;
                        const i = new er(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                r === n || t || (e.colorMask(n, n, n, n), r = n)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t, r, s, o, a) {
                                !0 === a && (t *= o, r *= o, s *= o), n.set(t, r, s, o), !1 === i.equals(n) && (e.clearColor(t, r, s, o), i.copy(n))
                            },
                            reset: function() {
                                t = !1, r = null, i.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    s = new function() {
                        let t = !1,
                            n = null,
                            r = null,
                            i = null;
                        return {
                            setTest: function(e) {
                                e ? ye(2929) : we(2929)
                            },
                            setMask: function(r) {
                                n === r || t || (e.depthMask(r), n = r)
                            },
                            setFunc: function(t) {
                                if (r !== t) {
                                    if (t) switch (t) {
                                        case z:
                                            e.depthFunc(512);
                                            break;
                                        case V:
                                            e.depthFunc(519);
                                            break;
                                        case G:
                                            e.depthFunc(513);
                                            break;
                                        case H:
                                            e.depthFunc(515);
                                            break;
                                        case W:
                                            e.depthFunc(514);
                                            break;
                                        case K:
                                            e.depthFunc(518);
                                            break;
                                        case X:
                                            e.depthFunc(516);
                                            break;
                                        case q:
                                            e.depthFunc(517);
                                            break;
                                        default:
                                            e.depthFunc(515)
                                    } else e.depthFunc(515);
                                    r = t
                                }
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                i !== t && (e.clearDepth(t), i = t)
                            },
                            reset: function() {
                                t = !1, n = null, r = null, i = null
                            }
                        }
                    },
                    c = new function() {
                        let t = !1,
                            n = null,
                            r = null,
                            i = null,
                            s = null,
                            o = null,
                            a = null,
                            l = null,
                            c = null;
                        return {
                            setTest: function(e) {
                                t || (e ? ye(2960) : we(2960))
                            },
                            setMask: function(r) {
                                n === r || t || (e.stencilMask(r), n = r)
                            },
                            setFunc: function(t, n, o) {
                                r === t && i === n && s === o || (e.stencilFunc(t, n, o), r = t, i = n, s = o)
                            },
                            setOp: function(t, n, r) {
                                o === t && a === n && l === r || (e.stencilOp(t, n, r), o = t, a = n, l = r)
                            },
                            setLocked: function(e) {
                                t = e
                            },
                            setClear: function(t) {
                                c !== t && (e.clearStencil(t), c = t)
                            },
                            reset: function() {
                                t = !1, n = null, r = null, i = null, s = null, o = null, a = null, l = null, c = null
                            }
                        }
                    },
                    u = new WeakMap,
                    p = new WeakMap;
                let h = {},
                    d = {},
                    f = new WeakMap,
                    g = [],
                    v = null,
                    Y = !1,
                    Z = null,
                    J = null,
                    $ = null,
                    Q = null,
                    ee = null,
                    te = null,
                    ne = null,
                    re = !1,
                    ie = null,
                    se = null,
                    oe = null,
                    ae = null,
                    le = null;
                const ce = e.getParameter(35661);
                let ue = !1,
                    pe = 0;
                const he = e.getParameter(7938); - 1 !== he.indexOf("WebGL") ? (pe = parseFloat(/^WebGL (\d)/.exec(he)[1]), ue = pe >= 1) : -1 !== he.indexOf("OpenGL ES") && (pe = parseFloat(/^OpenGL ES (\d)/.exec(he)[1]), ue = pe >= 2);
                let de = null,
                    fe = {};
                const _e = e.getParameter(3088),
                    me = e.getParameter(2978),
                    ge = (new er).fromArray(_e),
                    ve = (new er).fromArray(me);

                function be(t, n, r) {
                    const i = new Uint8Array(4),
                        s = e.createTexture();
                    e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                    for (let t = 0; t < r; t++) e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, i);
                    return s
                }
                const xe = {};

                function ye(t) {
                    !0 !== h[t] && (e.enable(t), h[t] = !0)
                }

                function we(t) {
                    !1 !== h[t] && (e.disable(t), h[t] = !1)
                }
                xe[3553] = be(3553, 3553, 1), xe[34067] = be(34067, 34069, 6), i.setClear(0, 0, 0, 1), s.setClear(1), c.setClear(0), ye(2929), s.setFunc(H), Ee(!1), Ae(a), ye(2884), Te(b);
                const Se = {
                    [T]: 32774,
                    [E]: 32778,
                    [A]: 32779
                };
                if (r) Se[C] = 32775, Se[R] = 32776;
                else {
                    const e = t.get("EXT_blend_minmax");
                    null !== e && (Se[C] = e.MIN_EXT, Se[R] = e.MAX_EXT)
                }
                const Me = {
                    [k]: 0,
                    [P]: 1,
                    [D]: 768,
                    [L]: 770,
                    [j]: 776,
                    [U]: 774,
                    [F]: 772,
                    [O]: 769,
                    [I]: 771,
                    [B]: 775,
                    [N]: 773
                };

                function Te(t, n, r, i, s, o, a, l) {
                    if (t !== b) {
                        if (!1 === Y && (ye(3042), Y = !0), t === M) s = s || n, o = o || r, a = a || i, n === J && s === ee || (e.blendEquationSeparate(Se[n], Se[s]), J = n, ee = s), r === $ && i === Q && o === te && a === ne || (e.blendFuncSeparate(Me[r], Me[i], Me[o], Me[a]), $ = r, Q = i, te = o, ne = a), Z = t, re = null;
                        else if (t !== Z || l !== re) {
                            if (J === T && ee === T || (e.blendEquation(32774), J = T, ee = T), l) switch (t) {
                                case x:
                                    e.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case y:
                                    e.blendFunc(1, 1);
                                    break;
                                case w:
                                    e.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case S:
                                    e.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            } else switch (t) {
                                case x:
                                    e.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case y:
                                    e.blendFunc(770, 1);
                                    break;
                                case w:
                                    e.blendFuncSeparate(0, 769, 0, 1);
                                    break;
                                case S:
                                    e.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                            $ = null, Q = null, te = null, ne = null, Z = t, re = l
                        }
                    } else !0 === Y && (we(3042), Y = !1)
                }

                function Ee(t) {
                    ie !== t && (t ? e.frontFace(2304) : e.frontFace(2305), ie = t)
                }

                function Ae(t) {
                    t !== o ? (ye(2884), t !== se && (t === a ? e.cullFace(1029) : t === l ? e.cullFace(1028) : e.cullFace(1032))) : we(2884), se = t
                }

                function Ce(t, n, r) {
                    t ? (ye(32823), ae === n && le === r || (e.polygonOffset(n, r), ae = n, le = r)) : we(32823)
                }

                function Re(t) {
                    void 0 === t && (t = 33984 + ce - 1), de !== t && (e.activeTexture(t), de = t)
                }
                return {
                    buffers: {
                        color: i,
                        depth: s,
                        stencil: c
                    },
                    enable: ye,
                    disable: we,
                    bindFramebuffer: function(t, n) {
                        return d[t] !== n && (e.bindFramebuffer(t, n), d[t] = n, r && (36009 === t && (d[36160] = n), 36160 === t && (d[36009] = n)), !0)
                    },
                    drawBuffers: function(r, i) {
                        let s = g,
                            o = !1;
                        if (r)
                            if (s = f.get(i), void 0 === s && (s = [], f.set(i, s)), r.isWebGLMultipleRenderTargets) {
                                const e = r.texture;
                                if (s.length !== e.length || 36064 !== s[0]) {
                                    for (let t = 0, n = e.length; t < n; t++) s[t] = 36064 + t;
                                    s.length = e.length, o = !0
                                }
                            } else 36064 !== s[0] && (s[0] = 36064, o = !0);
                        else 1029 !== s[0] && (s[0] = 1029, o = !0);
                        o && (n.isWebGL2 ? e.drawBuffers(s) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
                    },
                    useProgram: function(t) {
                        return v !== t && (e.useProgram(t), v = t, !0)
                    },
                    setBlending: Te,
                    setMaterial: function(e, t) {
                        e.side === m ? we(2884) : ye(2884);
                        let n = e.side === _;
                        t && (n = !n), Ee(n), e.blending === x && !1 === e.transparent ? Te(b) : Te(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), i.setMask(e.colorWrite);
                        const r = e.stencilWrite;
                        c.setTest(r), r && (c.setMask(e.stencilWriteMask), c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), Ce(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? ye(32926) : we(32926)
                    },
                    setFlipSided: Ee,
                    setCullFace: Ae,
                    setLineWidth: function(t) {
                        t !== oe && (ue && e.lineWidth(t), oe = t)
                    },
                    setPolygonOffset: Ce,
                    setScissorTest: function(e) {
                        e ? ye(3089) : we(3089)
                    },
                    activeTexture: Re,
                    bindTexture: function(t, n) {
                        null === de && Re();
                        let r = fe[de];
                        void 0 === r && (r = {
                            type: void 0,
                            texture: void 0
                        }, fe[de] = r), r.type === t && r.texture === n || (e.bindTexture(t, n || xe[t]), r.type = t, r.texture = n)
                    },
                    unbindTexture: function() {
                        const t = fe[de];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    updateUBOMapping: function(t, n) {
                        let r = p.get(n);
                        void 0 === r && (r = new WeakMap, p.set(n, r));
                        let i = r.get(t);
                        void 0 === i && (i = e.getUniformBlockIndex(n, t.name), r.set(t, i))
                    },
                    uniformBlockBinding: function(t, n) {
                        const r = p.get(n).get(t);
                        u.get(t) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex), u.set(t, r))
                    },
                    texStorage2D: function() {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            e.texStorage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            e.texSubImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            e.compressedTexSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(t) {
                        !1 === ge.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), ge.copy(t))
                    },
                    viewport: function(t) {
                        !1 === ve.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), ve.copy(t))
                    },
                    reset: function() {
                        e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === r && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), h = {}, de = null, fe = {}, d = {}, f = new WeakMap, g = [], v = null, Y = !1, Z = null, J = null, $ = null, Q = null, ee = null, te = null, ne = null, re = !1, ie = null, se = null, oe = null, ae = null, le = null, ge.set(0, 0, e.canvas.width, e.canvas.height), ve.set(0, 0, e.canvas.width, e.canvas.height), i.reset(), s.reset(), c.reset()
                    }
                }
            }

            function el(e, t, n, r, i, s, o) {
                const a = i.isWebGL2,
                    l = i.maxTextures,
                    c = i.maxCubemapSize,
                    u = i.maxTextureSize,
                    p = i.maxSamples,
                    h = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
                    d = /OculusBrowser/g.test(navigator.userAgent),
                    f = new WeakMap;
                let _;
                const m = new WeakMap;
                let g = !1;
                try {
                    g = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (e) {}

                function v(e, t) {
                    return g ? new OffscreenCanvas(e, t) : Fn("canvas")
                }

                function b(e, t, n, r) {
                    let i = 1;
                    if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                            const r = t ? Rn : Math.floor,
                                s = r(i * e.width),
                                o = r(i * e.height);
                            void 0 === _ && (_ = v(s, o));
                            const a = n ? v(s, o) : _;
                            return a.width = s, a.height = o, a.getContext("2d").drawImage(e, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + o + ")."), a
                        }
                        return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                    }
                    return e
                }

                function x(e) {
                    return An(e.width) && An(e.height)
                }

                function y(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== de && e.minFilter !== ve
                }

                function w(t) {
                    e.generateMipmap(t)
                }

                function S(n, r, i, s, o = !1) {
                    if (!1 === a) return r;
                    if (null !== n) {
                        if (void 0 !== e[n]) return e[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    let l = r;
                    return 6403 === r && (5126 === i && (l = 33326), 5131 === i && (l = 33325), 5121 === i && (l = 33321)), 33319 === r && (5126 === i && (l = 33328), 5131 === i && (l = 33327), 5121 === i && (l = 33323)), 6408 === r && (5126 === i && (l = 34836), 5131 === i && (l = 34842), 5121 === i && (l = s === Ot && !1 === o ? 35907 : 32856), 32819 === i && (l = 32854), 32820 === i && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || t.get("EXT_color_buffer_float"), l
                }

                function M(e, t, n) {
                    return !0 === y(e, n) || e.isFramebufferTexture && e.minFilter !== de && e.minFilter !== ve ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }

                function T(e) {
                    return e === de || e === fe || e === me ? 9728 : 9729
                }

                function E(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", E),
                        function(e) {
                            const t = r.get(e);
                            if (void 0 === t.__webglInit) return;
                            const n = e.source,
                                i = m.get(n);
                            if (i) {
                                const r = i[t.__cacheKey];
                                r.usedTimes--, 0 === r.usedTimes && C(e), 0 === Object.keys(i).length && m.delete(n)
                            }
                            r.remove(e)
                        }(t), t.isVideoTexture && f.delete(t)
                }

                function A(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", A),
                        function(t) {
                            const n = t.texture,
                                i = r.get(t),
                                s = r.get(n);
                            if (void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), o.memory.textures--), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget)
                                for (let t = 0; t < 6; t++) e.deleteFramebuffer(i.__webglFramebuffer[t]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[t]);
                            else {
                                if (e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer)
                                    for (let t = 0; t < i.__webglColorRenderbuffer.length; t++) i.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);
                                i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer)
                            }
                            if (t.isWebGLMultipleRenderTargets)
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = r.get(n[t]);
                                    i.__webglTexture && (e.deleteTexture(i.__webglTexture), o.memory.textures--), r.remove(n[t])
                                }
                            r.remove(n), r.remove(t)
                        }(n)
                }

                function C(t) {
                    const n = r.get(t);
                    e.deleteTexture(n.__webglTexture);
                    const i = t.source;
                    delete m.get(i)[n.__cacheKey], o.memory.textures--
                }
                let R = 0;

                function k(e, t) {
                    const i = r.get(e);
                    if (e.isVideoTexture && function(e) {
                            const t = o.render.frame;
                            f.get(e) !== t && (f.set(e, t), e.update())
                        }(e), !1 === e.isRenderTargetTexture && e.version > 0 && i.__version !== e.version) {
                        const n = e.image;
                        if (null === n) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                        else {
                            if (!1 !== n.complete) return void I(i, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + t), n.bindTexture(3553, i.__webglTexture)
                }
                const P = {
                        [ue]: 10497,
                        [pe]: 33071,
                        [he]: 33648
                    },
                    D = {
                        [de]: 9728,
                        [fe]: 9984,
                        [me]: 9986,
                        [ve]: 9729,
                        [be]: 9985,
                        [ye]: 9987
                    };

                function O(n, s, o) {
                    if (o ? (e.texParameteri(n, 10242, P[s.wrapS]), e.texParameteri(n, 10243, P[s.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, P[s.wrapR]), e.texParameteri(n, 10240, D[s.magFilter]), e.texParameteri(n, 10241, D[s.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), s.wrapS === pe && s.wrapT === pe || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, T(s.magFilter)), e.texParameteri(n, 10241, T(s.minFilter)), s.minFilter !== de && s.minFilter !== ve && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
                        const o = t.get("EXT_texture_filter_anisotropic");
                        if (s.type === Re && !1 === t.has("OES_texture_float_linear")) return;
                        if (!1 === a && s.type === ke && !1 === t.has("OES_texture_half_float_linear")) return;
                        (s.anisotropy > 1 || r.get(s).__currentAnisotropy) && (e.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, i.getMaxAnisotropy())), r.get(s).__currentAnisotropy = s.anisotropy)
                    }
                }

                function L(t, n) {
                    let r = !1;
                    void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", E));
                    const i = n.source;
                    let s = m.get(i);
                    void 0 === s && (s = {}, m.set(i, s));
                    const a = function(e) {
                        const t = [];
                        return t.push(e.wrapS), t.push(e.wrapT), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.encoding), t.join()
                    }(n);
                    if (a !== t.__cacheKey) {
                        void 0 === s[a] && (s[a] = {
                            texture: e.createTexture(),
                            usedTimes: 0
                        }, o.memory.textures++, r = !0), s[a].usedTimes++;
                        const i = s[t.__cacheKey];
                        void 0 !== i && (s[t.__cacheKey].usedTimes--, 0 === i.usedTimes && C(n)), t.__cacheKey = a, t.__webglTexture = s[a].texture
                    }
                    return r
                }

                function I(t, r, i) {
                    let o = 3553;
                    r.isDataArrayTexture && (o = 35866), r.isData3DTexture && (o = 32879);
                    const l = L(t, r),
                        c = r.source;
                    if (n.activeTexture(33984 + i), n.bindTexture(o, t.__webglTexture), c.version !== c.__currentVersion || !0 === l) {
                        e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);
                        const t = function(e) {
                            return !a && (e.wrapS !== pe || e.wrapT !== pe || e.minFilter !== de && e.minFilter !== ve)
                        }(r) && !1 === x(r.image);
                        let i = b(r.image, t, !1, u);
                        i = z(r, i);
                        const p = x(i) || a,
                            h = s.convert(r.format, r.encoding);
                        let d, f = s.convert(r.type),
                            _ = S(r.internalFormat, h, f, r.encoding, r.isVideoTexture);
                        O(o, r, p);
                        const m = r.mipmaps,
                            g = a && !0 !== r.isVideoTexture,
                            v = void 0 === c.__currentVersion || !0 === l,
                            T = M(r, i, p);
                        if (r.isDepthTexture) _ = 6402, a ? _ = r.type === Re ? 36012 : r.type === Ce ? 33190 : r.type === Oe ? 35056 : 33189 : r.type === Re && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === Be && 6402 === _ && r.type !== Ee && r.type !== Ce && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Ce, f = s.convert(r.type)), r.format === je && 6402 === _ && (_ = 34041, r.type !== Oe && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Oe, f = s.convert(r.type))), v && (g ? n.texStorage2D(3553, 1, _, i.width, i.height) : n.texImage2D(3553, 0, _, i.width, i.height, 0, h, f, null));
                        else if (r.isDataTexture)
                            if (m.length > 0 && p) {
                                g && v && n.texStorage2D(3553, T, _, m[0].width, m[0].height);
                                for (let e = 0, t = m.length; e < t; e++) d = m[e], g ? n.texSubImage2D(3553, e, 0, 0, d.width, d.height, h, f, d.data) : n.texImage2D(3553, e, _, d.width, d.height, 0, h, f, d.data);
                                r.generateMipmaps = !1
                            } else g ? (v && n.texStorage2D(3553, T, _, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, i.width, i.height, h, f, i.data)) : n.texImage2D(3553, 0, _, i.width, i.height, 0, h, f, i.data);
                        else if (r.isCompressedTexture) {
                            g && v && n.texStorage2D(3553, T, _, m[0].width, m[0].height);
                            for (let e = 0, t = m.length; e < t; e++) d = m[e], r.format !== Fe ? null !== h ? g ? n.compressedTexSubImage2D(3553, e, 0, 0, d.width, d.height, h, d.data) : n.compressedTexImage2D(3553, e, _, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : g ? n.texSubImage2D(3553, e, 0, 0, d.width, d.height, h, f, d.data) : n.texImage2D(3553, e, _, d.width, d.height, 0, h, f, d.data)
                        } else if (r.isDataArrayTexture) g ? (v && n.texStorage3D(35866, T, _, i.width, i.height, i.depth), n.texSubImage3D(35866, 0, 0, 0, 0, i.width, i.height, i.depth, h, f, i.data)) : n.texImage3D(35866, 0, _, i.width, i.height, i.depth, 0, h, f, i.data);
                        else if (r.isData3DTexture) g ? (v && n.texStorage3D(32879, T, _, i.width, i.height, i.depth), n.texSubImage3D(32879, 0, 0, 0, 0, i.width, i.height, i.depth, h, f, i.data)) : n.texImage3D(32879, 0, _, i.width, i.height, i.depth, 0, h, f, i.data);
                        else if (r.isFramebufferTexture) {
                            if (v)
                                if (g) n.texStorage2D(3553, T, _, i.width, i.height);
                                else {
                                    let e = i.width,
                                        t = i.height;
                                    for (let r = 0; r < T; r++) n.texImage2D(3553, r, _, e, t, 0, h, f, null), e >>= 1, t >>= 1
                                }
                        } else if (m.length > 0 && p) {
                            g && v && n.texStorage2D(3553, T, _, m[0].width, m[0].height);
                            for (let e = 0, t = m.length; e < t; e++) d = m[e], g ? n.texSubImage2D(3553, e, 0, 0, h, f, d) : n.texImage2D(3553, e, _, h, f, d);
                            r.generateMipmaps = !1
                        } else g ? (v && n.texStorage2D(3553, T, _, i.width, i.height), n.texSubImage2D(3553, 0, 0, 0, h, f, i)) : n.texImage2D(3553, 0, _, h, f, i);
                        y(r, p) && w(o), c.__currentVersion = c.version, r.onUpdate && r.onUpdate(r)
                    }
                    t.__version = r.version
                }

                function F(t, i, o, a, l) {
                    const c = s.convert(o.format, o.encoding),
                        u = s.convert(o.type),
                        p = S(o.internalFormat, c, u, o.encoding);
                    r.get(i).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, p, i.width, i.height, i.depth, 0, c, u, null) : n.texImage2D(l, 0, p, i.width, i.height, 0, c, u, null)), n.bindFramebuffer(36160, t), j(i) ? h.framebufferTexture2DMultisampleEXT(36160, a, l, r.get(o).__webglTexture, 0, B(i)) : e.framebufferTexture2D(36160, a, l, r.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null)
                }

                function N(t, n, r) {
                    if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                        let i = 33189;
                        if (r || j(n)) {
                            const t = n.depthTexture;
                            t && t.isDepthTexture && (t.type === Re ? i = 36012 : t.type === Ce && (i = 33190));
                            const r = B(n);
                            j(n) ? h.renderbufferStorageMultisampleEXT(36161, r, i, n.width, n.height) : e.renderbufferStorageMultisample(36161, r, i, n.width, n.height)
                        } else e.renderbufferStorage(36161, i, n.width, n.height);
                        e.framebufferRenderbuffer(36160, 36096, 36161, t)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        const i = B(n);
                        r && !1 === j(n) ? e.renderbufferStorageMultisample(36161, i, 35056, n.width, n.height) : j(n) ? h.renderbufferStorageMultisampleEXT(36161, i, 35056, n.width, n.height) : e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)
                    } else {
                        const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                        for (let i = 0; i < t.length; i++) {
                            const o = t[i],
                                a = s.convert(o.format, o.encoding),
                                l = s.convert(o.type),
                                c = S(o.internalFormat, a, l, o.encoding),
                                u = B(n);
                            r && !1 === j(n) ? e.renderbufferStorageMultisample(36161, u, c, n.width, n.height) : j(n) ? h.renderbufferStorageMultisampleEXT(36161, u, c, n.width, n.height) : e.renderbufferStorage(36161, c, n.width, n.height)
                        }
                    }
                    e.bindRenderbuffer(36161, null)
                }

                function U(t) {
                    const i = r.get(t),
                        s = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
                        if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(t, i) {
                            if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (n.bindFramebuffer(36160, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), k(i.depthTexture, 0);
                            const s = r.get(i.depthTexture).__webglTexture,
                                o = B(i);
                            if (i.depthTexture.format === Be) j(i) ? h.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, o) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
                            else {
                                if (i.depthTexture.format !== je) throw new Error("Unknown depthTexture format");
                                j(i) ? h.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, o) : e.framebufferTexture2D(36160, 33306, 3553, s, 0)
                            }
                        }(i.__webglFramebuffer, t)
                    } else if (s) {
                        i.__webglDepthbuffer = [];
                        for (let r = 0; r < 6; r++) n.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = e.createRenderbuffer(), N(i.__webglDepthbuffer[r], t, !1)
                    } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), N(i.__webglDepthbuffer, t, !1);
                    n.bindFramebuffer(36160, null)
                }

                function B(e) {
                    return Math.min(p, e.samples)
                }

                function j(e) {
                    const n = r.get(e);
                    return a && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
                }

                function z(e, n) {
                    const r = e.encoding,
                        i = e.format,
                        s = e.type;
                    return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === gn || r !== Dt && (r === Ot ? !1 === a ? !0 === t.has("EXT_sRGB") && i === Fe ? (e.format = gn, e.minFilter = ve, e.generateMipmaps = !1) : n = Yn.sRGBToLinear(n) : i === Fe && s === Se || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : r === RGBM16Encoding || console.error("THREE.WebGLTextures: Unsupported texture encoding:", r)), n
                }
                this.allocateTextureUnit = function() {
                    const e = R;
                    return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), R += 1, e
                }, this.resetTextureUnits = function() {
                    R = 0
                }, this.setTexture2D = k, this.setTexture2DArray = function(e, t) {
                    const i = r.get(e);
                    e.version > 0 && i.__version !== e.version ? I(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, i.__webglTexture))
                }, this.setTexture3D = function(e, t) {
                    const i = r.get(e);
                    e.version > 0 && i.__version !== e.version ? I(i, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, i.__webglTexture))
                }, this.setTextureCube = function(t, i) {
                    const o = r.get(t);
                    t.version > 0 && o.__version !== t.version ? function(t, r, i) {
                        if (6 !== r.image.length) return;
                        const o = L(t, r),
                            l = r.source;
                        if (n.activeTexture(33984 + i), n.bindTexture(34067, t.__webglTexture), l.version !== l.__currentVersion || !0 === o) {
                            e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0);
                            const t = r.isCompressedTexture || r.image[0].isCompressedTexture,
                                i = r.image[0] && r.image[0].isDataTexture,
                                u = [];
                            for (let e = 0; e < 6; e++) u[e] = t || i ? i ? r.image[e].image : r.image[e] : b(r.image[e], !1, !0, c), u[e] = z(r, u[e]);
                            const p = u[0],
                                h = x(p) || a,
                                d = s.convert(r.format, r.encoding),
                                f = s.convert(r.type),
                                _ = S(r.internalFormat, d, f, r.encoding),
                                m = a && !0 !== r.isVideoTexture,
                                g = void 0 === l.__currentVersion || !0 === o;
                            let v, T = M(r, p, h);
                            if (O(34067, r, h), t) {
                                m && g && n.texStorage2D(34067, T, _, p.width, p.height);
                                for (let e = 0; e < 6; e++) {
                                    v = u[e].mipmaps;
                                    for (let t = 0; t < v.length; t++) {
                                        const i = v[t];
                                        r.format !== Fe ? null !== d ? m ? n.compressedTexSubImage2D(34069 + e, t, 0, 0, i.width, i.height, d, i.data) : n.compressedTexImage2D(34069 + e, t, _, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : m ? n.texSubImage2D(34069 + e, t, 0, 0, i.width, i.height, d, f, i.data) : n.texImage2D(34069 + e, t, _, i.width, i.height, 0, d, f, i.data)
                                    }
                                }
                            } else {
                                v = r.mipmaps, m && g && (v.length > 0 && T++, n.texStorage2D(34067, T, _, u[0].width, u[0].height));
                                for (let e = 0; e < 6; e++)
                                    if (i) {
                                        m ? n.texSubImage2D(34069 + e, 0, 0, 0, u[e].width, u[e].height, d, f, u[e].data) : n.texImage2D(34069 + e, 0, _, u[e].width, u[e].height, 0, d, f, u[e].data);
                                        for (let t = 0; t < v.length; t++) {
                                            const r = v[t].image[e].image;
                                            m ? n.texSubImage2D(34069 + e, t + 1, 0, 0, r.width, r.height, d, f, r.data) : n.texImage2D(34069 + e, t + 1, _, r.width, r.height, 0, d, f, r.data)
                                        }
                                    } else {
                                        m ? n.texSubImage2D(34069 + e, 0, 0, 0, d, f, u[e]) : n.texImage2D(34069 + e, 0, _, d, f, u[e]);
                                        for (let t = 0; t < v.length; t++) {
                                            const r = v[t];
                                            m ? n.texSubImage2D(34069 + e, t + 1, 0, 0, d, f, r.image[e]) : n.texImage2D(34069 + e, t + 1, _, d, f, r.image[e])
                                        }
                                    }
                            }
                            y(r, h) && w(34067), l.__currentVersion = l.version, r.onUpdate && r.onUpdate(r)
                        }
                        t.__version = r.version
                    }(o, t, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture))
                }, this.rebindTextures = function(e, t, n) {
                    const i = r.get(e);
                    void 0 !== t && F(i.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== n && U(e)
                }, this.setupRenderTarget = function(t) {
                    const l = t.texture,
                        c = r.get(t),
                        u = r.get(l);
                    t.addEventListener("dispose", A), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = l.version, o.memory.textures++);
                    const p = !0 === t.isWebGLCubeRenderTarget,
                        h = !0 === t.isWebGLMultipleRenderTargets,
                        d = x(t) || a;
                    if (p) {
                        c.__webglFramebuffer = [];
                        for (let t = 0; t < 6; t++) c.__webglFramebuffer[t] = e.createFramebuffer()
                    } else {
                        if (c.__webglFramebuffer = e.createFramebuffer(), h)
                            if (i.drawBuffers) {
                                const n = t.texture;
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = r.get(n[t]);
                                    void 0 === i.__webglTexture && (i.__webglTexture = e.createTexture(), o.memory.textures++)
                                }
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                        if (a && t.samples > 0 && !1 === j(t)) {
                            const r = h ? l : [l];
                            c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer);
                            for (let n = 0; n < r.length; n++) {
                                const i = r[n];
                                c.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer[n]);
                                const o = s.convert(i.format, i.encoding),
                                    a = s.convert(i.type),
                                    l = S(i.internalFormat, o, a, i.encoding),
                                    u = B(t);
                                e.renderbufferStorageMultisample(36161, u, l, t.width, t.height), e.framebufferRenderbuffer(36160, 36064 + n, 36161, c.__webglColorRenderbuffer[n])
                            }
                            e.bindRenderbuffer(36161, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), N(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null)
                        }
                    }
                    if (p) {
                        n.bindTexture(34067, u.__webglTexture), O(34067, l, d);
                        for (let e = 0; e < 6; e++) F(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
                        y(l, d) && w(34067), n.unbindTexture()
                    } else if (h) {
                        const e = t.texture;
                        for (let i = 0, s = e.length; i < s; i++) {
                            const s = e[i],
                                o = r.get(s);
                            n.bindTexture(3553, o.__webglTexture), O(3553, s, d), F(c.__webglFramebuffer, t, s, 36064 + i, 3553), y(s, d) && w(3553)
                        }
                        n.unbindTexture()
                    } else {
                        let e = 3553;
                        (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (a ? e = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(e, u.__webglTexture), O(e, l, d), F(c.__webglFramebuffer, t, l, 36064, e), y(l, d) && w(e), n.unbindTexture()
                    }
                    t.depthBuffer && U(t)
                }, this.updateRenderTargetMipmap = function(e) {
                    const t = x(e) || a,
                        i = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                    for (let s = 0, o = i.length; s < o; s++) {
                        const o = i[s];
                        if (y(o, t)) {
                            const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                                i = r.get(o).__webglTexture;
                            n.bindTexture(t, i), w(t), n.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function(t) {
                    if (a && t.samples > 0 && !1 === j(t)) {
                        const i = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
                            s = t.width,
                            o = t.height;
                        let a = 16384;
                        const l = [],
                            c = t.stencilBuffer ? 33306 : 36096,
                            u = r.get(t),
                            p = !0 === t.isWebGLMultipleRenderTargets;
                        if (p)
                            for (let t = 0; t < i.length; t++) n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t, 36161, null), n.bindFramebuffer(36160, u.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t, 3553, null, 0);
                        n.bindFramebuffer(36008, u.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, u.__webglFramebuffer);
                        for (let n = 0; n < i.length; n++) {
                            l.push(36064 + n), t.depthBuffer && l.push(c);
                            const h = void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                            if (!1 === h && (t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024)), p && e.framebufferRenderbuffer(36008, 36064, 36161, u.__webglColorRenderbuffer[n]), !0 === h && (e.invalidateFramebuffer(36008, [c]), e.invalidateFramebuffer(36009, [c])), p) {
                                const t = r.get(i[n]).__webglTexture;
                                e.framebufferTexture2D(36009, 36064, 3553, t, 0)
                            }
                            e.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, 9728), d && e.invalidateFramebuffer(36008, l)
                        }
                        if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), p)
                            for (let t = 0; t < i.length; t++) {
                                n.bindFramebuffer(36160, u.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064 + t, 36161, u.__webglColorRenderbuffer[t]);
                                const s = r.get(i[t]).__webglTexture;
                                n.bindFramebuffer(36160, u.__webglFramebuffer), e.framebufferTexture2D(36009, 36064 + t, 3553, s, 0)
                            }
                        n.bindFramebuffer(36009, u.__webglMultisampledFramebuffer)
                    }
                }, this.setupDepthRenderbuffer = U, this.setupFrameBufferTexture = F, this.useMultisampledRTT = j
            }

            function tl(e, t, n) {
                const r = n.isWebGL2;
                return {
                    convert: function(n, i = null) {
                        let s;
                        if (n === Se) return 5121;
                        if (n === Pe) return 32819;
                        if (n === De) return 32820;
                        if (n === Me) return 5120;
                        if (n === Te) return 5122;
                        if (n === Ee) return 5123;
                        if (n === Ae) return 5124;
                        if (n === Ce) return 5125;
                        if (n === Re) return 5126;
                        if (n === ke) return r ? 5131 : (s = t.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
                        if (n === Le) return 6406;
                        if (n === Fe) return 6408;
                        if (n === Ne) return 6409;
                        if (n === Ue) return 6410;
                        if (n === Be) return 6402;
                        if (n === je) return 34041;
                        if (n === ze) return 6403;
                        if (n === Ie) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
                        if (n === gn) return s = t.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
                        if (n === Ve) return 36244;
                        if (n === Ge) return 33319;
                        if (n === He) return 33320;
                        if (n === We) return 36249;
                        if (n === Ke || n === Xe || n === qe || n === Ye)
                            if (i === Ot) {
                                if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
                                if (n === Ke) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (n === Xe) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (n === qe) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (n === Ye) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (s = t.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
                                if (n === Ke) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (n === Xe) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (n === qe) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (n === Ye) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                        if (n === Ze || n === Je || n === $e || n === Qe) {
                            if (s = t.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
                            if (n === Ze) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (n === Je) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (n === $e) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (n === Qe) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (n === et) return s = t.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if (n === tt || n === nt) {
                            if (s = t.get("WEBGL_compressed_texture_etc"), null === s) return null;
                            if (n === tt) return i === Ot ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                            if (n === nt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (n === rt || n === it || n === st || n === ot || n === at || n === lt || n === ct || n === ut || n === pt || n === ht || n === dt || n === ft || n === _t || n === mt) {
                            if (s = t.get("WEBGL_compressed_texture_astc"), null === s) return null;
                            if (n === rt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (n === it) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (n === st) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (n === ot) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (n === at) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (n === lt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (n === ct) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (n === ut) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (n === pt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (n === ht) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (n === dt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (n === ft) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (n === _t) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (n === mt) return i === Ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (n === gt) {
                            if (s = t.get("EXT_texture_compression_bptc"), null === s) return null;
                            if (n === gt) return i === Ot ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
                        }
                        return n === Oe ? r ? 34042 : (s = t.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n] ? e[n] : null
                    }
                }
            }
            class nl extends gs {
                constructor(e = []) {
                    super(), this.isArrayCamera = !0, this.cameras = e
                }
            }
            class rl extends ui {
                constructor() {
                    super(), this.isGroup = !0, this.type = "Group"
                }
            }
            const il = {
                type: "move"
            };
            class sl {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new rl, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new rl, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new lr, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new lr), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new rl, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new lr, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new lr), this._grip
                }
                dispatchEvent(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                }
                disconnect(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                }
                update(e, t, n) {
                    let r = null,
                        i = null,
                        s = null;
                    const o = this._targetRay,
                        a = this._grip,
                        l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState) {
                        if (l && e.hand) {
                            s = !0;
                            for (const r of e.hand.values()) {
                                const e = t.getJointPose(r, n);
                                if (void 0 === l.joints[r.jointName]) {
                                    const e = new rl;
                                    e.matrixAutoUpdate = !1, e.visible = !1, l.joints[r.jointName] = e, l.add(e)
                                }
                                const i = l.joints[r.jointName];
                                null !== e && (i.matrix.fromArray(e.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = e.radius), i.visible = null !== e
                            }
                            const r = l.joints["index-finger-tip"],
                                i = l.joints["thumb-tip"],
                                o = r.position.distanceTo(i.position),
                                a = .02,
                                c = .005;
                            l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: e.handedness,
                                target: this
                            })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: e.handedness,
                                target: this
                            }))
                        } else null !== a && e.gripSpace && (i = t.getPose(e.gripSpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1));
                        null !== o && (r = t.getPose(e.targetRaySpace, n), null === r && null !== i && (r = i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(il)))
                    }
                    return null !== o && (o.visible = null !== r), null !== a && (a.visible = null !== i), null !== l && (l.visible = null !== s), this
                }
            }
            class ol extends Qn {
                constructor(e, t, n, r, i, s, o, a, l, c) {
                    if ((c = void 0 !== c ? c : Be) !== Be && c !== je) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === n && c === Be && (n = Ce), void 0 === n && c === je && (n = Oe), super(null, r, i, s, o, a, c, n, l), this.isDepthTexture = !0, this.image = {
                        width: e,
                        height: t
                    }, this.magFilter = void 0 !== o ? o : de, this.minFilter = void 0 !== a ? a : de, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            class al extends vn {
                constructor(e, t) {
                    super();
                    const n = this;
                    let r = null,
                        i = 1,
                        s = null,
                        o = "local-floor",
                        a = null,
                        l = null,
                        c = null,
                        u = null,
                        p = null,
                        h = null;
                    const d = t.getContextAttributes();
                    let f = null,
                        _ = null;
                    const m = [],
                        g = [],
                        v = new gs;
                    v.layers.enable(1), v.viewport = new er;
                    const b = new gs;
                    b.layers.enable(2), b.viewport = new er;
                    const x = [v, b],
                        y = new nl;
                    y.layers.enable(1), y.layers.enable(2);
                    let w = null,
                        S = null;

                    function M(e) {
                        const t = g.indexOf(e.inputSource);
                        if (-1 === t) return;
                        const n = m[t];
                        void 0 !== n && n.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        })
                    }

                    function T() {
                        r.removeEventListener("select", M), r.removeEventListener("selectstart", M), r.removeEventListener("selectend", M), r.removeEventListener("squeeze", M), r.removeEventListener("squeezestart", M), r.removeEventListener("squeezeend", M), r.removeEventListener("end", T), r.removeEventListener("inputsourceschange", E);
                        for (let e = 0; e < m.length; e++) {
                            const t = g[e];
                            null !== t && (g[e] = null, m[e].disconnect(t))
                        }
                        w = null, S = null, e.setRenderTarget(f), p = null, u = null, c = null, r = null, _ = null, P.stop(), n.isPresenting = !1, n.dispatchEvent({
                            type: "sessionend"
                        })
                    }

                    function E(e) {
                        for (let t = 0; t < e.removed.length; t++) {
                            const n = e.removed[t],
                                r = g.indexOf(n);
                            r >= 0 && (g[r] = null, m[r].dispatchEvent({
                                type: "disconnected",
                                data: n
                            }))
                        }
                        for (let t = 0; t < e.added.length; t++) {
                            const n = e.added[t];
                            let r = g.indexOf(n);
                            if (-1 === r) {
                                for (let e = 0; e < m.length; e++) {
                                    if (e >= g.length) {
                                        g.push(n), r = e;
                                        break
                                    }
                                    if (null === g[e]) {
                                        g[e] = n, r = e;
                                        break
                                    }
                                }
                                if (-1 === r) break
                            }
                            const i = m[r];
                            i && i.dispatchEvent({
                                type: "connected",
                                data: n
                            })
                        }
                    }
                    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                        let t = m[e];
                        return void 0 === t && (t = new sl, m[e] = t), t.getTargetRaySpace()
                    }, this.getControllerGrip = function(e) {
                        let t = m[e];
                        return void 0 === t && (t = new sl, m[e] = t), t.getGripSpace()
                    }, this.getHand = function(e) {
                        let t = m[e];
                        return void 0 === t && (t = new sl, m[e] = t), t.getHandSpace()
                    }, this.setFramebufferScaleFactor = function(e) {
                        i = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }, this.setReferenceSpaceType = function(e) {
                        o = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }, this.getReferenceSpace = function() {
                        return a || s
                    }, this.setReferenceSpace = function(e) {
                        a = e
                    }, this.getBaseLayer = function() {
                        return null !== u ? u : p
                    }, this.getBinding = function() {
                        return c
                    }, this.getFrame = function() {
                        return h
                    }, this.getSession = function() {
                        return r
                    }, this.setSession = async function(l) {
                        if (r = l, null !== r) {
                            if (f = e.getRenderTarget(), r.addEventListener("select", M), r.addEventListener("selectstart", M), r.addEventListener("selectend", M), r.addEventListener("squeeze", M), r.addEventListener("squeezestart", M), r.addEventListener("squeezeend", M), r.addEventListener("end", T), r.addEventListener("inputsourceschange", E), !0 !== d.xrCompatible && await t.makeXRCompatible(), void 0 === r.renderState.layers || !1 === e.capabilities.isWebGL2) {
                                const n = {
                                    antialias: void 0 !== r.renderState.layers || d.antialias,
                                    alpha: d.alpha,
                                    depth: d.depth,
                                    stencil: d.stencil,
                                    framebufferScaleFactor: i
                                };
                                p = new XRWebGLLayer(r, t, n), r.updateRenderState({
                                    baseLayer: p
                                }), _ = new tr(p.framebufferWidth, p.framebufferHeight, {
                                    format: Fe,
                                    type: Se,
                                    encoding: e.outputEncoding
                                })
                            } else {
                                let n = null,
                                    s = null,
                                    o = null;
                                d.depth && (o = d.stencil ? 35056 : 33190, n = d.stencil ? je : Be, s = d.stencil ? Oe : Ce);
                                const a = {
                                    colorFormat: 32856,
                                    depthFormat: o,
                                    scaleFactor: i
                                };
                                c = new XRWebGLBinding(r, t), u = c.createProjectionLayer(a), r.updateRenderState({
                                    layers: [u]
                                }), _ = new tr(u.textureWidth, u.textureHeight, {
                                    format: Fe,
                                    type: Se,
                                    depthTexture: new ol(u.textureWidth, u.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                    stencilBuffer: d.stencil,
                                    encoding: e.outputEncoding,
                                    samples: d.antialias ? 4 : 0
                                }), e.properties.get(_).__ignoreDepthValues = u.ignoreDepthValues
                            }
                            _.isXRRenderTarget = !0, this.setFoveation(1), a = null, s = await r.requestReferenceSpace(o), P.setContext(r), P.start(), n.isPresenting = !0, n.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    };
                    const A = new lr,
                        C = new lr;

                    function R(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.updateCamera = function(e) {
                        if (null === r) return;
                        y.near = b.near = v.near = e.near, y.far = b.far = v.far = e.far, w === y.near && S === y.far || (r.updateRenderState({
                            depthNear: y.near,
                            depthFar: y.far
                        }), w = y.near, S = y.far);
                        const t = e.parent,
                            n = y.cameras;
                        R(y, t);
                        for (let e = 0; e < n.length; e++) R(n[e], t);
                        y.matrixWorld.decompose(y.position, y.quaternion, y.scale), e.position.copy(y.position), e.quaternion.copy(y.quaternion), e.scale.copy(y.scale), e.matrix.copy(y.matrix), e.matrixWorld.copy(y.matrixWorld);
                        const i = e.children;
                        for (let e = 0, t = i.length; e < t; e++) i[e].updateMatrixWorld(!0);
                        2 === n.length ? function(e, t, n) {
                            A.setFromMatrixPosition(t.matrixWorld), C.setFromMatrixPosition(n.matrixWorld);
                            const r = A.distanceTo(C),
                                i = t.projectionMatrix.elements,
                                s = n.projectionMatrix.elements,
                                o = i[14] / (i[10] - 1),
                                a = i[14] / (i[10] + 1),
                                l = (i[9] + 1) / i[5],
                                c = (i[9] - 1) / i[5],
                                u = (i[8] - 1) / i[0],
                                p = (s[8] + 1) / s[0],
                                h = o * u,
                                d = o * p,
                                f = r / (-u + p),
                                _ = f * -u;
                            t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(_), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                            const m = o + f,
                                g = a + f,
                                v = h - _,
                                b = d + (r - _),
                                x = l * a / g * m,
                                y = c * a / g * m;
                            e.projectionMatrix.makePerspective(v, b, x, y, m, g)
                        }(y, v, b) : y.projectionMatrix.copy(v.projectionMatrix)
                    }, this.getCamera = function() {
                        return y
                    }, this.getFoveation = function() {
                        return null !== u ? u.fixedFoveation : null !== p ? p.fixedFoveation : void 0
                    }, this.setFoveation = function(e) {
                        null !== u && (u.fixedFoveation = e), null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = e)
                    };
                    let k = null;
                    this.onPreAnimationFrameCallback = null;
                    const P = new Rs;
                    P.setAnimationLoop((function(t, r) {
                        if (n.onPreAnimationFrameCallback && n.onPreAnimationFrameCallback(t, r), l = r.getViewerPose(a || s), h = r, null !== l) {
                            const t = l.views;
                            null !== p && (e.setRenderTargetFramebuffer(_, p.framebuffer), e.setRenderTarget(_));
                            let n = !1;
                            t.length !== y.cameras.length && (y.cameras.length = 0, n = !0);
                            for (let r = 0; r < t.length; r++) {
                                const i = t[r];
                                let s = null;
                                if (null !== p) s = p.getViewport(i);
                                else {
                                    const t = c.getViewSubImage(u, i);
                                    s = t.viewport, 0 === r && (e.setRenderTargetTextures(_, t.colorTexture, u.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(_))
                                }
                                let o = x[r];
                                void 0 === o && (o = new gs, o.layers.enable(r), o.viewport = new er, x[r] = o), o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === r && y.matrix.copy(o.matrix), !0 === n && y.cameras.push(o)
                            }
                        }
                        for (let e = 0; e < m.length; e++) {
                            const t = g[e],
                                n = m[e];
                            null !== t && void 0 !== n && n.update(t, r, a || s)
                        }
                        k && k(t, r), h = null
                    })), this.setAnimationLoop = function(e) {
                        k = e
                    }, this.dispose = function() {}
                }
            }

            function ll(e, t) {
                function n(n, r) {
                    n.opacity.value = r.opacity, r.color && n.diffuse.value.copy(r.color), r.emissive && n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (n.map.value = r.map), r.alphaMap && (n.alphaMap.value = r.alphaMap), r.bumpMap && (n.bumpMap.value = r.bumpMap, n.bumpScale.value = r.bumpScale, r.side === _ && (n.bumpScale.value *= -1)), r.displacementMap && (n.displacementMap.value = r.displacementMap, n.displacementScale.value = r.displacementScale, n.displacementBias.value = r.displacementBias), r.emissiveMap && (n.emissiveMap.value = r.emissiveMap), r.normalMap && (n.normalMap.value = r.normalMap, n.normalScale.value.copy(r.normalScale), r.side === _ && n.normalScale.value.negate()), r.specularMap && (n.specularMap.value = r.specularMap), r.alphaTest > 0 && (n.alphaTest.value = r.alphaTest);
                    const i = t.get(r).envMap;
                    if (i) {
                        n.envMap.value = i;
                        const e = t.get(r).environment || i;
                        n.envMapRotation.value = e ? e.rotation : 0, n.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, n.reflectivity.value = r.reflectivity, n.ior.value = r.ior, n.refractionRatio.value = r.refractionRatio
                    }
                    if (r.lightMap) {
                        n.lightMap.value = r.lightMap;
                        const t = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
                        n.lightMapIntensity.value = r.lightMapIntensity * t
                    }
                    let s, o;
                    r.aoMap && (n.aoMap.value = r.aoMap, n.aoMapIntensity.value = r.aoMapIntensity), r.map ? s = r.map : r.specularMap ? s = r.specularMap : r.displacementMap ? s = r.displacementMap : r.normalMap ? s = r.normalMap : r.bumpMap ? s = r.bumpMap : r.roughnessMap ? s = r.roughnessMap : r.metalnessMap ? s = r.metalnessMap : r.alphaMap ? s = r.alphaMap : r.emissiveMap ? s = r.emissiveMap : r.clearcoatMap ? s = r.clearcoatMap : r.clearcoatNormalMap ? s = r.clearcoatNormalMap : r.clearcoatRoughnessMap ? s = r.clearcoatRoughnessMap : r.iridescenceMap ? s = r.iridescenceMap : r.iridescenceThicknessMap ? s = r.iridescenceThicknessMap : r.specularIntensityMap ? s = r.specularIntensityMap : r.specularColorMap ? s = r.specularColorMap : r.transmissionMap ? s = r.transmissionMap : r.thicknessMap ? s = r.thicknessMap : r.sheenColorMap ? s = r.sheenColorMap : r.sheenRoughnessMap && (s = r.sheenRoughnessMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), n.uvTransform.value.copy(s.matrix)), r.aoMap ? o = r.aoMap : r.lightMap && (o = r.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), n.uv2Transform.value.copy(o.matrix))
                }
                return {
                    refreshFogUniforms: function(e, t) {
                        e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                    },
                    refreshMaterialUniforms: function(e, r, i, s, o) {
                        r.isMeshBasicMaterial || r.isMeshLambertMaterial ? n(e, r) : r.isMeshToonMaterial ? (n(e, r), function(e, t) {
                            t.gradientMap && (e.gradientMap.value = t.gradientMap)
                        }(e, r)) : r.isMeshPhongMaterial ? (n(e, r), function(e, t) {
                            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4)
                        }(e, r)) : r.isMeshStandardMaterial ? (n(e, r), function(e, n) {
                            e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                        }(e, r), r.isMeshPhysicalMaterial && function(e, t, n) {
                            e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap)), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === _ && e.clearcoatNormalScale.value.negate())), t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap)), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = n.texture, e.transmissionSamplerSize.value.set(n.width, n.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)), e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap)
                        }(e, r, o)) : r.isMeshMatcapMaterial ? (n(e, r), function(e, t) {
                            t.matcap && (e.matcap.value = t.matcap)
                        }(e, r)) : r.isMeshDepthMaterial ? n(e, r) : r.isMeshDistanceMaterial ? (n(e, r), function(e, t) {
                            e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                        }(e, r)) : r.isMeshNormalMaterial ? n(e, r) : r.isLineBasicMaterial ? (function(e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
                        }(e, r), r.isLineDashedMaterial && function(e, t) {
                            e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                        }(e, r)) : r.isPointsMaterial ? function(e, t, n, r) {
                            let i;
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * r, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? i = t.map : t.alphaMap && (i = t.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix))
                        }(e, r, i, s) : r.isSpriteMaterial ? function(e, t) {
                            let n;
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                        }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (void 0 !== r.transmission && (e.transmission && (e.transmission.value = r.transmission), e.transmissionSamplerMap && o && (e.transmissionSamplerMap.value = o ? o.texture : null), e.transmissionSamplerSize && o && e.transmissionSamplerSize.value.set(o.width, o.height)), r.uniformsNeedUpdate = !1)
                    }
                }
            }

            function cl(e, t, n, r) {
                let i = {},
                    s = {},
                    o = [];
                const a = n.isWebGL2 ? e.getParameter(35375) : 0;

                function l(e, t, n) {
                    const r = e.value;
                    if (void 0 === n[t]) return n[t] = "number" == typeof r ? r : r.clone(), !0;
                    if ("number" == typeof r) {
                        if (n[t] !== r) return n[t] = r, !0
                    } else {
                        const e = n[t];
                        if (!1 === e.equals(r)) return e.copy(r), !0
                    }
                    return !1
                }

                function c(e) {
                    const t = e.value,
                        n = {
                            boundary: 0,
                            storage: 0
                        };
                    return "number" == typeof t ? (n.boundary = 4, n.storage = 4) : t.isVector2 ? (n.boundary = 8, n.storage = 8) : t.isVector3 || t.isColor ? (n.boundary = 16, n.storage = 12) : t.isVector4 ? (n.boundary = 16, n.storage = 16) : t.isMatrix3 ? (n.boundary = 48, n.storage = 48) : t.isMatrix4 ? (n.boundary = 64, n.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), n
                }

                function u(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", u);
                    const r = o.indexOf(n.__bindingPointIndex);
                    o.splice(r, 1), e.deleteBuffer(i[n.id]), delete i[n.id], delete s[n.id]
                }
                return {
                    bind: function(e, t) {
                        const n = t.program;
                        r.uniformBlockBinding(e, n)
                    },
                    update: function(n, p) {
                        let h = i[n.id];
                        void 0 === h && (function(e) {
                            const t = e.uniforms;
                            let n = 0;
                            let r = 0;
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e],
                                    s = c(i);
                                if (i.__data = new Float32Array(s.storage / Float32Array.BYTES_PER_ELEMENT), i.__offset = n, e > 0) {
                                    r = n % 16;
                                    const e = 16 - r;
                                    0 !== r && e - s.boundary < 0 && (n += 16 - r, i.__offset = n)
                                }
                                n += s.storage
                            }
                            r = n % 16, r > 0 && (n += 16 - r), e.__size = n, e.__cache = {}
                        }(n), h = function(t) {
                            const n = function() {
                                for (let e = 0; e < a; e++)
                                    if (-1 === o.indexOf(e)) return o.push(e), e;
                                return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                            }();
                            t.__bindingPointIndex = n;
                            const r = e.createBuffer(),
                                i = t.__size,
                                s = t.usage;
                            return e.bindBuffer(35345, r), e.bufferData(35345, i, s), e.bindBuffer(35345, null), e.bindBufferBase(35345, n, r), r
                        }(n), i[n.id] = h, n.addEventListener("dispose", u));
                        const d = p.program;
                        r.updateUBOMapping(n, d);
                        const f = t.render.frame;
                        s[n.id] !== f && (function(t) {
                            const n = i[t.id],
                                r = t.uniforms,
                                s = t.__cache;
                            e.bindBuffer(35345, n);
                            for (let t = 0, n = r.length; t < n; t++) {
                                const n = r[t];
                                if (!0 === l(n, t, s)) {
                                    const t = n.value,
                                        r = n.__offset;
                                    "number" == typeof t ? (n.__data[0] = t, e.bufferSubData(35345, r, n.__data)) : (n.value.isMatrix3 ? (n.__data[0] = n.value.elements[0], n.__data[1] = n.value.elements[1], n.__data[2] = n.value.elements[2], n.__data[3] = n.value.elements[0], n.__data[4] = n.value.elements[3], n.__data[5] = n.value.elements[4], n.__data[6] = n.value.elements[5], n.__data[7] = n.value.elements[0], n.__data[8] = n.value.elements[6], n.__data[9] = n.value.elements[7], n.__data[10] = n.value.elements[8], n.__data[11] = n.value.elements[0]) : t.toArray(n.__data), e.bufferSubData(35345, r, n.__data))
                                }
                            }
                            e.bindBuffer(35345, null)
                        }(n), s[n.id] = f)
                    },
                    dispose: function() {
                        for (const t in i) e.deleteBuffer(i[t]);
                        o = [], i = {}, s = {}
                    }
                }
            }

            function ul(e = {}) {
                this.isWebGLRenderer = !0;
                const t = void 0 !== e.canvas ? e.canvas : function() {
                        const e = Fn("canvas");
                        return e.style.display = "block", e
                    }(),
                    n = void 0 !== e.context ? e.context : null,
                    i = void 0 === e.depth || e.depth,
                    s = void 0 === e.stencil || e.stencil,
                    o = void 0 !== e.antialias && e.antialias,
                    a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    c = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
                let p;
                p = null !== n ? n.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
                let h = null,
                    d = null;
                const g = [],
                    v = [];
                this.domElement = t, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Dt, this.physicallyCorrectLights = !1, this.toneMapping = $, this.toneMappingExposure = 1, this.userData = {}, Object.defineProperties(this, {
                    gammaFactor: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
                        }
                    }
                });
                const b = this;
                let x = !1,
                    y = 0,
                    w = 0,
                    S = null,
                    M = -1,
                    T = null;
                const E = new er,
                    A = new er;
                let C = null,
                    R = t.width,
                    k = t.height,
                    P = 1,
                    D = null,
                    O = null;
                const L = new er(0, 0, R, k),
                    I = new er(0, 0, R, k);
                let F = !1;
                const N = new Cs;
                let U = !1,
                    B = !1,
                    j = null;
                const z = new Br,
                    V = new Pn,
                    G = new lr,
                    H = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function W() {
                    return null === S ? P : 1
                }
                let K, X, q, Y, Z, J, Q, ee, te, ne, re, ie, se, oe, ae, le, ce, ue, pe, he, de, fe, _e, me, ge = n;

                function ve(e, n) {
                    for (let r = 0; r < e.length; r++) {
                        const i = e[r],
                            s = t.getContext(i, n);
                        if (null !== s) return s
                    }
                    return null
                }
                try {
                    const e = {
                        alpha: !0,
                        depth: i,
                        stencil: s,
                        antialias: o,
                        premultipliedAlpha: a,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: u
                    };
                    if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${r}`), t.addEventListener("webglcontextlost", we, !1), t.addEventListener("webglcontextrestored", Me, !1), t.addEventListener("webglcontextcreationerror", Te, !1), null === ge) {
                        const t = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === b.isWebGL1Renderer && t.shift(), ge = ve(t, e), null === ge) throw ve(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    void 0 === ge.getShaderPrecisionFormat && (ge.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (e) {
                    throw console.error("THREE.WebGLRenderer: " + e.message), e
                }

                function be() {
                    K = new to(ge), X = new Us(ge, K, e), K.init(X), fe = new tl(ge, K, X), q = new Qa(ge, K, X), Y = new io, Z = new Ba, J = new el(ge, K, q, Z, X, fe, Y), Q = new js(b), ee = new eo(b), te = new ks(ge, X), _e = new Fs(ge, K, te, X), ne = new no(ge, te, Y, _e), re = new co(ge, ne, te, Y), pe = new lo(ge, X, J), le = new Bs(Z), ie = new Ua(b, Q, ee, K, X, _e, le), se = new ll(b, Z), oe = new Ga, ae = new Ya(K, X), ue = new Is(b, Q, q, re, p, a), ce = new $a(b, re, X), me = new cl(ge, Y, X, q), he = new Ns(ge, K, Y, X), de = new ro(ge, K, Y, X), Y.programs = ie.programs, b.capabilities = X, b.extensions = K, b.properties = Z, b.renderLists = oe, b.shadowMap = ce, b.state = q, b.info = Y, b.background = ue, b.cubeuvmaps = ee
                }
                be();
                const xe = new al(b, ge);

                function we(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0
                }

                function Me() {
                    console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
                    const e = Y.autoReset,
                        t = ce.enabled,
                        n = ce.autoUpdate,
                        r = ce.needsUpdate,
                        i = ce.type;
                    be(), Y.autoReset = e, ce.enabled = t, ce.autoUpdate = n, ce.needsUpdate = r, ce.type = i
                }

                function Te(e) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                }

                function Ee(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", Ee),
                        function(e) {
                            (function(e) {
                                const t = Z.get(e).programs;
                                void 0 !== t && (t.forEach((function(e) {
                                    ie.releaseProgram(e)
                                })), e.isShaderMaterial && ie.releaseShaderCache(e))
                            })(e), Z.remove(e)
                        }(t)
                }
                this.xr = xe, this.getContext = function() {
                    return ge
                }, this.getContextAttributes = function() {
                    return ge.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const e = K.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    const e = K.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() {
                    return P
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (P = e, this.setSize(R, k, !1))
                }, this.getSize = function(e) {
                    return e.set(R, k)
                }, this.setSize = function(e, n, r) {
                    xe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R = e, k = n, t.width = Math.floor(e * P), t.height = Math.floor(n * P), !1 !== r && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
                }, this.getDrawingBufferSize = function(e) {
                    return e.set(R * P, k * P).floor()
                }, this.setDrawingBufferSize = function(e, n, r) {
                    R = e, k = n, P = r, t.width = Math.floor(e * r), t.height = Math.floor(n * r), this.setViewport(0, 0, e, n)
                }, this.getCurrentViewport = function(e) {
                    return e.copy(E)
                }, this.getViewport = function(e) {
                    return e.copy(L)
                }, this.setViewport = function(e, t, n, r) {
                    e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, n, r), q.viewport(E.copy(L).multiplyScalar(P).floor())
                }, this.getScissor = function(e) {
                    return e.copy(I)
                }, this.setScissor = function(e, t, n, r) {
                    e.isVector4 ? I.set(e.x, e.y, e.z, e.w) : I.set(e, t, n, r), q.scissor(A.copy(I).multiplyScalar(P).floor())
                }, this.getScissorTest = function() {
                    return F
                }, this.setScissorTest = function(e) {
                    q.setScissorTest(F = e)
                }, this.setOpaqueSort = function(e) {
                    D = e
                }, this.setTransparentSort = function(e) {
                    O = e
                }, this.getClearColor = function(e) {
                    return e.copy(ue.getClearColor())
                }, this.setClearColor = function() {
                    ue.setClearColor.apply(ue, arguments)
                }, this.getClearAlpha = function() {
                    return ue.getClearAlpha()
                }, this.setClearAlpha = function() {
                    ue.setClearAlpha.apply(ue, arguments)
                }, this.clear = function(e = !0, t = !0, n = !0) {
                    let r = 0;
                    e && (r |= 16384), t && (r |= 256), n && (r |= 1024), ge.clear(r)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    t.removeEventListener("webglcontextlost", we, !1), t.removeEventListener("webglcontextrestored", Me, !1), t.removeEventListener("webglcontextcreationerror", Te, !1), oe.dispose(), ae.dispose(), Z.dispose(), Q.dispose(), ee.dispose(), re.dispose(), _e.dispose(), me.dispose(), ie.dispose(), xe.dispose(), xe.removeEventListener("sessionstart", Ce), xe.removeEventListener("sessionend", Pe), j && (j.dispose(), j = null), De.stop()
                }, this.renderBufferDirect = function(e, t, n, r, i, s) {
                    null === t && (t = H);
                    const o = i.isMesh && i.matrixWorld.determinant() < 0,
                        a = function(e, t, n, r, i) {
                            !0 !== t.isScene && (t = H), J.resetTextureUnits();
                            const s = t.fog,
                                o = r.isMeshStandardMaterial ? t.environment : null,
                                a = null === S ? b.outputEncoding : !0 === S.isXRRenderTarget || S.texture.encoding && S.texture.encoding !== Ot ? S.texture.encoding : Dt,
                                l = (r.isMeshStandardMaterial ? ee : Q).get(r.envMap || o),
                                c = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                u = !!r.normalMap && !!n.attributes.tangent,
                                p = !!n.morphAttributes.position,
                                h = !!n.morphAttributes.normal,
                                f = !!n.morphAttributes.color,
                                _ = r.toneMapped ? b.toneMapping : $,
                                m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                g = void 0 !== m ? m.length : 0,
                                v = Z.get(r),
                                x = d.state.lights;
                            if (!0 === U && (!0 === B || e !== T)) {
                                const t = e === T && r.id === M;
                                le.setState(r, e, t)
                            }
                            let y = !1;
                            r.version === v.__version ? v.needsLights && v.lightsStateVersion !== x.state.version || v.outputEncoding !== a || i.isInstancedMesh && !1 === v.instancing ? y = !0 : i.isInstancedMesh || !0 !== v.instancing ? i.isSkinnedMesh && !1 === v.skinning ? y = !0 : i.isSkinnedMesh || !0 !== v.skinning ? v.envMap !== l || !0 === r.fog && v.fog !== s ? y = !0 : void 0 === v.numClippingPlanes || v.numClippingPlanes === le.numPlanes && v.numIntersection === le.numIntersection ? (v.vertexAlphas !== c || v.vertexTangents !== u || v.morphTargets !== p || v.morphNormals !== h || v.morphColors !== f || v.toneMapping !== _ || !0 === X.isWebGL2 && v.morphTargetsCount !== g) && (y = !0) : y = !0 : y = !0 : y = !0 : (y = !0, v.__version = r.version);
                            let w = v.currentProgram;
                            !0 === y && (w = Ue(r, t, i));
                            let E = !1,
                                A = !1,
                                C = !1;
                            const R = w.getUniforms(),
                                D = v.uniforms;
                            if (q.useProgram(w.program) && (E = !0, A = !0, C = !0), r.id !== M && (M = r.id, A = !0), E || T !== e) {
                                if (R.setValue(ge, "projectionMatrix", e.projectionMatrix), X.logarithmicDepthBuffer && R.setValue(ge, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), T !== e && (T = e, A = !0, C = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) {
                                    const t = R.map.cameraPosition;
                                    void 0 !== t && t.setValue(ge, G.setFromMatrixPosition(e.matrixWorld))
                                }(r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && R.setValue(ge, "isOrthographic", !0 === e.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || i.isSkinnedMesh) && R.setValue(ge, "viewMatrix", e.matrixWorldInverse)
                            }
                            if (i.isSkinnedMesh) {
                                R.setOptional(ge, i, "bindMatrix"), R.setOptional(ge, i, "bindMatrixInverse");
                                const e = i.skeleton;
                                e && (X.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), R.setValue(ge, "boneTexture", e.boneTexture, J), R.setValue(ge, "boneTextureSize", e.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                            }
                            const O = n.morphAttributes;
                            var L, I;
                            (void 0 !== O.position || void 0 !== O.normal || void 0 !== O.color && !0 === X.isWebGL2) && pe.update(i, n, r, w), (A || v.receiveShadow !== i.receiveShadow) && (v.receiveShadow = i.receiveShadow, R.setValue(ge, "receiveShadow", i.receiveShadow)), A && (R.setValue(ge, "toneMappingExposure", b.toneMappingExposure), v.needsLights && (I = C, (L = D).ambientLightColor.needsUpdate = I, L.lightProbe.needsUpdate = I, L.directionalLights.needsUpdate = I, L.directionalLightShadows.needsUpdate = I, L.pointLights.needsUpdate = I, L.pointLightShadows.needsUpdate = I, L.spotLights.needsUpdate = I, L.spotLightShadows.needsUpdate = I, L.rectAreaLights.needsUpdate = I, L.hemisphereLights.needsUpdate = I), s && !0 === r.fog && se.refreshFogUniforms(D, s), se.refreshMaterialUniforms(D, r, P, k, b.userData.transmissionRenderTarget || j), fa.upload(ge, v.uniformsList, D, J)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (fa.upload(ge, v.uniformsList, D, J), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && R.setValue(ge, "center", i.center), R.setValue(ge, "modelViewMatrix", i.modelViewMatrix), R.setValue(ge, "normalMatrix", i.normalMatrix), R.setValue(ge, "modelMatrix", i.matrixWorld);
                            const F = r.extraUniformsToUpload;
                            if (F && Object.entries(F).forEach((([e, t]) => R.setValue(ge, e, t.value, J))), r.isShaderMaterial || r.isRawShaderMaterial) {
                                const e = r.uniformsGroups;
                                for (let t = 0, n = e.length; t < n; t++)
                                    if (X.isWebGL2) {
                                        const n = e[t];
                                        me.update(n, w), me.bind(n, w)
                                    } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                            }
                            return w
                        }(e, t, n, r, i);
                    q.setMaterial(r, o);
                    let l = n.index;
                    const c = n.attributes.position;
                    if (null === l) {
                        if (void 0 === c || 0 === c.count) return
                    } else if (0 === l.count) return;
                    let u, p = 1;
                    !0 === r.wireframe && (l = ne.getWireframeAttribute(n), p = 2), _e.setup(i, r, a, n, l);
                    let h = he;
                    null !== l && (u = te.get(l), h = de, h.setIndex(u));
                    const f = null !== l ? l.count : c.count,
                        _ = n.drawRange.start * p,
                        m = n.drawRange.count * p,
                        g = null !== s ? s.start * p : 0,
                        v = null !== s ? s.count * p : 1 / 0,
                        x = Math.max(_, g),
                        y = Math.min(f, _ + m, g + v) - 1,
                        w = Math.max(0, y - x + 1);
                    if (0 !== w) {
                        if (i.isMesh) !0 === r.wireframe ? (q.setLineWidth(r.wireframeLinewidth * W()), h.setMode(1)) : h.setMode(4);
                        else if (i.isLine) {
                            let e = r.linewidth;
                            void 0 === e && (e = 1), q.setLineWidth(e * W()), i.isLineSegments ? h.setMode(1) : i.isLineLoop ? h.setMode(2) : h.setMode(3)
                        } else i.isPoints ? h.setMode(0) : i.isSprite && h.setMode(4);
                        if (i.isInstancedMesh) h.renderInstances(x, w, i.count);
                        else if (n.isInstancedBufferGeometry) {
                            const e = Math.min(n.instanceCount, n._maxInstanceCount);
                            h.renderInstances(x, w, e)
                        } else h.render(x, w)
                    }
                }, this.compile = function(e, t) {
                    d = ae.get(e), d.init(), v.push(d), e.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e))
                    })), d.setupLights(b.physicallyCorrectLights), e.traverse((function(t) {
                        const n = t.material;
                        if (n)
                            if (Array.isArray(n))
                                for (let r = 0; r < n.length; r++) Ue(n[r], e, t);
                            else Ue(n, e, t)
                    })), v.pop(), d = null
                };
                let Ae = null;

                function Ce() {
                    De.stop()
                }

                function Pe() {
                    De.start()
                }
                const De = new Rs;

                function Oe(e, t, n, r) {
                    if (!1 === e.visible) return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup) n = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                    else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
                    else if (e.isSprite) {
                        if (!e.frustumCulled || N.intersectsSprite(e)) {
                            r && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
                            const t = re.update(e),
                                i = e.material;
                            i.visible && h.push(e, t, i, n, G.z, null)
                        }
                    } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== Y.render.frame && (e.skeleton.update(), e.skeleton.frame = Y.render.frame), !e.frustumCulled || N.intersectsObject(e))) {
                        r && G.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
                        const t = re.update(e),
                            i = e.material;
                        if (Array.isArray(i)) {
                            const r = t.groups;
                            for (let s = 0, o = r.length; s < o; s++) {
                                const o = r[s],
                                    a = i[o.materialIndex];
                                a && a.visible && h.push(e, t, a, n, G.z, o)
                            }
                        } else i.visible && h.push(e, t, i, n, G.z, null)
                    }
                    const i = e.children;
                    for (let e = 0, s = i.length; e < s; e++) Oe(i[e], t, n, r)
                }

                function Le(e, t, n, r) {
                    const i = e.opaque,
                        s = e.transmissive,
                        a = e.transparent;
                    d.setupLightsView(n), void 0 === b.userData.transmissionRender && !1 !== b.userData.renderTransmissionPass && s.length > 0 && function(e, t, n) {
                        const r = X.isWebGL2;
                        null === j && (j = new tr(1, 1, {
                            generateMipmaps: !0,
                            type: K.has("EXT_color_buffer_half_float") ? ke : Se,
                            minFilter: ye,
                            samples: r && !0 === o ? 4 : 0
                        })), b.getDrawingBufferSize(V), r ? j.setSize(V.x, V.y) : j.setSize(Rn(V.x), Rn(V.y));
                        const i = b.getRenderTarget();
                        b.setRenderTarget(j), b.clear();
                        const s = b.toneMapping;
                        b.toneMapping = $, Ie(e, t, n), b.toneMapping = s, J.updateMultisampleRenderTarget(j), J.updateRenderTargetMipmap(j), b.setRenderTarget(i)
                    }([...i, ...a], t, n), r && q.viewport(E.copy(r)), !1 !== b.userData.opaqueRender && i.length > 0 && Ie(i, t, n), !1 !== b.userData.transparentRender && a.length > 0 && Ie(a, t, n), !1 !== b.userData.transmissionRender && s.length > 0 && (j || (j = new tr(1, 1)), Ie(s, t, n)), q.buffers.depth.setTest(!0), q.buffers.depth.setMask(!0), q.buffers.color.setMask(!0), q.setPolygonOffset(!1)
                }

                function Ie(e, t, n) {
                    const r = { ...b.userData
                    };
                    b.userData.opaqueRender = void 0, b.userData.transparentRender = void 0, b.userData.transmissionRender = void 0, b.userData.backgroundRender = void 0;
                    const i = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, s = e.length; r < s; r++) {
                        const s = e[r],
                            o = s.object,
                            a = s.geometry,
                            l = null === i ? s.material : i,
                            c = s.group;
                        o.layers.test(n.layers) && Ne(o, t, n, a, l, c)
                    }
                    Object.assign(b.userData, r)
                }

                function Ne(e, t, n, r, i, s) {
                    e.onBeforeRender(b, t, n, r, i, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), i.onBeforeRender(b, t, n, r, e, s), !0 === i.transparent && i.side === m ? (i.side = _, i.needsUpdate = !0, b.renderBufferDirect(n, t, r, i, e, s), i.side = f, i.needsUpdate = !0, b.renderBufferDirect(n, t, r, i, e, s), i.side = m) : b.renderBufferDirect(n, t, r, i, e, s), e.onAfterRender(b, t, n, r, i, s)
                }

                function Ue(e, t, n) {
                    !0 !== t.isScene && (t = H);
                    const r = Z.get(e),
                        i = d.state.lights,
                        s = d.state.shadowsArray,
                        o = i.state.version,
                        a = ie.getParameters(e, i.state, s, t, n),
                        l = ie.getProgramCacheKey(a);
                    let c = r.programs;
                    r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? ee : Q).get(e.envMap || r.environment), void 0 === c && (e.addEventListener("dispose", Ee), c = new Map, r.programs = c);
                    let u = c.get(l);
                    if (void 0 !== u) {
                        if (r.currentProgram === u && r.lightsStateVersion === o) return Be(e, a), u
                    } else a.uniforms = ie.getUniforms(e), e.onBuild(n, a, b), e.onBeforeCompile(a, b), u = ie.acquireProgram(a, l), c.set(l, u), r.uniforms = a.uniforms;
                    const p = r.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (p.clippingPlanes = le.uniform), Be(e, a), r.needsLights = function(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e), r.lightsStateVersion = o, r.needsLights && (p.ambientLightColor.value = i.state.ambient, p.lightProbe.value = i.state.probe, p.directionalLights.value = i.state.directional, p.directionalLightShadows.value = i.state.directionalShadow, p.spotLights.value = i.state.spot, p.spotLightShadows.value = i.state.spotShadow, p.rectAreaLights.value = i.state.rectArea, p.ltc_1.value = i.state.rectAreaLTC1, p.ltc_2.value = i.state.rectAreaLTC2, p.pointLights.value = i.state.point, p.pointLightShadows.value = i.state.pointShadow, p.hemisphereLights.value = i.state.hemi, p.directionalShadowMap.value = i.state.directionalShadowMap, p.directionalShadowMatrix.value = i.state.directionalShadowMatrix, p.spotShadowMap.value = i.state.spotShadowMap, p.spotShadowMatrix.value = i.state.spotShadowMatrix, p.pointShadowMap.value = i.state.pointShadowMap, p.pointShadowMatrix.value = i.state.pointShadowMatrix);
                    const h = u.getUniforms(),
                        f = fa.seqWithValue(h.seq, p);
                    return r.currentProgram = u, r.uniformsList = f, u
                }

                function Be(e, t) {
                    const n = Z.get(e);
                    n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
                }
                De.setAnimationLoop((function(e) {
                    Ae && Ae(e)
                })), "undefined" != typeof self && De.setContext(self), this.setAnimationLoop = function(e) {
                    Ae = e, xe.setAnimationLoop(e), null === e ? De.stop() : De.start()
                }, xe.addEventListener("sessionstart", Ce), xe.addEventListener("sessionend", Pe), this.render = function(e, t) {
                    if (void 0 === t || !0 === t.isCamera) {
                        if (!0 !== x) {
                            if (!0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === xe.enabled && !0 === xe.isPresenting && (!0 === xe.cameraAutoUpdate && xe.updateCamera(t), t = xe.getCamera()), !0 === e.isScene && e.onBeforeRender(b, e, t, S), d = ae.get(e, v.length), d.init(), v.push(d), z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), N.setFromProjectionMatrix(z), B = this.localClippingEnabled, U = le.init(this.clippingPlanes, B, t), h = oe.get(e, g.length), h.init(), g.push(h), Oe(e, t, 0, b.sortObjects), h.finish(), !0 === b.sortObjects && h.sort(D, O), b.userData.shadowMapRender) {
                                !0 === U && le.beginShadows();
                                const n = d.state.shadowsArray;
                                n.length > 0 && ce.render(n, e, t), !0 === U && le.endShadows()
                            }
                            if (!0 === this.info.autoReset && this.info.reset(), !1 !== b.userData.backgroundRender && ue.render(h, e), !1 !== b.userData.sceneRender)
                                if (d.setupLights(b.physicallyCorrectLights), t.isArrayCamera) {
                                    const n = t.cameras;
                                    for (let t = 0, r = n.length; t < r; t++) {
                                        const r = n[t];
                                        Le(h, e, r, r.viewport)
                                    }
                                } else Le(h, e, t);
                            null !== S && (J.updateMultisampleRenderTarget(S), J.updateRenderTargetMipmap(S)), !0 === e.isScene && e.onAfterRender(b, e, t), _e.resetDefaultState(), M = -1, T = null, v.pop(), d = v.length > 0 ? v[v.length - 1] : null, g.pop(), h = g.length > 0 ? g[g.length - 1] : null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.getActiveCubeFace = function() {
                    return y
                }, this.getActiveMipmapLevel = function() {
                    return w
                }, this.getRenderTarget = function() {
                    return S
                }, this.setRenderTargetTextures = function(e, t, n) {
                    Z.get(e.texture).__webglTexture = t, Z.get(e.depthTexture).__webglTexture = n;
                    const r = Z.get(e);
                    r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 === K.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1))
                }, this.setRenderTargetFramebuffer = function(e, t) {
                    const n = Z.get(e);
                    n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
                }, this.setRenderTarget = function(e, t = 0, n = 0) {
                    S = e, y = t, w = n;
                    let r = !0;
                    if (e) {
                        const t = Z.get(e);
                        void 0 !== t.__useDefaultFramebuffer ? (q.bindFramebuffer(36160, null), r = !1) : void 0 === t.__webglFramebuffer ? J.setupRenderTarget(e) : t.__hasExternalTextures && J.rebindTextures(e, Z.get(e.texture).__webglTexture, Z.get(e.depthTexture).__webglTexture)
                    }
                    let i = null,
                        s = !1,
                        o = !1;
                    if (e) {
                        const n = e.texture;
                        (n.isData3DTexture || n.isDataArrayTexture) && (o = !0);
                        const r = Z.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (i = r[t], s = !0) : i = X.isWebGL2 && e.samples > 0 && !1 === J.useMultisampledRTT(e) ? Z.get(e).__webglMultisampledFramebuffer : r, E.copy(e.viewport), A.copy(e.scissor), C = e.scissorTest
                    } else E.copy(L).multiplyScalar(P).floor(), A.copy(I).multiplyScalar(P).floor(), C = F;
                    if (q.bindFramebuffer(36160, i) && X.drawBuffers && r && q.drawBuffers(e, i), q.viewport(E), q.scissor(A), q.setScissorTest(C), s) {
                        const r = Z.get(e.texture);
                        ge.framebufferTexture2D(36160, 36064, 34069 + t, r.__webglTexture, n)
                    } else if (o) {
                        const r = Z.get(e.texture),
                            i = t || 0;
                        ge.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i)
                    }
                    M = -1
                }, this.readRenderTargetPixels = function(e, t, n, r, i, s, o) {
                    if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let a = Z.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                        q.bindFramebuffer(36160, a);
                        try {
                            const o = e.texture,
                                a = o.format,
                                l = o.type;
                            if (a !== Fe && fe.convert(a) !== ge.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const c = l === ke && (K.has("EXT_color_buffer_half_float") || X.isWebGL2 && K.has("EXT_color_buffer_float"));
                            if (!(l === Se || fe.convert(l) === ge.getParameter(35738) || l === Re && (X.isWebGL2 || K.has("OES_texture_float") || K.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ge.readPixels(t, n, r, i, fe.convert(a), fe.convert(l), s)
                        } finally {
                            const e = null !== S ? Z.get(S).__webglFramebuffer : null;
                            q.bindFramebuffer(36160, e)
                        }
                    }
                }, this.copyFramebufferToTexture = function(e, t, n = 0) {
                    const r = Math.pow(2, -n),
                        i = Math.floor(t.image.width * r),
                        s = Math.floor(t.image.height * r);
                    J.setTexture2D(t, 0), ge.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, i, s), q.unbindTexture()
                }, this.copyTextureToTexture = function(e, t, n, r = 0) {
                    const i = t.image.width,
                        s = t.image.height,
                        o = fe.convert(n.format),
                        a = fe.convert(n.type);
                    J.setTexture2D(n, 0), ge.pixelStorei(37440, n.flipY), ge.pixelStorei(37441, n.premultiplyAlpha), ge.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? ge.texSubImage2D(3553, r, e.x, e.y, i, s, o, a, t.image.data) : t.isCompressedTexture ? ge.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : ge.texSubImage2D(3553, r, e.x, e.y, o, a, t.image), 0 === r && n.generateMipmaps && ge.generateMipmap(3553), q.unbindTexture()
                }, this.copyTextureToTexture3D = function(e, t, n, r, i = 0) {
                    if (b.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const s = e.max.x - e.min.x + 1,
                        o = e.max.y - e.min.y + 1,
                        a = e.max.z - e.min.z + 1,
                        l = fe.convert(r.format),
                        c = fe.convert(r.type);
                    let u;
                    if (r.isData3DTexture) J.setTexture3D(r, 0), u = 32879;
                    else {
                        if (!r.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        J.setTexture2DArray(r, 0), u = 35866
                    }
                    ge.pixelStorei(37440, r.flipY), ge.pixelStorei(37441, r.premultiplyAlpha), ge.pixelStorei(3317, r.unpackAlignment);
                    const p = ge.getParameter(3314),
                        h = ge.getParameter(32878),
                        d = ge.getParameter(3316),
                        f = ge.getParameter(3315),
                        _ = ge.getParameter(32877),
                        m = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                    ge.pixelStorei(3314, m.width), ge.pixelStorei(32878, m.height), ge.pixelStorei(3316, e.min.x), ge.pixelStorei(3315, e.min.y), ge.pixelStorei(32877, e.min.z), n.isDataTexture || n.isData3DTexture ? ge.texSubImage3D(u, i, t.x, t.y, t.z, s, o, a, l, c, m.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ge.compressedTexSubImage3D(u, i, t.x, t.y, t.z, s, o, a, l, m.data)) : ge.texSubImage3D(u, i, t.x, t.y, t.z, s, o, a, l, c, m), ge.pixelStorei(3314, p), ge.pixelStorei(32878, h), ge.pixelStorei(3316, d), ge.pixelStorei(3315, f), ge.pixelStorei(32877, _), 0 === i && r.generateMipmaps && ge.generateMipmap(u), q.unbindTexture()
                }, this.initTexture = function(e) {
                    e.isCubeTexture ? J.setTextureCube(e, 0) : e.isData3DTexture ? J.setTexture3D(e, 0) : e.isDataArrayTexture ? J.setTexture2DArray(e, 0) : J.setTexture2D(e, 0), q.unbindTexture()
                }, this.resetState = function() {
                    y = 0, w = 0, S = null, q.reset(), _e.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            class pl extends ul {}
            pl.prototype.isWebGL1Renderer = !0;
            class hl {
                constructor(e, t = 25e-5) {
                    this.isFogExp2 = !0, this.name = "", this.color = new Xn(e), this.density = t
                }
                clone() {
                    return new hl(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            class dl {
                constructor(e, t = 1, n = 1e3) {
                    this.isFog = !0, this.name = "", this.color = new Xn(e), this.near = t, this.far = n
                }
                clone() {
                    return new dl(this.color, this.near, this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            class fl extends ui {
                constructor() {
                    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(e, t) {
                    return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.fog && (t.object.fog = this.fog.toJSON()), t
                }
            }
            class _l {
                constructor(e, t) {
                    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = on, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0, this.uuid = Sn()
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                }
                copyAt(e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (let r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                clone(e) {
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Sn()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                        n = new this.constructor(t, this.stride);
                    return n.setUsage(this.usage), n
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                toJSON(e) {
                    return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Sn()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            const ml = new lr;
            class gl {
                constructor(e, t, n, r = !1) {
                    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === r
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(e) {
                    this.data.needsUpdate = e
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.data.count; t < n; t++) ml.fromBufferAttribute(this, t), ml.applyMatrix4(e), this.setXYZ(t, ml.x, ml.y, ml.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) ml.fromBufferAttribute(this, t), ml.applyNormalMatrix(e), this.setXYZ(t, ml.x, ml.y, ml.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) ml.fromBufferAttribute(this, t), ml.transformDirection(e), this.setXYZ(t, ml.x, ml.y, ml.z);
                    return this
                }
                setX(e, t) {
                    return this.data.array[e * this.data.stride + this.offset] = t, this
                }
                setY(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                }
                setZ(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                }
                setW(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                }
                getX(e) {
                    return this.data.array[e * this.data.stride + this.offset]
                }
                getY(e) {
                    return this.data.array[e * this.data.stride + this.offset + 1]
                }
                getZ(e) {
                    return this.data.array[e * this.data.stride + this.offset + 2]
                }
                getW(e) {
                    return this.data.array[e * this.data.stride + this.offset + 3]
                }
                setXY(e, t, n) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                }
                setXYZ(e, t, n, r) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
                }
                setXYZW(e, t, n, r, i) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
                }
                clone(e) {
                    if (void 0 === e) {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return new Ai(new this.array.constructor(e), this.itemSize, this.normalized)
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new gl(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                }
                toJSON(e) {
                    if (void 0 === e) {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: e,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }
            class vl extends Si {
                constructor(e) {
                    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Xn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                }
            }
            let bl;
            const xl = new lr,
                yl = new lr,
                wl = new lr,
                Sl = new Pn,
                Ml = new Pn,
                Tl = new Br,
                El = new lr,
                Al = new lr,
                Cl = new lr,
                Rl = new Pn,
                kl = new Pn,
                Pl = new Pn;
            class Dl extends ui {
                constructor(e) {
                    if (super(), this.isSprite = !0, this.type = "Sprite", void 0 === bl) {
                        bl = new Wi;
                        const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                            t = new _l(e, 5);
                        bl.setIndex([0, 1, 2, 0, 2, 3]), bl.setAttribute("position", new gl(t, 3, 0, !1)), bl.setAttribute("uv", new gl(t, 2, 3, !1))
                    }
                    this.geometry = bl, this.material = void 0 !== e ? e : new vl, this.center = new Pn(.5, .5)
                }
                raycast(e, t) {
                    null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), yl.setFromMatrixScale(this.matrixWorld), Tl.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), wl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && yl.multiplyScalar(-wl.z);
                    const n = this.material.rotation;
                    let r, i;
                    0 !== n && (i = Math.cos(n), r = Math.sin(n));
                    const s = this.center;
                    Ol(El.set(-.5, -.5, 0), wl, s, yl, r, i), Ol(Al.set(.5, -.5, 0), wl, s, yl, r, i), Ol(Cl.set(.5, .5, 0), wl, s, yl, r, i), Rl.set(0, 0), kl.set(1, 0), Pl.set(1, 1);
                    let o = e.ray.intersectTriangle(El, Al, Cl, !1, xl);
                    if (null === o && (Ol(Al.set(-.5, .5, 0), wl, s, yl, r, i), kl.set(0, 1), o = e.ray.intersectTriangle(El, Cl, Al, !1, xl), null === o)) return;
                    const a = e.ray.origin.distanceTo(xl);
                    a < e.near || a > e.far || t.push({
                        distance: a,
                        point: xl.clone(),
                        uv: yi.getUV(xl, El, Al, Cl, Rl, kl, Pl, new Pn),
                        face: null,
                        object: this
                    })
                }
                copy(e, t) {
                    return super.copy(e, t), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
                }
            }

            function Ol(e, t, n, r, i, s) {
                Sl.subVectors(e, n).addScalar(.5).multiply(r), void 0 !== i ? (Ml.x = s * Sl.x - i * Sl.y, Ml.y = i * Sl.x + s * Sl.y) : Ml.copy(Sl), e.copy(t), e.x += Ml.x, e.y += Ml.y, e.applyMatrix4(Tl)
            }
            const Ll = new lr,
                Il = new lr;
            class Fl extends ui {
                constructor() {
                    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                        levels: {
                            enumerable: !0,
                            value: []
                        },
                        isLOD: {
                            value: !0
                        }
                    }), this.autoUpdate = !0
                }
                copy(e) {
                    super.copy(e, !1);
                    const t = e.levels;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        this.addLevel(n.object.clone(), n.distance)
                    }
                    return this.autoUpdate = e.autoUpdate, this
                }
                addLevel(e, t = 0) {
                    t = Math.abs(t);
                    const n = this.levels;
                    let r;
                    for (r = 0; r < n.length && !(t < n[r].distance); r++);
                    return n.splice(r, 0, {
                        distance: t,
                        object: e
                    }), this.add(e), this
                }
                getCurrentLevel() {
                    return this._currentLevel
                }
                getObjectForDistance(e) {
                    const t = this.levels;
                    if (t.length > 0) {
                        let n, r;
                        for (n = 1, r = t.length; n < r && !(e < t[n].distance); n++);
                        return t[n - 1].object
                    }
                    return null
                }
                raycast(e, t) {
                    if (this.levels.length > 0) {
                        Ll.setFromMatrixPosition(this.matrixWorld);
                        const n = e.ray.origin.distanceTo(Ll);
                        this.getObjectForDistance(n).raycast(e, t)
                    }
                }
                update(e) {
                    const t = this.levels;
                    if (t.length > 1) {
                        Ll.setFromMatrixPosition(e.matrixWorld), Il.setFromMatrixPosition(this.matrixWorld);
                        const n = Ll.distanceTo(Il) / e.zoom;
                        let r, i;
                        for (t[0].object.visible = !0, r = 1, i = t.length; r < i && n >= t[r].distance; r++) t[r - 1].object.visible = !1, t[r].object.visible = !0;
                        for (this._currentLevel = r - 1; r < i; r++) t[r].object.visible = !1
                    }
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = [];
                    const n = this.levels;
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        t.object.levels.push({
                            object: r.object.uuid,
                            distance: r.distance
                        })
                    }
                    return t
                }
            }
            const Nl = new lr,
                Ul = new er,
                Bl = new er,
                jl = new lr,
                zl = new Br;
            class Vl extends cs {
                constructor(e, t) {
                    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Br, this.bindMatrixInverse = new Br
                }
                copy(e, t) {
                    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
                }
                bind(e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    const e = new er,
                        t = this.geometry.attributes.skinWeight;
                    for (let n = 0, r = t.count; n < r; n++) {
                        e.fromBufferAttribute(t, n);
                        const r = 1 / e.manhattanLength();
                        r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                    }
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                boneTransform(e, t) {
                    const n = this.skeleton,
                        r = this.geometry;
                    Ul.fromBufferAttribute(r.attributes.skinIndex, e), Bl.fromBufferAttribute(r.attributes.skinWeight, e), Nl.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                    for (let e = 0; e < 4; e++) {
                        const r = Bl.getComponent(e);
                        if (0 !== r) {
                            const i = Ul.getComponent(e);
                            zl.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), t.addScaledVector(jl.copy(Nl).applyMatrix4(zl), r)
                        }
                    }
                    return t.applyMatrix4(this.bindMatrixInverse)
                }
            }
            class Gl extends ui {
                constructor() {
                    super(), this.isBone = !0, this.type = "Bone"
                }
            }
            class Hl extends Qn {
                constructor(e = null, t = 1, n = 1, r, i, s, o, a, l = de, c = de, u, p) {
                    super(null, s, o, a, l, c, r, i, u, p), this.isDataTexture = !0, this.image = {
                        data: e,
                        width: t,
                        height: n
                    }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
                }
            }
            const Wl = new Br,
                Kl = new Br;
            class Xl {
                constructor(e = [], t = []) {
                    this.uuid = Sn(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                }
                init() {
                    const e = this.bones,
                        t = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                    else if (e.length !== t.length) {
                        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                        for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new Br)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = new Br;
                        this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
                    }
                }
                pose() {
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                    }
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                    }
                }
                update() {
                    const e = this.bones,
                        t = this.boneInverses,
                        n = this.boneMatrices,
                        r = this.boneTexture;
                    for (let r = 0, i = e.length; r < i; r++) {
                        const i = e[r] ? e[r].matrixWorld : Kl;
                        Wl.multiplyMatrices(i, t[r]), Wl.toArray(n, 16 * r)
                    }
                    null !== r && (r.needsUpdate = !0)
                }
                clone() {
                    return new Xl(this.bones, this.boneInverses)
                }
                computeBoneTexture() {
                    let e = Math.sqrt(4 * this.bones.length);
                    e = Cn(e), e = Math.max(e, 4);
                    const t = new Float32Array(e * e * 4);
                    t.set(this.boneMatrices);
                    const n = new Hl(t, e, e, Fe, Re);
                    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
                }
                getBoneByName(e) {
                    for (let t = 0, n = this.bones.length; t < n; t++) {
                        const n = this.bones[t];
                        if (n.name === e) return n
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                }
                fromJSON(e, t) {
                    this.uuid = e.uuid;
                    for (let n = 0, r = e.bones.length; n < r; n++) {
                        const r = e.bones[n];
                        let i = t[r];
                        void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new Gl), this.bones.push(i), this.boneInverses.push((new Br).fromArray(e.boneInverses[n]))
                    }
                    return this.init(), this
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    e.uuid = this.uuid;
                    const t = this.bones,
                        n = this.boneInverses;
                    for (let r = 0, i = t.length; r < i; r++) {
                        const i = t[r];
                        e.bones.push(i.uuid);
                        const s = n[r];
                        e.boneInverses.push(s.toArray())
                    }
                    return e
                }
            }
            class ql extends Ai {
                constructor(e, t, n, r = 1) {
                    "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                }
            }
            const Yl = new Br,
                Zl = new Br,
                Jl = [],
                $l = new cs;
            class Ql extends cs {
                constructor(e, t, n) {
                    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new ql(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
                }
                copy(e, t) {
                    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
                }
                getColorAt(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                }
                getMatrixAt(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                }
                raycast(e, t) {
                    const n = this.matrixWorld,
                        r = this.count;
                    if ($l.geometry = this.geometry, $l.material = this.material, void 0 !== $l.material)
                        for (let i = 0; i < r; i++) {
                            this.getMatrixAt(i, Yl), Zl.multiplyMatrices(n, Yl), $l.matrixWorld = Zl, $l.raycast(e, Jl);
                            for (let e = 0, n = Jl.length; e < n; e++) {
                                const n = Jl[e];
                                n.instanceId = i, n.object = this, t.push(n)
                            }
                            Jl.length = 0
                        }
                }
                setColorAt(e, t) {
                    null === this.instanceColor && (this.instanceColor = new ql(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
                }
                setMatrixAt(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class ec extends Si {
                constructor(e) {
                    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Xn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
                }
            }
            const tc = new lr,
                nc = new lr,
                rc = new Br,
                ic = new Ur,
                sc = new kr;
            class oc extends ui {
                constructor(e = new Wi, t = new ec) {
                    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (null === e.index) {
                        const t = e.attributes.position,
                            n = [0];
                        for (let e = 1, r = t.count; e < r; e++) tc.fromBufferAttribute(t, e - 1), nc.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += tc.distanceTo(nc);
                        e.setAttribute("lineDistance", new Fi(n, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
                raycast(e, t) {
                    const n = this.geometry,
                        r = this.matrixWorld,
                        i = e.params.Line.threshold,
                        s = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), sc.copy(n.boundingSphere), sc.applyMatrix4(r), sc.radius += i, !1 === e.ray.intersectsSphere(sc)) return;
                    rc.copy(r).invert(), ic.copy(e.ray).applyMatrix4(rc);
                    const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o,
                        l = new lr,
                        c = new lr,
                        u = new lr,
                        p = new lr,
                        h = this.isLineSegments ? 2 : 1,
                        d = n.index,
                        f = n.attributes.position;
                    if (null !== d)
                        for (let n = Math.max(0, s.start), r = Math.min(d.count, s.start + s.count) - 1; n < r; n += h) {
                            const r = d.getX(n),
                                i = d.getX(n + 1);
                            if (l.fromBufferAttribute(f, r), c.fromBufferAttribute(f, i), ic.distanceSqToSegment(l, c, p, u) > a) continue;
                            p.applyMatrix4(this.matrixWorld);
                            const s = e.ray.origin.distanceTo(p);
                            s < e.near || s > e.far || t.push({
                                distance: s,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        } else
                            for (let n = Math.max(0, s.start), r = Math.min(f.count, s.start + s.count) - 1; n < r; n += h) {
                                if (l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1), ic.distanceSqToSegment(l, c, p, u) > a) continue;
                                p.applyMatrix4(this.matrixWorld);
                                const r = e.ray.origin.distanceTo(p);
                                r < e.near || r > e.far || t.push({
                                    distance: r,
                                    point: u.clone().applyMatrix4(this.matrixWorld),
                                    index: n,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes,
                        t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
            }
            const ac = new lr,
                lc = new lr;
            class cc extends oc {
                constructor(e, t) {
                    super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (null === e.index) {
                        const t = e.attributes.position,
                            n = [];
                        for (let e = 0, r = t.count; e < r; e += 2) ac.fromBufferAttribute(t, e), lc.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + ac.distanceTo(lc);
                        e.setAttribute("lineDistance", new Fi(n, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
            }
            class uc extends oc {
                constructor(e, t) {
                    super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
                }
            }
            class pc extends Si {
                constructor(e) {
                    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Xn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                }
            }
            const hc = new Br,
                dc = new Ur,
                fc = new kr,
                _c = new lr;
            class mc extends ui {
                constructor(e = new Wi, t = new pc) {
                    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
                }
                raycast(e, t) {
                    const n = this.geometry,
                        r = this.matrixWorld,
                        i = e.params.Points.threshold,
                        s = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), fc.copy(n.boundingSphere), fc.applyMatrix4(r), fc.radius += i, !1 === e.ray.intersectsSphere(fc)) return;
                    hc.copy(r).invert(), dc.copy(e.ray).applyMatrix4(hc);
                    const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        a = o * o,
                        l = n.index,
                        c = n.attributes.position;
                    if (null !== l)
                        for (let n = Math.max(0, s.start), i = Math.min(l.count, s.start + s.count); n < i; n++) {
                            const i = l.getX(n);
                            _c.fromBufferAttribute(c, i), gc(_c, i, a, r, e, t, this)
                        } else
                            for (let n = Math.max(0, s.start), i = Math.min(c.count, s.start + s.count); n < i; n++) _c.fromBufferAttribute(c, n), gc(_c, n, a, r, e, t, this)
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes,
                        t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
            }

            function gc(e, t, n, r, i, s, o) {
                const a = dc.distanceSqToPoint(e);
                if (a < n) {
                    const n = new lr;
                    dc.closestPointToPoint(e, n), n.applyMatrix4(r);
                    const l = i.ray.origin.distanceTo(n);
                    if (l < i.near || l > i.far) return;
                    s.push({
                        distance: l,
                        distanceToRay: Math.sqrt(a),
                        point: n,
                        index: t,
                        face: null,
                        object: o
                    })
                }
            }
            class vc extends Qn {
                constructor(e, t, n, r, i, s, o, a, l) {
                    super(e, t, n, r, i, s, o, a, l), this.isVideoTexture = !0, this.minFilter = void 0 !== s ? s : ve, this.magFilter = void 0 !== i ? i : ve, this.generateMipmaps = !1;
                    const c = this;
                    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() {
                        c.needsUpdate = !0, e.requestVideoFrameCallback(t)
                    }))
                }
                clone() {
                    return new this.constructor(this.image).copy(this)
                }
                update() {
                    const e = this.image;
                    !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }
            class bc extends Qn {
                constructor(e, t, n) {
                    super({
                        width: e,
                        height: t
                    }), this.isFramebufferTexture = !0, this.format = n, this.magFilter = de, this.minFilter = de, this.generateMipmaps = !1, this.needsUpdate = !0
                }
            }
            class xc extends Qn {
                constructor(e, t, n, r, i, s, o, a, l, c, u, p) {
                    super(null, s, o, a, l, c, r, i, u, p), this.isCompressedTexture = !0, this.image = {
                        width: t,
                        height: n
                    }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            class yc extends Qn {
                constructor(e, t, n, r, i, s, o, a, l) {
                    super(e, t, n, r, i, s, o, a, l), this.isCanvasTexture = !0, this.needsUpdate = !0
                }
            }
            class wc {
                constructor() {
                    this.type = "Curve", this.arcLengthDivisions = 200
                }
                getPoint() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                }
                getPointAt(e, t) {
                    const n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                }
                getPoints(e = 5) {
                    const t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t
                }
                getSpacedPoints(e = 5) {
                    const t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t
                }
                getLength() {
                    const e = this.getLengths();
                    return e[e.length - 1]
                }
                getLengths(e = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const t = [];
                    let n, r = this.getPoint(0),
                        i = 0;
                    t.push(0);
                    for (let s = 1; s <= e; s++) n = this.getPoint(s / e), i += n.distanceTo(r), t.push(i), r = n;
                    return this.cacheArcLengths = t, t
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.getLengths()
                }
                getUtoTmapping(e, t) {
                    const n = this.getLengths();
                    let r = 0;
                    const i = n.length;
                    let s;
                    s = t || e * n[i - 1];
                    let o, a = 0,
                        l = i - 1;
                    for (; a <= l;)
                        if (r = Math.floor(a + (l - a) / 2), o = n[r] - s, o < 0) a = r + 1;
                        else {
                            if (!(o > 0)) {
                                l = r;
                                break
                            }
                            l = r - 1
                        }
                    if (r = l, n[r] === s) return r / (i - 1);
                    const c = n[r];
                    return (r + (s - c) / (n[r + 1] - c)) / (i - 1)
                }
                getTangent(e, t) {
                    const n = 1e-4;
                    let r = e - n,
                        i = e + n;
                    r < 0 && (r = 0), i > 1 && (i = 1);
                    const s = this.getPoint(r),
                        o = this.getPoint(i),
                        a = t || (s.isVector2 ? new Pn : new lr);
                    return a.copy(o).sub(s).normalize(), a
                }
                getTangentAt(e, t) {
                    const n = this.getUtoTmapping(e);
                    return this.getTangent(n, t)
                }
                computeFrenetFrames(e, t) {
                    const n = new lr,
                        r = [],
                        i = [],
                        s = [],
                        o = new lr,
                        a = new Br;
                    for (let t = 0; t <= e; t++) {
                        const n = t / e;
                        r[t] = this.getTangentAt(n, new lr)
                    }
                    i[0] = new lr, s[0] = new lr;
                    let l = Number.MAX_VALUE;
                    const c = Math.abs(r[0].x),
                        u = Math.abs(r[0].y),
                        p = Math.abs(r[0].z);
                    c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), p <= l && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), s[0].crossVectors(r[0], i[0]);
                    for (let t = 1; t <= e; t++) {
                        if (i[t] = i[t - 1].clone(), s[t] = s[t - 1].clone(), o.crossVectors(r[t - 1], r[t]), o.length() > Number.EPSILON) {
                            o.normalize();
                            const e = Math.acos(Mn(r[t - 1].dot(r[t]), -1, 1));
                            i[t].applyMatrix4(a.makeRotationAxis(o, e))
                        }
                        s[t].crossVectors(r[t], i[t])
                    }
                    if (!0 === t) {
                        let t = Math.acos(Mn(i[0].dot(i[e]), -1, 1));
                        t /= e, r[0].dot(o.crossVectors(i[0], i[e])) > 0 && (t = -t);
                        for (let n = 1; n <= e; n++) i[n].applyMatrix4(a.makeRotationAxis(r[n], t * n)), s[n].crossVectors(r[n], i[n])
                    }
                    return {
                        tangents: r,
                        normals: i,
                        binormals: s
                    }
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                }
                fromJSON(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }
            class Sc extends wc {
                constructor(e = 0, t = 0, n = 1, r = 1, i = 0, s = 2 * Math.PI, o = !1, a = 0) {
                    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a
                }
                getPoint(e, t) {
                    const n = t || new Pn,
                        r = 2 * Math.PI;
                    let i = this.aEndAngle - this.aStartAngle;
                    const s = Math.abs(i) < Number.EPSILON;
                    for (; i < 0;) i += r;
                    for (; i > r;) i -= r;
                    i < Number.EPSILON && (i = s ? 0 : r), !0 !== this.aClockwise || s || (i === r ? i = -r : i -= r);
                    const o = this.aStartAngle + e * i;
                    let a = this.aX + this.xRadius * Math.cos(o),
                        l = this.aY + this.yRadius * Math.sin(o);
                    if (0 !== this.aRotation) {
                        const e = Math.cos(this.aRotation),
                            t = Math.sin(this.aRotation),
                            n = a - this.aX,
                            r = l - this.aY;
                        a = n * e - r * t + this.aX, l = n * t + r * e + this.aY
                    }
                    return n.set(a, l)
                }
                copy(e) {
                    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
            }
            class Mc extends Sc {
                constructor(e, t, n, r, i, s) {
                    super(e, t, n, n, r, i, s), this.isArcCurve = !0, this.type = "ArcCurve"
                }
            }

            function Tc() {
                let e = 0,
                    t = 0,
                    n = 0,
                    r = 0;

                function i(i, s, o, a) {
                    e = i, t = o, n = -3 * i + 3 * s - 2 * o - a, r = 2 * i - 2 * s + o + a
                }
                return {
                    initCatmullRom: function(e, t, n, r, s) {
                        i(t, n, s * (n - e), s * (r - t))
                    },
                    initNonuniformCatmullRom: function(e, t, n, r, s, o, a) {
                        let l = (t - e) / s - (n - e) / (s + o) + (n - t) / o,
                            c = (n - t) / o - (r - t) / (o + a) + (r - n) / a;
                        l *= o, c *= o, i(t, n, l, c)
                    },
                    calc: function(i) {
                        const s = i * i;
                        return e + t * i + n * s + r * (s * i)
                    }
                }
            }
            const Ec = new lr,
                Ac = new Tc,
                Cc = new Tc,
                Rc = new Tc;
            class kc extends wc {
                constructor(e = [], t = !1, n = "centripetal", r = .5) {
                    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r
                }
                getPoint(e, t = new lr) {
                    const n = t,
                        r = this.points,
                        i = r.length,
                        s = (i - (this.closed ? 0 : 1)) * e;
                    let o, a, l = Math.floor(s),
                        c = s - l;
                    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2, c = 1), this.closed || l > 0 ? o = r[(l - 1) % i] : (Ec.subVectors(r[0], r[1]).add(r[0]), o = Ec);
                    const u = r[l % i],
                        p = r[(l + 1) % i];
                    if (this.closed || l + 2 < i ? a = r[(l + 2) % i] : (Ec.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), a = Ec), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        const e = "chordal" === this.curveType ? .5 : .25;
                        let t = Math.pow(o.distanceToSquared(u), e),
                            n = Math.pow(u.distanceToSquared(p), e),
                            r = Math.pow(p.distanceToSquared(a), e);
                        n < 1e-4 && (n = 1), t < 1e-4 && (t = n), r < 1e-4 && (r = n), Ac.initNonuniformCatmullRom(o.x, u.x, p.x, a.x, t, n, r), Cc.initNonuniformCatmullRom(o.y, u.y, p.y, a.y, t, n, r), Rc.initNonuniformCatmullRom(o.z, u.z, p.z, a.z, t, n, r)
                    } else "catmullrom" === this.curveType && (Ac.initCatmullRom(o.x, u.x, p.x, a.x, this.tension), Cc.initCatmullRom(o.y, u.y, p.y, a.y, this.tension), Rc.initCatmullRom(o.z, u.z, p.z, a.z, this.tension));
                    return n.set(Ac.calc(c), Cc.calc(c), Rc.calc(c)), n
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        const n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push((new lr).fromArray(n))
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
            }

            function Pc(e, t, n, r, i) {
                const s = .5 * (r - t),
                    o = .5 * (i - n),
                    a = e * e;
                return (2 * n - 2 * r + s + o) * (e * a) + (-3 * n + 3 * r - 2 * s - o) * a + s * e + n
            }

            function Dc(e, t, n, r) {
                return function(e, t) {
                    const n = 1 - e;
                    return n * n * t
                }(e, t) + function(e, t) {
                    return 2 * (1 - e) * e * t
                }(e, n) + function(e, t) {
                    return e * e * t
                }(e, r)
            }

            function Oc(e, t, n, r, i) {
                return function(e, t) {
                    const n = 1 - e;
                    return n * n * n * t
                }(e, t) + function(e, t) {
                    const n = 1 - e;
                    return 3 * n * n * e * t
                }(e, n) + function(e, t) {
                    return 3 * (1 - e) * e * e * t
                }(e, r) + function(e, t) {
                    return e * e * e * t
                }(e, i)
            }
            class Lc extends wc {
                constructor(e = new Pn, t = new Pn, n = new Pn, r = new Pn) {
                    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
                }
                getPoint(e, t = new Pn) {
                    const n = t,
                        r = this.v0,
                        i = this.v1,
                        s = this.v2,
                        o = this.v3;
                    return n.set(Oc(e, r.x, i.x, s.x, o.x), Oc(e, r.y, i.y, s.y, o.y)), n
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            class Ic extends wc {
                constructor(e = new lr, t = new lr, n = new lr, r = new lr) {
                    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r
                }
                getPoint(e, t = new lr) {
                    const n = t,
                        r = this.v0,
                        i = this.v1,
                        s = this.v2,
                        o = this.v3;
                    return n.set(Oc(e, r.x, i.x, s.x, o.x), Oc(e, r.y, i.y, s.y, o.y), Oc(e, r.z, i.z, s.z, o.z)), n
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            class Fc extends wc {
                constructor(e = new Pn, t = new Pn) {
                    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new Pn) {
                    const n = t;
                    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                getTangent(e, t) {
                    const n = t || new Pn;
                    return n.copy(this.v2).sub(this.v1).normalize(), n
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class Nc extends wc {
                constructor(e = new lr, t = new lr) {
                    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new lr) {
                    const n = t;
                    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class Uc extends wc {
                constructor(e = new Pn, t = new Pn, n = new Pn) {
                    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
                }
                getPoint(e, t = new Pn) {
                    const n = t,
                        r = this.v0,
                        i = this.v1,
                        s = this.v2;
                    return n.set(Dc(e, r.x, i.x, s.x), Dc(e, r.y, i.y, s.y)), n
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class Bc extends wc {
                constructor(e = new lr, t = new lr, n = new lr) {
                    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
                }
                getPoint(e, t = new lr) {
                    const n = t,
                        r = this.v0,
                        i = this.v1,
                        s = this.v2;
                    return n.set(Dc(e, r.x, i.x, s.x), Dc(e, r.y, i.y, s.y), Dc(e, r.z, i.z, s.z)), n
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class jc extends wc {
                constructor(e = []) {
                    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
                }
                getPoint(e, t = new Pn) {
                    const n = t,
                        r = this.points,
                        i = (r.length - 1) * e,
                        s = Math.floor(i),
                        o = i - s,
                        a = r[0 === s ? s : s - 1],
                        l = r[s],
                        c = r[s > r.length - 2 ? r.length - 1 : s + 1],
                        u = r[s > r.length - 3 ? r.length - 1 : s + 2];
                    return n.set(Pc(o, a.x, l.x, c.x, u.x), Pc(o, a.y, l.y, c.y, u.y)), n
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        const n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push((new Pn).fromArray(n))
                    }
                    return this
                }
            }
            var zc = Object.freeze({
                __proto__: null,
                ArcCurve: Mc,
                CatmullRomCurve3: kc,
                CubicBezierCurve: Lc,
                CubicBezierCurve3: Ic,
                EllipseCurve: Sc,
                LineCurve: Fc,
                LineCurve3: Nc,
                QuadraticBezierCurve: Uc,
                QuadraticBezierCurve3: Bc,
                SplineCurve: jc
            });
            class Vc extends wc {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }
                add(e) {
                    this.curves.push(e)
                }
                closePath() {
                    const e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new Fc(t, e))
                }
                getPoint(e, t) {
                    const n = e * this.getLength(),
                        r = this.getCurveLengths();
                    let i = 0;
                    for (; i < r.length;) {
                        if (r[i] >= n) {
                            const e = r[i] - n,
                                s = this.curves[i],
                                o = s.getLength(),
                                a = 0 === o ? 0 : 1 - e / o;
                            return s.getPointAt(a, t)
                        }
                        i++
                    }
                    return null
                }
                getLength() {
                    const e = this.getCurveLengths();
                    return e[e.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const e = [];
                    let t = 0;
                    for (let n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(), e.push(t);
                    return this.cacheLengths = e, e
                }
                getSpacedPoints(e = 40) {
                    const t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]), t
                }
                getPoints(e = 12) {
                    const t = [];
                    let n;
                    for (let r = 0, i = this.curves; r < i.length; r++) {
                        const s = i[r],
                            o = s.isEllipseCurve ? 2 * e : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e,
                            a = s.getPoints(o);
                        for (let e = 0; e < a.length; e++) {
                            const r = a[e];
                            n && n.equals(r) || (t.push(r), n = r)
                        }
                    }
                    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
                }
                copy(e) {
                    super.copy(e), this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        const n = e.curves[t];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = e.autoClose, this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.autoClose = this.autoClose, e.curves = [];
                    for (let t = 0, n = this.curves.length; t < n; t++) {
                        const n = this.curves[t];
                        e.curves.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        const n = e.curves[t];
                        this.curves.push((new zc[n.type]).fromJSON(n))
                    }
                    return this
                }
            }
            class Gc extends Vc {
                constructor(e) {
                    super(), this.type = "Path", this.currentPoint = new Pn, e && this.setFromPoints(e)
                }
                setFromPoints(e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                    return this
                }
                moveTo(e, t) {
                    return this.currentPoint.set(e, t), this
                }
                lineTo(e, t) {
                    const n = new Fc(this.currentPoint.clone(), new Pn(e, t));
                    return this.curves.push(n), this.currentPoint.set(e, t), this
                }
                quadraticCurveTo(e, t, n, r) {
                    const i = new Uc(this.currentPoint.clone(), new Pn(e, t), new Pn(n, r));
                    return this.curves.push(i), this.currentPoint.set(n, r), this
                }
                bezierCurveTo(e, t, n, r, i, s) {
                    const o = new Lc(this.currentPoint.clone(), new Pn(e, t), new Pn(n, r), new Pn(i, s));
                    return this.curves.push(o), this.currentPoint.set(i, s), this
                }
                splineThru(e) {
                    const t = [this.currentPoint.clone()].concat(e),
                        n = new jc(t);
                    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
                }
                arc(e, t, n, r, i, s) {
                    const o = this.currentPoint.x,
                        a = this.currentPoint.y;
                    return this.absarc(e + o, t + a, n, r, i, s), this
                }
                absarc(e, t, n, r, i, s) {
                    return this.absellipse(e, t, n, n, r, i, s), this
                }
                ellipse(e, t, n, r, i, s, o, a) {
                    const l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    return this.absellipse(e + l, t + c, n, r, i, s, o, a), this
                }
                absellipse(e, t, n, r, i, s, o, a) {
                    const l = new Sc(e, t, n, r, i, s, o, a);
                    if (this.curves.length > 0) {
                        const e = l.getPoint(0);
                        e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                    }
                    this.curves.push(l);
                    const c = l.getPoint(1);
                    return this.currentPoint.copy(c), this
                }
                copy(e) {
                    return super.copy(e), this.currentPoint.copy(e.currentPoint), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.currentPoint = this.currentPoint.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }
            class Hc extends Wi {
                constructor(e = [new Pn(0, -.5), new Pn(.5, 0), new Pn(0, .5)], t = 12, n = 0, r = 2 * Math.PI) {
                    super(), this.type = "LatheGeometry", this.parameters = {
                        points: e,
                        segments: t,
                        phiStart: n,
                        phiLength: r
                    }, t = Math.floor(t), r = Mn(r, 0, 2 * Math.PI);
                    const i = [],
                        s = [],
                        o = [],
                        a = [],
                        l = [],
                        c = 1 / t,
                        u = new lr,
                        p = new Pn,
                        h = new lr,
                        d = new lr,
                        f = new lr;
                    let _ = 0,
                        m = 0;
                    for (let t = 0; t <= e.length - 1; t++) switch (t) {
                        case 0:
                            _ = e[t + 1].x - e[t].x, m = e[t + 1].y - e[t].y, h.x = 1 * m, h.y = -_, h.z = 0 * m, f.copy(h), h.normalize(), a.push(h.x, h.y, h.z);
                            break;
                        case e.length - 1:
                            a.push(f.x, f.y, f.z);
                            break;
                        default:
                            _ = e[t + 1].x - e[t].x, m = e[t + 1].y - e[t].y, h.x = 1 * m, h.y = -_, h.z = 0 * m, d.copy(h), h.x += f.x, h.y += f.y, h.z += f.z, h.normalize(), a.push(h.x, h.y, h.z), f.copy(d)
                    }
                    for (let i = 0; i <= t; i++) {
                        const h = n + i * c * r,
                            d = Math.sin(h),
                            f = Math.cos(h);
                        for (let n = 0; n <= e.length - 1; n++) {
                            u.x = e[n].x * d, u.y = e[n].y, u.z = e[n].x * f, s.push(u.x, u.y, u.z), p.x = i / t, p.y = n / (e.length - 1), o.push(p.x, p.y);
                            const r = a[3 * n + 0] * d,
                                c = a[3 * n + 1],
                                h = a[3 * n + 0] * f;
                            l.push(r, c, h)
                        }
                    }
                    for (let n = 0; n < t; n++)
                        for (let t = 0; t < e.length - 1; t++) {
                            const r = t + n * e.length,
                                s = r,
                                o = r + e.length,
                                a = r + e.length + 1,
                                l = r + 1;
                            i.push(s, o, l), i.push(a, l, o)
                        }
                    this.setIndex(i), this.setAttribute("position", new Fi(s, 3)), this.setAttribute("uv", new Fi(o, 2)), this.setAttribute("normal", new Fi(l, 3))
                }
                static fromJSON(e) {
                    return new Hc(e.points, e.segments, e.phiStart, e.phiLength)
                }
            }
            class Wc extends Hc {
                constructor(e = 1, t = 1, n = 4, r = 8) {
                    const i = new Gc;
                    i.absarc(0, -t / 2, e, 1.5 * Math.PI, 0), i.absarc(0, t / 2, e, 0, .5 * Math.PI), super(i.getPoints(n), r), this.type = "CapsuleGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        capSegments: n,
                        radialSegments: r
                    }
                }
                static fromJSON(e) {
                    return new Wc(e.radius, e.length, e.capSegments, e.radialSegments)
                }
            }
            class Kc extends Wi {
                constructor(e = 1, t = 8, n = 0, r = 2 * Math.PI) {
                    super(), this.type = "CircleGeometry", this.parameters = {
                        radius: e,
                        segments: t,
                        thetaStart: n,
                        thetaLength: r
                    }, t = Math.max(3, t);
                    const i = [],
                        s = [],
                        o = [],
                        a = [],
                        l = new lr,
                        c = new Pn;
                    s.push(0, 0, 0), o.push(0, 0, 1), a.push(.5, .5);
                    for (let i = 0, u = 3; i <= t; i++, u += 3) {
                        const p = n + i / t * r;
                        l.x = e * Math.cos(p), l.y = e * Math.sin(p), s.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (s[u] / e + 1) / 2, c.y = (s[u + 1] / e + 1) / 2, a.push(c.x, c.y)
                    }
                    for (let e = 1; e <= t; e++) i.push(e, e + 1, 0);
                    this.setIndex(i), this.setAttribute("position", new Fi(s, 3)), this.setAttribute("normal", new Fi(o, 3)), this.setAttribute("uv", new Fi(a, 2))
                }
                static fromJSON(e) {
                    return new Kc(e.radius, e.segments, e.thetaStart, e.thetaLength)
                }
            }
            class Xc extends Wi {
                constructor(e = 1, t = 1, n = 1, r = 8, i = 1, s = !1, o = 0, a = 2 * Math.PI) {
                    super(), this.type = "CylinderGeometry", this.parameters = {
                        radiusTop: e,
                        radiusBottom: t,
                        height: n,
                        radialSegments: r,
                        heightSegments: i,
                        openEnded: s,
                        thetaStart: o,
                        thetaLength: a
                    };
                    const l = this;
                    r = Math.floor(r), i = Math.floor(i);
                    const c = [],
                        u = [],
                        p = [],
                        h = [];
                    let d = 0;
                    const f = [],
                        _ = n / 2;
                    let m = 0;

                    function g(n) {
                        const i = d,
                            s = new Pn,
                            f = new lr;
                        let g = 0;
                        const v = !0 === n ? e : t,
                            b = !0 === n ? 1 : -1;
                        for (let e = 1; e <= r; e++) u.push(0, _ * b, 0), p.push(0, b, 0), h.push(.5, .5), d++;
                        const x = d;
                        for (let e = 0; e <= r; e++) {
                            const t = e / r * a + o,
                                n = Math.cos(t),
                                i = Math.sin(t);
                            f.x = v * i, f.y = _ * b, f.z = v * n, u.push(f.x, f.y, f.z), p.push(0, b, 0), s.x = .5 * n + .5, s.y = .5 * i * b + .5, h.push(s.x, s.y), d++
                        }
                        for (let e = 0; e < r; e++) {
                            const t = i + e,
                                r = x + e;
                            !0 === n ? c.push(r, r + 1, t) : c.push(r + 1, r, t), g += 3
                        }
                        l.addGroup(m, g, !0 === n ? 1 : 2), m += g
                    }! function() {
                        const s = new lr,
                            g = new lr;
                        let v = 0;
                        const b = (t - e) / n;
                        for (let l = 0; l <= i; l++) {
                            const c = [],
                                m = l / i,
                                v = m * (t - e) + e;
                            for (let e = 0; e <= r; e++) {
                                const t = e / r,
                                    i = t * a + o,
                                    l = Math.sin(i),
                                    f = Math.cos(i);
                                g.x = v * l, g.y = -m * n + _, g.z = v * f, u.push(g.x, g.y, g.z), s.set(l, b, f).normalize(), p.push(s.x, s.y, s.z), h.push(t, 1 - m), c.push(d++)
                            }
                            f.push(c)
                        }
                        for (let e = 0; e < r; e++)
                            for (let t = 0; t < i; t++) {
                                const n = f[t][e],
                                    r = f[t + 1][e],
                                    i = f[t + 1][e + 1],
                                    s = f[t][e + 1];
                                c.push(n, r, s), c.push(r, i, s), v += 6
                            }
                        l.addGroup(m, v, 0), m += v
                    }(), !1 === s && (e > 0 && g(!0), t > 0 && g(!1)), this.setIndex(c), this.setAttribute("position", new Fi(u, 3)), this.setAttribute("normal", new Fi(p, 3)), this.setAttribute("uv", new Fi(h, 2))
                }
                static fromJSON(e) {
                    return new Xc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class qc extends Xc {
                constructor(e = 1, t = 1, n = 8, r = 1, i = !1, s = 0, o = 2 * Math.PI) {
                    super(0, e, t, n, r, i, s, o), this.type = "ConeGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        radialSegments: n,
                        heightSegments: r,
                        openEnded: i,
                        thetaStart: s,
                        thetaLength: o
                    }
                }
                static fromJSON(e) {
                    return new qc(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class Yc extends Wi {
                constructor(e = [], t = [], n = 1, r = 0) {
                    super(), this.type = "PolyhedronGeometry", this.parameters = {
                        vertices: e,
                        indices: t,
                        radius: n,
                        detail: r
                    };
                    const i = [],
                        s = [];

                    function o(e, t, n, r) {
                        const i = r + 1,
                            s = [];
                        for (let r = 0; r <= i; r++) {
                            s[r] = [];
                            const o = e.clone().lerp(n, r / i),
                                a = t.clone().lerp(n, r / i),
                                l = i - r;
                            for (let e = 0; e <= l; e++) s[r][e] = 0 === e && r === i ? o : o.clone().lerp(a, e / l)
                        }
                        for (let e = 0; e < i; e++)
                            for (let t = 0; t < 2 * (i - e) - 1; t++) {
                                const n = Math.floor(t / 2);
                                t % 2 == 0 ? (a(s[e][n + 1]), a(s[e + 1][n]), a(s[e][n])) : (a(s[e][n + 1]), a(s[e + 1][n + 1]), a(s[e + 1][n]))
                            }
                    }

                    function a(e) {
                        i.push(e.x, e.y, e.z)
                    }

                    function l(t, n) {
                        const r = 3 * t;
                        n.x = e[r + 0], n.y = e[r + 1], n.z = e[r + 2]
                    }

                    function c(e, t, n, r) {
                        r < 0 && 1 === e.x && (s[t] = e.x - 1), 0 === n.x && 0 === n.z && (s[t] = r / 2 / Math.PI + .5)
                    }

                    function u(e) {
                        return Math.atan2(e.z, -e.x)
                    }! function(e) {
                        const n = new lr,
                            r = new lr,
                            i = new lr;
                        for (let s = 0; s < t.length; s += 3) l(t[s + 0], n), l(t[s + 1], r), l(t[s + 2], i), o(n, r, i, e)
                    }(r),
                    function(e) {
                        const t = new lr;
                        for (let n = 0; n < i.length; n += 3) t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2], t.normalize().multiplyScalar(e), i[n + 0] = t.x, i[n + 1] = t.y, i[n + 2] = t.z
                    }(n),
                    function() {
                        const e = new lr;
                        for (let n = 0; n < i.length; n += 3) {
                            e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2];
                            const r = u(e) / 2 / Math.PI + .5,
                                o = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
                            s.push(r, 1 - o)
                        }
                        var t;
                        (function() {
                            const e = new lr,
                                t = new lr,
                                n = new lr,
                                r = new lr,
                                o = new Pn,
                                a = new Pn,
                                l = new Pn;
                            for (let p = 0, h = 0; p < i.length; p += 9, h += 6) {
                                e.set(i[p + 0], i[p + 1], i[p + 2]), t.set(i[p + 3], i[p + 4], i[p + 5]), n.set(i[p + 6], i[p + 7], i[p + 8]), o.set(s[h + 0], s[h + 1]), a.set(s[h + 2], s[h + 3]), l.set(s[h + 4], s[h + 5]), r.copy(e).add(t).add(n).divideScalar(3);
                                const d = u(r);
                                c(o, h + 0, e, d), c(a, h + 2, t, d), c(l, h + 4, n, d)
                            }
                        })(),
                        function() {
                            for (let e = 0; e < s.length; e += 6) {
                                const t = s[e + 0],
                                    n = s[e + 2],
                                    r = s[e + 4],
                                    i = Math.max(t, n, r),
                                    o = Math.min(t, n, r);
                                i > .9 && o < .1 && (t < .2 && (s[e + 0] += 1), n < .2 && (s[e + 2] += 1), r < .2 && (s[e + 4] += 1))
                            }
                        }()
                    }(), this.setAttribute("position", new Fi(i, 3)), this.setAttribute("normal", new Fi(i.slice(), 3)), this.setAttribute("uv", new Fi(s, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
                }
                static fromJSON(e) {
                    return new Yc(e.vertices, e.indices, e.radius, e.details)
                }
            }
            class Zc extends Yc {
                constructor(e = 1, t = 0) {
                    const n = (1 + Math.sqrt(5)) / 2,
                        r = 1 / n;
                    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new Zc(e.radius, e.detail)
                }
            }
            const Jc = new lr,
                $c = new lr,
                Qc = new lr,
                eu = new yi;
            class tu extends Wi {
                constructor(e = null, t = 1) {
                    if (super(), this.type = "EdgesGeometry", this.parameters = {
                            geometry: e,
                            thresholdAngle: t
                        }, null !== e) {
                        const n = 4,
                            r = Math.pow(10, n),
                            i = Math.cos(yn * t),
                            s = e.getIndex(),
                            o = e.getAttribute("position"),
                            a = s ? s.count : o.count,
                            l = [0, 0, 0],
                            c = ["a", "b", "c"],
                            u = new Array(3),
                            p = {},
                            h = [];
                        for (let e = 0; e < a; e += 3) {
                            s ? (l[0] = s.getX(e), l[1] = s.getX(e + 1), l[2] = s.getX(e + 2)) : (l[0] = e, l[1] = e + 1, l[2] = e + 2);
                            const {
                                a: t,
                                b: n,
                                c: a
                            } = eu;
                            if (t.fromBufferAttribute(o, l[0]), n.fromBufferAttribute(o, l[1]), a.fromBufferAttribute(o, l[2]), eu.getNormal(Qc), u[0] = `${Math.round(t.x*r)},${Math.round(t.y*r)},${Math.round(t.z*r)}`, u[1] = `${Math.round(n.x*r)},${Math.round(n.y*r)},${Math.round(n.z*r)}`, u[2] = `${Math.round(a.x*r)},${Math.round(a.y*r)},${Math.round(a.z*r)}`, u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0])
                                for (let e = 0; e < 3; e++) {
                                    const t = (e + 1) % 3,
                                        n = u[e],
                                        r = u[t],
                                        s = eu[c[e]],
                                        o = eu[c[t]],
                                        a = `${n}_${r}`,
                                        d = `${r}_${n}`;
                                    d in p && p[d] ? (Qc.dot(p[d].normal) <= i && (h.push(s.x, s.y, s.z), h.push(o.x, o.y, o.z)), p[d] = null) : a in p || (p[a] = {
                                        index0: l[e],
                                        index1: l[t],
                                        normal: Qc.clone()
                                    })
                                }
                        }
                        for (const e in p)
                            if (p[e]) {
                                const {
                                    index0: t,
                                    index1: n
                                } = p[e];
                                Jc.fromBufferAttribute(o, t), $c.fromBufferAttribute(o, n), h.push(Jc.x, Jc.y, Jc.z), h.push($c.x, $c.y, $c.z)
                            }
                        this.setAttribute("position", new Fi(h, 3))
                    }
                }
            }
            class nu extends Gc {
                constructor(e) {
                    super(e), this.uuid = Sn(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(e) {
                    const t = [];
                    for (let n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
                    return t
                }
                extractPoints(e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                }
                copy(e) {
                    super.copy(e), this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        const n = e.holes[t];
                        this.holes.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.uuid = this.uuid, e.holes = [];
                    for (let t = 0, n = this.holes.length; t < n; t++) {
                        const n = this.holes[t];
                        e.holes.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        const n = e.holes[t];
                        this.holes.push((new Gc).fromJSON(n))
                    }
                    return this
                }
            }

            function ru(e, t, n, r, i) {
                let s, o;
                if (i === function(e, t, n, r) {
                        let i = 0;
                        for (let s = t, o = n - r; s < n; s += r) i += (e[o] - e[s]) * (e[s + 1] + e[o + 1]), o = s;
                        return i
                    }(e, t, n, r) > 0)
                    for (s = t; s < n; s += r) o = Mu(s, e[s], e[s + 1], o);
                else
                    for (s = n - r; s >= t; s -= r) o = Mu(s, e[s], e[s + 1], o);
                return o && vu(o, o.next) && (Tu(o), o = o.next), o
            }

            function iu(e, t) {
                if (!e) return e;
                t || (t = e);
                let n, r = e;
                do {
                    if (n = !1, r.steiner || !vu(r, r.next) && 0 !== gu(r.prev, r, r.next)) r = r.next;
                    else {
                        if (Tu(r), r = t = r.prev, r === r.next) break;
                        n = !0
                    }
                } while (n || r !== t);
                return t
            }

            function su(e, t, n, r, i, s, o) {
                if (!e) return;
                !o && s && function(e, t, n, r) {
                    let i = e;
                    do {
                        null === i.z && (i.z = du(i.x, i.y, t, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                    } while (i !== e);
                    i.prevZ.nextZ = null, i.prevZ = null,
                        function(e) {
                            let t, n, r, i, s, o, a, l, c = 1;
                            do {
                                for (n = e, e = null, s = null, o = 0; n;) {
                                    for (o++, r = n, a = 0, t = 0; t < c && (a++, r = r.nextZ, r); t++);
                                    for (l = c; a > 0 || l > 0 && r;) 0 !== a && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : e = i, i.prevZ = s, s = i;
                                    n = r
                                }
                                s.nextZ = null, c *= 2
                            } while (o > 1)
                        }(i)
                }(e, r, i, s);
                let a, l, c = e;
                for (; e.prev !== e.next;)
                    if (a = e.prev, l = e.next, s ? au(e, r, i, s) : ou(e)) t.push(a.i / n), t.push(e.i / n), t.push(l.i / n), Tu(e), e = l.next, c = l.next;
                    else if ((e = l) === c) {
                    o ? 1 === o ? su(e = lu(iu(e), t, n), t, n, r, i, s, 2) : 2 === o && cu(e, t, n, r, i, s) : su(iu(e), t, n, r, i, s, 1);
                    break
                }
            }

            function ou(e) {
                const t = e.prev,
                    n = e,
                    r = e.next;
                if (gu(t, n, r) >= 0) return !1;
                let i = e.next.next;
                for (; i !== e.prev;) {
                    if (_u(t.x, t.y, n.x, n.y, r.x, r.y, i.x, i.y) && gu(i.prev, i, i.next) >= 0) return !1;
                    i = i.next
                }
                return !0
            }

            function au(e, t, n, r) {
                const i = e.prev,
                    s = e,
                    o = e.next;
                if (gu(i, s, o) >= 0) return !1;
                const a = i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x,
                    l = i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y,
                    c = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x,
                    u = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y,
                    p = du(a, l, t, n, r),
                    h = du(c, u, t, n, r);
                let d = e.prevZ,
                    f = e.nextZ;
                for (; d && d.z >= p && f && f.z <= h;) {
                    if (d !== e.prev && d !== e.next && _u(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && gu(d.prev, d, d.next) >= 0) return !1;
                    if (d = d.prevZ, f !== e.prev && f !== e.next && _u(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) && gu(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                for (; d && d.z >= p;) {
                    if (d !== e.prev && d !== e.next && _u(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && gu(d.prev, d, d.next) >= 0) return !1;
                    d = d.prevZ
                }
                for (; f && f.z <= h;) {
                    if (f !== e.prev && f !== e.next && _u(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) && gu(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                return !0
            }

            function lu(e, t, n) {
                let r = e;
                do {
                    const i = r.prev,
                        s = r.next.next;
                    !vu(i, s) && bu(i, r, r.next, s) && wu(i, s) && wu(s, i) && (t.push(i.i / n), t.push(r.i / n), t.push(s.i / n), Tu(r), Tu(r.next), r = e = s), r = r.next
                } while (r !== e);
                return iu(r)
            }

            function cu(e, t, n, r, i, s) {
                let o = e;
                do {
                    let e = o.next.next;
                    for (; e !== o.prev;) {
                        if (o.i !== e.i && mu(o, e)) {
                            let a = Su(o, e);
                            return o = iu(o, o.next), a = iu(a, a.next), su(o, t, n, r, i, s), void su(a, t, n, r, i, s)
                        }
                        e = e.next
                    }
                    o = o.next
                } while (o !== e)
            }

            function uu(e, t) {
                return e.x - t.x
            }

            function pu(e, t) {
                if (t = function(e, t) {
                        let n = t;
                        const r = e.x,
                            i = e.y;
                        let s, o = -1 / 0;
                        do {
                            if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
                                const e = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (e <= r && e > o) {
                                    if (o = e, e === r) {
                                        if (i === n.y) return n;
                                        if (i === n.next.y) return n.next
                                    }
                                    s = n.x < n.next.x ? n : n.next
                                }
                            }
                            n = n.next
                        } while (n !== t);
                        if (!s) return null;
                        if (r === o) return s;
                        const a = s,
                            l = s.x,
                            c = s.y;
                        let u, p = 1 / 0;
                        n = s;
                        do {
                            r >= n.x && n.x >= l && r !== n.x && _u(i < c ? r : o, i, l, c, i < c ? o : r, i, n.x, n.y) && (u = Math.abs(i - n.y) / (r - n.x), wu(n, e) && (u < p || u === p && (n.x > s.x || n.x === s.x && hu(s, n))) && (s = n, p = u)), n = n.next
                        } while (n !== a);
                        return s
                    }(e, t)) {
                    const n = Su(t, e);
                    iu(t, t.next), iu(n, n.next)
                }
            }

            function hu(e, t) {
                return gu(e.prev, e, t.prev) < 0 && gu(t.next, e, e.next) < 0
            }

            function du(e, t, n, r, i) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }

            function fu(e) {
                let t = e,
                    n = e;
                do {
                    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
                } while (t !== e);
                return n
            }

            function _u(e, t, n, r, i, s, o, a) {
                return (i - o) * (t - a) - (e - o) * (s - a) >= 0 && (e - o) * (r - a) - (n - o) * (t - a) >= 0 && (n - o) * (s - a) - (i - o) * (r - a) >= 0
            }

            function mu(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
                    let n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && bu(n, n.next, e, t)) return !0;
                        n = n.next
                    } while (n !== e);
                    return !1
                }(e, t) && (wu(e, t) && wu(t, e) && function(e, t) {
                    let n = e,
                        r = !1;
                    const i = (e.x + t.x) / 2,
                        s = (e.y + t.y) / 2;
                    do {
                        n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                    } while (n !== e);
                    return r
                }(e, t) && (gu(e.prev, e, t.prev) || gu(e, t.prev, t)) || vu(e, t) && gu(e.prev, e, e.next) > 0 && gu(t.prev, t, t.next) > 0)
            }

            function gu(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function vu(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function bu(e, t, n, r) {
                const i = yu(gu(e, t, n)),
                    s = yu(gu(e, t, r)),
                    o = yu(gu(n, r, e)),
                    a = yu(gu(n, r, t));
                return i !== s && o !== a || !(0 !== i || !xu(e, n, t)) || !(0 !== s || !xu(e, r, t)) || !(0 !== o || !xu(n, e, r)) || !(0 !== a || !xu(n, t, r))
            }

            function xu(e, t, n) {
                return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
            }

            function yu(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }

            function wu(e, t) {
                return gu(e.prev, e, e.next) < 0 ? gu(e, t, e.next) >= 0 && gu(e, e.prev, t) >= 0 : gu(e, t, e.prev) < 0 || gu(e, e.next, t) < 0
            }

            function Su(e, t) {
                const n = new Eu(e.i, e.x, e.y),
                    r = new Eu(t.i, t.x, t.y),
                    i = e.next,
                    s = t.prev;
                return e.next = t, t.prev = e, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r
            }

            function Mu(e, t, n, r) {
                const i = new Eu(e, t, n);
                return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
            }

            function Tu(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function Eu(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            class Au {
                static area(e) {
                    const t = e.length;
                    let n = 0;
                    for (let r = t - 1, i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
                    return .5 * n
                }
                static isClockWise(e) {
                    return Au.area(e) < 0
                }
                static triangulateShape(e, t) {
                    const n = [],
                        r = [],
                        i = [];
                    Cu(e), Ru(n, e);
                    let s = e.length;
                    t.forEach(Cu);
                    for (let e = 0; e < t.length; e++) r.push(s), s += t[e].length, Ru(n, t[e]);
                    const o = function(e, t, n = 2) {
                        const r = t && t.length,
                            i = r ? t[0] * n : e.length;
                        let s = ru(e, 0, i, n, !0);
                        const o = [];
                        if (!s || s.next === s.prev) return o;
                        let a, l, c, u, p, h, d;
                        if (r && (s = function(e, t, n, r) {
                                const i = [];
                                let s, o, a, l, c;
                                for (s = 0, o = t.length; s < o; s++) a = t[s] * r, l = s < o - 1 ? t[s + 1] * r : e.length, c = ru(e, a, l, r, !1), c === c.next && (c.steiner = !0), i.push(fu(c));
                                for (i.sort(uu), s = 0; s < i.length; s++) pu(i[s], n), n = iu(n, n.next);
                                return n
                            }(e, t, s, n)), e.length > 80 * n) {
                            a = c = e[0], l = u = e[1];
                            for (let t = n; t < i; t += n) p = e[t], h = e[t + 1], p < a && (a = p), h < l && (l = h), p > c && (c = p), h > u && (u = h);
                            d = Math.max(c - a, u - l), d = 0 !== d ? 1 / d : 0
                        }
                        return su(s, o, n, a, l, d), o
                    }(n, r);
                    for (let e = 0; e < o.length; e += 3) i.push(o.slice(e, e + 3));
                    return i
                }
            }

            function Cu(e) {
                const t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function Ru(e, t) {
                for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }
            class ku extends Wi {
                constructor(e = new nu([new Pn(.5, .5), new Pn(-.5, .5), new Pn(-.5, -.5), new Pn(.5, -.5)]), t = {}) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: e,
                        options: t
                    }, e = Array.isArray(e) ? e : [e];
                    const n = this,
                        r = [],
                        i = [];
                    for (let t = 0, n = e.length; t < n; t++) s(e[t]);

                    function s(e) {
                        const s = [],
                            o = void 0 !== t.curveSegments ? t.curveSegments : 12,
                            a = void 0 !== t.steps ? t.steps : 1,
                            l = void 0 !== t.depth ? t.depth : 1;
                        let c = void 0 === t.bevelEnabled || t.bevelEnabled,
                            u = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
                            p = void 0 !== t.bevelSize ? t.bevelSize : u - .1,
                            h = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                            d = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
                        const f = t.extrudePath,
                            _ = void 0 !== t.UVGenerator ? t.UVGenerator : Pu;
                        let m, g, v, b, x, y = !1;
                        f && (m = f.getSpacedPoints(a), y = !0, c = !1, g = f.computeFrenetFrames(a, !1), v = new lr, b = new lr, x = new lr), c || (d = 0, u = 0, p = 0, h = 0);
                        const w = e.extractPoints(o);
                        let S = w.shape;
                        const M = w.holes;
                        if (!Au.isClockWise(S)) {
                            S = S.reverse();
                            for (let e = 0, t = M.length; e < t; e++) {
                                const t = M[e];
                                Au.isClockWise(t) && (M[e] = t.reverse())
                            }
                        }
                        const T = Au.triangulateShape(S, M),
                            E = S;
                        for (let e = 0, t = M.length; e < t; e++) {
                            const t = M[e];
                            S = S.concat(t)
                        }

                        function A(e, t, n) {
                            return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                        }
                        const C = S.length,
                            R = T.length;

                        function k(e, t, n) {
                            let r, i, s;
                            const o = e.x - t.x,
                                a = e.y - t.y,
                                l = n.x - e.x,
                                c = n.y - e.y,
                                u = o * o + a * a,
                                p = o * c - a * l;
                            if (Math.abs(p) > Number.EPSILON) {
                                const p = Math.sqrt(u),
                                    h = Math.sqrt(l * l + c * c),
                                    d = t.x - a / p,
                                    f = t.y + o / p,
                                    _ = ((n.x - c / h - d) * c - (n.y + l / h - f) * l) / (o * c - a * l);
                                r = d + o * _ - e.x, i = f + a * _ - e.y;
                                const m = r * r + i * i;
                                if (m <= 2) return new Pn(r, i);
                                s = Math.sqrt(m / 2)
                            } else {
                                let e = !1;
                                o > Number.EPSILON ? l > Number.EPSILON && (e = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(a) === Math.sign(c) && (e = !0), e ? (r = -a, i = o, s = Math.sqrt(u)) : (r = o, i = a, s = Math.sqrt(u / 2))
                            }
                            return new Pn(r / s, i / s)
                        }
                        const P = [];
                        for (let e = 0, t = E.length, n = t - 1, r = e + 1; e < t; e++, n++, r++) n === t && (n = 0), r === t && (r = 0), P[e] = k(E[e], E[n], E[r]);
                        const D = [];
                        let O, L = P.concat();
                        for (let e = 0, t = M.length; e < t; e++) {
                            const t = M[e];
                            O = [];
                            for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++, r++, i++) r === n && (r = 0), i === n && (i = 0), O[e] = k(t[e], t[r], t[i]);
                            D.push(O), L = L.concat(O)
                        }
                        for (let e = 0; e < d; e++) {
                            const t = e / d,
                                n = u * Math.cos(t * Math.PI / 2),
                                r = p * Math.sin(t * Math.PI / 2) + h;
                            for (let e = 0, t = E.length; e < t; e++) {
                                const t = A(E[e], P[e], r);
                                N(t.x, t.y, -n)
                            }
                            for (let e = 0, t = M.length; e < t; e++) {
                                const t = M[e];
                                O = D[e];
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = A(t[e], O[e], r);
                                    N(i.x, i.y, -n)
                                }
                            }
                        }
                        const I = p + h;
                        for (let e = 0; e < C; e++) {
                            const t = c ? A(S[e], L[e], I) : S[e];
                            y ? (b.copy(g.normals[0]).multiplyScalar(t.x), v.copy(g.binormals[0]).multiplyScalar(t.y), x.copy(m[0]).add(b).add(v), N(x.x, x.y, x.z)) : N(t.x, t.y, 0)
                        }
                        for (let e = 1; e <= a; e++)
                            for (let t = 0; t < C; t++) {
                                const n = c ? A(S[t], L[t], I) : S[t];
                                y ? (b.copy(g.normals[e]).multiplyScalar(n.x), v.copy(g.binormals[e]).multiplyScalar(n.y), x.copy(m[e]).add(b).add(v), N(x.x, x.y, x.z)) : N(n.x, n.y, l / a * e)
                            }
                        for (let e = d - 1; e >= 0; e--) {
                            const t = e / d,
                                n = u * Math.cos(t * Math.PI / 2),
                                r = p * Math.sin(t * Math.PI / 2) + h;
                            for (let e = 0, t = E.length; e < t; e++) {
                                const t = A(E[e], P[e], r);
                                N(t.x, t.y, l + n)
                            }
                            for (let e = 0, t = M.length; e < t; e++) {
                                const t = M[e];
                                O = D[e];
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = A(t[e], O[e], r);
                                    y ? N(i.x, i.y + m[a - 1].y, m[a - 1].x + n) : N(i.x, i.y, l + n)
                                }
                            }
                        }

                        function F(e, t) {
                            let n = e.length;
                            for (; --n >= 0;) {
                                const r = n;
                                let i = n - 1;
                                i < 0 && (i = e.length - 1);
                                for (let e = 0, n = a + 2 * d; e < n; e++) {
                                    const n = C * e,
                                        s = C * (e + 1);
                                    B(t + r + n, t + i + n, t + i + s, t + r + s)
                                }
                            }
                        }

                        function N(e, t, n) {
                            s.push(e), s.push(t), s.push(n)
                        }

                        function U(e, t, i) {
                            j(e), j(t), j(i);
                            const s = r.length / 3,
                                o = _.generateTopUV(n, r, s - 3, s - 2, s - 1);
                            z(o[0]), z(o[1]), z(o[2])
                        }

                        function B(e, t, i, s) {
                            j(e), j(t), j(s), j(t), j(i), j(s);
                            const o = r.length / 3,
                                a = _.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);
                            z(a[0]), z(a[1]), z(a[3]), z(a[1]), z(a[2]), z(a[3])
                        }

                        function j(e) {
                            r.push(s[3 * e + 0]), r.push(s[3 * e + 1]), r.push(s[3 * e + 2])
                        }

                        function z(e) {
                            i.push(e.x), i.push(e.y)
                        }! function() {
                            const e = r.length / 3;
                            if (c) {
                                let e = 0,
                                    t = C * e;
                                for (let e = 0; e < R; e++) {
                                    const n = T[e];
                                    U(n[2] + t, n[1] + t, n[0] + t)
                                }
                                e = a + 2 * d, t = C * e;
                                for (let e = 0; e < R; e++) {
                                    const n = T[e];
                                    U(n[0] + t, n[1] + t, n[2] + t)
                                }
                            } else {
                                for (let e = 0; e < R; e++) {
                                    const t = T[e];
                                    U(t[2], t[1], t[0])
                                }
                                for (let e = 0; e < R; e++) {
                                    const t = T[e];
                                    U(t[0] + C * a, t[1] + C * a, t[2] + C * a)
                                }
                            }
                            n.addGroup(e, r.length / 3 - e, 0)
                        }(),
                        function() {
                            const e = r.length / 3;
                            let t = 0;
                            F(E, t), t += E.length;
                            for (let e = 0, n = M.length; e < n; e++) {
                                const n = M[e];
                                F(n, t), t += n.length
                            }
                            n.addGroup(e, r.length / 3 - e, 1)
                        }()
                    }
                    this.setAttribute("position", new Fi(r, 3)), this.setAttribute("uv", new Fi(i, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    const e = super.toJSON();
                    return function(e, t, n) {
                        if (n.shapes = [], Array.isArray(e))
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = e[t];
                                n.shapes.push(r.uuid)
                            } else n.shapes.push(e.uuid);
                        return n.options = Object.assign({}, t), void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
                    }(this.parameters.shapes, this.parameters.options, e)
                }
                static fromJSON(e, t) {
                    const n = [];
                    for (let r = 0, i = e.shapes.length; r < i; r++) {
                        const i = t[e.shapes[r]];
                        n.push(i)
                    }
                    const r = e.options.extrudePath;
                    return void 0 !== r && (e.options.extrudePath = (new zc[r.type]).fromJSON(r)), new ku(n, e.options)
                }
            }
            const Pu = {
                generateTopUV: function(e, t, n, r, i) {
                    const s = t[3 * n],
                        o = t[3 * n + 1],
                        a = t[3 * r],
                        l = t[3 * r + 1],
                        c = t[3 * i],
                        u = t[3 * i + 1];
                    return [new Pn(s, o), new Pn(a, l), new Pn(c, u)]
                },
                generateSideWallUV: function(e, t, n, r, i, s) {
                    const o = t[3 * n],
                        a = t[3 * n + 1],
                        l = t[3 * n + 2],
                        c = t[3 * r],
                        u = t[3 * r + 1],
                        p = t[3 * r + 2],
                        h = t[3 * i],
                        d = t[3 * i + 1],
                        f = t[3 * i + 2],
                        _ = t[3 * s],
                        m = t[3 * s + 1],
                        g = t[3 * s + 2];
                    return Math.abs(a - u) < Math.abs(o - c) ? [new Pn(o, 1 - l), new Pn(c, 1 - p), new Pn(h, 1 - f), new Pn(_, 1 - g)] : [new Pn(a, 1 - l), new Pn(u, 1 - p), new Pn(d, 1 - f), new Pn(m, 1 - g)]
                }
            };
            class Du extends Yc {
                constructor(e = 1, t = 0) {
                    const n = (1 + Math.sqrt(5)) / 2;
                    super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new Du(e.radius, e.detail)
                }
            }
            class Ou extends Yc {
                constructor(e = 1, t = 0) {
                    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new Ou(e.radius, e.detail)
                }
            }
            class Lu extends Wi {
                constructor(e = .5, t = 1, n = 8, r = 1, i = 0, s = 2 * Math.PI) {
                    super(), this.type = "RingGeometry", this.parameters = {
                        innerRadius: e,
                        outerRadius: t,
                        thetaSegments: n,
                        phiSegments: r,
                        thetaStart: i,
                        thetaLength: s
                    }, n = Math.max(3, n);
                    const o = [],
                        a = [],
                        l = [],
                        c = [];
                    let u = e;
                    const p = (t - e) / (r = Math.max(1, r)),
                        h = new lr,
                        d = new Pn;
                    for (let e = 0; e <= r; e++) {
                        for (let e = 0; e <= n; e++) {
                            const r = i + e / n * s;
                            h.x = u * Math.cos(r), h.y = u * Math.sin(r), a.push(h.x, h.y, h.z), l.push(0, 0, 1), d.x = (h.x / t + 1) / 2, d.y = (h.y / t + 1) / 2, c.push(d.x, d.y)
                        }
                        u += p
                    }
                    for (let e = 0; e < r; e++) {
                        const t = e * (n + 1);
                        for (let e = 0; e < n; e++) {
                            const r = e + t,
                                i = r,
                                s = r + n + 1,
                                a = r + n + 2,
                                l = r + 1;
                            o.push(i, s, l), o.push(s, a, l)
                        }
                    }
                    this.setIndex(o), this.setAttribute("position", new Fi(a, 3)), this.setAttribute("normal", new Fi(l, 3)), this.setAttribute("uv", new Fi(c, 2))
                }
                static fromJSON(e) {
                    return new Lu(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
                }
            }
            class Iu extends Wi {
                constructor(e = new nu([new Pn(0, .5), new Pn(-.5, -.5), new Pn(.5, -.5)]), t = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: e,
                        curveSegments: t
                    };
                    const n = [],
                        r = [],
                        i = [],
                        s = [];
                    let o = 0,
                        a = 0;
                    if (!1 === Array.isArray(e)) l(e);
                    else
                        for (let t = 0; t < e.length; t++) l(e[t]), this.addGroup(o, a, t), o += a, a = 0;

                    function l(e) {
                        const o = r.length / 3,
                            l = e.extractPoints(t);
                        let c = l.shape;
                        const u = l.holes;
                        !1 === Au.isClockWise(c) && (c = c.reverse());
                        for (let e = 0, t = u.length; e < t; e++) {
                            const t = u[e];
                            !0 === Au.isClockWise(t) && (u[e] = t.reverse())
                        }
                        const p = Au.triangulateShape(c, u);
                        for (let e = 0, t = u.length; e < t; e++) {
                            const t = u[e];
                            c = c.concat(t)
                        }
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            r.push(t.x, t.y, 0), i.push(0, 0, 1), s.push(t.x, t.y)
                        }
                        for (let e = 0, t = p.length; e < t; e++) {
                            const t = p[e],
                                r = t[0] + o,
                                i = t[1] + o,
                                s = t[2] + o;
                            n.push(r, i, s), a += 3
                        }
                    }
                    this.setIndex(n), this.setAttribute("position", new Fi(r, 3)), this.setAttribute("normal", new Fi(i, 3)), this.setAttribute("uv", new Fi(s, 2))
                }
                toJSON() {
                    const e = super.toJSON();
                    return function(e, t) {
                        if (t.shapes = [], Array.isArray(e))
                            for (let n = 0, r = e.length; n < r; n++) {
                                const r = e[n];
                                t.shapes.push(r.uuid)
                            } else t.shapes.push(e.uuid);
                        return t
                    }(this.parameters.shapes, e)
                }
                static fromJSON(e, t) {
                    const n = [];
                    for (let r = 0, i = e.shapes.length; r < i; r++) {
                        const i = t[e.shapes[r]];
                        n.push(i)
                    }
                    return new Iu(n, e.curveSegments)
                }
            }
            class Fu extends Wi {
                constructor(e = 1, t = 32, n = 16, r = 0, i = 2 * Math.PI, s = 0, o = Math.PI) {
                    super(), this.type = "SphereGeometry", this.parameters = {
                        radius: e,
                        widthSegments: t,
                        heightSegments: n,
                        phiStart: r,
                        phiLength: i,
                        thetaStart: s,
                        thetaLength: o
                    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
                    const a = Math.min(s + o, Math.PI);
                    let l = 0;
                    const c = [],
                        u = new lr,
                        p = new lr,
                        h = [],
                        d = [],
                        f = [],
                        _ = [];
                    for (let h = 0; h <= n; h++) {
                        const m = [],
                            g = h / n;
                        let v = 0;
                        0 == h && 0 == s ? v = .5 / t : h == n && a == Math.PI && (v = -.5 / t);
                        for (let n = 0; n <= t; n++) {
                            const a = n / t;
                            u.x = -e * Math.cos(r + a * i) * Math.sin(s + g * o), u.y = e * Math.cos(s + g * o), u.z = e * Math.sin(r + a * i) * Math.sin(s + g * o), d.push(u.x, u.y, u.z), p.copy(u).normalize(), f.push(p.x, p.y, p.z), _.push(a + v, 1 - g), m.push(l++)
                        }
                        c.push(m)
                    }
                    for (let e = 0; e < n; e++)
                        for (let r = 0; r < t; r++) {
                            const t = c[e][r + 1],
                                i = c[e][r],
                                o = c[e + 1][r],
                                l = c[e + 1][r + 1];
                            (0 !== e || s > 0) && h.push(t, i, l), (e !== n - 1 || a < Math.PI) && h.push(i, o, l)
                        }
                    this.setIndex(h), this.setAttribute("position", new Fi(d, 3)), this.setAttribute("normal", new Fi(f, 3)), this.setAttribute("uv", new Fi(_, 2))
                }
                static fromJSON(e) {
                    return new Fu(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
                }
            }
            class Nu extends Yc {
                constructor(e = 1, t = 0) {
                    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new Nu(e.radius, e.detail)
                }
            }
            class Uu extends Wi {
                constructor(e = 1, t = .4, n = 8, r = 6, i = 2 * Math.PI) {
                    super(), this.type = "TorusGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        radialSegments: n,
                        tubularSegments: r,
                        arc: i
                    }, n = Math.floor(n), r = Math.floor(r);
                    const s = [],
                        o = [],
                        a = [],
                        l = [],
                        c = new lr,
                        u = new lr,
                        p = new lr;
                    for (let s = 0; s <= n; s++)
                        for (let h = 0; h <= r; h++) {
                            const d = h / r * i,
                                f = s / n * Math.PI * 2;
                            u.x = (e + t * Math.cos(f)) * Math.cos(d), u.y = (e + t * Math.cos(f)) * Math.sin(d), u.z = t * Math.sin(f), o.push(u.x, u.y, u.z), c.x = e * Math.cos(d), c.y = e * Math.sin(d), p.subVectors(u, c).normalize(), a.push(p.x, p.y, p.z), l.push(h / r), l.push(s / n)
                        }
                    for (let e = 1; e <= n; e++)
                        for (let t = 1; t <= r; t++) {
                            const n = (r + 1) * e + t - 1,
                                i = (r + 1) * (e - 1) + t - 1,
                                o = (r + 1) * (e - 1) + t,
                                a = (r + 1) * e + t;
                            s.push(n, i, a), s.push(i, o, a)
                        }
                    this.setIndex(s), this.setAttribute("position", new Fi(o, 3)), this.setAttribute("normal", new Fi(a, 3)), this.setAttribute("uv", new Fi(l, 2))
                }
                static fromJSON(e) {
                    return new Uu(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
                }
            }
            class Bu extends Wi {
                constructor(e = 1, t = .4, n = 64, r = 8, i = 2, s = 3) {
                    super(), this.type = "TorusKnotGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        tubularSegments: n,
                        radialSegments: r,
                        p: i,
                        q: s
                    }, n = Math.floor(n), r = Math.floor(r);
                    const o = [],
                        a = [],
                        l = [],
                        c = [],
                        u = new lr,
                        p = new lr,
                        h = new lr,
                        d = new lr,
                        f = new lr,
                        _ = new lr,
                        m = new lr;
                    for (let o = 0; o <= n; ++o) {
                        const v = o / n * i * Math.PI * 2;
                        g(v, i, s, e, h), g(v + .01, i, s, e, d), _.subVectors(d, h), m.addVectors(d, h), f.crossVectors(_, m), m.crossVectors(f, _), f.normalize(), m.normalize();
                        for (let e = 0; e <= r; ++e) {
                            const i = e / r * Math.PI * 2,
                                s = -t * Math.cos(i),
                                d = t * Math.sin(i);
                            u.x = h.x + (s * m.x + d * f.x), u.y = h.y + (s * m.y + d * f.y), u.z = h.z + (s * m.z + d * f.z), a.push(u.x, u.y, u.z), p.subVectors(u, h).normalize(), l.push(p.x, p.y, p.z), c.push(o / n), c.push(e / r)
                        }
                    }
                    for (let e = 1; e <= n; e++)
                        for (let t = 1; t <= r; t++) {
                            const n = (r + 1) * (e - 1) + (t - 1),
                                i = (r + 1) * e + (t - 1),
                                s = (r + 1) * e + t,
                                a = (r + 1) * (e - 1) + t;
                            o.push(n, i, a), o.push(i, s, a)
                        }

                    function g(e, t, n, r, i) {
                        const s = Math.cos(e),
                            o = Math.sin(e),
                            a = n / t * e,
                            l = Math.cos(a);
                        i.x = r * (2 + l) * .5 * s, i.y = r * (2 + l) * o * .5, i.z = r * Math.sin(a) * .5
                    }
                    this.setIndex(o), this.setAttribute("position", new Fi(a, 3)), this.setAttribute("normal", new Fi(l, 3)), this.setAttribute("uv", new Fi(c, 2))
                }
                static fromJSON(e) {
                    return new Bu(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
                }
            }
            class ju extends Wi {
                constructor(e = new Bc(new lr(-1, -1, 0), new lr(-1, 1, 0), new lr(1, 1, 0)), t = 64, n = 1, r = 8, i = !1) {
                    super(), this.type = "TubeGeometry", this.parameters = {
                        path: e,
                        tubularSegments: t,
                        radius: n,
                        radialSegments: r,
                        closed: i
                    };
                    const s = e.computeFrenetFrames(t, i);
                    this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
                    const o = new lr,
                        a = new lr,
                        l = new Pn;
                    let c = new lr;
                    const u = [],
                        p = [],
                        h = [],
                        d = [];

                    function f(i) {
                        c = e.getPointAt(i / t, c);
                        const l = s.normals[i],
                            h = s.binormals[i];
                        for (let e = 0; e <= r; e++) {
                            const t = e / r * Math.PI * 2,
                                i = Math.sin(t),
                                s = -Math.cos(t);
                            a.x = s * l.x + i * h.x, a.y = s * l.y + i * h.y, a.z = s * l.z + i * h.z, a.normalize(), p.push(a.x, a.y, a.z), o.x = c.x + n * a.x, o.y = c.y + n * a.y, o.z = c.z + n * a.z, u.push(o.x, o.y, o.z)
                        }
                    }! function() {
                        for (let e = 0; e < t; e++) f(e);
                        f(!1 === i ? t : 0),
                            function() {
                                for (let e = 0; e <= t; e++)
                                    for (let n = 0; n <= r; n++) l.x = e / t, l.y = n / r, h.push(l.x, l.y)
                            }(),
                            function() {
                                for (let e = 1; e <= t; e++)
                                    for (let t = 1; t <= r; t++) {
                                        const n = (r + 1) * (e - 1) + (t - 1),
                                            i = (r + 1) * e + (t - 1),
                                            s = (r + 1) * e + t,
                                            o = (r + 1) * (e - 1) + t;
                                        d.push(n, i, o), d.push(i, s, o)
                                    }
                            }()
                    }(), this.setIndex(d), this.setAttribute("position", new Fi(u, 3)), this.setAttribute("normal", new Fi(p, 3)), this.setAttribute("uv", new Fi(h, 2))
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.path = this.parameters.path.toJSON(), e
                }
                static fromJSON(e) {
                    return new ju((new zc[e.path.type]).fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
                }
            }
            class zu extends Wi {
                constructor(e = null) {
                    if (super(), this.type = "WireframeGeometry", this.parameters = {
                            geometry: e
                        }, null !== e) {
                        const t = [],
                            n = new Set,
                            r = new lr,
                            i = new lr;
                        if (null !== e.index) {
                            const s = e.attributes.position,
                                o = e.index;
                            let a = e.groups;
                            0 === a.length && (a = [{
                                start: 0,
                                count: o.count,
                                materialIndex: 0
                            }]);
                            for (let e = 0, l = a.length; e < l; ++e) {
                                const l = a[e],
                                    c = l.start;
                                for (let e = c, a = c + l.count; e < a; e += 3)
                                    for (let a = 0; a < 3; a++) {
                                        const l = o.getX(e + a),
                                            c = o.getX(e + (a + 1) % 3);
                                        r.fromBufferAttribute(s, l), i.fromBufferAttribute(s, c), !0 === Vu(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
                                    }
                            }
                        } else {
                            const s = e.attributes.position;
                            for (let e = 0, o = s.count / 3; e < o; e++)
                                for (let o = 0; o < 3; o++) {
                                    const a = 3 * e + o,
                                        l = 3 * e + (o + 1) % 3;
                                    r.fromBufferAttribute(s, a), i.fromBufferAttribute(s, l), !0 === Vu(r, i, n) && (t.push(r.x, r.y, r.z), t.push(i.x, i.y, i.z))
                                }
                        }
                        this.setAttribute("position", new Fi(t, 3))
                    }
                }
            }

            function Vu(e, t, n) {
                const r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
                    i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
                return !0 !== n.has(r) && !0 !== n.has(i) && (n.add(r), n.add(i), !0)
            }
            var Gu = Object.freeze({
                __proto__: null,
                BoxGeometry: ps,
                BoxBufferGeometry: ps,
                CapsuleGeometry: Wc,
                CapsuleBufferGeometry: Wc,
                CircleGeometry: Kc,
                CircleBufferGeometry: Kc,
                ConeGeometry: qc,
                ConeBufferGeometry: qc,
                CylinderGeometry: Xc,
                CylinderBufferGeometry: Xc,
                DodecahedronGeometry: Zc,
                DodecahedronBufferGeometry: Zc,
                EdgesGeometry: tu,
                ExtrudeGeometry: ku,
                ExtrudeBufferGeometry: ku,
                IcosahedronGeometry: Du,
                IcosahedronBufferGeometry: Du,
                LatheGeometry: Hc,
                LatheBufferGeometry: Hc,
                OctahedronGeometry: Ou,
                OctahedronBufferGeometry: Ou,
                PlaneGeometry: Ps,
                PlaneBufferGeometry: Ps,
                PolyhedronGeometry: Yc,
                PolyhedronBufferGeometry: Yc,
                RingGeometry: Lu,
                RingBufferGeometry: Lu,
                ShapeGeometry: Iu,
                ShapeBufferGeometry: Iu,
                SphereGeometry: Fu,
                SphereBufferGeometry: Fu,
                TetrahedronGeometry: Nu,
                TetrahedronBufferGeometry: Nu,
                TorusGeometry: Uu,
                TorusBufferGeometry: Uu,
                TorusKnotGeometry: Bu,
                TorusKnotBufferGeometry: Bu,
                TubeGeometry: ju,
                TubeBufferGeometry: ju,
                WireframeGeometry: zu
            });
            class Hu extends Si {
                constructor(e) {
                    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Xn(0), this.transparent = !0, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
                }
            }
            class Wu extends _s {
                constructor(e) {
                    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
                }
            }
            class Ku extends Si {
                constructor(e) {
                    super(), this.isMeshStandardMaterial = !0, this.defines = {
                        STANDARD: ""
                    }, this.type = "MeshStandardMaterial", this.color = new Xn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class Xu extends Ku {
                constructor(e) {
                    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Pn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                        get: function() {
                            return Mn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(e) {
                            this.ior = (1 + .4 * e) / (1 - .4 * e)
                        }
                    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Xn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Xn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Xn(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e)
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(e) {
                    this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(e) {
                    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                }
                get iridescence() {
                    return this._iridescence
                }
                set iridescence(e) {
                    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(e) {
                    this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                }
            }
            class qu extends Si {
                constructor(e) {
                    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Xn(16777215), this.specular = new Xn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Y, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class Yu extends Si {
                constructor(e) {
                    super(), this.isMeshToonMaterial = !0, this.defines = {
                        TOON: ""
                    }, this.type = "MeshToonMaterial", this.color = new Xn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                }
            }
            class Zu extends Si {
                constructor(e) {
                    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
                }
            }
            class Ju extends Si {
                constructor(e) {
                    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Xn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Y, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                }
            }
            class $u extends Si {
                constructor(e) {
                    super(), this.isMeshMatcapMaterial = !0, this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new Xn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ut, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        MATCAP: ""
                    }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
                }
            }
            class Qu extends ec {
                constructor(e) {
                    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
                }
            }

            function ep(e, t, n) {
                return np(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
            }

            function tp(e, t, n) {
                return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            }

            function np(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            }

            function rp(e) {
                const t = e.length,
                    n = new Array(t);
                for (let e = 0; e !== t; ++e) n[e] = e;
                return n.sort((function(t, n) {
                    return e[t] - e[n]
                })), n
            }

            function ip(e, t, n) {
                const r = e.length,
                    i = new e.constructor(r);
                for (let s = 0, o = 0; o !== r; ++s) {
                    const r = n[s] * t;
                    for (let n = 0; n !== t; ++n) i[o++] = e[r + n]
                }
                return i
            }

            function sp(e, t, n, r) {
                let i = 1,
                    s = e[0];
                for (; void 0 !== s && void 0 === s[r];) s = e[i++];
                if (void 0 === s) return;
                let o = s[r];
                if (void 0 !== o)
                    if (Array.isArray(o))
                        do {
                            o = s[r], void 0 !== o && (t.push(s.time), n.push.apply(n, o)), s = e[i++]
                        } while (void 0 !== s);
                    else if (void 0 !== o.toArray)
                    do {
                        o = s[r], void 0 !== o && (t.push(s.time), o.toArray(n, n.length)), s = e[i++]
                    } while (void 0 !== s);
                else
                    do {
                        o = s[r], void 0 !== o && (t.push(s.time), n.push(o)), s = e[i++]
                    } while (void 0 !== s)
            }
            var op = Object.freeze({
                __proto__: null,
                arraySlice: ep,
                convertArray: tp,
                isTypedArray: np,
                getKeyframeOrder: rp,
                sortedArray: ip,
                flattenJSON: sp,
                subclip: function(e, t, n, r, i = 30) {
                    const s = e.clone();
                    s.name = t;
                    const o = [];
                    for (let e = 0; e < s.tracks.length; ++e) {
                        const t = s.tracks[e],
                            a = t.getValueSize(),
                            l = [],
                            c = [];
                        for (let e = 0; e < t.times.length; ++e) {
                            const s = t.times[e] * i;
                            if (!(s < n || s >= r)) {
                                l.push(t.times[e]);
                                for (let n = 0; n < a; ++n) c.push(t.values[e * a + n])
                            }
                        }
                        0 !== l.length && (t.times = tp(l, t.times.constructor), t.values = tp(c, t.values.constructor), o.push(t))
                    }
                    s.tracks = o;
                    let a = 1 / 0;
                    for (let e = 0; e < s.tracks.length; ++e) a > s.tracks[e].times[0] && (a = s.tracks[e].times[0]);
                    for (let e = 0; e < s.tracks.length; ++e) s.tracks[e].shift(-1 * a);
                    return s.resetDuration(), s
                },
                makeClipAdditive: function(e, t = 0, n = e, r = 30) {
                    r <= 0 && (r = 30);
                    const i = n.tracks.length,
                        s = t / r;
                    for (let t = 0; t < i; ++t) {
                        const r = n.tracks[t],
                            i = r.ValueTypeName;
                        if ("bool" === i || "string" === i) continue;
                        const o = e.tracks.find((function(e) {
                            return e.name === r.name && e.ValueTypeName === i
                        }));
                        if (void 0 === o) continue;
                        let a = 0;
                        const l = r.getValueSize();
                        r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                        let c = 0;
                        const u = o.getValueSize();
                        o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                        const p = r.times.length - 1;
                        let h;
                        if (s <= r.times[0]) {
                            const e = a,
                                t = l - a;
                            h = ep(r.values, e, t)
                        } else if (s >= r.times[p]) {
                            const e = p * l + a,
                                t = e + l - a;
                            h = ep(r.values, e, t)
                        } else {
                            const e = r.createInterpolant(),
                                t = a,
                                n = l - a;
                            e.evaluate(s), h = ep(e.resultBuffer, t, n)
                        }
                        "quaternion" === i && (new ar).fromArray(h).normalize().conjugate().toArray(h);
                        const d = o.times.length;
                        for (let e = 0; e < d; ++e) {
                            const t = e * u + c;
                            if ("quaternion" === i) ar.multiplyQuaternionsFlat(o.values, t, h, 0, o.values, t);
                            else {
                                const e = u - 2 * c;
                                for (let n = 0; n < e; ++n) o.values[t + n] -= h[n]
                            }
                        }
                    }
                    return e.blendMode = Ct, e
                }
            });
            class ap {
                constructor(e, t, n, r) {
                    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(e) {
                    const t = this.parameterPositions;
                    let n = this._cachedIndex,
                        r = t[n],
                        i = t[n - 1];
                    e: {
                        t: {
                            let s;n: {
                                r: if (!(e < r)) {
                                    for (let s = n + 2;;) {
                                        if (void 0 === r) {
                                            if (e < i) break r;
                                            return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                        }
                                        if (n === s) break;
                                        if (i = r, r = t[++n], e < r) break t
                                    }
                                    s = t.length;
                                    break n
                                }if (e >= i) break e; {
                                    const o = t[1];
                                    e < o && (n = 2, i = o);
                                    for (let s = n - 2;;) {
                                        if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                                        if (n === s) break;
                                        if (r = i, i = t[--n - 1], e >= i) break t
                                    }
                                    s = n, n = 0
                                }
                            }
                            for (; n < s;) {
                                const r = n + s >>> 1;
                                e < t[r] ? s = r : n = r + 1
                            }
                            if (r = t[n], i = t[n - 1], void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (void 0 === r) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, i, r)
                    }
                    return this.interpolate_(n, i, e, r)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer,
                        n = this.sampleValues,
                        r = this.valueSize,
                        i = e * r;
                    for (let e = 0; e !== r; ++e) t[e] = n[i + e];
                    return t
                }
                interpolate_() {
                    throw new Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            class lp extends ap {
                constructor(e, t, n, r) {
                    super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: Mt,
                        endingEnd: Mt
                    }
                }
                intervalChanged_(e, t, n) {
                    const r = this.parameterPositions;
                    let i = e - 2,
                        s = e + 1,
                        o = r[i],
                        a = r[s];
                    if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case Tt:
                            i = e, o = 2 * t - n;
                            break;
                        case Et:
                            i = r.length - 2, o = t + r[i] - r[i + 1];
                            break;
                        default:
                            i = e, o = n
                    }
                    if (void 0 === a) switch (this.getSettings_().endingEnd) {
                        case Tt:
                            s = e, a = 2 * n - t;
                            break;
                        case Et:
                            s = 1, a = n + r[1] - r[0];
                            break;
                        default:
                            s = e - 1, a = t
                    }
                    const l = .5 * (n - t),
                        c = this.valueSize;
                    this._weightPrev = l / (t - o), this._weightNext = l / (a - n), this._offsetPrev = i * c, this._offsetNext = s * c
                }
                interpolate_(e, t, n, r) {
                    const i = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = e * o,
                        l = a - o,
                        c = this._offsetPrev,
                        u = this._offsetNext,
                        p = this._weightPrev,
                        h = this._weightNext,
                        d = (n - t) / (r - t),
                        f = d * d,
                        _ = f * d,
                        m = -p * _ + 2 * p * f - p * d,
                        g = (1 + p) * _ + (-1.5 - 2 * p) * f + (-.5 + p) * d + 1,
                        v = (-1 - h) * _ + (1.5 + h) * f + .5 * d,
                        b = h * _ - h * f;
                    for (let e = 0; e !== o; ++e) i[e] = m * s[c + e] + g * s[l + e] + v * s[a + e] + b * s[u + e];
                    return i
                }
            }
            class cp extends ap {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e, t, n, r) {
                    const i = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = e * o,
                        l = a - o,
                        c = (n - t) / (r - t),
                        u = 1 - c;
                    for (let e = 0; e !== o; ++e) i[e] = s[l + e] * u + s[a + e] * c;
                    return i
                }
            }
            class up extends ap {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e) {
                    return this.copySampleValue_(e - 1)
                }
            }
            class pp {
                constructor(e, t, n, r) {
                    if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e, this.times = tp(t, this.TimeBufferType), this.values = tp(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
                }
                static toJSON(e) {
                    const t = e.constructor;
                    let n;
                    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
                    else {
                        n = {
                            name: e.name,
                            times: tp(e.times, Array),
                            values: tp(e.values, Array)
                        };
                        const t = e.getInterpolation();
                        t !== e.DefaultInterpolation && (n.interpolation = t)
                    }
                    return n.type = e.ValueTypeName, n
                }
                InterpolantFactoryMethodDiscrete(e) {
                    return new up(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new cp(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodSmooth(e) {
                    return new lp(this.times, this.values, this.getValueSize(), e)
                }
                setInterpolation(e) {
                    let t;
                    switch (e) {
                        case yt:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case wt:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case St:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(t);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", t), this
                    }
                    return this.createInterpolant = t, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return yt;
                        case this.InterpolantFactoryMethodLinear:
                            return wt;
                        case this.InterpolantFactoryMethodSmooth:
                            return St
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(e) {
                    if (0 !== e) {
                        const t = this.times;
                        for (let n = 0, r = t.length; n !== r; ++n) t[n] += e
                    }
                    return this
                }
                scale(e) {
                    if (1 !== e) {
                        const t = this.times;
                        for (let n = 0, r = t.length; n !== r; ++n) t[n] *= e
                    }
                    return this
                }
                trim(e, t) {
                    const n = this.times,
                        r = n.length;
                    let i = 0,
                        s = r - 1;
                    for (; i !== r && n[i] < e;) ++i;
                    for (; - 1 !== s && n[s] > t;) --s;
                    if (++s, 0 !== i || s !== r) {
                        i >= s && (s = Math.max(s, 1), i = s - 1);
                        const e = this.getValueSize();
                        this.times = ep(n, i, s), this.values = ep(this.values, i * e, s * e)
                    }
                    return this
                }
                validate() {
                    let e = !0;
                    const t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    const n = this.times,
                        r = this.values,
                        i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    let s = null;
                    for (let t = 0; t !== i; t++) {
                        const r = n[t];
                        if ("number" == typeof r && isNaN(r)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, r), e = !1;
                            break
                        }
                        if (null !== s && s > r) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, t, r, s), e = !1;
                            break
                        }
                        s = r
                    }
                    if (void 0 !== r && np(r))
                        for (let t = 0, n = r.length; t !== n; ++t) {
                            const n = r[t];
                            if (isNaN(n)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1;
                                break
                            }
                        }
                    return e
                }
                optimize() {
                    const e = ep(this.times),
                        t = ep(this.values),
                        n = this.getValueSize(),
                        r = this.getInterpolation() === St,
                        i = e.length - 1;
                    let s = 1;
                    for (let o = 1; o < i; ++o) {
                        let i = !1;
                        const a = e[o];
                        if (a !== e[o + 1] && (1 !== o || a !== e[0]))
                            if (r) i = !0;
                            else {
                                const e = o * n,
                                    r = e - n,
                                    s = e + n;
                                for (let o = 0; o !== n; ++o) {
                                    const n = t[e + o];
                                    if (n !== t[r + o] || n !== t[s + o]) {
                                        i = !0;
                                        break
                                    }
                                }
                            }
                        if (i) {
                            if (o !== s) {
                                e[s] = e[o];
                                const r = o * n,
                                    i = s * n;
                                for (let e = 0; e !== n; ++e) t[i + e] = t[r + e]
                            }++s
                        }
                    }
                    if (i > 0) {
                        e[s] = e[i];
                        for (let e = i * n, r = s * n, o = 0; o !== n; ++o) t[r + o] = t[e + o];
                        ++s
                    }
                    return s !== e.length ? (this.times = ep(e, 0, s), this.values = ep(t, 0, s * n)) : (this.times = e, this.values = t), this
                }
                clone() {
                    const e = ep(this.times, 0),
                        t = ep(this.values, 0),
                        n = new(0, this.constructor)(this.name, e, t);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }
            pp.prototype.TimeBufferType = Float32Array, pp.prototype.ValueBufferType = Float32Array, pp.prototype.DefaultInterpolation = wt;
            class hp extends pp {}
            hp.prototype.ValueTypeName = "bool", hp.prototype.ValueBufferType = Array, hp.prototype.DefaultInterpolation = yt, hp.prototype.InterpolantFactoryMethodLinear = void 0, hp.prototype.InterpolantFactoryMethodSmooth = void 0;
            class dp extends pp {}
            dp.prototype.ValueTypeName = "color";
            class fp extends pp {}
            fp.prototype.ValueTypeName = "number";
            class _p extends ap {
                constructor(e, t, n, r) {
                    super(e, t, n, r)
                }
                interpolate_(e, t, n, r) {
                    const i = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = (n - t) / (r - t);
                    let l = e * o;
                    for (let e = l + o; l !== e; l += 4) ar.slerpFlat(i, 0, s, l - o, s, l, a);
                    return i
                }
            }
            class mp extends pp {
                InterpolantFactoryMethodLinear(e) {
                    return new _p(this.times, this.values, this.getValueSize(), e)
                }
            }
            mp.prototype.ValueTypeName = "quaternion", mp.prototype.DefaultInterpolation = wt, mp.prototype.InterpolantFactoryMethodSmooth = void 0;
            class gp extends pp {}
            gp.prototype.ValueTypeName = "string", gp.prototype.ValueBufferType = Array, gp.prototype.DefaultInterpolation = yt, gp.prototype.InterpolantFactoryMethodLinear = void 0, gp.prototype.InterpolantFactoryMethodSmooth = void 0;
            class vp extends pp {}
            vp.prototype.ValueTypeName = "vector";
            class bp {
                constructor(e, t = -1, n, r = At) {
                    this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = Sn(), this.duration < 0 && this.resetDuration()
                }
                static parse(e) {
                    const t = [],
                        n = e.tracks,
                        r = 1 / (e.fps || 1);
                    for (let e = 0, i = n.length; e !== i; ++e) t.push(xp(n[e]).scale(r));
                    const i = new this(e.name, e.duration, t, e.blendMode);
                    return i.uuid = e.uuid, i
                }
                static toJSON(e) {
                    const t = [],
                        n = e.tracks,
                        r = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode
                        };
                    for (let e = 0, r = n.length; e !== r; ++e) t.push(pp.toJSON(n[e]));
                    return r
                }
                static CreateFromMorphTargetSequence(e, t, n, r) {
                    const i = t.length,
                        s = [];
                    for (let e = 0; e < i; e++) {
                        let o = [],
                            a = [];
                        o.push((e + i - 1) % i, e, (e + 1) % i), a.push(0, 1, 0);
                        const l = rp(o);
                        o = ip(o, 1, l), a = ip(a, 1, l), r || 0 !== o[0] || (o.push(i), a.push(a[0])), s.push(new fp(".morphTargetInfluences[" + t[e].name + "]", o, a).scale(1 / n))
                    }
                    return new this(e, -1, s)
                }
                static findByName(e, t) {
                    let n = e;
                    if (!Array.isArray(e)) {
                        const t = e;
                        n = t.geometry && t.geometry.animations || t.animations
                    }
                    for (let e = 0; e < n.length; e++)
                        if (n[e].name === t) return n[e];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(e, t, n) {
                    const r = {},
                        i = /^([\w-]*?)([\d]+)$/;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t],
                            s = n.name.match(i);
                        if (s && s.length > 1) {
                            const e = s[1];
                            let t = r[e];
                            t || (r[e] = t = []), t.push(n)
                        }
                    }
                    const s = [];
                    for (const e in r) s.push(this.CreateFromMorphTargetSequence(e, r[e], t, n));
                    return s
                }
                static parseAnimation(e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    const n = function(e, t, n, r, i) {
                            if (0 !== n.length) {
                                const s = [],
                                    o = [];
                                sp(n, s, o, r), 0 !== s.length && i.push(new e(t, s, o))
                            }
                        },
                        r = [],
                        i = e.name || "default",
                        s = e.fps || 30,
                        o = e.blendMode;
                    let a = e.length || -1;
                    const l = e.hierarchy || [];
                    for (let e = 0; e < l.length; e++) {
                        const i = l[e].keys;
                        if (i && 0 !== i.length)
                            if (i[0].morphTargets) {
                                const e = {};
                                let t;
                                for (t = 0; t < i.length; t++)
                                    if (i[t].morphTargets)
                                        for (let n = 0; n < i[t].morphTargets.length; n++) e[i[t].morphTargets[n]] = -1;
                                for (const n in e) {
                                    const e = [],
                                        s = [];
                                    for (let r = 0; r !== i[t].morphTargets.length; ++r) {
                                        const r = i[t];
                                        e.push(r.time), s.push(r.morphTarget === n ? 1 : 0)
                                    }
                                    r.push(new fp(".morphTargetInfluence[" + n + "]", e, s))
                                }
                                a = e.length * s
                            } else {
                                const s = ".bones[" + t[e].name + "]";
                                n(vp, s + ".position", i, "pos", r), n(mp, s + ".quaternion", i, "rot", r), n(vp, s + ".scale", i, "scl", r)
                            }
                    }
                    return 0 === r.length ? null : new this(i, a, r, o)
                }
                resetDuration() {
                    let e = 0;
                    for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                        const n = this.tracks[t];
                        e = Math.max(e, n.times[n.times.length - 1])
                    }
                    return this.duration = e, this
                }
                trim() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                }
                validate() {
                    let e = !0;
                    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                }
                optimize() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
                clone() {
                    const e = [];
                    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new this.constructor(this.name, this.duration, e, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }

            function xp(e) {
                if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const t = function(e) {
                    switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return fp;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return vp;
                        case "color":
                            return dp;
                        case "quaternion":
                            return mp;
                        case "bool":
                        case "boolean":
                            return hp;
                        case "string":
                            return gp
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }(e.type);
                if (void 0 === e.times) {
                    const t = [],
                        n = [];
                    sp(e.keys, t, n, "value"), e.times = t, e.values = n
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }
            const yp = {
                enabled: !1,
                files: {},
                add: function(e, t) {
                    !1 !== this.enabled && (this.files[e] = t)
                },
                get: function(e, t) {
                    return !1 === this.enabled ? t ? Promise.resolve() : void 0 : t ? Promise.resolve(this.files[e]) : this.files[e]
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            };
            class wp {
                constructor(e, t, n) {
                    const r = this;
                    let i, s = !1,
                        o = 0,
                        a = 0;
                    const l = [];
                    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                        a++, !1 === s && void 0 !== r.onStart && r.onStart(e, o, a), s = !0
                    }, this.itemEnd = function(e) {
                        o++, void 0 !== r.onProgress && r.onProgress(e, o, a), o === a && (s = !1, void 0 !== r.onLoad && r.onLoad())
                    }, this.itemError = function(e) {
                        void 0 !== r.onError && r.onError(e)
                    }, this.resolveURL = function(e) {
                        return i ? i(e) : e
                    }, this.setURLModifier = function(e) {
                        return i = e, this
                    }, this.addHandler = function(e, t) {
                        return l.push(e, t), this
                    }, this.removeHandler = function(e) {
                        const t = l.indexOf(e);
                        return -1 !== t && l.splice(t, 2), this
                    }, this.getHandler = function(e) {
                        for (let t = 0, n = l.length; t < n; t += 2) {
                            const n = l[t],
                                r = l[t + 1];
                            if (n.global && (n.lastIndex = 0), n.test(e)) return r
                        }
                        return null
                    }
                }
            }
            const Sp = new wp;
            class Mp {
                constructor(e) {
                    this.manager = void 0 !== e ? e : Sp, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(e, t) {
                    const n = this;
                    return new Promise((function(r, i) {
                        n.load(e, r, t, i)
                    }))
                }
                parse() {}
                setCrossOrigin(e) {
                    return this.crossOrigin = e, this
                }
                setWithCredentials(e) {
                    return this.withCredentials = e, this
                }
                setPath(e) {
                    return this.path = e, this
                }
                setResourcePath(e) {
                    return this.resourcePath = e, this
                }
                setRequestHeader(e) {
                    return this.requestHeader = e, this
                }
            }
            const Tp = {};
            class Ep extends Mp {
                constructor(e) {
                    super(e), this.responseType = "text"
                }
                load(e, t, n, r) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e), yp.get(e, this.responseType, this.mimeType).then((i => {
                        if (void 0 !== i) return this.manager.itemStart(e), setTimeout((() => {
                            t && t(i), this.manager.itemEnd(e)
                        }), 0), i;
                        if (void 0 !== Tp[e]) return void Tp[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: r
                        });
                        Tp[e] = [], Tp[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: r
                        });
                        const s = new Request(e, {
                                headers: new Headers(this.requestHeader),
                                credentials: this.withCredentials ? "include" : "same-origin"
                            }),
                            o = this.mimeType,
                            a = this.responseType;
                        fetch(s).then((t => {
                            if (200 === t.status || 0 === t.status) {
                                if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                                const n = Tp[e],
                                    r = t.body.getReader(),
                                    i = t.headers.get("Content-Length"),
                                    s = i ? parseInt(i) : 0,
                                    o = 0 !== s;
                                let a = 0;
                                const l = new ReadableStream({
                                    start(e) {
                                        ! function t() {
                                            r.read().then((({
                                                done: r,
                                                value: i
                                            }) => {
                                                if (r) e.close();
                                                else {
                                                    a += i.byteLength;
                                                    const r = new ProgressEvent("progress", {
                                                        lengthComputable: o,
                                                        loaded: a,
                                                        total: s
                                                    });
                                                    for (let e = 0, t = n.length; e < t; e++) {
                                                        const t = n[e];
                                                        t.onProgress && t.onProgress(r)
                                                    }
                                                    e.enqueue(i), t()
                                                }
                                            }))
                                        }()
                                    }
                                });
                                return new Response(l)
                            }
                            throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)
                        })).then((e => {
                            switch (a) {
                                case "arraybuffer":
                                    return e.arrayBuffer();
                                case "blob":
                                    return e.blob();
                                case "document":
                                    return e.text().then((e => (new DOMParser).parseFromString(e, o)));
                                case "json":
                                    return e.json();
                                default:
                                    if (void 0 === o) return e.text(); {
                                        const t = /charset="?([^;"\s]*)"?/i.exec(o),
                                            n = t && t[1] ? t[1].toLowerCase() : void 0,
                                            r = new TextDecoder(n);
                                        return e.arrayBuffer().then((e => r.decode(e)))
                                    }
                            }
                        })).then((t => {
                            yp.add(e, t, this.responseType);
                            const n = Tp[e];
                            delete Tp[e];
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = n[e];
                                r.onLoad && r.onLoad(t)
                            }
                        })).catch((t => {
                            const n = Tp[e];
                            if (void 0 === n) throw this.manager.itemError(e), t;
                            delete Tp[e];
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = n[e];
                                r.onError && r.onError(t)
                            }
                            this.manager.itemError(e)
                        })).finally((() => {
                            this.manager.itemEnd(e)
                        })), this.manager.itemStart(e)
                    }))
                }
                setResponseType(e) {
                    return this.responseType = e, this
                }
                setMimeType(e) {
                    return this.mimeType = e, this
                }
            }
            class Ap extends Mp {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    const i = this,
                        s = new Ep(this.manager);
                    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function(n) {
                        try {
                            t(i.parse(JSON.parse(n)))
                        } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                        }
                    }), n, r)
                }
                parse(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++) {
                        const r = bp.parse(e[n]);
                        t.push(r)
                    }
                    return t
                }
            }
            class Cp extends Mp {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    const i = this,
                        s = [],
                        o = new xc,
                        a = new Ep(this.manager);
                    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(i.withCredentials);
                    let l = 0;

                    function c(c) {
                        a.load(e[c], (function(e) {
                            const n = i.parse(e, !0);
                            s[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, l += 1, 6 === l && (1 === n.mipmapCount && (o.minFilter = ve), o.image = s, o.format = n.format, o.needsUpdate = !0, t && t(o))
                        }), n, r)
                    }
                    if (Array.isArray(e))
                        for (let t = 0, n = e.length; t < n; ++t) c(t);
                    else a.load(e, (function(e) {
                        const n = i.parse(e, !0);
                        if (n.isCubemap) {
                            const e = n.mipmaps.length / n.mipmapCount;
                            for (let t = 0; t < e; t++) {
                                s[t] = {
                                    mipmaps: []
                                };
                                for (let e = 0; e < n.mipmapCount; e++) s[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), s[t].format = n.format, s[t].width = n.width, s[t].height = n.height
                            }
                            o.image = s
                        } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (o.minFilter = ve), o.format = n.format, o.needsUpdate = !0, t && t(o)
                    }), n, r);
                    return o
                }
            }
            class Rp extends Mp {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const i = this,
                        s = yp.get(e);
                    if (void 0 !== s) return i.manager.itemStart(e), setTimeout((function() {
                        t && t(s), i.manager.itemEnd(e)
                    }), 0), s;
                    const o = Fn("img");

                    function a() {
                        c(), yp.add(e, this), t && t(this), i.manager.itemEnd(e)
                    }

                    function l(t) {
                        c(), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                    }

                    function c() {
                        o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1)
                    }
                    return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(e), o.src = e, o
                }
            }
            class kp extends Mp {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    const i = new xs,
                        s = new Rp(this.manager);
                    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                    let o = 0;

                    function a(n) {
                        s.load(e[n], (function(e) {
                            i.images[n] = e, o++, 6 === o && (i.needsUpdate = !0, t && t(i))
                        }), void 0, r)
                    }
                    for (let t = 0; t < e.length; ++t) a(t);
                    return i
                }
            }
            class Pp extends Mp {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    const i = this,
                        s = new Hl,
                        o = new Ep(this.manager);
                    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(e, (function(e) {
                        const n = i.parse(e);
                        n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data, s.image.complete = !0), s.wrapS = void 0 !== n.wrapS ? n.wrapS : pe, s.wrapT = void 0 !== n.wrapT ? n.wrapT : pe, s.magFilter = void 0 !== n.magFilter ? n.magFilter : ve, s.minFilter = void 0 !== n.minFilter ? n.minFilter : ve, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = ye), 1 === n.mipmapCount && (s.minFilter = ve), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, t && t(s, n))
                    }), n, r), s
                }
            }
            class Dp extends Mp {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    const i = new Qn,
                        s = new Rp(this.manager);
                    return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function(e) {
                        i.image = e, i.needsUpdate = !0, void 0 !== t && t(i)
                    }), n, r), i
                }
            }
            class Op extends ui {
                constructor(e, t = 1) {
                    super(), this.isLight = !0, this.type = "Light", this.color = new Xn(e), this.intensity = t
                }
                dispose() {}
                copy(e, t) {
                    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }
            class Lp extends Op {
                constructor(e, t, n) {
                    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.groundColor = new Xn(t)
                }
                copy(e, t) {
                    return super.copy(e, t), this.groundColor.copy(e.groundColor), this
                }
            }
            const Ip = new Br,
                Fp = new lr,
                Np = new lr;
            class Up {
                constructor(e) {
                    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Pn(512, 512), this.map = null, this.mapPass = null, this.matrix = new Br, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Cs, this._frameExtents = new Pn(1, 1), this._viewportCount = 1, this._viewports = [new er(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(e) {
                    const t = this.camera,
                        n = this.matrix;
                    Fp.setFromMatrixPosition(e.matrixWorld), t.position.copy(Fp), Np.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Np), t.updateMatrixWorld(), Ip.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ip), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
                }
                getViewport(e) {
                    return this._viewports[e]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }
            class Bp extends Up {
                constructor() {
                    super(new gs(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
                }
                updateMatrices(e) {
                    const t = this.camera,
                        n = 2 * wn * e.angle * this.focus,
                        r = this.mapSize.width / this.mapSize.height,
                        i = e.distance || t.far;
                    n === t.fov && r === t.aspect && i === t.far || (t.fov = n, t.aspect = r, t.far = i, t.updateProjectionMatrix()), super.updateMatrices(e)
                }
                copy(e) {
                    return super.copy(e), this.focus = e.focus, this
                }
            }
            class jp extends Op {
                constructor(e, t, n = 0, r = Math.PI / 3, i = 0, s = 1) {
                    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.target = new ui, this.distance = n, this.angle = r, this.penumbra = i, this.decay = s, this.shadow = new Bp
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / Math.PI
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            const zp = new Br,
                Vp = new lr,
                Gp = new lr;
            class Hp extends Up {
                constructor() {
                    super(new gs(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Pn(4, 2), this._viewportCount = 6, this._viewports = [new er(2, 1, 1, 1), new er(0, 1, 1, 1), new er(3, 1, 1, 1), new er(1, 1, 1, 1), new er(3, 0, 1, 1), new er(1, 0, 1, 1)], this._cubeDirections = [new lr(1, 0, 0), new lr(-1, 0, 0), new lr(0, 0, 1), new lr(0, 0, -1), new lr(0, 1, 0), new lr(0, -1, 0)], this._cubeUps = [new lr(0, 1, 0), new lr(0, 1, 0), new lr(0, 1, 0), new lr(0, 1, 0), new lr(0, 0, 1), new lr(0, 0, -1)]
                }
                updateMatrices(e, t = 0) {
                    const n = this.camera,
                        r = this.matrix,
                        i = e.distance || n.far;
                    i !== n.far && (n.far = i, n.updateProjectionMatrix()), Vp.setFromMatrixPosition(e.matrixWorld), n.position.copy(Vp), Gp.copy(n.position), Gp.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Gp), n.updateMatrixWorld(), r.makeTranslation(-Vp.x, -Vp.y, -Vp.z), zp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(zp)
                }
            }
            class Wp extends Op {
                constructor(e, t, n = 0, r = 1) {
                    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new Hp
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / (4 * Math.PI)
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }
            class Kp extends Up {
                constructor() {
                    super(new zs(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
                }
            }
            class Xp extends Op {
                constructor(e, t) {
                    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ui.DefaultUp), this.updateMatrix(), this.target = new ui, this.shadow = new Kp
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            class qp extends Op {
                constructor(e, t) {
                    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
                }
            }
            class Yp extends Op {
                constructor(e, t, n = 10, r = 10) {
                    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r
                }
                get power() {
                    return this.intensity * this.width * this.height * Math.PI
                }
                set power(e) {
                    this.intensity = e / (this.width * this.height * Math.PI)
                }
                copy(e) {
                    return super.copy(e), this.width = e.width, this.height = e.height, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            }
            class Zp {
                constructor() {
                    this.isSphericalHarmonics3 = !0, this.coefficients = [];
                    for (let e = 0; e < 9; e++) this.coefficients.push(new lr)
                }
                set(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                    return this
                }
                zero() {
                    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                    return this
                }
                getAt(e, t) {
                    const n = e.x,
                        r = e.y,
                        i = e.z,
                        s = this.coefficients;
                    return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * r), t.addScaledVector(s[2], .488603 * i), t.addScaledVector(s[3], .488603 * n), t.addScaledVector(s[4], n * r * 1.092548), t.addScaledVector(s[5], r * i * 1.092548), t.addScaledVector(s[6], .315392 * (3 * i * i - 1)), t.addScaledVector(s[7], n * i * 1.092548), t.addScaledVector(s[8], .546274 * (n * n - r * r)), t
                }
                getIrradianceAt(e, t) {
                    const n = e.x,
                        r = e.y,
                        i = e.z,
                        s = this.coefficients;
                    return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * r), t.addScaledVector(s[2], 1.023328 * i), t.addScaledVector(s[3], 1.023328 * n), t.addScaledVector(s[4], .858086 * n * r), t.addScaledVector(s[5], .858086 * r * i), t.addScaledVector(s[6], .743125 * i * i - .247708), t.addScaledVector(s[7], .858086 * n * i), t.addScaledVector(s[8], .429043 * (n * n - r * r)), t
                }
                add(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                    return this
                }
                addScaledSH(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                    return this
                }
                scale(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                    return this
                }
                lerp(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                    return this
                }
                equals(e) {
                    for (let t = 0; t < 9; t++)
                        if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
                    return !0
                }
                copy(e) {
                    return this.set(e.coefficients)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                fromArray(e, t = 0) {
                    const n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].fromArray(e, t + 3 * r);
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.coefficients;
                    for (let r = 0; r < 9; r++) n[r].toArray(e, t + 3 * r);
                    return e
                }
                static getBasisAt(e, t) {
                    const n = e.x,
                        r = e.y,
                        i = e.z;
                    t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * i, t[3] = .488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * i, t[6] = .315392 * (3 * i * i - 1), t[7] = 1.092548 * n * i, t[8] = .546274 * (n * n - r * r)
                }
            }
            class Jp extends Op {
                constructor(e = new Zp, t = 1) {
                    super(void 0, t), this.isLightProbe = !0, this.sh = e
                }
                copy(e) {
                    return super.copy(e), this.sh.copy(e.sh), this
                }
                fromJSON(e) {
                    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.sh = this.sh.toArray(), t
                }
            }
            class $p extends Mp {
                constructor(e) {
                    super(e), this.textures = {}
                }
                load(e, t, n, r) {
                    const i = this,
                        s = new Ep(i.manager);
                    s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, (function(n) {
                        try {
                            t(i.parse(JSON.parse(n)))
                        } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                        }
                    }), n, r)
                }
                parse(e) {
                    const t = this.textures;

                    function n(e) {
                        return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                    }
                    const r = $p.createMaterialFromType(e.type);
                    if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = e.sheen), void 0 !== e.sheenColor && (r.sheenColor = (new Xn).setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (r.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.specularIntensity && (r.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== r.specularColor && r.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.iridescence && (r.iridescence = e.iridescence), void 0 !== e.iridescenceIOR && (r.iridescenceIOR = e.iridescenceIOR), void 0 !== e.iridescenceThicknessRange && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.thickness && (r.thickness = e.thickness), void 0 !== e.attenuationDistance && (r.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== r.attenuationColor && r.attenuationColor.setHex(e.attenuationColor), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.shadowSide && (r.shadowSide = e.shadowSide), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.alphaToCoverage && (r.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (r.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms)
                        for (const t in e.uniforms) {
                            const i = e.uniforms[t];
                            switch (r.uniforms[t] = {}, i.type) {
                                case "t":
                                    r.uniforms[t].value = n(i.value);
                                    break;
                                case "c":
                                    r.uniforms[t].value = (new Xn).setHex(i.value);
                                    break;
                                case "v2":
                                    r.uniforms[t].value = (new Pn).fromArray(i.value);
                                    break;
                                case "v3":
                                    r.uniforms[t].value = (new lr).fromArray(i.value);
                                    break;
                                case "v4":
                                    r.uniforms[t].value = (new er).fromArray(i.value);
                                    break;
                                case "m3":
                                    r.uniforms[t].value = (new Dn).fromArray(i.value);
                                    break;
                                case "m4":
                                    r.uniforms[t].value = (new Br).fromArray(i.value);
                                    break;
                                default:
                                    r.uniforms[t].value = i.value
                            }
                        }
                    if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                        for (const t in e.extensions) r.extensions[t] = e.extensions[t];
                    if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = n(e.map)), void 0 !== e.matcap && (r.matcap = n(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                        let t = e.normalScale;
                        !1 === Array.isArray(t) && (t = [t, t]), r.normalScale = (new Pn).fromArray(t)
                    }
                    return void 0 !== e.displacementMap && (r.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = n(e.specularMap)), void 0 !== e.specularIntensityMap && (r.specularIntensityMap = n(e.specularIntensityMap)), void 0 !== e.specularColorMap && (r.specularColorMap = n(e.specularColorMap)), void 0 !== e.envMap && (r.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new Pn).fromArray(e.clearcoatNormalScale)), void 0 !== e.iridescenceMap && (r.iridescenceMap = n(e.iridescenceMap)), void 0 !== e.iridescenceThicknessMap && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), void 0 !== e.transmissionMap && (r.transmissionMap = n(e.transmissionMap)), void 0 !== e.thicknessMap && (r.thicknessMap = n(e.thicknessMap)), void 0 !== e.sheenColorMap && (r.sheenColorMap = n(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r
                }
                setTextures(e) {
                    return this.textures = e, this
                }
                static createMaterialFromType(e) {
                    return new {
                        ShadowMaterial: Hu,
                        SpriteMaterial: vl,
                        RawShaderMaterial: Wu,
                        ShaderMaterial: _s,
                        PointsMaterial: pc,
                        MeshPhysicalMaterial: Xu,
                        MeshStandardMaterial: Ku,
                        MeshPhongMaterial: qu,
                        MeshToonMaterial: Yu,
                        MeshNormalMaterial: Zu,
                        MeshLambertMaterial: Ju,
                        MeshDepthMaterial: Za,
                        MeshDistanceMaterial: Ja,
                        MeshBasicMaterial: Mi,
                        MeshMatcapMaterial: $u,
                        LineDashedMaterial: Qu,
                        LineBasicMaterial: ec,
                        Material: Si
                    }[e]
                }
            }
            class Qp {
                static decodeText(e) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                    let t = "";
                    for (let n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
                    try {
                        return decodeURIComponent(escape(t))
                    } catch (e) {
                        return t
                    }
                }
                static extractUrlBase(e) {
                    const t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.slice(0, t + 1)
                }
                static resolveURL(e, t) {
                    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                }
            }
            class eh extends Wi {
                constructor() {
                    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                }
                copy(e) {
                    return super.copy(e), this.instanceCount = e.instanceCount, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const e = super.toJSON(this);
                    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
                }
            }
            class th extends Mp {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    const i = this,
                        s = new Ep(i.manager);
                    s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(e, (function(n) {
                        try {
                            t(i.parse(JSON.parse(n)))
                        } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                        }
                    }), n, r)
                }
                parse(e) {
                    const t = {},
                        n = {};

                    function r(e, r) {
                        if (void 0 !== t[r]) return t[r];
                        const i = e.interleavedBuffers[r],
                            s = function(e, t) {
                                if (void 0 !== n[t]) return n[t];
                                const r = e.arrayBuffers[t],
                                    i = new Uint32Array(r).buffer;
                                return n[t] = i, i
                            }(e, i.buffer),
                            o = In(i.type, s),
                            a = new _l(o, i.stride);
                        return a.uuid = i.uuid, t[r] = a, a
                    }
                    const i = e.isInstancedBufferGeometry ? new eh : new Wi,
                        s = e.data.index;
                    if (void 0 !== s) {
                        const e = In(s.type, s.array);
                        i.setIndex(new Ai(e, 1))
                    }
                    const o = e.data.attributes;
                    for (const t in o) {
                        const n = o[t];
                        let s;
                        if (n.isInterleavedBufferAttribute) {
                            const t = r(e.data, n.data);
                            s = new gl(t, n.itemSize, n.offset, n.normalized)
                        } else {
                            const e = In(n.type, n.array);
                            s = new(n.isInstancedBufferAttribute ? ql : Ai)(e, n.itemSize, n.normalized)
                        }
                        void 0 !== n.name && (s.name = n.name), void 0 !== n.usage && s.setUsage(n.usage), void 0 !== n.updateRange && (s.updateRange.offset = n.updateRange.offset, s.updateRange.count = n.updateRange.count), i.setAttribute(t, s)
                    }
                    const a = e.data.morphAttributes;
                    if (a)
                        for (const t in a) {
                            const n = a[t],
                                s = [];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                let o;
                                if (i.isInterleavedBufferAttribute) {
                                    const t = r(e.data, i.data);
                                    o = new gl(t, i.itemSize, i.offset, i.normalized)
                                } else {
                                    const e = In(i.type, i.array);
                                    o = new Ai(e, i.itemSize, i.normalized)
                                }
                                void 0 !== i.name && (o.name = i.name), s.push(o)
                            }
                            i.morphAttributes[t] = s
                        }
                    e.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
                    const l = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== l)
                        for (let e = 0, t = l.length; e !== t; ++e) {
                            const t = l[e];
                            i.addGroup(t.start, t.count, t.materialIndex)
                        }
                    const c = e.data.boundingSphere;
                    if (void 0 !== c) {
                        const e = new lr;
                        void 0 !== c.center && e.fromArray(c.center), i.boundingSphere = new kr(e, c.radius)
                    }
                    return e.name && (i.name = e.name), e.userData && (i.userData = e.userData), i
                }
            }
            class nh extends Mp {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    const i = this,
                        s = "" === this.path ? Qp.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || s;
                    const o = new Ep(this.manager);
                    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(n) {
                        let s = null;
                        try {
                            s = JSON.parse(n)
                        } catch (t) {
                            return void 0 !== r && r(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                        }
                        const o = s.metadata;
                        void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? i.parse(s, t) : console.error("THREE.ObjectLoader: Can't load " + e)
                    }), n, r)
                }
                async loadAsync(e, t) {
                    const n = "" === this.path ? Qp.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || n;
                    const r = new Ep(this.manager);
                    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
                    const i = await r.loadAsync(e, t),
                        s = JSON.parse(i),
                        o = s.metadata;
                    if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e);
                    return await this.parseAsync(s)
                }
                parse(e, t) {
                    const n = this.parseAnimations(e.animations),
                        r = this.parseShapes(e.shapes),
                        i = this.parseGeometries(e.geometries, r),
                        s = this.parseImages(e.images, (function() {
                            void 0 !== t && t(l)
                        })),
                        o = this.parseTextures(e.textures, s),
                        a = this.parseMaterials(e.materials, o),
                        l = this.parseObject(e.object, i, a, o, n),
                        c = this.parseSkeletons(e.skeletons, l);
                    if (this.bindSkeletons(l, c), void 0 !== t) {
                        let e = !1;
                        for (const t in s)
                            if (s[t].data instanceof HTMLImageElement) {
                                e = !0;
                                break
                            }!1 === e && t(l)
                    }
                    return l
                }
                async parseAsync(e) {
                    const t = this.parseAnimations(e.animations),
                        n = this.parseShapes(e.shapes),
                        r = this.parseGeometries(e.geometries, n),
                        i = await this.parseImagesAsync(e.images),
                        s = this.parseTextures(e.textures, i),
                        o = this.parseMaterials(e.materials, s),
                        a = this.parseObject(e.object, r, o, s, t),
                        l = this.parseSkeletons(e.skeletons, a);
                    return this.bindSkeletons(a, l), a
                }
                parseShapes(e) {
                    const t = {};
                    if (void 0 !== e)
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = (new nu).fromJSON(e[n]);
                            t[r.uuid] = r
                        }
                    return t
                }
                parseSkeletons(e, t) {
                    const n = {},
                        r = {};
                    if (t.traverse((function(e) {
                            e.isBone && (r[e.uuid] = e)
                        })), void 0 !== e)
                        for (let t = 0, i = e.length; t < i; t++) {
                            const i = (new Xl).fromJSON(e[t], r);
                            n[i.uuid] = i
                        }
                    return n
                }
                parseGeometries(e, t) {
                    const n = {};
                    if (void 0 !== e) {
                        const r = new th;
                        for (let i = 0, s = e.length; i < s; i++) {
                            let s;
                            const o = e[i];
                            switch (o.type) {
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    s = r.parse(o);
                                    break;
                                case "Geometry":
                                    console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                                    break;
                                default:
                                    o.type in Gu ? s = Gu[o.type].fromJSON(o, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o.type}"`)
                            }
                            s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData), n[o.uuid] = s
                        }
                    }
                    return n
                }
                parseMaterials(e, t) {
                    const n = {},
                        r = {};
                    if (void 0 !== e) {
                        const i = new $p;
                        i.setTextures(t);
                        for (let t = 0, s = e.length; t < s; t++) {
                            const s = e[t];
                            if ("MultiMaterial" === s.type) {
                                const e = [];
                                for (let t = 0; t < s.materials.length; t++) {
                                    const r = s.materials[t];
                                    void 0 === n[r.uuid] && (n[r.uuid] = i.parse(r)), e.push(n[r.uuid])
                                }
                                r[s.uuid] = e
                            } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
                        }
                    }
                    return r
                }
                parseAnimations(e) {
                    const t = {};
                    if (void 0 !== e)
                        for (let n = 0; n < e.length; n++) {
                            const r = e[n],
                                i = bp.parse(r);
                            t[i.uuid] = i
                        }
                    return t
                }
                parseImages(e, t) {
                    const n = this,
                        r = {};
                    let i;

                    function s(e) {
                        if ("string" == typeof e) {
                            const t = e;
                            return function(e) {
                                return n.manager.itemStart(e), i.load(e, (function() {
                                    n.manager.itemEnd(e)
                                }), void 0, (function() {
                                    n.manager.itemError(e), n.manager.itemEnd(e)
                                }))
                            }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t)
                        }
                        return e.data ? {
                            data: In(e.type, e.data),
                            width: e.width,
                            height: e.height,
                            complete: !0
                        } : null
                    }
                    if (void 0 !== e && e.length > 0) {
                        const n = new wp(t);
                        i = new Rp(n), i.setCrossOrigin(this.crossOrigin);
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t],
                                i = n.url;
                            if (Array.isArray(i)) {
                                const e = [];
                                for (let t = 0, n = i.length; t < n; t++) {
                                    const n = s(i[t]);
                                    null !== n && (n instanceof HTMLImageElement ? e.push(n) : e.push(new Hl(n.data, n.width, n.height)))
                                }
                                r[n.uuid] = new Zn(e)
                            } else {
                                const e = s(n.url);
                                r[n.uuid] = new Zn(e)
                            }
                        }
                    }
                    return r
                }
                async parseImagesAsync(e) {
                    const t = this,
                        n = {};
                    let r;
                    async function i(e) {
                        if ("string" == typeof e) {
                            const n = e,
                                i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n;
                            return await r.loadAsync(i)
                        }
                        return e.data ? {
                            data: In(e.type, e.data),
                            width: e.width,
                            height: e.height,
                            complete: !0
                        } : null
                    }
                    if (void 0 !== e && e.length > 0) {
                        r = new Rp(this.manager), r.setCrossOrigin(this.crossOrigin);
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = e[t],
                                s = r.url;
                            if (Array.isArray(s)) {
                                const e = [];
                                for (let t = 0, n = s.length; t < n; t++) {
                                    const n = s[t],
                                        r = await i(n);
                                    null !== r && (r instanceof HTMLImageElement ? e.push(r) : e.push(new Hl(r.data, r.width, r.height)))
                                }
                                n[r.uuid] = new Zn(e)
                            } else {
                                const e = await i(r.url);
                                n[r.uuid] = new Zn(e)
                            }
                        }
                    }
                    return n
                }
                parseTextures(e, t) {
                    function n(e, t) {
                        return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                    }
                    const r = {};
                    if (void 0 !== e)
                        for (let i = 0, s = e.length; i < s; i++) {
                            const s = e[i];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                            const o = t[s.image],
                                a = o ? o.data : void 0;
                            let l;
                            Array.isArray(a) ? (l = new xs, 6 === a.length && (l.needsUpdate = !0)) : (l = a && a.data ? new Hl : new Qn, a && a.complete && (l.needsUpdate = !0)), l.source = o, l.uuid = s.uuid, void 0 !== s.name && (l.name = s.name), void 0 !== s.mapping && (l.mapping = n(s.mapping, rh)), void 0 !== s.offset && l.offset.fromArray(s.offset), void 0 !== s.repeat && l.repeat.fromArray(s.repeat), void 0 !== s.center && l.center.fromArray(s.center), void 0 !== s.rotation && (l.rotation = s.rotation), void 0 !== s.wrap && (l.wrapS = n(s.wrap[0], ih), l.wrapT = n(s.wrap[1], ih)), void 0 !== s.format && (l.format = s.format), void 0 !== s.type && (l.type = s.type), void 0 !== s.encoding && (l.encoding = s.encoding), void 0 !== s.minFilter && (l.minFilter = n(s.minFilter, sh)), void 0 !== s.magFilter && (l.magFilter = n(s.magFilter, sh)), void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy), void 0 !== s.flipY && (l.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (l.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (l.unpackAlignment = s.unpackAlignment), void 0 !== s.userData && (l.userData = s.userData), r[s.uuid] = l
                        }
                    return r
                }
                parseObject(e, t, n, r, i) {
                    let s, o, a;

                    function l(e) {
                        return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                    }

                    function c(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                const t = [];
                                for (let r = 0, i = e.length; r < i; r++) {
                                    const i = e[r];
                                    void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i), t.push(n[i])
                                }
                                return t
                            }
                            return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                        }
                    }

                    function u(e) {
                        return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), r[e]
                    }
                    switch (e.type) {
                        case "Scene":
                            s = new fl, void 0 !== e.background && (Number.isInteger(e.background) ? s.background = new Xn(e.background) : s.background = u(e.background)), void 0 !== e.environment && (s.environment = u(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? s.fog = new dl(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (s.fog = new hl(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            s = new gs(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (s.focus = e.focus), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.filmGauge && (s.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (s.filmOffset = e.filmOffset), void 0 !== e.view && (s.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            s = new zs(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (s.zoom = e.zoom), void 0 !== e.view && (s.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            s = new qp(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            s = new Xp(e.color, e.intensity);
                            break;
                        case "PointLight":
                            s = new Wp(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            s = new Yp(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            s = new jp(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            s = new Lp(e.color, e.groundColor, e.intensity);
                            break;
                        case "LightProbe":
                            s = (new Jp).fromJSON(e);
                            break;
                        case "SkinnedMesh":
                            o = l(e.geometry), a = c(e.material), s = new Vl(o, a), void 0 !== e.bindMode && (s.bindMode = e.bindMode), void 0 !== e.bindMatrix && s.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (s.skeleton = e.skeleton);
                            break;
                        case "Mesh":
                            o = l(e.geometry), a = c(e.material), s = new cs(o, a);
                            break;
                        case "InstancedMesh":
                            o = l(e.geometry), a = c(e.material);
                            const t = e.count,
                                n = e.instanceMatrix,
                                r = e.instanceColor;
                            s = new Ql(o, a, t), s.instanceMatrix = new ql(new Float32Array(n.array), 16), void 0 !== r && (s.instanceColor = new ql(new Float32Array(r.array), r.itemSize));
                            break;
                        case "LOD":
                            s = new Fl;
                            break;
                        case "Line":
                            s = new oc(l(e.geometry), c(e.material));
                            break;
                        case "LineLoop":
                            s = new uc(l(e.geometry), c(e.material));
                            break;
                        case "LineSegments":
                            s = new cc(l(e.geometry), c(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            s = new mc(l(e.geometry), c(e.material));
                            break;
                        case "Sprite":
                            s = new Dl(c(e.material));
                            break;
                        case "Group":
                            s = new rl;
                            break;
                        case "Bone":
                            s = new Gl;
                            break;
                        default:
                            s = new ui
                    }
                    if (s.uuid = e.uuid, void 0 !== e.name && (s.name = e.name), void 0 !== e.matrix ? (s.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (s.matrixAutoUpdate = e.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== e.position && s.position.fromArray(e.position), void 0 !== e.rotation && s.rotation.fromArray(e.rotation), void 0 !== e.quaternion && s.quaternion.fromArray(e.quaternion), void 0 !== e.scale && s.scale.fromArray(e.scale)), void 0 !== e.castShadow && (s.castShadow = e.castShadow), void 0 !== e.receiveShadow && (s.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (s.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (s.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (s.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && s.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (s.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.frustumCulled && (s.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (s.renderOrder = e.renderOrder), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.layers && (s.layers.mask = e.layers), void 0 !== e.children) {
                        const o = e.children;
                        for (let e = 0; e < o.length; e++) s.add(this.parseObject(o[e], t, n, r, i))
                    }
                    if (void 0 !== e.animations) {
                        const t = e.animations;
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e];
                            s.animations.push(i[n])
                        }
                    }
                    if ("LOD" === e.type) {
                        void 0 !== e.autoUpdate && (s.autoUpdate = e.autoUpdate);
                        const t = e.levels;
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e],
                                r = s.getObjectByProperty("uuid", n.object);
                            void 0 !== r && s.addLevel(r, n.distance)
                        }
                    }
                    return s
                }
                bindSkeletons(e, t) {
                    0 !== Object.keys(t).length && e.traverse((function(e) {
                        if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                            const n = t[e.skeleton];
                            void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix)
                        }
                    }))
                }
            }
            const rh = {
                    UVMapping: ie,
                    CubeReflectionMapping: se,
                    CubeRefractionMapping: oe,
                    EquirectangularReflectionMapping: ae,
                    EquirectangularRefractionMapping: le,
                    CubeUVReflectionMapping: ce
                },
                ih = {
                    RepeatWrapping: ue,
                    ClampToEdgeWrapping: pe,
                    MirroredRepeatWrapping: he
                },
                sh = {
                    NearestFilter: de,
                    NearestMipmapNearestFilter: fe,
                    NearestMipmapLinearFilter: me,
                    LinearFilter: ve,
                    LinearMipmapNearestFilter: be,
                    LinearMipmapLinearFilter: ye
                };
            class oh extends Mp {
                constructor(e) {
                    super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                setOptions(e) {
                    return this.options = e, this
                }
                load(e, t, n, r) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const i = this,
                        s = yp.get(e);
                    if (void 0 !== s) return i.manager.itemStart(e), setTimeout((function() {
                        t && t(s), i.manager.itemEnd(e)
                    }), 0), s;
                    const o = {};
                    o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then((function(e) {
                        return e.blob()
                    })).then((function(e) {
                        return createImageBitmap(e, Object.assign(i.options, {
                            colorSpaceConversion: "none"
                        }))
                    })).then((function(n) {
                        yp.add(e, n), t && t(n), i.manager.itemEnd(e)
                    })).catch((function(t) {
                        r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                    })), i.manager.itemStart(e)
                }
            }
            let ah;
            const lh = {
                getContext: function() {
                    return void 0 === ah && (ah = new(window.AudioContext || window.webkitAudioContext)), ah
                },
                setContext: function(e) {
                    ah = e
                }
            };
            class ch extends Mp {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, r) {
                    const i = this,
                        s = new Ep(this.manager);
                    s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function(n) {
                        try {
                            const e = n.slice(0);
                            lh.getContext().decodeAudioData(e, (function(e) {
                                t(e)
                            }))
                        } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                        }
                    }), n, r)
                }
            }
            class uh extends Jp {
                constructor(e, t, n = 1) {
                    super(void 0, n), this.isHemisphereLightProbe = !0;
                    const r = (new Xn).set(e),
                        i = (new Xn).set(t),
                        s = new lr(r.r, r.g, r.b),
                        o = new lr(i.r, i.g, i.b),
                        a = Math.sqrt(Math.PI),
                        l = a * Math.sqrt(.75);
                    this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
                }
            }
            class ph extends Jp {
                constructor(e, t = 1) {
                    super(void 0, t), this.isAmbientLightProbe = !0;
                    const n = (new Xn).set(e);
                    this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                }
            }
            const hh = new Br,
                dh = new Br,
                fh = new Br;
            class _h {
                constructor() {
                    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new gs, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new gs, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                        focus: null,
                        fov: null,
                        aspect: null,
                        near: null,
                        far: null,
                        zoom: null,
                        eyeSep: null
                    }
                }
                update(e) {
                    const t = this._cache;
                    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                        t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, fh.copy(e.projectionMatrix);
                        const n = t.eyeSep / 2,
                            r = n * t.near / t.focus,
                            i = t.near * Math.tan(yn * t.fov * .5) / t.zoom;
                        let s, o;
                        dh.elements[12] = -n, hh.elements[12] = n, s = -i * t.aspect + r, o = i * t.aspect + r, fh.elements[0] = 2 * t.near / (o - s), fh.elements[8] = (o + s) / (o - s), this.cameraL.projectionMatrix.copy(fh), s = -i * t.aspect - r, o = i * t.aspect - r, fh.elements[0] = 2 * t.near / (o - s), fh.elements[8] = (o + s) / (o - s), this.cameraR.projectionMatrix.copy(fh)
                    }
                    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(dh), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(hh)
                }
            }
            class mh {
                constructor(e = !0) {
                    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = gh(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        const t = gh();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }

            function gh() {
                return ("undefined" == typeof performance ? Date : performance).now()
            }
            const vh = new lr,
                bh = new ar,
                xh = new lr,
                yh = new lr;
            class wh extends ui {
                constructor() {
                    super(), this.type = "AudioListener", this.context = lh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new mh
                }
                getInput() {
                    return this.gain
                }
                removeFilter() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                }
                getFilter() {
                    return this.filter
                }
                setFilter(e) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                }
                getMasterVolume() {
                    return this.gain.gain.value
                }
                setMasterVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e);
                    const t = this.context.listener,
                        n = this.up;
                    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(vh, bh, xh), yh.set(0, 0, -1).applyQuaternion(bh), t.positionX) {
                        const e = this.context.currentTime + this.timeDelta;
                        t.positionX.linearRampToValueAtTime(vh.x, e), t.positionY.linearRampToValueAtTime(vh.y, e), t.positionZ.linearRampToValueAtTime(vh.z, e), t.forwardX.linearRampToValueAtTime(yh.x, e), t.forwardY.linearRampToValueAtTime(yh.y, e), t.forwardZ.linearRampToValueAtTime(yh.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e)
                    } else t.setPosition(vh.x, vh.y, vh.z), t.setOrientation(yh.x, yh.y, yh.z, n.x, n.y, n.z)
                }
            }
            class Sh extends ui {
                constructor(e) {
                    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                }
                setMediaElementSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                }
                setMediaStreamSource(e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                }
                setBuffer(e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(e = 0) {
                    if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    this._startedAt = this.context.currentTime + e;
                    const t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                stop() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(e) {
                    return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
                }
                setDetune(e) {
                    if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(e) {
                    return this.setFilters(e ? [e] : [])
                }
                setPlaybackRate(e) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                }
                setLoop(e) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                setLoopStart(e) {
                    return this.loopStart = e, this
                }
                setLoopEnd(e) {
                    return this.loopEnd = e, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }
            const Mh = new lr,
                Th = new ar,
                Eh = new lr,
                Ah = new lr;
            class Ch extends Sh {
                constructor(e) {
                    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                }
                disconnect() {
                    super.disconnect(), this.panner.disconnect(this.gain)
                }
                getOutput() {
                    return this.panner
                }
                getRefDistance() {
                    return this.panner.refDistance
                }
                setRefDistance(e) {
                    return this.panner.refDistance = e, this
                }
                getRolloffFactor() {
                    return this.panner.rolloffFactor
                }
                setRolloffFactor(e) {
                    return this.panner.rolloffFactor = e, this
                }
                getDistanceModel() {
                    return this.panner.distanceModel
                }
                setDistanceModel(e) {
                    return this.panner.distanceModel = e, this
                }
                getMaxDistance() {
                    return this.panner.maxDistance
                }
                setMaxDistance(e) {
                    return this.panner.maxDistance = e, this
                }
                setDirectionalCone(e, t, n) {
                    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
                }
                updateMatrixWorld(e) {
                    if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                    this.matrixWorld.decompose(Mh, Th, Eh), Ah.set(0, 0, 1).applyQuaternion(Th);
                    const t = this.panner;
                    if (t.positionX) {
                        const e = this.context.currentTime + this.listener.timeDelta;
                        t.positionX.linearRampToValueAtTime(Mh.x, e), t.positionY.linearRampToValueAtTime(Mh.y, e), t.positionZ.linearRampToValueAtTime(Mh.z, e), t.orientationX.linearRampToValueAtTime(Ah.x, e), t.orientationY.linearRampToValueAtTime(Ah.y, e), t.orientationZ.linearRampToValueAtTime(Ah.z, e)
                    } else t.setPosition(Mh.x, Mh.y, Mh.z), t.setOrientation(Ah.x, Ah.y, Ah.z)
                }
            }
            class Rh {
                constructor(e, t = 2048) {
                    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
                }
                getFrequencyData() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
                getAverageFrequency() {
                    let e = 0;
                    const t = this.getFrequencyData();
                    for (let n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }
            class kh {
                constructor(e, t, n) {
                    let r, i, s;
                    switch (this.binding = e, this.valueSize = n, t) {
                        case "quaternion":
                            r = this._slerp, i = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            r = this._select, i = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                            break;
                        default:
                            r = this._lerp, i = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                    }
                    this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                }
                accumulate(e, t) {
                    const n = this.buffer,
                        r = this.valueSize,
                        i = e * r + r;
                    let s = this.cumulativeWeight;
                    if (0 === s) {
                        for (let e = 0; e !== r; ++e) n[i + e] = n[e];
                        s = t
                    } else {
                        s += t;
                        const e = t / s;
                        this._mixBufferRegion(n, i, 0, e, r)
                    }
                    this.cumulativeWeight = s
                }
                accumulateAdditive(e) {
                    const t = this.buffer,
                        n = this.valueSize,
                        r = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e
                }
                apply(e) {
                    const t = this.valueSize,
                        n = this.buffer,
                        r = e * t + t,
                        i = this.cumulativeWeight,
                        s = this.cumulativeWeightAdditive,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
                        const e = t * this._origIndex;
                        this._mixBufferRegion(n, r, e, 1 - i, t)
                    }
                    s > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
                    for (let e = t, i = t + t; e !== i; ++e)
                        if (n[e] !== n[e + t]) {
                            o.setValue(n, r);
                            break
                        }
                }
                saveOriginalState() {
                    const e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        r = n * this._origIndex;
                    e.getValue(t, r);
                    for (let e = n, i = r; e !== i; ++e) t[e] = t[r + e % n];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                }
                restoreOriginalState() {
                    const e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                }
                _setAdditiveIdentityNumeric() {
                    const e = this._addIndex * this.valueSize,
                        t = e + this.valueSize;
                    for (let n = e; n < t; n++) this.buffer[n] = 0
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                }
                _setAdditiveIdentityOther() {
                    const e = this._origIndex * this.valueSize,
                        t = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
                }
                _select(e, t, n, r, i) {
                    if (r >= .5)
                        for (let r = 0; r !== i; ++r) e[t + r] = e[n + r]
                }
                _slerp(e, t, n, r) {
                    ar.slerpFlat(e, t, e, t, e, n, r)
                }
                _slerpAdditive(e, t, n, r, i) {
                    const s = this._workIndex * i;
                    ar.multiplyQuaternionsFlat(e, s, e, t, e, n), ar.slerpFlat(e, t, e, t, e, s, r)
                }
                _lerp(e, t, n, r, i) {
                    const s = 1 - r;
                    for (let o = 0; o !== i; ++o) {
                        const i = t + o;
                        e[i] = e[i] * s + e[n + o] * r
                    }
                }
                _lerpAdditive(e, t, n, r, i) {
                    for (let s = 0; s !== i; ++s) {
                        const i = t + s;
                        e[i] = e[i] + e[n + s] * r
                    }
                }
            }
            const Ph = new RegExp("[\\[\\]\\.:\\/]", "g"),
                Dh = "[^\\[\\]\\.:\\/]",
                Oh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                Lh = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Dh) + /(WCOD+)?/.source.replace("WCOD", Oh) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Dh) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Dh) + "$"),
                Ih = ["material", "materials", "bones"];
            class Fh {
                constructor(e, t, n) {
                    this.path = t, this.parsedPath = n || Fh.parseTrackName(t), this.node = Fh.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(e, t, n) {
                    return e && e.isAnimationObjectGroup ? new Fh.Composite(e, t, n) : new Fh(e, t, n)
                }
                static sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace(Ph, "")
                }
                static parseTrackName(e) {
                    const t = Lh.exec(e);
                    if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    const n = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        const e = n.nodeName.substring(r + 1); - 1 !== Ih.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = e)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }
                static findNode(e, t) {
                    if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        const n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n) return n
                    }
                    if (e.children) {
                        const n = function(e) {
                                for (let r = 0; r < e.length; r++) {
                                    const i = e[r];
                                    if (i.name === t || i.uuid === t) return i;
                                    const s = n(i.children);
                                    if (s) return s
                                }
                                return null
                            },
                            r = n(e.children);
                        if (r) return r
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName]
                }
                _getValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
                }
                _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }
                _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                }
                _setValue_array_setNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(e, t) {
                    this.bind(), this.getValue(e, t)
                }
                _setValue_unbound(e, t) {
                    this.bind(), this.setValue(e, t)
                }
                bind() {
                    let e = this.node;
                    const t = this.parsedPath,
                        n = t.objectName,
                        r = t.propertyName;
                    let i = t.propertyIndex;
                    if (e || (e = Fh.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (n) {
                        let r = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                e = e.skeleton.bones;
                                for (let t = 0; t < e.length; t++)
                                    if (e[t].name === r) {
                                        r = t;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                e = e[n]
                        }
                        if (void 0 !== r) {
                            if (void 0 === e[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[r]
                        }
                    }
                    const s = e[r];
                    if (void 0 === s) {
                        const n = t.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e)
                    }
                    let o = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                    let a = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === r) {
                            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
                        }
                        a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                    this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            Fh.Composite = class {
                constructor(e, t, n) {
                    const r = n || Fh.parseTrackName(t);
                    this._targetGroup = e, this._bindings = e.subscribe_(t, r)
                }
                getValue(e, t) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_,
                        r = this._bindings[n];
                    void 0 !== r && r.getValue(e, t)
                }
                setValue(e, t) {
                    const n = this._bindings;
                    for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
                }
                bind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                }
                unbind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }, Fh.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, Fh.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, Fh.prototype.GetterByBindingType = [Fh.prototype._getValue_direct, Fh.prototype._getValue_array, Fh.prototype._getValue_arrayElement, Fh.prototype._getValue_toArray], Fh.prototype.SetterByBindingTypeAndVersioning = [
                [Fh.prototype._setValue_direct, Fh.prototype._setValue_direct_setNeedsUpdate, Fh.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [Fh.prototype._setValue_array, Fh.prototype._setValue_array_setNeedsUpdate, Fh.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [Fh.prototype._setValue_arrayElement, Fh.prototype._setValue_arrayElement_setNeedsUpdate, Fh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [Fh.prototype._setValue_fromArray, Fh.prototype._setValue_fromArray_setNeedsUpdate, Fh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            class Nh {
                constructor() {
                    this.isAnimationObjectGroup = !0, this.uuid = Sn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                    const e = {};
                    this._indicesByUUID = e;
                    for (let t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                    const t = this;
                    this.stats = {
                        objects: {
                            get total() {
                                return t._objects.length
                            },
                            get inUse() {
                                return this.total - t.nCachedObjects_
                            }
                        },
                        get bindingsPerObject() {
                            return t._bindings.length
                        }
                    }
                }
                add() {
                    const e = this._objects,
                        t = this._indicesByUUID,
                        n = this._paths,
                        r = this._parsedPaths,
                        i = this._bindings,
                        s = i.length;
                    let o, a = e.length,
                        l = this.nCachedObjects_;
                    for (let c = 0, u = arguments.length; c !== u; ++c) {
                        const u = arguments[c],
                            p = u.uuid;
                        let h = t[p];
                        if (void 0 === h) {
                            h = a++, t[p] = h, e.push(u);
                            for (let e = 0, t = s; e !== t; ++e) i[e].push(new Fh(u, n[e], r[e]))
                        } else if (h < l) {
                            o = e[h];
                            const a = --l,
                                c = e[a];
                            t[c.uuid] = h, e[h] = c, t[p] = a, e[a] = u;
                            for (let e = 0, t = s; e !== t; ++e) {
                                const t = i[e],
                                    s = t[a];
                                let o = t[h];
                                t[h] = s, void 0 === o && (o = new Fh(u, n[e], r[e])), t[a] = o
                            }
                        } else e[h] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = l
                }
                remove() {
                    const e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length;
                    let i = this.nCachedObjects_;
                    for (let s = 0, o = arguments.length; s !== o; ++s) {
                        const o = arguments[s],
                            a = o.uuid,
                            l = t[a];
                        if (void 0 !== l && l >= i) {
                            const s = i++,
                                c = e[s];
                            t[c.uuid] = l, e[l] = c, t[a] = s, e[s] = o;
                            for (let e = 0, t = r; e !== t; ++e) {
                                const t = n[e],
                                    r = t[s],
                                    i = t[l];
                                t[l] = r, t[s] = i
                            }
                        }
                    }
                    this.nCachedObjects_ = i
                }
                uncache() {
                    const e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length;
                    let i = this.nCachedObjects_,
                        s = e.length;
                    for (let o = 0, a = arguments.length; o !== a; ++o) {
                        const a = arguments[o].uuid,
                            l = t[a];
                        if (void 0 !== l)
                            if (delete t[a], l < i) {
                                const o = --i,
                                    a = e[o],
                                    c = --s,
                                    u = e[c];
                                t[a.uuid] = l, e[l] = a, t[u.uuid] = o, e[o] = u, e.pop();
                                for (let e = 0, t = r; e !== t; ++e) {
                                    const t = n[e],
                                        r = t[o],
                                        i = t[c];
                                    t[l] = r, t[o] = i, t.pop()
                                }
                            } else {
                                const i = --s,
                                    o = e[i];
                                i > 0 && (t[o.uuid] = l), e[l] = o, e.pop();
                                for (let e = 0, t = r; e !== t; ++e) {
                                    const t = n[e];
                                    t[l] = t[i], t.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = i
                }
                subscribe_(e, t) {
                    const n = this._bindingsIndicesByPath;
                    let r = n[e];
                    const i = this._bindings;
                    if (void 0 !== r) return i[r];
                    const s = this._paths,
                        o = this._parsedPaths,
                        a = this._objects,
                        l = a.length,
                        c = this.nCachedObjects_,
                        u = new Array(l);
                    r = i.length, n[e] = r, s.push(e), o.push(t), i.push(u);
                    for (let n = c, r = a.length; n !== r; ++n) {
                        const r = a[n];
                        u[n] = new Fh(r, e, t)
                    }
                    return u
                }
                unsubscribe_(e) {
                    const t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        const r = this._paths,
                            i = this._parsedPaths,
                            s = this._bindings,
                            o = s.length - 1,
                            a = s[o];
                        t[e[o]] = n, s[n] = a, s.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop()
                    }
                }
            }
            class Uh {
                constructor(e, t, n = null, r = t.blendMode) {
                    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
                    const i = t.tracks,
                        s = i.length,
                        o = new Array(s),
                        a = {
                            endingStart: Mt,
                            endingEnd: Mt
                        };
                    for (let e = 0; e !== s; ++e) {
                        const t = i[e].createInterpolant(null);
                        o[e] = t, t.settings = a
                    }
                    this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = bt, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(e) {
                    return this._startTime = e, this
                }
                setLoop(e, t) {
                    return this.loop = e, this.repetitions = t, this
                }
                setEffectiveWeight(e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(e) {
                    return this._scheduleFading(e, 0, 1)
                }
                fadeOut(e) {
                    return this._scheduleFading(e, 1, 0)
                }
                crossFadeFrom(e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        const n = this._clip.duration,
                            r = e._clip.duration,
                            i = r / n,
                            s = n / r;
                        e.warp(1, i, t), this.warp(s, 1, t)
                    }
                    return this
                }
                crossFadeTo(e, t, n) {
                    return e.crossFadeFrom(this, t, n)
                }
                stopFading() {
                    const e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                setEffectiveTimeScale(e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                }
                syncWith(e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                }
                halt(e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                }
                warp(e, t, n) {
                    const r = this._mixer,
                        i = r.time,
                        s = this.timeScale;
                    let o = this._timeScaleInterpolant;
                    null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                    const a = o.parameterPositions,
                        l = o.sampleValues;
                    return a[0] = i, a[1] = i + n, l[0] = e / s, l[1] = t / s, this
                }
                stopWarping() {
                    const e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(e, t, n, r) {
                    if (!this.enabled) return void this._updateWeight(e);
                    const i = this._startTime;
                    if (null !== i) {
                        const r = (e - i) * n;
                        if (r < 0 || 0 === n) return;
                        this._startTime = null, t = n * r
                    }
                    t *= this._updateTimeScale(e);
                    const s = this._updateTime(t),
                        o = this._updateWeight(e);
                    if (o > 0) {
                        const e = this._interpolants,
                            t = this._propertyBindings;
                        switch (this.blendMode) {
                            case Ct:
                                for (let n = 0, r = e.length; n !== r; ++n) e[n].evaluate(s), t[n].accumulateAdditive(o);
                                break;
                            case At:
                            default:
                                for (let n = 0, i = e.length; n !== i; ++n) e[n].evaluate(s), t[n].accumulate(r, o)
                        }
                    }
                }
                _updateWeight(e) {
                    let t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        const n = this._weightInterpolant;
                        if (null !== n) {
                            const r = n.evaluate(e)[0];
                            t *= r, e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                }
                _updateTimeScale(e) {
                    let t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        const n = this._timeScaleInterpolant;
                        null !== n && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t))
                    }
                    return this._effectiveTimeScale = t, t
                }
                _updateTime(e) {
                    const t = this._clip.duration,
                        n = this.loop;
                    let r = this.time + e,
                        i = this._loopCount;
                    const s = n === xt;
                    if (0 === e) return -1 === i ? r : s && 1 == (1 & i) ? t - r : r;
                    if (n === vt) {
                        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        e: {
                            if (r >= t) r = t;
                            else {
                                if (!(r < 0)) {
                                    this.time = r;
                                    break e
                                }
                                r = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = r,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === i && (e >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), r >= t || r < 0) {
                            const n = Math.floor(r / t);
                            r -= t * n, i += Math.abs(n);
                            const o = this.repetitions - i;
                            if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                            else {
                                if (1 === o) {
                                    const t = e < 0;
                                    this._setEndings(t, !t, s)
                                } else this._setEndings(!1, !1, s);
                                this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: n
                                })
                            }
                        } else this.time = r;
                        if (s && 1 == (1 & i)) return t - r
                    }
                    return r
                }
                _setEndings(e, t, n) {
                    const r = this._interpolantSettings;
                    n ? (r.endingStart = Tt, r.endingEnd = Tt) : (r.endingStart = e ? this.zeroSlopeAtStart ? Tt : Mt : Et, r.endingEnd = t ? this.zeroSlopeAtEnd ? Tt : Mt : Et)
                }
                _scheduleFading(e, t, n) {
                    const r = this._mixer,
                        i = r.time;
                    let s = this._weightInterpolant;
                    null === s && (s = r._lendControlInterpolant(), this._weightInterpolant = s);
                    const o = s.parameterPositions,
                        a = s.sampleValues;
                    return o[0] = i, a[0] = t, o[1] = i + e, a[1] = n, this
                }
            }
            const Bh = new Float32Array(1);
            class jh extends vn {
                constructor(e) {
                    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                }
                _bindAction(e, t) {
                    const n = e._localRoot || this._root,
                        r = e._clip.tracks,
                        i = r.length,
                        s = e._propertyBindings,
                        o = e._interpolants,
                        a = n.uuid,
                        l = this._bindingsByRootAndName;
                    let c = l[a];
                    void 0 === c && (c = {}, l[a] = c);
                    for (let e = 0; e !== i; ++e) {
                        const i = r[e],
                            l = i.name;
                        let u = c[l];
                        if (void 0 !== u) ++u.referenceCount, s[e] = u;
                        else {
                            if (u = s[e], void 0 !== u) {
                                null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, l));
                                continue
                            }
                            const r = t && t._propertyBindings[e].binding.parsedPath;
                            u = new kh(Fh.create(n, l, r), i.ValueTypeName, i.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, a, l), s[e] = u
                        }
                        o[e].resultBuffer = u.buffer
                    }
                }
                _activateAction(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            const t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                r = this._actionsByClip[n];
                            this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        const t = e._propertyBindings;
                        for (let e = 0, n = t.length; e !== n; ++e) {
                            const n = t[e];
                            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                }
                _deactivateAction(e) {
                    if (this._isActiveAction(e)) {
                        const t = e._propertyBindings;
                        for (let e = 0, n = t.length; e !== n; ++e) {
                            const n = t[e];
                            0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                        }
                        this._takeBackAction(e)
                    }
                }
                _initMemoryManager() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    const e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                }
                _isActiveAction(e) {
                    const t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                }
                _addInactiveAction(e, t, n) {
                    const r = this._actions,
                        i = this._actionsByClip;
                    let s = i[t];
                    if (void 0 === s) s = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, i[t] = s;
                    else {
                        const t = s.knownActions;
                        e._byClipCacheIndex = t.length, t.push(e)
                    }
                    e._cacheIndex = r.length, r.push(e), s.actionByRoot[n] = e
                }
                _removeInactiveAction(e) {
                    const t = this._actions,
                        n = t[t.length - 1],
                        r = e._cacheIndex;
                    n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
                    const i = e._clip.uuid,
                        s = this._actionsByClip,
                        o = s[i],
                        a = o.knownActions,
                        l = a[a.length - 1],
                        c = e._byClipCacheIndex;
                    l._byClipCacheIndex = c, a[c] = l, a.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === a.length && delete s[i], this._removeInactiveBindingsForAction(e)
                }
                _removeInactiveBindingsForAction(e) {
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 == --n.referenceCount && this._removeInactiveBinding(n)
                    }
                }
                _lendAction(e) {
                    const t = this._actions,
                        n = e._cacheIndex,
                        r = this._nActiveActions++,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _takeBackAction(e) {
                    const t = this._actions,
                        n = e._cacheIndex,
                        r = --this._nActiveActions,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _addInactiveBinding(e, t, n) {
                    const r = this._bindingsByRootAndName,
                        i = this._bindings;
                    let s = r[t];
                    void 0 === s && (s = {}, r[t] = s), s[n] = e, e._cacheIndex = i.length, i.push(e)
                }
                _removeInactiveBinding(e) {
                    const t = this._bindings,
                        n = e.binding,
                        r = n.rootNode.uuid,
                        i = n.path,
                        s = this._bindingsByRootAndName,
                        o = s[r],
                        a = t[t.length - 1],
                        l = e._cacheIndex;
                    a._cacheIndex = l, t[l] = a, t.pop(), delete o[i], 0 === Object.keys(o).length && delete s[r]
                }
                _lendBinding(e) {
                    const t = this._bindings,
                        n = e._cacheIndex,
                        r = this._nActiveBindings++,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _takeBackBinding(e) {
                    const t = this._bindings,
                        n = e._cacheIndex,
                        r = --this._nActiveBindings,
                        i = t[r];
                    e._cacheIndex = r, t[r] = e, i._cacheIndex = n, t[n] = i
                }
                _lendControlInterpolant() {
                    const e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++;
                    let n = e[t];
                    return void 0 === n && (n = new cp(new Float32Array(2), new Float32Array(2), 1, Bh), n.__cacheIndex = t, e[t] = n), n
                }
                _takeBackControlInterpolant(e) {
                    const t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        r = --this._nActiveControlInterpolants,
                        i = t[r];
                    e.__cacheIndex = r, t[r] = e, i.__cacheIndex = n, t[n] = i
                }
                clipAction(e, t, n) {
                    const r = t || this._root,
                        i = r.uuid;
                    let s = "string" == typeof e ? bp.findByName(r, e) : e;
                    const o = null !== s ? s.uuid : e,
                        a = this._actionsByClip[o];
                    let l = null;
                    if (void 0 === n && (n = null !== s ? s.blendMode : At), void 0 !== a) {
                        const e = a.actionByRoot[i];
                        if (void 0 !== e && e.blendMode === n) return e;
                        l = a.knownActions[0], null === s && (s = l._clip)
                    }
                    if (null === s) return null;
                    const c = new Uh(this, s, t, n);
                    return this._bindAction(c, l), this._addInactiveAction(c, o, i), c
                }
                existingAction(e, t) {
                    const n = t || this._root,
                        r = n.uuid,
                        i = "string" == typeof e ? bp.findByName(n, e) : e,
                        s = i ? i.uuid : e,
                        o = this._actionsByClip[s];
                    return void 0 !== o && o.actionByRoot[r] || null
                }
                stopAllAction() {
                    const e = this._actions;
                    for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
                    return this
                }
                update(e) {
                    e *= this.timeScale;
                    const t = this._actions,
                        n = this._nActiveActions,
                        r = this.time += e,
                        i = Math.sign(e),
                        s = this._accuIndex ^= 1;
                    for (let o = 0; o !== n; ++o) t[o]._update(r, e, i, s);
                    const o = this._bindings,
                        a = this._nActiveBindings;
                    for (let e = 0; e !== a; ++e) o[e].apply(s);
                    return this
                }
                setTime(e) {
                    this.time = 0;
                    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                    return this.update(e)
                }
                getRoot() {
                    return this._root
                }
                uncacheClip(e) {
                    const t = this._actions,
                        n = e.uuid,
                        r = this._actionsByClip,
                        i = r[n];
                    if (void 0 !== i) {
                        const e = i.knownActions;
                        for (let n = 0, r = e.length; n !== r; ++n) {
                            const r = e[n];
                            this._deactivateAction(r);
                            const i = r._cacheIndex,
                                s = t[t.length - 1];
                            r._cacheIndex = null, r._byClipCacheIndex = null, s._cacheIndex = i, t[i] = s, t.pop(), this._removeInactiveBindingsForAction(r)
                        }
                        delete r[n]
                    }
                }
                uncacheRoot(e) {
                    const t = e.uuid,
                        n = this._actionsByClip;
                    for (const e in n) {
                        const r = n[e].actionByRoot[t];
                        void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                    }
                    const r = this._bindingsByRootAndName[t];
                    if (void 0 !== r)
                        for (const e in r) {
                            const t = r[e];
                            t.restoreOriginalState(), this._removeInactiveBinding(t)
                        }
                }
                uncacheAction(e, t) {
                    const n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }
            class zh {
                constructor(e) {
                    "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
                }
                clone() {
                    return new zh(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }
            let Vh = 0;
            class Gh extends vn {
                constructor() {
                    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
                        value: Vh++
                    }), this.name = "", this.usage = on, this.uniforms = []
                }
                add(e) {
                    return this.uniforms.push(e), this
                }
                remove(e) {
                    const t = this.uniforms.indexOf(e);
                    return -1 !== t && this.uniforms.splice(t, 1), this
                }
                setName(e) {
                    return this.name = e, this
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                dispose() {
                    return this.dispatchEvent({
                        type: "dispose"
                    }), this
                }
                copy(e) {
                    this.name = e.name, this.usage = e.usage;
                    const t = e.uniforms;
                    this.uniforms.length = 0;
                    for (let e = 0, n = t.length; e < n; e++) this.uniforms.push(t[e].clone());
                    return this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class Hh extends _l {
                constructor(e, t, n = 1) {
                    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                clone(e) {
                    const t = super.clone(e);
                    return t.meshPerAttribute = this.meshPerAttribute, t
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
                }
            }
            class Wh {
                constructor(e, t, n, r, i) {
                    this.isGLBufferAttribute = !0, this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setBuffer(e) {
                    return this.buffer = e, this
                }
                setType(e, t) {
                    return this.type = e, this.elementSize = t, this
                }
                setItemSize(e) {
                    return this.itemSize = e, this
                }
                setCount(e) {
                    return this.count = e, this
                }
            }
            class Kh {
                constructor(e, t, n = 0, r = 1 / 0) {
                    this.ray = new Ur(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new Zr, this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                set(e, t) {
                    this.ray.set(e, t)
                }
                setFromCamera(e, t) {
                    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                }
                intersectObject(e, t = !0, n = []) {
                    return qh(e, this, n, t), n.sort(Xh), n
                }
                intersectObjects(e, t = !0, n = []) {
                    for (let r = 0, i = e.length; r < i; r++) qh(e[r], this, n, t);
                    return n.sort(Xh), n
                }
            }

            function Xh(e, t) {
                return e.distance - t.distance
            }

            function qh(e, t, n, r) {
                if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r) {
                    const r = e.children;
                    for (let e = 0, i = r.length; e < i; e++) qh(r[e], t, n, !0)
                }
            }
            class Yh {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                copy(e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                }
                makeSafe() {
                    const e = 1e-6;
                    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Mn(t / this.radius, -1, 1))), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class Zh {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
                copy(e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Jh = new Pn;
            class $h {
                constructor(e = new Pn(1 / 0, 1 / 0), t = new Pn(-1 / 0, -1 / 0)) {
                    this.isBox2 = !0, this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const n = Jh.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return Jh.copy(e).clamp(this.min, this.max).sub(e).length()
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            const Qh = new lr,
                ed = new lr;
            class td {
                constructor(e = new lr, t = new lr) {
                    this.start = e, this.end = t
                }
                set(e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                }
                copy(e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                }
                getCenter(e) {
                    return e.addVectors(this.start, this.end).multiplyScalar(.5)
                }
                delta(e) {
                    return e.subVectors(this.end, this.start)
                }
                distanceSq() {
                    return this.start.distanceToSquared(this.end)
                }
                distance() {
                    return this.start.distanceTo(this.end)
                }
                at(e, t) {
                    return this.delta(t).multiplyScalar(e).add(this.start)
                }
                closestPointToPointParameter(e, t) {
                    Qh.subVectors(e, this.start), ed.subVectors(this.end, this.start);
                    const n = ed.dot(ed);
                    let r = ed.dot(Qh) / n;
                    return t && (r = Mn(r, 0, 1)), r
                }
                closestPointToPoint(e, t, n) {
                    const r = this.closestPointToPointParameter(e, t);
                    return this.delta(n).multiplyScalar(r).add(this.start)
                }
                applyMatrix4(e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                }
                equals(e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const nd = new lr;
            class rd extends ui {
                constructor(e, t) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                    const n = new Wi,
                        r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                    for (let e = 0, t = 1, n = 32; e < n; e++, t++) {
                        const i = e / n * Math.PI * 2,
                            s = t / n * Math.PI * 2;
                        r.push(Math.cos(i), Math.sin(i), 1, Math.cos(s), Math.sin(s), 1)
                    }
                    n.setAttribute("position", new Fi(r, 3));
                    const i = new ec({
                        fog: !1,
                        toneMapped: !1
                    });
                    this.cone = new cc(n, i), this.add(this.cone), this.update()
                }
                dispose() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }
                update() {
                    this.light.updateMatrixWorld();
                    const e = this.light.distance ? this.light.distance : 1e3,
                        t = e * Math.tan(this.light.angle);
                    this.cone.scale.set(t, t, e), nd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(nd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }
            const id = new lr,
                sd = new Br,
                od = new Br;
            class ad extends cc {
                constructor(e) {
                    const t = ld(e),
                        n = new Wi,
                        r = [],
                        i = [],
                        s = new Xn(0, 0, 1),
                        o = new Xn(0, 1, 0);
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e];
                        n.parent && n.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(s.r, s.g, s.b), i.push(o.r, o.g, o.b))
                    }
                    n.setAttribute("position", new Fi(r, 3)), n.setAttribute("color", new Fi(i, 3)), super(n, new ec({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    })), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(e) {
                    const t = this.bones,
                        n = this.geometry,
                        r = n.getAttribute("position");
                    od.copy(this.root.matrixWorld).invert();
                    for (let e = 0, n = 0; e < t.length; e++) {
                        const i = t[e];
                        i.parent && i.parent.isBone && (sd.multiplyMatrices(od, i.matrixWorld), id.setFromMatrixPosition(sd), r.setXYZ(n, id.x, id.y, id.z), sd.multiplyMatrices(od, i.parent.matrixWorld), id.setFromMatrixPosition(sd), r.setXYZ(n + 1, id.x, id.y, id.z), n += 2)
                    }
                    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
                }
            }

            function ld(e) {
                const t = [];
                !0 === e.isBone && t.push(e);
                for (let n = 0; n < e.children.length; n++) t.push.apply(t, ld(e.children[n]));
                return t
            }
            class cd extends cs {
                constructor(e, t, n) {
                    super(new Fu(t, 4, 2), new Mi({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    })), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
                update() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }
            }
            const ud = new lr,
                pd = new Xn,
                hd = new Xn;
            class dd extends ui {
                constructor(e, t, n) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                    const r = new Ou(t);
                    r.rotateY(.5 * Math.PI), this.material = new Mi({
                        wireframe: !0,
                        fog: !1,
                        toneMapped: !1
                    }), void 0 === this.color && (this.material.vertexColors = !0);
                    const i = r.getAttribute("position"),
                        s = new Float32Array(3 * i.count);
                    r.setAttribute("color", new Ai(s, 3)), this.add(new cs(r, this.material)), this.update()
                }
                dispose() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }
                update() {
                    const e = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        const t = e.geometry.getAttribute("color");
                        pd.copy(this.light.color), hd.copy(this.light.groundColor);
                        for (let e = 0, n = t.count; e < n; e++) {
                            const r = e < n / 2 ? pd : hd;
                            t.setXYZ(e, r.r, r.g, r.b)
                        }
                        t.needsUpdate = !0
                    }
                    e.lookAt(ud.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }
            class fd extends cc {
                constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
                    n = new Xn(n), r = new Xn(r);
                    const i = t / 2,
                        s = e / t,
                        o = e / 2,
                        a = [],
                        l = [];
                    for (let e = 0, c = 0, u = -o; e <= t; e++, u += s) {
                        a.push(-o, 0, u, o, 0, u), a.push(u, 0, -o, u, 0, o);
                        const t = e === i ? n : r;
                        t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3
                    }
                    const c = new Wi;
                    c.setAttribute("position", new Fi(a, 3)), c.setAttribute("color", new Fi(l, 3)), super(c, new ec({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "GridHelper"
                }
            }
            class _d extends cc {
                constructor(e = 10, t = 16, n = 8, r = 64, i = 4473924, s = 8947848) {
                    i = new Xn(i), s = new Xn(s);
                    const o = [],
                        a = [];
                    for (let n = 0; n <= t; n++) {
                        const r = n / t * (2 * Math.PI),
                            l = Math.sin(r) * e,
                            c = Math.cos(r) * e;
                        o.push(0, 0, 0), o.push(l, 0, c);
                        const u = 1 & n ? i : s;
                        a.push(u.r, u.g, u.b), a.push(u.r, u.g, u.b)
                    }
                    for (let t = 0; t <= n; t++) {
                        const l = 1 & t ? i : s,
                            c = e - e / n * t;
                        for (let e = 0; e < r; e++) {
                            let t = e / r * (2 * Math.PI),
                                n = Math.sin(t) * c,
                                i = Math.cos(t) * c;
                            o.push(n, 0, i), a.push(l.r, l.g, l.b), t = (e + 1) / r * (2 * Math.PI), n = Math.sin(t) * c, i = Math.cos(t) * c, o.push(n, 0, i), a.push(l.r, l.g, l.b)
                        }
                    }
                    const l = new Wi;
                    l.setAttribute("position", new Fi(o, 3)), l.setAttribute("color", new Fi(a, 3)), super(l, new ec({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "PolarGridHelper"
                }
            }
            const md = new lr,
                gd = new lr,
                vd = new lr;
            class bd extends ui {
                constructor(e, t, n) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
                    let r = new Wi;
                    r.setAttribute("position", new Fi([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                    const i = new ec({
                        fog: !1,
                        toneMapped: !1
                    });
                    this.lightPlane = new oc(r, i), this.add(this.lightPlane), r = new Wi, r.setAttribute("position", new Fi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new oc(r, i), this.add(this.targetLine), this.update()
                }
                dispose() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }
                update() {
                    md.setFromMatrixPosition(this.light.matrixWorld), gd.setFromMatrixPosition(this.light.target.matrixWorld), vd.subVectors(gd, md), this.lightPlane.lookAt(gd), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(gd), this.targetLine.scale.z = vd.length()
                }
            }
            const xd = new lr,
                yd = new ms;
            class wd extends cc {
                constructor(e) {
                    const t = new Wi,
                        n = new ec({
                            color: 16777215,
                            vertexColors: !0,
                            toneMapped: !1
                        }),
                        r = [],
                        i = [],
                        s = {};

                    function o(e, t) {
                        a(e), a(t)
                    }

                    function a(e) {
                        r.push(0, 0, 0), i.push(0, 0, 0), void 0 === s[e] && (s[e] = []), s[e].push(r.length / 3 - 1)
                    }
                    o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4"), t.setAttribute("position", new Fi(r, 3)), t.setAttribute("color", new Fi(i, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update();
                    const l = new Xn(16755200),
                        c = new Xn(16711680),
                        u = new Xn(43775),
                        p = new Xn(16777215),
                        h = new Xn(3355443);
                    this.setColors(l, c, u, p, h)
                }
                setColors(e, t, n, r, i) {
                    const s = this.geometry.getAttribute("color");
                    s.setXYZ(0, e.r, e.g, e.b), s.setXYZ(1, e.r, e.g, e.b), s.setXYZ(2, e.r, e.g, e.b), s.setXYZ(3, e.r, e.g, e.b), s.setXYZ(4, e.r, e.g, e.b), s.setXYZ(5, e.r, e.g, e.b), s.setXYZ(6, e.r, e.g, e.b), s.setXYZ(7, e.r, e.g, e.b), s.setXYZ(8, e.r, e.g, e.b), s.setXYZ(9, e.r, e.g, e.b), s.setXYZ(10, e.r, e.g, e.b), s.setXYZ(11, e.r, e.g, e.b), s.setXYZ(12, e.r, e.g, e.b), s.setXYZ(13, e.r, e.g, e.b), s.setXYZ(14, e.r, e.g, e.b), s.setXYZ(15, e.r, e.g, e.b), s.setXYZ(16, e.r, e.g, e.b), s.setXYZ(17, e.r, e.g, e.b), s.setXYZ(18, e.r, e.g, e.b), s.setXYZ(19, e.r, e.g, e.b), s.setXYZ(20, e.r, e.g, e.b), s.setXYZ(21, e.r, e.g, e.b), s.setXYZ(22, e.r, e.g, e.b), s.setXYZ(23, e.r, e.g, e.b), s.setXYZ(24, t.r, t.g, t.b), s.setXYZ(25, t.r, t.g, t.b), s.setXYZ(26, t.r, t.g, t.b), s.setXYZ(27, t.r, t.g, t.b), s.setXYZ(28, t.r, t.g, t.b), s.setXYZ(29, t.r, t.g, t.b), s.setXYZ(30, t.r, t.g, t.b), s.setXYZ(31, t.r, t.g, t.b), s.setXYZ(32, n.r, n.g, n.b), s.setXYZ(33, n.r, n.g, n.b), s.setXYZ(34, n.r, n.g, n.b), s.setXYZ(35, n.r, n.g, n.b), s.setXYZ(36, n.r, n.g, n.b), s.setXYZ(37, n.r, n.g, n.b), s.setXYZ(38, r.r, r.g, r.b), s.setXYZ(39, r.r, r.g, r.b), s.setXYZ(40, i.r, i.g, i.b), s.setXYZ(41, i.r, i.g, i.b), s.setXYZ(42, i.r, i.g, i.b), s.setXYZ(43, i.r, i.g, i.b), s.setXYZ(44, i.r, i.g, i.b), s.setXYZ(45, i.r, i.g, i.b), s.setXYZ(46, i.r, i.g, i.b), s.setXYZ(47, i.r, i.g, i.b), s.setXYZ(48, i.r, i.g, i.b), s.setXYZ(49, i.r, i.g, i.b), s.needsUpdate = !0
                }
                update() {
                    const e = this.geometry,
                        t = this.pointMap;
                    yd.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Sd("c", t, e, yd, 0, 0, -1), Sd("t", t, e, yd, 0, 0, 1), Sd("n1", t, e, yd, -1, -1, -1), Sd("n2", t, e, yd, 1, -1, -1), Sd("n3", t, e, yd, -1, 1, -1), Sd("n4", t, e, yd, 1, 1, -1), Sd("f1", t, e, yd, -1, -1, 1), Sd("f2", t, e, yd, 1, -1, 1), Sd("f3", t, e, yd, -1, 1, 1), Sd("f4", t, e, yd, 1, 1, 1), Sd("u1", t, e, yd, .7, 1.1, -1), Sd("u2", t, e, yd, -.7, 1.1, -1), Sd("u3", t, e, yd, 0, 2, -1), Sd("cf1", t, e, yd, -1, 0, 1), Sd("cf2", t, e, yd, 1, 0, 1), Sd("cf3", t, e, yd, 0, -1, 1), Sd("cf4", t, e, yd, 0, 1, 1), Sd("cn1", t, e, yd, -1, 0, -1), Sd("cn2", t, e, yd, 1, 0, -1), Sd("cn3", t, e, yd, 0, -1, -1), Sd("cn4", t, e, yd, 0, 1, -1), e.getAttribute("position").needsUpdate = !0
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }

            function Sd(e, t, n, r, i, s, o) {
                xd.set(i, s, o).unproject(r);
                const a = t[e];
                if (void 0 !== a) {
                    const e = n.getAttribute("position");
                    for (let t = 0, n = a.length; t < n; t++) e.setXYZ(a[t], xd.x, xd.y, xd.z)
                }
            }
            const Md = new pr;
            class Td extends cc {
                constructor(e, t = 16776960) {
                    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        r = new Float32Array(24),
                        i = new Wi;
                    i.setIndex(new Ai(n, 1)), i.setAttribute("position", new Ai(r, 3)), super(i, new ec({
                        color: t,
                        toneMapped: !1
                    })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
                }
                update(e) {
                    if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Md.setFromObject(this.object), Md.isEmpty()) return;
                    const t = Md.min,
                        n = Md.max,
                        r = this.geometry.attributes.position,
                        i = r.array;
                    i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = t.x, i[4] = n.y, i[5] = n.z, i[6] = t.x, i[7] = t.y, i[8] = n.z, i[9] = n.x, i[10] = t.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = t.z, i[15] = t.x, i[16] = n.y, i[17] = t.z, i[18] = t.x, i[19] = t.y, i[20] = t.z, i[21] = n.x, i[22] = t.y, i[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
                setFromObject(e) {
                    return this.object = e, this.update(), this
                }
                copy(e, t) {
                    return super.copy(e, t), this.object = e.object, this
                }
            }
            class Ed extends cc {
                constructor(e, t = 16776960) {
                    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        r = new Wi;
                    r.setIndex(new Ai(n, 1)), r.setAttribute("position", new Fi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new ec({
                        color: t,
                        toneMapped: !1
                    })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                }
                updateMatrixWorld(e) {
                    const t = this.box;
                    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
                }
            }
            class Ad extends oc {
                constructor(e, t = 1, n = 16776960) {
                    const r = n,
                        i = new Wi;
                    i.setAttribute("position", new Fi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), super(i, new ec({
                        color: r,
                        toneMapped: !1
                    })), this.type = "PlaneHelper", this.plane = e, this.size = t;
                    const s = new Wi;
                    s.setAttribute("position", new Fi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new cs(s, new Mi({
                        color: r,
                        opacity: .2,
                        transparent: !0,
                        depthWrite: !1,
                        toneMapped: !1
                    })))
                }
                updateMatrixWorld(e) {
                    let t = -this.plane.constant;
                    Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? _ : f, this.lookAt(this.plane.normal), super.updateMatrixWorld(e)
                }
            }
            const Cd = new lr;
            let Rd, kd;
            class Pd extends ui {
                constructor(e = new lr(0, 0, 1), t = new lr(0, 0, 0), n = 1, r = 16776960, i = .2 * n, s = .2 * i) {
                    super(), this.type = "ArrowHelper", void 0 === Rd && (Rd = new Wi, Rd.setAttribute("position", new Fi([0, 0, 0, 0, 1, 0], 3)), kd = new Xc(0, .5, 1, 5, 1), kd.translate(0, -.5, 0)), this.position.copy(t), this.line = new oc(Rd, new ec({
                        color: r,
                        toneMapped: !1
                    })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new cs(kd, new Mi({
                        color: r,
                        toneMapped: !1
                    })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, i, s)
                }
                setDirection(e) {
                    if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
                    else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                    else {
                        Cd.set(e.z, 0, -e.x).normalize();
                        const t = Math.acos(e.y);
                        this.quaternion.setFromAxisAngle(Cd, t)
                    }
                }
                setLength(e, t = .2 * e, n = .2 * t) {
                    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
                }
                setColor(e) {
                    this.line.material.color.set(e), this.cone.material.color.set(e)
                }
                copy(e) {
                    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
                }
            }
            class Dd extends cc {
                constructor(e = 1) {
                    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                        n = new Wi;
                    n.setAttribute("position", new Fi(t, 3)), n.setAttribute("color", new Fi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new ec({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "AxesHelper"
                }
                setColors(e, t, n) {
                    const r = new Xn,
                        i = this.geometry.attributes.color.array;
                    return r.set(e), r.toArray(i, 0), r.toArray(i, 3), r.set(t), r.toArray(i, 6), r.toArray(i, 9), r.set(n), r.toArray(i, 12), r.toArray(i, 15), this.geometry.attributes.color.needsUpdate = !0, this
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            class Od {
                constructor() {
                    this.type = "ShapePath", this.color = new Xn, this.subPaths = [], this.currentPath = null
                }
                moveTo(e, t) {
                    return this.currentPath = new Gc, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
                }
                lineTo(e, t) {
                    return this.currentPath.lineTo(e, t), this
                }
                quadraticCurveTo(e, t, n, r) {
                    return this.currentPath.quadraticCurveTo(e, t, n, r), this
                }
                bezierCurveTo(e, t, n, r, i, s) {
                    return this.currentPath.bezierCurveTo(e, t, n, r, i, s), this
                }
                splineThru(e) {
                    return this.currentPath.splineThru(e), this
                }
                toShapes(e, t) {
                    function n(e) {
                        const t = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n],
                                i = new nu;
                            i.curves = r.curves, t.push(i)
                        }
                        return t
                    }

                    function r(e, t) {
                        const n = t.length;
                        let r = !1;
                        for (let i = n - 1, s = 0; s < n; i = s++) {
                            let n = t[i],
                                o = t[s],
                                a = o.x - n.x,
                                l = o.y - n.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (n = t[s], a = -a, o = t[i], l = -l), e.y < n.y || e.y > o.y) continue;
                                if (e.y === n.y) {
                                    if (e.x === n.x) return !0
                                } else {
                                    const t = l * (e.x - n.x) - a * (e.y - n.y);
                                    if (0 === t) return !0;
                                    if (t < 0) continue;
                                    r = !r
                                }
                            } else {
                                if (e.y !== n.y) continue;
                                if (o.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= o.x) return !0
                            }
                        }
                        return r
                    }
                    const i = Au.isClockWise,
                        s = this.subPaths;
                    if (0 === s.length) return [];
                    if (!0 === t) return n(s);
                    let o, a, l;
                    const c = [];
                    if (1 === s.length) return a = s[0], l = new nu, l.curves = a.curves, c.push(l), c;
                    let u = !i(s[0].getPoints());
                    u = e ? !u : u;
                    const p = [],
                        h = [];
                    let d, f, _ = [],
                        m = 0;
                    h[m] = void 0, _[m] = [];
                    for (let t = 0, n = s.length; t < n; t++) a = s[t], d = a.getPoints(), o = i(d), o = e ? !o : o, o ? (!u && h[m] && m++, h[m] = {
                        s: new nu,
                        p: d
                    }, h[m].s.curves = a.curves, u && m++, _[m] = []) : _[m].push({
                        h: a,
                        p: d[0]
                    });
                    if (!h[0]) return n(s);
                    if (h.length > 1) {
                        let e = !1,
                            t = 0;
                        for (let e = 0, t = h.length; e < t; e++) p[e] = [];
                        for (let n = 0, i = h.length; n < i; n++) {
                            const i = _[n];
                            for (let s = 0; s < i.length; s++) {
                                const o = i[s];
                                let a = !0;
                                for (let i = 0; i < h.length; i++) r(o.p, h[i].p) && (n !== i && t++, a ? (a = !1, p[i].push(o)) : e = !0);
                                a && p[n].push(o)
                            }
                        }
                        t > 0 && !1 === e && (_ = p)
                    }
                    for (let e = 0, t = h.length; e < t; e++) {
                        l = h[e].s, c.push(l), f = _[e];
                        for (let e = 0, t = f.length; e < t; e++) l.holes.push(f[e].h)
                    }
                    return c
                }
            }
            const {
                floatView: Ld,
                uint32View: Id,
                baseTable: Fd,
                shiftTable: Nd,
                mantissaTable: Ud,
                exponentTable: Bd,
                offsetTable: jd
            } = zd();

            function zd() {
                const e = new ArrayBuffer(4),
                    t = new Float32Array(e),
                    n = new Uint32Array(e),
                    r = new Uint32Array(512),
                    i = new Uint32Array(512);
                for (let e = 0; e < 256; ++e) {
                    const t = e - 127;
                    t < -27 ? (r[e] = 0, r[256 | e] = 32768, i[e] = 24, i[256 | e] = 24) : t < -14 ? (r[e] = 1024 >> -t - 14, r[256 | e] = 1024 >> -t - 14 | 32768, i[e] = -t - 1, i[256 | e] = -t - 1) : t <= 15 ? (r[e] = t + 15 << 10, r[256 | e] = t + 15 << 10 | 32768, i[e] = 13, i[256 | e] = 13) : t < 128 ? (r[e] = 31744, r[256 | e] = 64512, i[e] = 24, i[256 | e] = 24) : (r[e] = 31744, r[256 | e] = 64512, i[e] = 13, i[256 | e] = 13)
                }
                const s = new Uint32Array(2048),
                    o = new Uint32Array(64),
                    a = new Uint32Array(64);
                for (let e = 1; e < 1024; ++e) {
                    let t = e << 13,
                        n = 0;
                    for (; 0 == (8388608 & t);) t <<= 1, n -= 8388608;
                    t &= -8388609, n += 947912704, s[e] = t | n
                }
                for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + (e - 1024 << 13);
                for (let e = 1; e < 31; ++e) o[e] = e << 23;
                o[31] = 1199570944, o[32] = 2147483648;
                for (let e = 33; e < 63; ++e) o[e] = 2147483648 + (e - 32 << 23);
                o[63] = 3347054592;
                for (let e = 1; e < 64; ++e) 32 !== e && (a[e] = 1024);
                return {
                    floatView: t,
                    uint32View: n,
                    baseTable: r,
                    shiftTable: i,
                    mantissaTable: s,
                    exponentTable: o,
                    offsetTable: a
                }
            }
            var Vd = Object.freeze({
                __proto__: null,
                toHalfFloat: function(e) {
                    Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = Mn(e, -65504, 65504), Ld[0] = e;
                    const t = Id[0],
                        n = t >> 23 & 511;
                    return Fd[n] + ((8388607 & t) >> Nd[n])
                },
                fromHalfFloat: function(e) {
                    const t = e >> 10;
                    return Id[0] = Ud[jd[t] + (1023 & e)] + Bd[t], Ld[0]
                }
            });
            class Gd extends Wi {
                constructor() {
                    console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), super()
                }
            }
            class Hd extends Wi {
                constructor() {
                    console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), super()
                }
            }

            function Wd() {
                console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")
            }

            function Kd() {
                console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")
            }

            function Xd() {
                console.error("THREE.ImmediateRenderObject has been removed.")
            }
            class qd extends tr {
                constructor(e, t, n) {
                    console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, n), this.samples = 4
                }
            }
            class Yd extends nr {
                constructor(e, t, n, r) {
                    console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(e, t, n, r)
                }
            }
            class Zd extends ir {
                constructor(e, t, n, r) {
                    console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(e, t, n, r)
                }
            }
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: r
                }
            })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r)
        },
        365: function(e, t, n) {
            n.d(t, {
                _: function() {
                    return s
                }
            });
            var r = n(927);
            const i = new WeakMap;
            class s extends r.aNw {
                constructor(e) {
                    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                        position: "POSITION",
                        normal: "NORMAL",
                        color: "COLOR",
                        uv: "TEX_COORD"
                    }, this.defaultAttributeTypes = {
                        position: "Float32Array",
                        normal: "Float32Array",
                        color: "Float32Array",
                        uv: "Float32Array"
                    }
                }
                setDecoderPath(e) {
                    return this.decoderPath = e, this
                }
                setDecoderConfig(e) {
                    return this.decoderConfig = e, this
                }
                setWorkerLimit(e) {
                    return this.workerLimit = e, this
                }
                load(e, t, n, i) {
                    const s = new r.hH6(this.manager);
                    s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (e => {
                        const n = {
                            attributeIDs: this.defaultAttributeIDs,
                            attributeTypes: this.defaultAttributeTypes,
                            useUniqueIDs: !1
                        };
                        this.decodeGeometry(e, n).then(t).catch(i)
                    }), n, i)
                }
                decodeDracoFile(e, t, n, r) {
                    const i = {
                        attributeIDs: n || this.defaultAttributeIDs,
                        attributeTypes: r || this.defaultAttributeTypes,
                        useUniqueIDs: !!n
                    };
                    this.decodeGeometry(e, i).then(t)
                }
                decodeGeometry(e, t) {
                    for (const e in t.attributeTypes) {
                        const n = t.attributeTypes[e];
                        void 0 !== n.BYTES_PER_ELEMENT && (t.attributeTypes[e] = n.name)
                    }
                    const n = JSON.stringify(t);
                    if (i.has(e)) {
                        const t = i.get(e);
                        if (t.key === n) return t.promise;
                        if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                    }
                    let r;
                    const s = this.workerNextTaskID++,
                        o = e.byteLength,
                        a = this._getWorker(s, o).then((n => (r = n, new Promise(((n, i) => {
                            r._callbacks[s] = {
                                resolve: n,
                                reject: i
                            }, r.postMessage({
                                type: "decode",
                                id: s,
                                taskConfig: t,
                                buffer: e
                            }, [e])
                        }))))).then((e => this._createGeometry(e.geometry)));
                    return a.catch((() => !0)).then((() => {
                        r && s && this._releaseTask(r, s)
                    })), i.set(e, {
                        key: n,
                        promise: a
                    }), a
                }
                _createGeometry(e) {
                    const t = new r.u9r;
                    e.index && t.setIndex(new r.TlE(e.index.array, 1));
                    for (let n = 0; n < e.attributes.length; n++) {
                        const i = e.attributes[n],
                            s = i.name,
                            o = i.array,
                            a = i.itemSize;
                        t.setAttribute(s, new r.TlE(o, a))
                    }
                    return t
                }
                _loadLibrary(e, t) {
                    const n = new r.hH6(this.manager);
                    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, r) => {
                        n.load(e, t, void 0, r)
                    }))
                }
                preload() {
                    return this._initDecoder(), this
                }
                _initDecoder() {
                    if (this.decoderPending) return this.decoderPending;
                    const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                        t = [];
                    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                        const n = t[0];
                        e || (this.decoderConfig.wasmBinary = t[1]);
                        const r = o.toString(),
                            i = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([i]))
                    })), this.decoderPending
                }
                _getWorker(e, t) {
                    return this._initDecoder().then((() => {
                        if (this.workerPool.length < this.workerLimit) {
                            const e = new Worker(this.workerSourceURL);
                            e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                                type: "init",
                                decoderConfig: this.decoderConfig
                            }), e.onmessage = function(t) {
                                const n = t.data;
                                switch (n.type) {
                                    case "decode":
                                        e._callbacks[n.id].resolve(n);
                                        break;
                                    case "error":
                                        e._callbacks[n.id].reject(n);
                                        break;
                                    default:
                                        console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                                }
                            }, this.workerPool.push(e)
                        } else this.workerPool.sort((function(e, t) {
                            return e._taskLoad > t._taskLoad ? -1 : 1
                        }));
                        const n = this.workerPool[this.workerPool.length - 1];
                        return n._taskCosts[e] = t, n._taskLoad += t, n
                    }))
                }
                _releaseTask(e, t) {
                    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
                }
                debug() {
                    console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
                }
                dispose() {
                    for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                    return this.workerPool.length = 0, this
                }
            }

            function o() {
                let e, t;

                function n(e, t, n, r, i, s) {
                    const o = s.num_components(),
                        a = n.num_points() * o,
                        l = a * i.BYTES_PER_ELEMENT,
                        c = function(e, t) {
                            switch (t) {
                                case Float32Array:
                                    return e.DT_FLOAT32;
                                case Int8Array:
                                    return e.DT_INT8;
                                case Int16Array:
                                    return e.DT_INT16;
                                case Int32Array:
                                    return e.DT_INT32;
                                case Uint8Array:
                                    return e.DT_UINT8;
                                case Uint16Array:
                                    return e.DT_UINT16;
                                case Uint32Array:
                                    return e.DT_UINT32
                            }
                        }(e, i),
                        u = e._malloc(l);
                    t.GetAttributeDataArrayForAllPoints(n, s, c, l, u);
                    const p = new i(e.HEAPF32.buffer, u, a).slice();
                    return e._free(u), {
                        name: r,
                        array: p,
                        itemSize: o
                    }
                }
                onmessage = function(r) {
                    const i = r.data;
                    switch (i.type) {
                        case "init":
                            e = i.decoderConfig, t = new Promise((function(t) {
                                e.onModuleLoaded = function(e) {
                                    t({
                                        draco: e
                                    })
                                }, DracoDecoderModule(e)
                            }));
                            break;
                        case "decode":
                            const r = i.buffer,
                                s = i.taskConfig;
                            t.then((e => {
                                const t = e.draco,
                                    o = new t.Decoder,
                                    a = new t.DecoderBuffer;
                                a.Init(new Int8Array(r), r.byteLength);
                                try {
                                    const e = function(e, t, r, i) {
                                            const s = i.attributeIDs,
                                                o = i.attributeTypes;
                                            let a, l;
                                            const c = t.GetEncodedGeometryType(r);
                                            if (c === e.TRIANGULAR_MESH) a = new e.Mesh, l = t.DecodeBufferToMesh(r, a);
                                            else {
                                                if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                                a = new e.PointCloud, l = t.DecodeBufferToPointCloud(r, a)
                                            }
                                            if (!l.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                            const u = {
                                                index: null,
                                                attributes: []
                                            };
                                            for (const r in s) {
                                                const l = self[o[r]];
                                                let c, p;
                                                if (i.useUniqueIDs) p = s[r], c = t.GetAttributeByUniqueId(a, p);
                                                else {
                                                    if (p = t.GetAttributeId(a, e[s[r]]), -1 === p) continue;
                                                    c = t.GetAttribute(a, p)
                                                }
                                                u.attributes.push(n(e, t, a, r, l, c))
                                            }
                                            return c === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                                const r = 3 * n.num_faces(),
                                                    i = 4 * r,
                                                    s = e._malloc(i);
                                                t.GetTrianglesUInt32Array(n, i, s);
                                                const o = new Uint32Array(e.HEAPF32.buffer, s, r).slice();
                                                return e._free(s), {
                                                    array: o,
                                                    itemSize: 1
                                                }
                                            }(e, t, a)), e.destroy(a), u
                                        }(t, o, a, s),
                                        r = e.attributes.map((e => e.array.buffer));
                                    e.index && r.push(e.index.array.buffer), self.postMessage({
                                        type: "decode",
                                        id: i.id,
                                        geometry: e
                                    }, r)
                                } catch (e) {
                                    console.error(e), self.postMessage({
                                        type: "error",
                                        id: i.id,
                                        error: e.message
                                    })
                                } finally {
                                    t.destroy(a), t.destroy(o)
                                }
                            }))
                    }
                }
            }
        },
        352: function(e) {
            e.exports = function(e) {
                var t = [];
                return t.toString = function() {
                    return this.map((function(t) {
                        var n = e(t);
                        return t[2] ? "@media ".concat(t[2], " {").concat(n, "}") : n
                    })).join("")
                }, t.i = function(e, n, r) {
                    "string" == typeof e && (e = [
                        [null, e, ""]
                    ]);
                    var i = {};
                    if (r)
                        for (var s = 0; s < this.length; s++) {
                            var o = this[s][0];
                            null != o && (i[o] = !0)
                        }
                    for (var a = 0; a < e.length; a++) {
                        var l = [].concat(e[a]);
                        r && i[l[0]] || (n && (l[2] ? l[2] = "".concat(n, " and ").concat(l[2]) : l[2] = n), t.push(l))
                    }
                }, t
            }
        },
        445: function(e) {
            function t(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
                return r
            }
            e.exports = function(e) {
                var n, r, i = (r = 4, function(e) {
                        if (Array.isArray(e)) return e
                    }(n = e) || function(e, t) {
                        var n = e && ("undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"]);
                        if (null != n) {
                            var r, i, s = [],
                                o = !0,
                                a = !1;
                            try {
                                for (n = n.call(e); !(o = (r = n.next()).done) && (s.push(r.value), !t || s.length !== t); o = !0);
                            } catch (e) {
                                a = !0, i = e
                            } finally {
                                try {
                                    o || null == n.return || n.return()
                                } finally {
                                    if (a) throw i
                                }
                            }
                            return s
                        }
                    }(n, r) || function(e, n) {
                        if (e) {
                            if ("string" == typeof e) return t(e, n);
                            var r = Object.prototype.toString.call(e).slice(8, -1);
                            return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? t(e, n) : void 0
                        }
                    }(n, r) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()),
                    s = i[1],
                    o = i[3];
                if ("function" == typeof btoa) {
                    var a = btoa(unescape(encodeURIComponent(JSON.stringify(o)))),
                        l = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(a),
                        c = "/*# ".concat(l, " */"),
                        u = o.sources.map((function(e) {
                            return "/*# sourceURL=".concat(o.sourceRoot || "").concat(e, " */")
                        }));
                    return [s].concat(u).concat([c]).join("\n")
                }
                return [s].join("\n")
            }
        },
        388: function(e) {
            e.exports = function e(t, n, r) {
                function i(o, a) {
                    if (!n[o]) {
                        if (!t[o]) {
                            if (s) return s(o, !0);
                            throw new Error("Cannot find module '" + o + "'")
                        }
                        var l = n[o] = {
                            exports: {}
                        };
                        t[o][0].call(l.exports, (function(e) {
                            return i(t[o][1][e] || e)
                        }), l, l.exports, e, t, n, r)
                    }
                    return n[o].exports
                }
                for (var s = void 0, o = 0; o < r.length; o++) i(r[o]);
                return i
            }({
                1: [function(e, t, n) {
                    (function(r, i, s, o, a, l, c, u, p) {
                        var h = e("crypto");

                        function d(e, t) {
                            return function(e, t) {
                                var n;
                                if (void 0 === (n = "passthrough" !== t.algorithm ? h.createHash(t.algorithm) : new b).write && (n.write = n.update, n.end = n.update), v(t, n).dispatch(e), n.update || n.end(""), n.digest) return n.digest("buffer" === t.encoding ? void 0 : t.encoding);
                                var r = n.read();
                                return "buffer" !== t.encoding ? r.toString(t.encoding) : r
                            }(e, t = m(e, t))
                        }(n = t.exports = d).sha1 = function(e) {
                            return d(e)
                        }, n.keys = function(e) {
                            return d(e, {
                                excludeValues: !0,
                                algorithm: "sha1",
                                encoding: "hex"
                            })
                        }, n.MD5 = function(e) {
                            return d(e, {
                                algorithm: "md5",
                                encoding: "hex"
                            })
                        }, n.keysMD5 = function(e) {
                            return d(e, {
                                algorithm: "md5",
                                encoding: "hex",
                                excludeValues: !0
                            })
                        };
                        var f = h.getHashes ? h.getHashes().slice() : ["sha1", "md5"];
                        f.push("passthrough");
                        var _ = ["buffer", "hex", "binary", "base64"];

                        function m(e, t) {
                            t = t || {};
                            var n = {};
                            if (n.algorithm = t.algorithm || "sha1", n.encoding = t.encoding || "hex", n.excludeValues = !!t.excludeValues, n.algorithm = n.algorithm.toLowerCase(), n.encoding = n.encoding.toLowerCase(), n.ignoreUnknown = !0 === t.ignoreUnknown, n.respectType = !1 !== t.respectType, n.respectFunctionNames = !1 !== t.respectFunctionNames, n.respectFunctionProperties = !1 !== t.respectFunctionProperties, n.unorderedArrays = !0 === t.unorderedArrays, n.unorderedSets = !1 !== t.unorderedSets, n.unorderedObjects = !1 !== t.unorderedObjects, n.replacer = t.replacer || void 0, n.excludeKeys = t.excludeKeys || void 0, void 0 === e) throw new Error("Object argument required.");
                            for (var r = 0; r < f.length; ++r) f[r].toLowerCase() === n.algorithm.toLowerCase() && (n.algorithm = f[r]);
                            if (-1 === f.indexOf(n.algorithm)) throw new Error('Algorithm "' + n.algorithm + '"  not supported. supported values: ' + f.join(", "));
                            if (-1 === _.indexOf(n.encoding) && "passthrough" !== n.algorithm) throw new Error('Encoding "' + n.encoding + '"  not supported. supported values: ' + _.join(", "));
                            return n
                        }

                        function g(e) {
                            if ("function" == typeof e) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e))
                        }

                        function v(e, t, n) {
                            function r(e) {
                                return t.update ? t.update(e, "utf8") : t.write(e, "utf8")
                            }
                            return n = n || [], {
                                dispatch: function(t) {
                                    return e.replacer && (t = e.replacer(t)), this["_" + (null === t ? "null" : typeof t)](t)
                                },
                                _object: function(t) {
                                    var i, o = Object.prototype.toString.call(t),
                                        a = /\[object (.*)\]/i.exec(o);
                                    if (a = (a = a ? a[1] : "unknown:[" + o + "]").toLowerCase(), 0 <= (i = n.indexOf(t))) return this.dispatch("[CIRCULAR:" + i + "]");
                                    if (n.push(t), void 0 !== s && s.isBuffer && s.isBuffer(t)) return r("buffer:"), r(t);
                                    if ("object" === a || "function" === a || "asyncfunction" === a) {
                                        var l = Object.keys(t);
                                        e.unorderedObjects && (l = l.sort()), !1 === e.respectType || g(t) || l.splice(0, 0, "prototype", "__proto__", "constructor"), e.excludeKeys && (l = l.filter((function(t) {
                                            return !e.excludeKeys(t)
                                        }))), r("object:" + l.length + ":");
                                        var c = this;
                                        return l.forEach((function(n) {
                                            c.dispatch(n), r(":"), e.excludeValues || c.dispatch(t[n]), r(",")
                                        }))
                                    }
                                    if (!this["_" + a]) {
                                        if (e.ignoreUnknown) return r("[" + a + "]");
                                        throw new Error('Unknown object type "' + a + '"')
                                    }
                                    this["_" + a](t)
                                },
                                _array: function(t, i) {
                                    i = void 0 !== i ? i : !1 !== e.unorderedArrays;
                                    var s = this;
                                    if (r("array:" + t.length + ":"), !i || t.length <= 1) return t.forEach((function(e) {
                                        return s.dispatch(e)
                                    }));
                                    var o = [],
                                        a = t.map((function(t) {
                                            var r = new b,
                                                i = n.slice();
                                            return v(e, r, i).dispatch(t), o = o.concat(i.slice(n.length)), r.read().toString()
                                        }));
                                    return n = n.concat(o), a.sort(), this._array(a, !1)
                                },
                                _date: function(e) {
                                    return r("date:" + e.toJSON())
                                },
                                _symbol: function(e) {
                                    return r("symbol:" + e.toString())
                                },
                                _error: function(e) {
                                    return r("error:" + e.toString())
                                },
                                _boolean: function(e) {
                                    return r("bool:" + e.toString())
                                },
                                _string: function(e) {
                                    r("string:" + e.length + ":"), r(e.toString())
                                },
                                _function: function(t) {
                                    r("fn:"), g(t) ? this.dispatch("[native]") : this.dispatch(t.toString()), !1 !== e.respectFunctionNames && this.dispatch("function-name:" + String(t.name)), e.respectFunctionProperties && this._object(t)
                                },
                                _number: function(e) {
                                    return r("number:" + e.toString())
                                },
                                _xml: function(e) {
                                    return r("xml:" + e.toString())
                                },
                                _null: function() {
                                    return r("Null")
                                },
                                _undefined: function() {
                                    return r("Undefined")
                                },
                                _regexp: function(e) {
                                    return r("regex:" + e.toString())
                                },
                                _uint8array: function(e) {
                                    return r("uint8array:"), this.dispatch(Array.prototype.slice.call(e))
                                },
                                _uint8clampedarray: function(e) {
                                    return r("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e))
                                },
                                _int8array: function(e) {
                                    return r("uint8array:"), this.dispatch(Array.prototype.slice.call(e))
                                },
                                _uint16array: function(e) {
                                    return r("uint16array:"), this.dispatch(Array.prototype.slice.call(e))
                                },
                                _int16array: function(e) {
                                    return r("uint16array:"), this.dispatch(Array.prototype.slice.call(e))
                                },
                                _uint32array: function(e) {
                                    return r("uint32array:"), this.dispatch(Array.prototype.slice.call(e))
                                },
                                _int32array: function(e) {
                                    return r("uint32array:"), this.dispatch(Array.prototype.slice.call(e))
                                },
                                _float32array: function(e) {
                                    return r("float32array:"), this.dispatch(Array.prototype.slice.call(e))
                                },
                                _float64array: function(e) {
                                    return r("float64array:"), this.dispatch(Array.prototype.slice.call(e))
                                },
                                _arraybuffer: function(e) {
                                    return r("arraybuffer:"), this.dispatch(new Uint8Array(e))
                                },
                                _url: function(e) {
                                    return r("url:" + e.toString())
                                },
                                _map: function(t) {
                                    r("map:");
                                    var n = Array.from(t);
                                    return this._array(n, !1 !== e.unorderedSets)
                                },
                                _set: function(t) {
                                    r("set:");
                                    var n = Array.from(t);
                                    return this._array(n, !1 !== e.unorderedSets)
                                },
                                _file: function(e) {
                                    return r("file:"), this.dispatch([e.name, e.size, e.type, e.lastModfied])
                                },
                                _blob: function() {
                                    if (e.ignoreUnknown) return r("[blob]");
                                    throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n')
                                },
                                _domwindow: function() {
                                    return r("domwindow")
                                },
                                _bigint: function(e) {
                                    return r("bigint:" + e.toString())
                                },
                                _process: function() {
                                    return r("process")
                                },
                                _timer: function() {
                                    return r("timer")
                                },
                                _pipe: function() {
                                    return r("pipe")
                                },
                                _tcp: function() {
                                    return r("tcp")
                                },
                                _udp: function() {
                                    return r("udp")
                                },
                                _tty: function() {
                                    return r("tty")
                                },
                                _statwatcher: function() {
                                    return r("statwatcher")
                                },
                                _securecontext: function() {
                                    return r("securecontext")
                                },
                                _connection: function() {
                                    return r("connection")
                                },
                                _zlib: function() {
                                    return r("zlib")
                                },
                                _context: function() {
                                    return r("context")
                                },
                                _nodescript: function() {
                                    return r("nodescript")
                                },
                                _httpparser: function() {
                                    return r("httpparser")
                                },
                                _dataview: function() {
                                    return r("dataview")
                                },
                                _signal: function() {
                                    return r("signal")
                                },
                                _fsevent: function() {
                                    return r("fsevent")
                                },
                                _tlswrap: function() {
                                    return r("tlswrap")
                                }
                            }
                        }

                        function b() {
                            return {
                                buf: "",
                                write: function(e) {
                                    this.buf += e
                                },
                                end: function(e) {
                                    this.buf += e
                                },
                                read: function() {
                                    return this.buf
                                }
                            }
                        }
                        n.writeToStream = function(e, t, n) {
                            return void 0 === n && (n = t, t = {}), v(t = m(e, t), n).dispatch(e)
                        }
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_7eac155c.js", "/")
                }, {
                    buffer: 3,
                    crypto: 5,
                    lYpoI2: 10
                }],
                2: [function(e, t, n) {
                    (function(e, t, r, i, s, o, a, l, c) {
                        ! function(e) {
                            var t = "undefined" != typeof Uint8Array ? Uint8Array : Array,
                                n = "+".charCodeAt(0),
                                r = "/".charCodeAt(0),
                                i = "0".charCodeAt(0),
                                s = "a".charCodeAt(0),
                                o = "A".charCodeAt(0),
                                a = "-".charCodeAt(0),
                                l = "_".charCodeAt(0);

                            function c(e) {
                                var t = e.charCodeAt(0);
                                return t === n || t === a ? 62 : t === r || t === l ? 63 : t < i ? -1 : t < i + 10 ? t - i + 26 + 26 : t < o + 26 ? t - o : t < s + 26 ? t - s + 26 : void 0
                            }
                            e.toByteArray = function(e) {
                                var n, r;
                                if (0 < e.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
                                var i = e.length,
                                    s = "=" === e.charAt(i - 2) ? 2 : "=" === e.charAt(i - 1) ? 1 : 0,
                                    o = new t(3 * e.length / 4 - s),
                                    a = 0 < s ? e.length - 4 : e.length,
                                    l = 0;

                                function u(e) {
                                    o[l++] = e
                                }
                                for (n = 0; n < a; n += 4, 0) u((16711680 & (r = c(e.charAt(n)) << 18 | c(e.charAt(n + 1)) << 12 | c(e.charAt(n + 2)) << 6 | c(e.charAt(n + 3)))) >> 16), u((65280 & r) >> 8), u(255 & r);
                                return 2 == s ? u(255 & (r = c(e.charAt(n)) << 2 | c(e.charAt(n + 1)) >> 4)) : 1 == s && (u((r = c(e.charAt(n)) << 10 | c(e.charAt(n + 1)) << 4 | c(e.charAt(n + 2)) >> 2) >> 8 & 255), u(255 & r)), o
                            }, e.fromByteArray = function(e) {
                                var t, n, r, i, s = e.length % 3,
                                    o = "";

                                function a(e) {
                                    return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e)
                                }
                                for (t = 0, r = e.length - s; t < r; t += 3) o += a((i = n = (e[t] << 16) + (e[t + 1] << 8) + e[t + 2]) >> 18 & 63) + a(i >> 12 & 63) + a(i >> 6 & 63) + a(63 & i);
                                switch (s) {
                                    case 1:
                                        o += a((n = e[e.length - 1]) >> 2), o += a(n << 4 & 63), o += "==";
                                        break;
                                    case 2:
                                        o += a((n = (e[e.length - 2] << 8) + e[e.length - 1]) >> 10), o += a(n >> 4 & 63), o += a(n << 2 & 63), o += "="
                                }
                                return o
                            }
                        }(void 0 === n ? this.base64js = {} : n)
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib")
                }, {
                    buffer: 3,
                    lYpoI2: 10
                }],
                3: [function(e, t, n) {
                    (function(t, r, i, s, o, a, l, c, u) {
                        var p = e("base64-js"),
                            h = e("ieee754");

                        function i(e, t, n) {
                            if (!(this instanceof i)) return new i(e, t, n);
                            var r, s, o, a, l, c = typeof e;
                            if ("base64" === t && "string" == c)
                                for (e = (r = e).trim ? r.trim() : r.replace(/^\s+|\s+$/g, ""); e.length % 4 != 0;) e += "=";
                            if ("number" == c) s = A(e);
                            else if ("string" == c) s = i.byteLength(e, t);
                            else {
                                if ("object" != c) throw new Error("First argument needs to be a number, array or string.");
                                s = A(e.length)
                            }
                            if (i._useTypedArrays ? o = i._augment(new Uint8Array(s)) : ((o = this).length = s, o._isBuffer = !0), i._useTypedArrays && "number" == typeof e.byteLength) o._set(e);
                            else if (C(l = e) || i.isBuffer(l) || l && "object" == typeof l && "number" == typeof l.length)
                                for (a = 0; a < s; a++) i.isBuffer(e) ? o[a] = e.readUInt8(a) : o[a] = e[a];
                            else if ("string" == c) o.write(e, 0, t);
                            else if ("number" == c && !i._useTypedArrays && !n)
                                for (a = 0; a < s; a++) o[a] = 0;
                            return o
                        }

                        function d(e, t, n, r) {
                            r || (N("boolean" == typeof n, "missing or invalid endian"), N(null != t, "missing offset"), N(t + 1 < e.length, "Trying to read beyond buffer length"));
                            var i, s = e.length;
                            if (!(s <= t)) return n ? (i = e[t], t + 1 < s && (i |= e[t + 1] << 8)) : (i = e[t] << 8, t + 1 < s && (i |= e[t + 1])), i
                        }

                        function f(e, t, n, r) {
                            r || (N("boolean" == typeof n, "missing or invalid endian"), N(null != t, "missing offset"), N(t + 3 < e.length, "Trying to read beyond buffer length"));
                            var i, s = e.length;
                            if (!(s <= t)) return n ? (t + 2 < s && (i = e[t + 2] << 16), t + 1 < s && (i |= e[t + 1] << 8), i |= e[t], t + 3 < s && (i += e[t + 3] << 24 >>> 0)) : (t + 1 < s && (i = e[t + 1] << 16), t + 2 < s && (i |= e[t + 2] << 8), t + 3 < s && (i |= e[t + 3]), i += e[t] << 24 >>> 0), i
                        }

                        function _(e, t, n, r) {
                            if (r || (N("boolean" == typeof n, "missing or invalid endian"), N(null != t, "missing offset"), N(t + 1 < e.length, "Trying to read beyond buffer length")), !(e.length <= t)) {
                                var i = d(e, t, n, !0);
                                return 32768 & i ? -1 * (65535 - i + 1) : i
                            }
                        }

                        function m(e, t, n, r) {
                            if (r || (N("boolean" == typeof n, "missing or invalid endian"), N(null != t, "missing offset"), N(t + 3 < e.length, "Trying to read beyond buffer length")), !(e.length <= t)) {
                                var i = f(e, t, n, !0);
                                return 2147483648 & i ? -1 * (4294967295 - i + 1) : i
                            }
                        }

                        function g(e, t, n, r) {
                            return r || (N("boolean" == typeof n, "missing or invalid endian"), N(t + 3 < e.length, "Trying to read beyond buffer length")), h.read(e, t, n, 23, 4)
                        }

                        function v(e, t, n, r) {
                            return r || (N("boolean" == typeof n, "missing or invalid endian"), N(t + 7 < e.length, "Trying to read beyond buffer length")), h.read(e, t, n, 52, 8)
                        }

                        function b(e, t, n, r, i) {
                            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 1 < e.length, "trying to write beyond buffer length"), L(t, 65535));
                            var s = e.length;
                            if (!(s <= n))
                                for (var o = 0, a = Math.min(s - n, 2); o < a; o++) e[n + o] = (t & 255 << 8 * (r ? o : 1 - o)) >>> 8 * (r ? o : 1 - o)
                        }

                        function x(e, t, n, r, i) {
                            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 3 < e.length, "trying to write beyond buffer length"), L(t, 4294967295));
                            var s = e.length;
                            if (!(s <= n))
                                for (var o = 0, a = Math.min(s - n, 4); o < a; o++) e[n + o] = t >>> 8 * (r ? o : 3 - o) & 255
                        }

                        function y(e, t, n, r, i) {
                            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 1 < e.length, "Trying to write beyond buffer length"), I(t, 32767, -32768)), e.length <= n || b(e, 0 <= t ? t : 65535 + t + 1, n, r, i)
                        }

                        function w(e, t, n, r, i) {
                            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 3 < e.length, "Trying to write beyond buffer length"), I(t, 2147483647, -2147483648)), e.length <= n || x(e, 0 <= t ? t : 4294967295 + t + 1, n, r, i)
                        }

                        function S(e, t, n, r, i) {
                            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 3 < e.length, "Trying to write beyond buffer length"), F(t, 34028234663852886e22, -34028234663852886e22)), e.length <= n || h.write(e, t, n, r, 23, 4)
                        }

                        function M(e, t, n, r, i) {
                            i || (N(null != t, "missing value"), N("boolean" == typeof r, "missing or invalid endian"), N(null != n, "missing offset"), N(n + 7 < e.length, "Trying to write beyond buffer length"), F(t, 17976931348623157e292, -17976931348623157e292)), e.length <= n || h.write(e, t, n, r, 52, 8)
                        }
                        n.Buffer = i, n.SlowBuffer = i, n.INSPECT_MAX_BYTES = 50, i.poolSize = 8192, i._useTypedArrays = function() {
                            try {
                                var e = new ArrayBuffer(0),
                                    t = new Uint8Array(e);
                                return t.foo = function() {
                                    return 42
                                }, 42 === t.foo() && "function" == typeof t.subarray
                            } catch (e) {
                                return !1
                            }
                        }(), i.isEncoding = function(e) {
                            switch (String(e).toLowerCase()) {
                                case "hex":
                                case "utf8":
                                case "utf-8":
                                case "ascii":
                                case "binary":
                                case "base64":
                                case "raw":
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                    return !0;
                                default:
                                    return !1
                            }
                        }, i.isBuffer = function(e) {
                            return !(null == e || !e._isBuffer)
                        }, i.byteLength = function(e, t) {
                            var n;
                            switch (e += "", t || "utf8") {
                                case "hex":
                                    n = e.length / 2;
                                    break;
                                case "utf8":
                                case "utf-8":
                                    n = k(e).length;
                                    break;
                                case "ascii":
                                case "binary":
                                case "raw":
                                    n = e.length;
                                    break;
                                case "base64":
                                    n = P(e).length;
                                    break;
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                    n = 2 * e.length;
                                    break;
                                default:
                                    throw new Error("Unknown encoding")
                            }
                            return n
                        }, i.concat = function(e, t) {
                            if (N(C(e), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e.length) return new i(0);
                            if (1 === e.length) return e[0];
                            if ("number" != typeof t)
                                for (s = t = 0; s < e.length; s++) t += e[s].length;
                            for (var n = new i(t), r = 0, s = 0; s < e.length; s++) {
                                var o = e[s];
                                o.copy(n, r), r += o.length
                            }
                            return n
                        }, i.prototype.write = function(e, t, n, r) {
                            var s;
                            isFinite(t) ? isFinite(n) || (r = n, n = void 0) : (s = r, r = t, t = n, n = s), t = Number(t) || 0;
                            var o, a, l, c, u, p, h, d = this.length - t;
                            switch ((!n || d < (n = Number(n))) && (n = d), r = String(r || "utf8").toLowerCase()) {
                                case "hex":
                                    o = function(e, t, n, r) {
                                        n = Number(n) || 0;
                                        var s = e.length - n;
                                        (!r || s < (r = Number(r))) && (r = s);
                                        var o = t.length;
                                        N(o % 2 == 0, "Invalid hex string"), o / 2 < r && (r = o / 2);
                                        for (var a = 0; a < r; a++) {
                                            var l = parseInt(t.substr(2 * a, 2), 16);
                                            N(!isNaN(l), "Invalid hex string"), e[n + a] = l
                                        }
                                        return i._charsWritten = 2 * a, a
                                    }(this, e, t, n);
                                    break;
                                case "utf8":
                                case "utf-8":
                                    this, u = e, p = t, h = n, o = i._charsWritten = D(k(u), this, p, h);
                                    break;
                                case "ascii":
                                case "binary":
                                    o = function(e, t, n, r) {
                                        return i._charsWritten = D(function(e) {
                                            for (var t = [], n = 0; n < e.length; n++) t.push(255 & e.charCodeAt(n));
                                            return t
                                        }(t), e, n, r)
                                    }(this, e, t, n);
                                    break;
                                case "base64":
                                    this, a = e, l = t, c = n, o = i._charsWritten = D(P(a), this, l, c);
                                    break;
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                    o = function(e, t, n, r) {
                                        return i._charsWritten = D(function(e) {
                                            for (var t, n, r, i = [], s = 0; s < e.length; s++) n = (t = e.charCodeAt(s)) >> 8, r = t % 256, i.push(r), i.push(n);
                                            return i
                                        }(t), e, n, r)
                                    }(this, e, t, n);
                                    break;
                                default:
                                    throw new Error("Unknown encoding")
                            }
                            return o
                        }, i.prototype.toString = function(e, t, n) {
                            var r, i, s, o, a = this;
                            if (e = String(e || "utf8").toLowerCase(), t = Number(t) || 0, (n = void 0 !== n ? Number(n) : n = a.length) === t) return "";
                            switch (e) {
                                case "hex":
                                    r = function(e, t, n) {
                                        var r = e.length;
                                        (!t || t < 0) && (t = 0), (!n || n < 0 || r < n) && (n = r);
                                        for (var i = "", s = t; s < n; s++) i += R(e[s]);
                                        return i
                                    }(a, t, n);
                                    break;
                                case "utf8":
                                case "utf-8":
                                    r = function(e, t, n) {
                                        var r = "",
                                            i = "";
                                        n = Math.min(e.length, n);
                                        for (var s = t; s < n; s++) e[s] <= 127 ? (r += O(i) + String.fromCharCode(e[s]), i = "") : i += "%" + e[s].toString(16);
                                        return r + O(i)
                                    }(a, t, n);
                                    break;
                                case "ascii":
                                case "binary":
                                    r = function(e, t, n) {
                                        var r = "";
                                        n = Math.min(e.length, n);
                                        for (var i = t; i < n; i++) r += String.fromCharCode(e[i]);
                                        return r
                                    }(a, t, n);
                                    break;
                                case "base64":
                                    i = a, o = n, r = 0 === (s = t) && o === i.length ? p.fromByteArray(i) : p.fromByteArray(i.slice(s, o));
                                    break;
                                case "ucs2":
                                case "ucs-2":
                                case "utf16le":
                                case "utf-16le":
                                    r = function(e, t, n) {
                                        for (var r = e.slice(t, n), i = "", s = 0; s < r.length; s += 2) i += String.fromCharCode(r[s] + 256 * r[s + 1]);
                                        return i
                                    }(a, t, n);
                                    break;
                                default:
                                    throw new Error("Unknown encoding")
                            }
                            return r
                        }, i.prototype.toJSON = function() {
                            return {
                                type: "Buffer",
                                data: Array.prototype.slice.call(this._arr || this, 0)
                            }
                        }, i.prototype.copy = function(e, t, n, r) {
                            if (n = n || 0, r || 0 === r || (r = this.length), t = t || 0, r !== n && 0 !== e.length && 0 !== this.length) {
                                N(n <= r, "sourceEnd < sourceStart"), N(0 <= t && t < e.length, "targetStart out of bounds"), N(0 <= n && n < this.length, "sourceStart out of bounds"), N(0 <= r && r <= this.length, "sourceEnd out of bounds"), r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
                                var s = r - n;
                                if (s < 100 || !i._useTypedArrays)
                                    for (var o = 0; o < s; o++) e[o + t] = this[o + n];
                                else e._set(this.subarray(n, n + s), t)
                            }
                        }, i.prototype.slice = function(e, t) {
                            var n = this.length;
                            if (e = E(e, n, 0), t = E(t, n, n), i._useTypedArrays) return i._augment(this.subarray(e, t));
                            for (var r = t - e, s = new i(r, void 0, !0), o = 0; o < r; o++) s[o] = this[o + e];
                            return s
                        }, i.prototype.get = function(e) {
                            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e)
                        }, i.prototype.set = function(e, t) {
                            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e, t)
                        }, i.prototype.readUInt8 = function(e, t) {
                            if (t || (N(null != e, "missing offset"), N(e < this.length, "Trying to read beyond buffer length")), !(e >= this.length)) return this[e]
                        }, i.prototype.readUInt16LE = function(e, t) {
                            return d(this, e, !0, t)
                        }, i.prototype.readUInt16BE = function(e, t) {
                            return d(this, e, !1, t)
                        }, i.prototype.readUInt32LE = function(e, t) {
                            return f(this, e, !0, t)
                        }, i.prototype.readUInt32BE = function(e, t) {
                            return f(this, e, !1, t)
                        }, i.prototype.readInt8 = function(e, t) {
                            if (t || (N(null != e, "missing offset"), N(e < this.length, "Trying to read beyond buffer length")), !(e >= this.length)) return 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
                        }, i.prototype.readInt16LE = function(e, t) {
                            return _(this, e, !0, t)
                        }, i.prototype.readInt16BE = function(e, t) {
                            return _(this, e, !1, t)
                        }, i.prototype.readInt32LE = function(e, t) {
                            return m(this, e, !0, t)
                        }, i.prototype.readInt32BE = function(e, t) {
                            return m(this, e, !1, t)
                        }, i.prototype.readFloatLE = function(e, t) {
                            return g(this, e, !0, t)
                        }, i.prototype.readFloatBE = function(e, t) {
                            return g(this, e, !1, t)
                        }, i.prototype.readDoubleLE = function(e, t) {
                            return v(this, e, !0, t)
                        }, i.prototype.readDoubleBE = function(e, t) {
                            return v(this, e, !1, t)
                        }, i.prototype.writeUInt8 = function(e, t, n) {
                            n || (N(null != e, "missing value"), N(null != t, "missing offset"), N(t < this.length, "trying to write beyond buffer length"), L(e, 255)), t >= this.length || (this[t] = e)
                        }, i.prototype.writeUInt16LE = function(e, t, n) {
                            b(this, e, t, !0, n)
                        }, i.prototype.writeUInt16BE = function(e, t, n) {
                            b(this, e, t, !1, n)
                        }, i.prototype.writeUInt32LE = function(e, t, n) {
                            x(this, e, t, !0, n)
                        }, i.prototype.writeUInt32BE = function(e, t, n) {
                            x(this, e, t, !1, n)
                        }, i.prototype.writeInt8 = function(e, t, n) {
                            n || (N(null != e, "missing value"), N(null != t, "missing offset"), N(t < this.length, "Trying to write beyond buffer length"), I(e, 127, -128)), t >= this.length || (0 <= e ? this.writeUInt8(e, t, n) : this.writeUInt8(255 + e + 1, t, n))
                        }, i.prototype.writeInt16LE = function(e, t, n) {
                            y(this, e, t, !0, n)
                        }, i.prototype.writeInt16BE = function(e, t, n) {
                            y(this, e, t, !1, n)
                        }, i.prototype.writeInt32LE = function(e, t, n) {
                            w(this, e, t, !0, n)
                        }, i.prototype.writeInt32BE = function(e, t, n) {
                            w(this, e, t, !1, n)
                        }, i.prototype.writeFloatLE = function(e, t, n) {
                            S(this, e, t, !0, n)
                        }, i.prototype.writeFloatBE = function(e, t, n) {
                            S(this, e, t, !1, n)
                        }, i.prototype.writeDoubleLE = function(e, t, n) {
                            M(this, e, t, !0, n)
                        }, i.prototype.writeDoubleBE = function(e, t, n) {
                            M(this, e, t, !1, n)
                        }, i.prototype.fill = function(e, t, n) {
                            if (e = e || 0, t = t || 0, n = n || this.length, "string" == typeof e && (e = e.charCodeAt(0)), N("number" == typeof e && !isNaN(e), "value is not a number"), N(t <= n, "end < start"), n !== t && 0 !== this.length) {
                                N(0 <= t && t < this.length, "start out of bounds"), N(0 <= n && n <= this.length, "end out of bounds");
                                for (var r = t; r < n; r++) this[r] = e
                            }
                        }, i.prototype.inspect = function() {
                            for (var e = [], t = this.length, r = 0; r < t; r++)
                                if (e[r] = R(this[r]), r === n.INSPECT_MAX_BYTES) {
                                    e[r + 1] = "...";
                                    break
                                }
                            return "<Buffer " + e.join(" ") + ">"
                        }, i.prototype.toArrayBuffer = function() {
                            if ("undefined" == typeof Uint8Array) throw new Error("Buffer.toArrayBuffer not supported in this browser");
                            if (i._useTypedArrays) return new i(this).buffer;
                            for (var e = new Uint8Array(this.length), t = 0, n = e.length; t < n; t += 1) e[t] = this[t];
                            return e.buffer
                        };
                        var T = i.prototype;

                        function E(e, t, n) {
                            return "number" != typeof e ? n : t <= (e = ~~e) ? t : 0 <= e || 0 <= (e += t) ? e : 0
                        }

                        function A(e) {
                            return (e = ~~Math.ceil(+e)) < 0 ? 0 : e
                        }

                        function C(e) {
                            return (Array.isArray || function(e) {
                                return "[object Array]" === Object.prototype.toString.call(e)
                            })(e)
                        }

                        function R(e) {
                            return e < 16 ? "0" + e.toString(16) : e.toString(16)
                        }

                        function k(e) {
                            for (var t = [], n = 0; n < e.length; n++) {
                                var r = e.charCodeAt(n);
                                if (r <= 127) t.push(e.charCodeAt(n));
                                else {
                                    var i = n;
                                    55296 <= r && r <= 57343 && n++;
                                    for (var s = encodeURIComponent(e.slice(i, n + 1)).substr(1).split("%"), o = 0; o < s.length; o++) t.push(parseInt(s[o], 16))
                                }
                            }
                            return t
                        }

                        function P(e) {
                            return p.toByteArray(e)
                        }

                        function D(e, t, n, r) {
                            for (var i = 0; i < r && !(i + n >= t.length || i >= e.length); i++) t[i + n] = e[i];
                            return i
                        }

                        function O(e) {
                            try {
                                return decodeURIComponent(e)
                            } catch (e) {
                                return String.fromCharCode(65533)
                            }
                        }

                        function L(e, t) {
                            N("number" == typeof e, "cannot write a non-number as a number"), N(0 <= e, "specified a negative value for writing an unsigned value"), N(e <= t, "value is larger than maximum value for type"), N(Math.floor(e) === e, "value has a fractional component")
                        }

                        function I(e, t, n) {
                            N("number" == typeof e, "cannot write a non-number as a number"), N(e <= t, "value larger than maximum allowed value"), N(n <= e, "value smaller than minimum allowed value"), N(Math.floor(e) === e, "value has a fractional component")
                        }

                        function F(e, t, n) {
                            N("number" == typeof e, "cannot write a non-number as a number"), N(e <= t, "value larger than maximum allowed value"), N(n <= e, "value smaller than minimum allowed value")
                        }

                        function N(e, t) {
                            if (!e) throw new Error(t || "Failed assertion")
                        }
                        i._augment = function(e) {
                            return e._isBuffer = !0, e._get = e.get, e._set = e.set, e.get = T.get, e.set = T.set, e.write = T.write, e.toString = T.toString, e.toLocaleString = T.toString, e.toJSON = T.toJSON, e.copy = T.copy, e.slice = T.slice, e.readUInt8 = T.readUInt8, e.readUInt16LE = T.readUInt16LE, e.readUInt16BE = T.readUInt16BE, e.readUInt32LE = T.readUInt32LE, e.readUInt32BE = T.readUInt32BE, e.readInt8 = T.readInt8, e.readInt16LE = T.readInt16LE, e.readInt16BE = T.readInt16BE, e.readInt32LE = T.readInt32LE, e.readInt32BE = T.readInt32BE, e.readFloatLE = T.readFloatLE, e.readFloatBE = T.readFloatBE, e.readDoubleLE = T.readDoubleLE, e.readDoubleBE = T.readDoubleBE, e.writeUInt8 = T.writeUInt8, e.writeUInt16LE = T.writeUInt16LE, e.writeUInt16BE = T.writeUInt16BE, e.writeUInt32LE = T.writeUInt32LE, e.writeUInt32BE = T.writeUInt32BE, e.writeInt8 = T.writeInt8, e.writeInt16LE = T.writeInt16LE, e.writeInt16BE = T.writeInt16BE, e.writeInt32LE = T.writeInt32LE, e.writeInt32BE = T.writeInt32BE, e.writeFloatLE = T.writeFloatLE, e.writeFloatBE = T.writeFloatBE, e.writeDoubleLE = T.writeDoubleLE, e.writeDoubleBE = T.writeDoubleBE, e.fill = T.fill, e.inspect = T.inspect, e.toArrayBuffer = T.toArrayBuffer, e
                        }
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer")
                }, {
                    "base64-js": 2,
                    buffer: 3,
                    ieee754: 11,
                    lYpoI2: 10
                }],
                4: [function(e, t, n) {
                    (function(n, r, i, s, o, a, l, c, u) {
                        i = e("buffer").Buffer;
                        var p = new i(4);
                        p.fill(0), t.exports = {
                            hash: function(e, t, n, r) {
                                return i.isBuffer(e) || (e = new i(e)),
                                    function(e, t, n) {
                                        for (var r = new i(t), s = n ? r.writeInt32BE : r.writeInt32LE, o = 0; o < e.length; o++) s.call(r, e[o], 4 * o, !0);
                                        return r
                                    }(t(function(e, t) {
                                        var n;
                                        e.length % 4 != 0 && (n = e.length + (4 - e.length % 4), e = i.concat([e, p], n));
                                        for (var r = [], s = t ? e.readInt32BE : e.readInt32LE, o = 0; o < e.length; o += 4) r.push(s.call(e, o));
                                        return r
                                    }(e, r), 8 * e.length), n, r)
                            }
                        }
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
                }, {
                    buffer: 3,
                    lYpoI2: 10
                }],
                5: [function(e, t, n) {
                    (function(t, r, i, s, o, a, l, c, u) {
                        i = e("buffer").Buffer;
                        var p = e("./sha"),
                            h = e("./sha256"),
                            d = e("./rng"),
                            f = {
                                sha1: p,
                                sha256: h,
                                md5: e("./md5")
                            },
                            _ = 64,
                            m = new i(_);

                        function g(e, t) {
                            var n = f[e = e || "sha1"],
                                r = [];
                            return n || v("algorithm:", e, "is not yet supported"), {
                                update: function(e) {
                                    return i.isBuffer(e) || (e = new i(e)), r.push(e), e.length, this
                                },
                                digest: function(e) {
                                    var s = i.concat(r),
                                        o = t ? function(e, t, n) {
                                            i.isBuffer(t) || (t = new i(t)), i.isBuffer(n) || (n = new i(n)), t.length > _ ? t = e(t) : t.length < _ && (t = i.concat([t, m], _));
                                            for (var r = new i(_), s = new i(_), o = 0; o < _; o++) r[o] = 54 ^ t[o], s[o] = 92 ^ t[o];
                                            var a = e(i.concat([r, n]));
                                            return e(i.concat([s, a]))
                                        }(n, t, s) : n(s);
                                    return r = null, e ? o.toString(e) : o
                                }
                            }
                        }

                        function v() {
                            var e = [].slice.call(arguments).join(" ");
                            throw new Error([e, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"))
                        }
                        m.fill(0), n.createHash = function(e) {
                                return g(e)
                            }, n.createHmac = g, n.randomBytes = function(e, t) {
                                if (!t || !t.call) return new i(d(e));
                                try {
                                    t.call(this, void 0, new i(d(e)))
                                } catch (e) {
                                    t(e)
                                }
                            },
                            function(e, t) {
                                for (var n in e) t(e[n])
                            }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], (function(e) {
                                n[e] = function() {
                                    v("sorry,", e, "is not implemented yet")
                                }
                            }))
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
                }, {
                    "./md5": 6,
                    "./rng": 7,
                    "./sha": 8,
                    "./sha256": 9,
                    buffer: 3,
                    lYpoI2: 10
                }],
                6: [function(e, t, n) {
                    (function(n, r, i, s, o, a, l, c, u) {
                        var p = e("./helpers");

                        function h(e, t) {
                            e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
                            for (var n = 1732584193, r = -271733879, i = -1732584194, s = 271733878, o = 0; o < e.length; o += 16) {
                                var a = n,
                                    l = r,
                                    c = i,
                                    u = s;
                                n = f(n, r, i, s, e[o + 0], 7, -680876936), s = f(s, n, r, i, e[o + 1], 12, -389564586), i = f(i, s, n, r, e[o + 2], 17, 606105819), r = f(r, i, s, n, e[o + 3], 22, -1044525330), n = f(n, r, i, s, e[o + 4], 7, -176418897), s = f(s, n, r, i, e[o + 5], 12, 1200080426), i = f(i, s, n, r, e[o + 6], 17, -1473231341), r = f(r, i, s, n, e[o + 7], 22, -45705983), n = f(n, r, i, s, e[o + 8], 7, 1770035416), s = f(s, n, r, i, e[o + 9], 12, -1958414417), i = f(i, s, n, r, e[o + 10], 17, -42063), r = f(r, i, s, n, e[o + 11], 22, -1990404162), n = f(n, r, i, s, e[o + 12], 7, 1804603682), s = f(s, n, r, i, e[o + 13], 12, -40341101), i = f(i, s, n, r, e[o + 14], 17, -1502002290), n = _(n, r = f(r, i, s, n, e[o + 15], 22, 1236535329), i, s, e[o + 1], 5, -165796510), s = _(s, n, r, i, e[o + 6], 9, -1069501632), i = _(i, s, n, r, e[o + 11], 14, 643717713), r = _(r, i, s, n, e[o + 0], 20, -373897302), n = _(n, r, i, s, e[o + 5], 5, -701558691), s = _(s, n, r, i, e[o + 10], 9, 38016083), i = _(i, s, n, r, e[o + 15], 14, -660478335), r = _(r, i, s, n, e[o + 4], 20, -405537848), n = _(n, r, i, s, e[o + 9], 5, 568446438), s = _(s, n, r, i, e[o + 14], 9, -1019803690), i = _(i, s, n, r, e[o + 3], 14, -187363961), r = _(r, i, s, n, e[o + 8], 20, 1163531501), n = _(n, r, i, s, e[o + 13], 5, -1444681467), s = _(s, n, r, i, e[o + 2], 9, -51403784), i = _(i, s, n, r, e[o + 7], 14, 1735328473), n = m(n, r = _(r, i, s, n, e[o + 12], 20, -1926607734), i, s, e[o + 5], 4, -378558), s = m(s, n, r, i, e[o + 8], 11, -2022574463), i = m(i, s, n, r, e[o + 11], 16, 1839030562), r = m(r, i, s, n, e[o + 14], 23, -35309556), n = m(n, r, i, s, e[o + 1], 4, -1530992060), s = m(s, n, r, i, e[o + 4], 11, 1272893353), i = m(i, s, n, r, e[o + 7], 16, -155497632), r = m(r, i, s, n, e[o + 10], 23, -1094730640), n = m(n, r, i, s, e[o + 13], 4, 681279174), s = m(s, n, r, i, e[o + 0], 11, -358537222), i = m(i, s, n, r, e[o + 3], 16, -722521979), r = m(r, i, s, n, e[o + 6], 23, 76029189), n = m(n, r, i, s, e[o + 9], 4, -640364487), s = m(s, n, r, i, e[o + 12], 11, -421815835), i = m(i, s, n, r, e[o + 15], 16, 530742520), n = g(n, r = m(r, i, s, n, e[o + 2], 23, -995338651), i, s, e[o + 0], 6, -198630844), s = g(s, n, r, i, e[o + 7], 10, 1126891415), i = g(i, s, n, r, e[o + 14], 15, -1416354905), r = g(r, i, s, n, e[o + 5], 21, -57434055), n = g(n, r, i, s, e[o + 12], 6, 1700485571), s = g(s, n, r, i, e[o + 3], 10, -1894986606), i = g(i, s, n, r, e[o + 10], 15, -1051523), r = g(r, i, s, n, e[o + 1], 21, -2054922799), n = g(n, r, i, s, e[o + 8], 6, 1873313359), s = g(s, n, r, i, e[o + 15], 10, -30611744), i = g(i, s, n, r, e[o + 6], 15, -1560198380), r = g(r, i, s, n, e[o + 13], 21, 1309151649), n = g(n, r, i, s, e[o + 4], 6, -145523070), s = g(s, n, r, i, e[o + 11], 10, -1120210379), i = g(i, s, n, r, e[o + 2], 15, 718787259), r = g(r, i, s, n, e[o + 9], 21, -343485551), n = v(n, a), r = v(r, l), i = v(i, c), s = v(s, u)
                            }
                            return Array(n, r, i, s)
                        }

                        function d(e, t, n, r, i, s) {
                            return v((o = v(v(t, e), v(r, s))) << (a = i) | o >>> 32 - a, n);
                            var o, a
                        }

                        function f(e, t, n, r, i, s, o) {
                            return d(t & n | ~t & r, e, t, i, s, o)
                        }

                        function _(e, t, n, r, i, s, o) {
                            return d(t & r | n & ~r, e, t, i, s, o)
                        }

                        function m(e, t, n, r, i, s, o) {
                            return d(t ^ n ^ r, e, t, i, s, o)
                        }

                        function g(e, t, n, r, i, s, o) {
                            return d(n ^ (t | ~r), e, t, i, s, o)
                        }

                        function v(e, t) {
                            var n = (65535 & e) + (65535 & t);
                            return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                        }
                        t.exports = function(e) {
                            return p.hash(e, h, 16)
                        }
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
                }, {
                    "./helpers": 4,
                    buffer: 3,
                    lYpoI2: 10
                }],
                7: [function(e, t, n) {
                    (function(e, n, r, i, s, o, a, l, c) {
                        var u;
                        u = function(e) {
                            for (var t, n = new Array(e), r = 0; r < e; r++) 0 == (3 & r) && (t = 4294967296 * Math.random()), n[r] = t >>> ((3 & r) << 3) & 255;
                            return n
                        }, t.exports = u
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
                }, {
                    buffer: 3,
                    lYpoI2: 10
                }],
                8: [function(e, t, n) {
                    (function(n, r, i, s, o, a, l, c, u) {
                        var p = e("./helpers");

                        function h(e, t) {
                            e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
                            for (var n, r, i, s, o, a = Array(80), l = 1732584193, c = -271733879, u = -1732584194, p = 271733878, h = -1009589776, _ = 0; _ < e.length; _ += 16) {
                                for (var m = l, g = c, v = u, b = p, x = h, y = 0; y < 80; y++) {
                                    a[y] = y < 16 ? e[_ + y] : f(a[y - 3] ^ a[y - 8] ^ a[y - 14] ^ a[y - 16], 1);
                                    var w = d(d(f(l, 5), (i = c, s = u, o = p, (r = y) < 20 ? i & s | ~i & o : !(r < 40) && r < 60 ? i & s | i & o | s & o : i ^ s ^ o)), d(d(h, a[y]), (n = y) < 20 ? 1518500249 : n < 40 ? 1859775393 : n < 60 ? -1894007588 : -899497514));
                                    h = p, p = u, u = f(c, 30), c = l, l = w
                                }
                                l = d(l, m), c = d(c, g), u = d(u, v), p = d(p, b), h = d(h, x)
                            }
                            return Array(l, c, u, p, h)
                        }

                        function d(e, t) {
                            var n = (65535 & e) + (65535 & t);
                            return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                        }

                        function f(e, t) {
                            return e << t | e >>> 32 - t
                        }
                        t.exports = function(e) {
                            return p.hash(e, h, 20, !0)
                        }
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
                }, {
                    "./helpers": 4,
                    buffer: 3,
                    lYpoI2: 10
                }],
                9: [function(e, t, n) {
                    (function(n, r, i, s, o, a, l, c, u) {
                        function p(e, t) {
                            var n = (65535 & e) + (65535 & t);
                            return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                        }

                        function h(e, t) {
                            return e >>> t | e << 32 - t
                        }

                        function d(e, t) {
                            var n, r, i, s, o, a, l, c, u, d, f = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298),
                                _ = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225),
                                m = new Array(64);
                            e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
                            for (var g, v, b, x, y, w, S, M, T = 0; T < e.length; T += 16) {
                                n = _[0], r = _[1], i = _[2], s = _[3], o = _[4], a = _[5], l = _[6], c = _[7];
                                for (var E = 0; E < 64; E++) m[E] = E < 16 ? e[E + T] : p(p(p(h(M = m[E - 2], 17) ^ h(M, 19) ^ M >>> 10, m[E - 7]), h(S = m[E - 15], 7) ^ h(S, 18) ^ S >>> 3), m[E - 16]), u = p(p(p(p(c, h(w = o, 6) ^ h(w, 11) ^ h(w, 25)), (y = o) & a ^ ~y & l), f[E]), m[E]), d = p(h(x = n, 2) ^ h(x, 13) ^ h(x, 22), (g = n) & (v = r) ^ g & (b = i) ^ v & b), c = l, l = a, a = o, o = p(s, u), s = i, i = r, r = n, n = p(u, d);
                                _[0] = p(n, _[0]), _[1] = p(r, _[1]), _[2] = p(i, _[2]), _[3] = p(s, _[3]), _[4] = p(o, _[4]), _[5] = p(a, _[5]), _[6] = p(l, _[6]), _[7] = p(c, _[7])
                            }
                            return _
                        }
                        var f = e("./helpers");
                        t.exports = function(e) {
                            return f.hash(e, d, 32, !0)
                        }
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
                }, {
                    "./helpers": 4,
                    buffer: 3,
                    lYpoI2: 10
                }],
                10: [function(e, t, n) {
                    (function(e, n, r, i, s, o, a, l, c) {
                        function u() {}(e = t.exports = {}).nextTick = function() {
                            var e = "undefined" != typeof window && window.setImmediate,
                                t = "undefined" != typeof window && window.postMessage && window.addEventListener;
                            if (e) return function(e) {
                                return window.setImmediate(e)
                            };
                            if (t) {
                                var n = [];
                                return window.addEventListener("message", (function(e) {
                                        var t = e.source;
                                        t !== window && null !== t || "process-tick" !== e.data || (e.stopPropagation(), 0 < n.length && n.shift()())
                                    }), !0),
                                    function(e) {
                                        n.push(e), window.postMessage("process-tick", "*")
                                    }
                            }
                            return function(e) {
                                setTimeout(e, 0)
                            }
                        }(), e.title = "browser", e.browser = !0, e.env = {}, e.argv = [], e.on = u, e.addListener = u, e.once = u, e.off = u, e.removeListener = u, e.removeAllListeners = u, e.emit = u, e.binding = function(e) {
                            throw new Error("process.binding is not supported")
                        }, e.cwd = function() {
                            return "/"
                        }, e.chdir = function(e) {
                            throw new Error("process.chdir is not supported")
                        }
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process")
                }, {
                    buffer: 3,
                    lYpoI2: 10
                }],
                11: [function(e, t, n) {
                    (function(e, t, r, i, s, o, a, l, c) {
                        n.read = function(e, t, n, r, i) {
                            var s, o, a = 8 * i - r - 1,
                                l = (1 << a) - 1,
                                c = l >> 1,
                                u = -7,
                                p = n ? i - 1 : 0,
                                h = n ? -1 : 1,
                                d = e[t + p];
                            for (p += h, s = d & (1 << -u) - 1, d >>= -u, u += a; 0 < u; s = 256 * s + e[t + p], p += h, u -= 8);
                            for (o = s & (1 << -u) - 1, s >>= -u, u += r; 0 < u; o = 256 * o + e[t + p], p += h, u -= 8);
                            if (0 === s) s = 1 - c;
                            else {
                                if (s === l) return o ? NaN : 1 / 0 * (d ? -1 : 1);
                                o += Math.pow(2, r), s -= c
                            }
                            return (d ? -1 : 1) * o * Math.pow(2, s - r)
                        }, n.write = function(e, t, n, r, i, s) {
                            var o, a, l, c = 8 * s - i - 1,
                                u = (1 << c) - 1,
                                p = u >> 1,
                                h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                                d = r ? 0 : s - 1,
                                f = r ? 1 : -1,
                                _ = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                            for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, o = u) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), 2 <= (t += 1 <= o + p ? h / l : h * Math.pow(2, 1 - p)) * l && (o++, l /= 2), u <= o + p ? (a = 0, o = u) : 1 <= o + p ? (a = (t * l - 1) * Math.pow(2, i), o += p) : (a = t * Math.pow(2, p - 1) * Math.pow(2, i), o = 0)); 8 <= i; e[n + d] = 255 & a, d += f, a /= 256, i -= 8);
                            for (o = o << i | a, c += i; 0 < c; e[n + d] = 255 & o, d += f, o /= 256, c -= 8);
                            e[n + d - f] |= 128 * _
                        }
                    }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754")
                }, {
                    buffer: 3,
                    lYpoI2: 10
                }]
            }, {}, [1])(1)
        },
        701: function(e) {
            var t = [];

            function n(e) {
                for (var n = -1, r = 0; r < t.length; r++)
                    if (t[r].identifier === e) {
                        n = r;
                        break
                    }
                return n
            }

            function r(e, r) {
                for (var s = {}, o = [], a = 0; a < e.length; a++) {
                    var l = e[a],
                        c = r.base ? l[0] + r.base : l[0],
                        u = s[c] || 0,
                        p = "".concat(c, " ").concat(u);
                    s[c] = u + 1;
                    var h = n(p),
                        d = {
                            css: l[1],
                            media: l[2],
                            sourceMap: l[3],
                            supports: l[4],
                            layer: l[5]
                        };
                    if (-1 !== h) t[h].references++, t[h].updater(d);
                    else {
                        var f = i(d, r);
                        r.byIndex = a, t.splice(a, 0, {
                            identifier: p,
                            updater: f,
                            references: 1
                        })
                    }
                    o.push(p)
                }
                return o
            }

            function i(e, t) {
                var n = t.domAPI(t);
                return n.update(e),
                    function(t) {
                        if (t) {
                            if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer) return;
                            n.update(e = t)
                        } else n.remove()
                    }
            }
            e.exports = function(e, i) {
                var s = r(e = e || [], i = i || {});
                return function(e) {
                    e = e || [];
                    for (var o = 0; o < s.length; o++) {
                        var a = n(s[o]);
                        t[a].references--
                    }
                    for (var l = r(e, i), c = 0; c < s.length; c++) {
                        var u = n(s[c]);
                        0 === t[u].references && (t[u].updater(), t.splice(u, 1))
                    }
                    s = l
                }
            }
        },
        80: function(e) {
            var t = {};
            e.exports = function(e, n) {
                var r = function(e) {
                    if (void 0 === t[e]) {
                        var n = document.querySelector(e);
                        if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try {
                            n = n.contentDocument.head
                        } catch (e) {
                            n = null
                        }
                        t[e] = n
                    }
                    return t[e]
                }(e);
                if (!r) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                r.appendChild(n)
            }
        },
        182: function(e) {
            e.exports = function(e) {
                var t = document.createElement("style");
                return e.setAttributes(t, e.attributes), e.insert(t, e.options), t
            }
        },
        850: function(e, t, n) {
            e.exports = function(e) {
                var t = n.nc;
                t && e.setAttribute("nonce", t)
            }
        },
        236: function(e) {
            e.exports = function(e) {
                var t = e.insertStyleElement(e);
                return {
                    update: function(n) {
                        ! function(e, t, n) {
                            var r = "";
                            n.supports && (r += "@supports (".concat(n.supports, ") {")), n.media && (r += "@media ".concat(n.media, " {"));
                            var i = void 0 !== n.layer;
                            i && (r += "@layer".concat(n.layer.length > 0 ? " ".concat(n.layer) : "", " {")), r += n.css, i && (r += "}"), n.media && (r += "}"), n.supports && (r += "}"), n.sourceMap, t.styleTagTransform(r, e, t.options)
                        }(t, e, n)
                    },
                    remove: function() {
                        ! function(e) {
                            if (null === e.parentNode) return !1;
                            e.parentNode.removeChild(e)
                        }(t)
                    }
                }
            }
        },
        213: function(e) {
            e.exports = function(e, t) {
                if (t.styleSheet) t.styleSheet.cssText = e;
                else {
                    for (; t.firstChild;) t.removeChild(t.firstChild);
                    t.appendChild(document.createTextNode(e))
                }
            }
        },
        585: function(e) {
            window,
            e.exports = function(e) {
                var t = {};

                function n(r) {
                    if (t[r]) return t[r].exports;
                    var i = t[r] = {
                        i: r,
                        l: !1,
                        exports: {}
                    };
                    return e[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
                }
                return n.m = e, n.c = t, n.d = function(e, t, r) {
                    n.o(e, t) || Object.defineProperty(e, t, {
                        enumerable: !0,
                        get: r
                    })
                }, n.r = function(e) {
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(e, "__esModule", {
                        value: !0
                    })
                }, n.t = function(e, t) {
                    if (1 & t && (e = n(e)), 8 & t) return e;
                    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                    var r = Object.create(null);
                    if (n.r(r), Object.defineProperty(r, "default", {
                            enumerable: !0,
                            value: e
                        }), 2 & t && "string" != typeof e)
                        for (var i in e) n.d(r, i, function(t) {
                            return e[t]
                        }.bind(null, i));
                    return r
                }, n.n = function(e) {
                    var t = e && e.__esModule ? function() {
                        return e.default
                    } : function() {
                        return e
                    };
                    return n.d(t, "a", t), t
                }, n.o = function(e, t) {
                    return Object.prototype.hasOwnProperty.call(e, t)
                }, n.p = "", n(n.s = 0)
            }([function(e, t, n) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = c;
                var r, i = (r = n(1)) && r.__esModule ? r : {
                    default: r
                };

                function s(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e
                    }(e) || function(e, t) {
                        var n = [],
                            r = !0,
                            i = !1,
                            s = void 0;
                        try {
                            for (var o, a = e[Symbol.iterator](); !(r = (o = a.next()).done) && (n.push(o.value), !t || n.length !== t); r = !0);
                        } catch (e) {
                            i = !0, s = e
                        } finally {
                            try {
                                r || null == a.return || a.return()
                            } finally {
                                if (i) throw s
                            }
                        }
                        return n
                    }(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance")
                    }()
                }

                function o(e) {
                    var t = {};
                    return e.reduce((function(e, n) {
                        return t[n] || (t[n] = !0, e.push(n)), e
                    }), [])
                }

                function a(e, t) {
                    requestAnimationFrame((function() {
                        t.enter(), requestAnimationFrame((function() {
                            t.active(), setTimeout((function() {
                                t.leave()
                            }), e)
                        }))
                    }))
                }

                function l(e, t) {
                    try {
                        var n = e.liElementsById[t.parent.id];
                        n.classList.contains("treejs-node__close") || n.getElementsByClassName("treejs-switcher")[0].click()
                    } catch (e) {
                        return
                    }
                    t.hasOwnProperty("parent") && l(e, t.parent)
                }

                function c(e, t) {
                    var n = this;
                    this.treeNodes = [], this.nodesById = {}, this.leafNodesById = {}, this.liElementsById = {}, this.willUpdateNodesById = {}, this.container = e, this.options = Object.assign({
                        selectMode: "checkbox",
                        values: [],
                        disables: [],
                        beforeLoad: null,
                        loaded: null,
                        url: null,
                        method: "GET",
                        closeDepth: null
                    }, t), Object.defineProperties(this, {
                        values: {
                            get: function() {
                                return this.getValues()
                            },
                            set: function(e) {
                                return this.setValues(o(e))
                            }
                        },
                        disables: {
                            get: function() {
                                return this.getDisables()
                            },
                            set: function(e) {
                                return this.setDisables(o(e))
                            }
                        },
                        selectedNodes: {
                            get: function() {
                                var e = [],
                                    t = this.nodesById;
                                for (var n in t)
                                    if (t.hasOwnProperty(n) && (1 === t[n].status || 2 === t[n].status)) {
                                        var r = Object.assign({}, t[n]);
                                        delete r.parent, delete r.children, e.push(r)
                                    }
                                return e
                            }
                        },
                        disabledNodes: {
                            get: function() {
                                var e = [],
                                    t = this.nodesById;
                                for (var n in t)
                                    if (t.hasOwnProperty(n) && t[n].disabled) {
                                        var r = Object.assign({}, t[n]);
                                        delete r.parent, e.push(r)
                                    }
                                return e
                            }
                        }
                    }), this.options.url ? this.load((function(e) {
                        n.init(e)
                    })) : this.init(this.options.data)
                }
                n(2), c.prototype.init = function(e) {
                    var t = c.parseTreeData(e),
                        n = t.treeNodes,
                        r = t.nodesById,
                        i = t.leafNodesById,
                        s = t.defaultValues,
                        o = t.defaultDisables;
                    this.treeNodes = n, this.nodesById = r, this.leafNodesById = i, this.render(this.treeNodes);
                    var a = this.options,
                        l = a.values,
                        u = a.disables,
                        p = a.loaded;
                    l && l.length && (s = l), s.length && this.setValues(s), u && u.length && (o = u), o.length && this.setDisables(o), p && p.call(this)
                }, c.prototype.load = function(e) {
                    var t = this.options,
                        n = t.url,
                        r = t.method,
                        s = t.beforeLoad;
                    (0, i.default)({
                        url: n,
                        method: r,
                        success: function(t) {
                            var n = t;
                            s && (n = s(t)), e(n)
                        }
                    })
                }, c.prototype.render = function(e) {
                    var t = c.createRootEle();
                    t.appendChild(this.buildTree(e, 0)), this.bindEvent(t);
                    var n = document.querySelector(this.container);
                    ! function(e) {
                        for (; e.firstChild;) e.removeChild(e.firstChild)
                    }(n), n.appendChild(t)
                }, c.prototype.buildTree = function(e, t) {
                    var n = this,
                        r = c.createUlEle();
                    return e && e.length && e.forEach((function(e) {
                        var i = c.createLiEle(e, t === n.options.closeDepth - 1);
                        n.liElementsById[e.id] = i;
                        var s = null;
                        e.children && e.children.length && (s = n.buildTree(e.children, t + 1)), s && i.appendChild(s), r.appendChild(i)
                    })), r
                }, c.prototype.bindEvent = function(e) {
                    var t = this;
                    e.addEventListener("click", (function(e) {
                        var n = e.target;
                        "SPAN" === n.nodeName && n.classList.contains("treejs-checkbox") ? t.onItemClick(n.parentNode.nodeId) : "SPAN" === n.nodeName && n.classList.contains("treejs-label") ? t.onItemLabelClick(n.parentNode.nodeId) : "LI" === n.nodeName && n.classList.contains("treejs-node") ? t.onItemClick(n.nodeId) : "SPAN" === n.nodeName && n.classList.contains("treejs-switcher") && t.onSwitcherClick(n)
                    }), !1)
                }, c.prototype.onItemClick = function(e) {
                    var t = this.nodesById[e],
                        n = this.options.onChange;
                    t.disabled || (this.setValue(e), this.updateLiElements()), n && n.call(this)
                }, c.prototype.onItemLabelClick = function(e) {
                    var t = this.options.onItemLabelClick;
                    t && t.call(this, e)
                }, c.prototype.setValue = function(e) {
                    var t = this.nodesById[e];
                    if (t) {
                        var n = t.status,
                            r = 1 === n || 2 === n ? 0 : 2;
                        t.status = r, this.markWillUpdateNode(t), this.walkUp(t, "status"), this.walkDown(t, "status")
                    }
                }, c.prototype.getValues = function() {
                    var e = [];
                    for (var t in this.leafNodesById) this.leafNodesById.hasOwnProperty(t) && (1 !== this.leafNodesById[t].status && 2 !== this.leafNodesById[t].status || e.push(t));
                    return e
                }, c.prototype.setValues = function(e) {
                    var t = this;
                    this.emptyNodesCheckStatus(), e.forEach((function(e) {
                        t.setValue(e)
                    })), this.updateLiElements();
                    var n = this.options.onChange;
                    n && n.call(this)
                }, c.prototype.setDisable = function(e) {
                    var t = this.nodesById[e];
                    t && (t.disabled || (t.disabled = !0, this.markWillUpdateNode(t), this.walkUp(t, "disabled"), this.walkDown(t, "disabled")))
                }, c.prototype.getDisables = function() {
                    var e = [];
                    for (var t in this.leafNodesById) this.leafNodesById.hasOwnProperty(t) && this.leafNodesById[t].disabled && e.push(t);
                    return e
                }, c.prototype.setDisables = function(e) {
                    var t = this;
                    this.emptyNodesDisable(), e.forEach((function(e) {
                        t.setDisable(e)
                    })), this.updateLiElements()
                }, c.prototype.emptyNodesCheckStatus = function() {
                    this.willUpdateNodesById = this.getSelectedNodesById(), Object.values(this.willUpdateNodesById).forEach((function(e) {
                        e.disabled || (e.status = 0)
                    }))
                }, c.prototype.emptyNodesDisable = function() {
                    this.willUpdateNodesById = this.getDisabledNodesById(), Object.values(this.willUpdateNodesById).forEach((function(e) {
                        e.disabled = !1
                    }))
                }, c.prototype.getSelectedNodesById = function() {
                    return Object.entries(this.nodesById).reduce((function(e, t) {
                        var n = s(t, 2),
                            r = n[0],
                            i = n[1];
                        return 1 !== i.status && 2 !== i.status || (e[r] = i), e
                    }), {})
                }, c.prototype.getDisabledNodesById = function() {
                    return Object.entries(this.nodesById).reduce((function(e, t) {
                        var n = s(t, 2),
                            r = n[0],
                            i = n[1];
                        return i.disabled && (e[r] = i), e
                    }), {})
                }, c.prototype.updateLiElements = function() {
                    var e = this;
                    Object.values(this.willUpdateNodesById).forEach((function(t) {
                        e.updateLiElement(t)
                    })), this.willUpdateNodesById = {}
                }, c.prototype.markWillUpdateNode = function(e) {
                    this.willUpdateNodesById[e.id] = e
                }, c.prototype.onSwitcherClick = function(e) {
                    var t = e.parentNode,
                        n = t.lastChild,
                        r = n.scrollHeight;
                    t.classList.contains("treejs-node__close") ? a(150, {
                        enter: function() {
                            n.style.height = 0, n.style.opacity = 0
                        },
                        active: function() {
                            n.style.height = "".concat(r, "px"), n.style.opacity = 1
                        },
                        leave: function() {
                            n.style.height = "", n.style.opacity = "", t.classList.remove("treejs-node__close")
                        }
                    }) : a(150, {
                        enter: function() {
                            n.style.height = "".concat(r, "px"), n.style.opacity = 1
                        },
                        active: function() {
                            n.style.height = 0, n.style.opacity = 0
                        },
                        leave: function() {
                            n.style.height = "", n.style.opacity = "", t.classList.add("treejs-node__close")
                        }
                    })
                }, c.prototype.walkUp = function(e, t) {
                    var n = e.parent;
                    if (n) {
                        if ("status" === t) {
                            var r, i = n.children.reduce((function(e, t) {
                                return isNaN(t.status) ? e : e + t.status
                            }), 0);
                            if (r = i ? i === 2 * n.children.length ? 2 : 1 : 0, n.status === r) return;
                            n.status = r
                        } else {
                            var s = n.children.reduce((function(e, t) {
                                return e && t.disabled
                            }), !0);
                            if (n.disabled === s) return;
                            n.disabled = s
                        }
                        this.markWillUpdateNode(n), this.walkUp(n, t)
                    }
                }, c.prototype.walkDown = function(e, t) {
                    var n = this;
                    e.children && e.children.length && e.children.forEach((function(r) {
                        "status" === t && r.disabled || (r[t] = e[t], n.markWillUpdateNode(r), n.walkDown(r, t))
                    }))
                }, c.prototype.updateLiElement = function(e) {
                    var t = this.liElementsById[e.id].classList;
                    switch (e.status) {
                        case 0:
                            t.remove("treejs-node__halfchecked", "treejs-node__checked");
                            break;
                        case 1:
                            t.remove("treejs-node__checked"), t.add("treejs-node__halfchecked");
                            break;
                        case 2:
                            t.remove("treejs-node__halfchecked"), t.add("treejs-node__checked")
                    }
                    switch (e.disabled) {
                        case !0:
                            t.contains("treejs-node__disabled") || t.add("treejs-node__disabled");
                            break;
                        case !1:
                            t.contains("treejs-node__disabled") && t.remove("treejs-node__disabled")
                    }
                }, c.prototype.collapseAll = function() {
                    var e = this.leafNodesById;
                    for (var t in e) l(this, e[t])
                }, c.prototype.expandAll = function() {
                    ! function e(t, n) {
                        var r = t.liElementsById[n.id];
                        if (r.classList.contains("treejs-node__close") && r.getElementsByClassName("treejs-switcher")[0].click(), n.hasOwnProperty("children")) {
                            var i = !0,
                                s = !1,
                                o = void 0;
                            try {
                                for (var a, l = n.children[Symbol.iterator](); !(i = (a = l.next()).done); i = !0) e(t, a.value)
                            } catch (e) {
                                s = !0, o = e
                            } finally {
                                try {
                                    i || null == l.return || l.return()
                                } finally {
                                    if (s) throw o
                                }
                            }
                        }
                    }(this, this.treeNodes[0])
                }, c.parseTreeData = function(e) {
                    var t, n = (t = e, JSON.parse(JSON.stringify(t))),
                        r = {},
                        i = {},
                        s = [],
                        o = [];
                    return function e(t, n) {
                        t.forEach((function(t) {
                            r[t.id] = t, t.checked && s.push(t.id), t.disabled && o.push(t.id), n && (t.parent = n), t.children && t.children.length ? e(t.children, t) : i[t.id] = t
                        }))
                    }(n), {
                        treeNodes: n,
                        nodesById: r,
                        leafNodesById: i,
                        defaultValues: s,
                        defaultDisables: o
                    }
                }, c.createRootEle = function() {
                    var e = document.createElement("div");
                    return e.classList.add("treejs"), e
                }, c.createUlEle = function() {
                    var e = document.createElement("ul");
                    return e.classList.add("treejs-nodes"), e
                }, c.createLiEle = function(e, t) {
                    var n = document.createElement("li");
                    if (n.classList.add("treejs-node"), t && n.classList.add("treejs-node__close"), e.children && e.children.length) {
                        var r = document.createElement("span");
                        r.classList.add("treejs-switcher"), n.appendChild(r)
                    } else n.classList.add("treejs-placeholder");
                    var i = document.createElement("span");
                    i.classList.add("treejs-checkbox"), n.appendChild(i);
                    var s = document.createElement("span");
                    s.classList.add("treejs-label");
                    var o = document.createTextNode(e.text);
                    return s.appendChild(o), n.appendChild(s), n.nodeId = e.id, n
                }
            }, function(e, t, n) {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e) {
                    var t = {
                            method: "GET",
                            url: "",
                            async: !0,
                            success: null,
                            failed: null,
                            data: {},
                            "Content-Type": "application/json; charset=utf-8"
                        },
                        n = Object.assign(t, e),
                        r = new XMLHttpRequest,
                        i = Object.entries(n.data).reduce((function(e, t) {
                            var n, r = (2, function(e) {
                                    if (Array.isArray(e)) return e
                                }(n = t) || function(e, t) {
                                    var n = [],
                                        r = !0,
                                        i = !1,
                                        s = void 0;
                                    try {
                                        for (var o, a = e[Symbol.iterator](); !(r = (o = a.next()).done) && (n.push(o.value), 2 !== n.length); r = !0);
                                    } catch (e) {
                                        i = !0, s = e
                                    } finally {
                                        try {
                                            r || null == a.return || a.return()
                                        } finally {
                                            if (i) throw s
                                        }
                                    }
                                    return n
                                }(n) || function() {
                                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                                }()),
                                i = r[0],
                                s = r[1];
                            return e.push("".concat(i, "=").concat(s)), e
                        }), []).join("&");
                    if ("POST" === n.method.toUpperCase()) r.open(n.method, n.url, n.async), r.setRequestHeader("Content-Type", n["Content-Type"]), r.send(i);
                    else if ("GET" === n.method.toUpperCase()) {
                        var s = n.url;
                        i && (s.indexOf("?"), s += "&".concat(i)), r.open(n.method, s, n.async), r.setRequestHeader("Content-Type", n["Content-Type"]), r.send(null)
                    }
                    r.onreadystatechange = function() {
                        if (4 === r.readyState && 200 === r.status) {
                            var e = r.responseText;
                            n["Content-Type"] === t["Content-Type"] && (e = JSON.parse(e)), n.success && n.success(e)
                        } else n.failed && n.failed(r.status)
                    }
                }
            }, function(e, t, n) {
                var r = n(3);
                "string" == typeof r && (r = [
                    [e.i, r, ""]
                ]);
                n(5)(r, {
                    hmr: !0,
                    transform: void 0,
                    insertInto: void 0
                }), r.locals && (e.exports = r.locals)
            }, function(e, t, n) {
                (e.exports = n(4)(!1)).push([e.i, ".treejs {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  font-size: 14px;\n  margin-left: -18px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.treejs *:after,\n.treejs *:before {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.treejs > .treejs-node {\n  padding-left: 0;\n}\n.treejs .treejs-nodes {\n  list-style: none;\n  padding-left: 18px;\n  margin: 0;\n  overflow: hidden;\n  -webkit-transition: height 150ms ease-out, opacity 150ms ease-out;\n  -o-transition: height 150ms ease-out, opacity 150ms ease-out;\n  transition: height 150ms ease-out, opacity 150ms ease-out;\n}\n.treejs .treejs-node {\n  cursor: pointer;\n  overflow: hidden;\n}\n.treejs .treejs-node.treejs-placeholder {\n  padding-left: 18px;\n}\n.treejs .treejs-switcher {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n  -webkit-transition: -webkit-transform 150ms ease-out;\n  transition: -webkit-transform 150ms ease-out;\n  -o-transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out;\n  transition: transform 150ms ease-out, -webkit-transform 150ms ease-out;\n}\n.treejs .treejs-switcher:before {\n  position: absolute;\n  top: 8px;\n  left: 6px;\n  display: block;\n  content: ' ';\n  border: 4px solid transparent;\n  border-top: 4px solid rgba(245, 245, 245, 0.7);\n  -webkit-transition: border-color 150ms;\n  -o-transition: border-color 150ms;\n  transition: border-color 150ms;\n}\n.treejs .treejs-switcher:hover:before {\n  border-top: 4px solid rgba(245, 245, 245, 0.96);\n}\n.treejs .treejs-node__close > .treejs-switcher {\n  -webkit-transform: rotate(-90deg);\n      -ms-transform: rotate(-90deg);\n          transform: rotate(-90deg);\n}\n.treejs .treejs-node__close > .treejs-nodes {\n  height: 0;\n}\n.treejs .treejs-checkbox {\n  display: inline-block;\n  vertical-align: middle;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  position: relative;\n}\n.treejs .treejs-checkbox:before {\n  -webkit-transition: all 0.3s;\n  -o-transition: all 0.3s;\n  transition: all 0.3s;\n  cursor: pointer;\n  position: absolute;\n  top: 2px;\n  content: ' ';\n  display: block;\n  width: 16px;\n  height: 16px;\n  border: 1px solid #d9d9d9;\n  border-radius: 2px;\n}\n.treejs .treejs-checkbox:hover:before {\n  -webkit-box-shadow: 0 0 2px 1px #1890ff;\n          box-shadow: 0 0 2px 1px #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__checked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 4px;\n  left: 5px;\n  width: 5px;\n  height: 9px;\n  border: 2px solid #fff;\n  border-top: none;\n  border-left: none;\n  -webkit-transform: rotate(45deg);\n      -ms-transform: rotate(45deg);\n          transform: rotate(45deg);\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:before {\n  background-color: #1890ff;\n  border-color: #1890ff;\n}\n.treejs .treejs-node__halfchecked > .treejs-checkbox:after {\n  position: absolute;\n  content: ' ';\n  display: block;\n  top: 9px;\n  left: 3px;\n  width: 10px;\n  height: 2px;\n  background-color: #fff;\n}\n.treejs .treejs-node__disabled {\n  cursor: not-allowed;\n  color: rgba(255, 255, 255, 0.25);\n}\n.treejs .treejs-node__disabled .treejs-checkbox {\n  cursor: not-allowed;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:before {\n  cursor: not-allowed;\n  border-color: #d9d9d9 !important;\n  background-color: #f5f5f5 !important;\n}\n.treejs .treejs-node__disabled .treejs-checkbox:hover:before {\n  -webkit-box-shadow: none !important;\n          box-shadow: none !important;\n}\n.treejs .treejs-node__disabled .treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled .treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__checked > .treejs-checkbox:after {\n  border-color: #d9d9d9;\n}\n.treejs .treejs-node__disabled.treejs-node__halfchecked > .treejs-checkbox:after {\n  background-color: #d9d9d9;\n}\n.treejs .treejs-label {\n  vertical-align: middle;\n}\n", ""])
            }, function(e, t) {
                e.exports = function(e) {
                    var t = [];
                    return t.toString = function() {
                        return this.map((function(t) {
                            var n = function(e, t) {
                                var n, r = e[1] || "",
                                    i = e[3];
                                if (!i) return r;
                                if (t && "function" == typeof btoa) {
                                    var s = (n = i, ""),
                                        o = i.sources.map((function(e) {
                                            return "/*# sourceURL=" + i.sourceRoot + e + " */"
                                        }));
                                    return [r].concat(o).concat([s]).join("\n")
                                }
                                return [r].join("\n")
                            }(t, e);
                            return t[2] ? "@media " + t[2] + "{" + n + "}" : n
                        })).join("")
                    }, t.i = function(e, n) {
                        "string" == typeof e && (e = [
                            [null, e, ""]
                        ]);
                        for (var r = {}, i = 0; i < this.length; i++) {
                            var s = this[i][0];
                            "number" == typeof s && (r[s] = !0)
                        }
                        for (i = 0; i < e.length; i++) {
                            var o = e[i];
                            "number" == typeof o[0] && r[o[0]] || (n && !o[2] ? o[2] = n : n && (o[2] = "(" + o[2] + ") and (" + n + ")"), t.push(o))
                        }
                    }, t
                }
            }, function(e, t, n) {
                var r, i, s = {},
                    o = (r = function() {
                        return window && document && document.all && !window.atob
                    }, function() {
                        return void 0 === i && (i = r.apply(this, arguments)), i
                    }),
                    a = function(e) {
                        var t = {};
                        return function(e) {
                            if ("function" == typeof e) return e();
                            if (void 0 === t[e]) {
                                var n = function(e) {
                                    return document.querySelector(e)
                                }.call(this, e);
                                if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try {
                                    n = n.contentDocument.head
                                } catch (e) {
                                    n = null
                                }
                                t[e] = n
                            }
                            return t[e]
                        }
                    }(),
                    l = null,
                    c = 0,
                    u = [],
                    p = n(6);

                function h(e, t) {
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n],
                            i = s[r.id];
                        if (i) {
                            i.refs++;
                            for (var o = 0; o < i.parts.length; o++) i.parts[o](r.parts[o]);
                            for (; o < r.parts.length; o++) i.parts.push(v(r.parts[o], t))
                        } else {
                            var a = [];
                            for (o = 0; o < r.parts.length; o++) a.push(v(r.parts[o], t));
                            s[r.id] = {
                                id: r.id,
                                refs: 1,
                                parts: a
                            }
                        }
                    }
                }

                function d(e, t) {
                    for (var n = [], r = {}, i = 0; i < e.length; i++) {
                        var s = e[i],
                            o = t.base ? s[0] + t.base : s[0],
                            a = {
                                css: s[1],
                                media: s[2],
                                sourceMap: s[3]
                            };
                        r[o] ? r[o].parts.push(a) : n.push(r[o] = {
                            id: o,
                            parts: [a]
                        })
                    }
                    return n
                }

                function f(e, t) {
                    var n = a(e.insertInto);
                    if (!n) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
                    var r = u[u.length - 1];
                    if ("top" === e.insertAt) r ? r.nextSibling ? n.insertBefore(t, r.nextSibling) : n.appendChild(t) : n.insertBefore(t, n.firstChild), u.push(t);
                    else if ("bottom" === e.insertAt) n.appendChild(t);
                    else {
                        if ("object" != typeof e.insertAt || !e.insertAt.before) throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
                        var i = a(e.insertInto + " " + e.insertAt.before);
                        n.insertBefore(t, i)
                    }
                }

                function _(e) {
                    if (null === e.parentNode) return !1;
                    e.parentNode.removeChild(e);
                    var t = u.indexOf(e);
                    t >= 0 && u.splice(t, 1)
                }

                function m(e) {
                    var t = document.createElement("style");
                    return void 0 === e.attrs.type && (e.attrs.type = "text/css"), g(t, e.attrs), f(e, t), t
                }

                function g(e, t) {
                    Object.keys(t).forEach((function(n) {
                        e.setAttribute(n, t[n])
                    }))
                }

                function v(e, t) {
                    var n, r, i, s;
                    if (t.transform && e.css) {
                        if (!(s = t.transform(e.css))) return function() {};
                        e.css = s
                    }
                    if (t.singleton) {
                        var o = c++;
                        n = l || (l = m(t)), r = y.bind(null, n, o, !1), i = y.bind(null, n, o, !0)
                    } else e.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (n = function(e) {
                        var t = document.createElement("link");
                        return void 0 === e.attrs.type && (e.attrs.type = "text/css"), e.attrs.rel = "stylesheet", g(t, e.attrs), f(e, t), t
                    }(t), r = function(e, t, n) {
                        var r = n.css,
                            i = n.sourceMap,
                            s = void 0 === t.convertToAbsoluteUrls && i;
                        (t.convertToAbsoluteUrls || s) && (r = p(r)), i && (r += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(i)))) + " */");
                        var o = new Blob([r], {
                                type: "text/css"
                            }),
                            a = e.href;
                        e.href = URL.createObjectURL(o), a && URL.revokeObjectURL(a)
                    }.bind(null, n, t), i = function() {
                        _(n), n.href && URL.revokeObjectURL(n.href)
                    }) : (n = m(t), r = function(e, t) {
                        var n = t.css,
                            r = t.media;
                        if (r && e.setAttribute("media", r), e.styleSheet) e.styleSheet.cssText = n;
                        else {
                            for (; e.firstChild;) e.removeChild(e.firstChild);
                            e.appendChild(document.createTextNode(n))
                        }
                    }.bind(null, n), i = function() {
                        _(n)
                    });
                    return r(e),
                        function(t) {
                            if (t) {
                                if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap) return;
                                r(e = t)
                            } else i()
                        }
                }
                e.exports = function(e, t) {
                    if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document) throw new Error("The style-loader cannot be used in a non-browser environment");
                    (t = t || {}).attrs = "object" == typeof t.attrs ? t.attrs : {}, t.singleton || "boolean" == typeof t.singleton || (t.singleton = o()), t.insertInto || (t.insertInto = "head"), t.insertAt || (t.insertAt = "bottom");
                    var n = d(e, t);
                    return h(n, t),
                        function(e) {
                            for (var r = [], i = 0; i < n.length; i++) {
                                var o = n[i];
                                (a = s[o.id]).refs--, r.push(a)
                            }
                            for (e && h(d(e, t), t), i = 0; i < r.length; i++) {
                                var a;
                                if (0 === (a = r[i]).refs) {
                                    for (var l = 0; l < a.parts.length; l++) a.parts[l]();
                                    delete s[a.id]
                                }
                            }
                        }
                };
                var b, x = (b = [], function(e, t) {
                    return b[e] = t, b.filter(Boolean).join("\n")
                });

                function y(e, t, n, r) {
                    var i = n ? "" : r.css;
                    if (e.styleSheet) e.styleSheet.cssText = x(t, i);
                    else {
                        var s = document.createTextNode(i),
                            o = e.childNodes;
                        o[t] && e.removeChild(o[t]), o.length ? e.insertBefore(s, o[t]) : e.appendChild(s)
                    }
                }
            }, function(e, t) {
                e.exports = function(e) {
                    var t = "undefined" != typeof window && window.location;
                    if (!t) throw new Error("fixUrls requires window.location");
                    if (!e || "string" != typeof e) return e;
                    var n = t.protocol + "//" + t.host,
                        r = n + t.pathname.replace(/\/[^\/]*$/, "/");
                    return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, (function(e, t) {
                        var i, s = t.trim().replace(/^"(.*)"$/, (function(e, t) {
                            return t
                        })).replace(/^'(.*)'$/, (function(e, t) {
                            return t
                        }));
                        return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(s) ? e : (i = 0 === s.indexOf("//") ? s : 0 === s.indexOf("/") ? n + s : r + s.replace(/^\.\//, ""), "url(" + JSON.stringify(i) + ")")
                    }))
                }
            }]).default
        },
        466: function(e, t, n) {
            e.exports = n(585)
        },
        819: function(e, t) {
            ! function(e) {
                const t = "tp";

                function n(e) {
                    return t => n => {
                        if (!t && void 0 === n) return {
                            succeeded: !1,
                            value: void 0
                        };
                        if (t && void 0 === n) return {
                            succeeded: !0,
                            value: void 0
                        };
                        const r = e(n);
                        return void 0 !== r ? {
                            succeeded: !0,
                            value: r
                        } : {
                            succeeded: !1,
                            value: void 0
                        }
                    }
                }

                function r(e) {
                    return {
                        custom: t => n(t)(e),
                        boolean: n((e => "boolean" == typeof e ? e : void 0))(e),
                        number: n((e => "number" == typeof e ? e : void 0))(e),
                        string: n((e => "string" == typeof e ? e : void 0))(e),
                        function: n((e => "function" == typeof e ? e : void 0))(e),
                        constant: t => n((e => e === t ? t : void 0))(e),
                        raw: n((e => e))(e),
                        object: t => n((e => {
                            if (null !== (n = e) && "object" == typeof n) return function(e, t) {
                                return Object.keys(t).reduce(((n, r) => {
                                    if (void 0 === n) return;
                                    const i = (0, t[r])(e[r]);
                                    return i.succeeded ? Object.assign(Object.assign({}, n), {
                                        [r]: i.value
                                    }) : void 0
                                }), {})
                            }(e, t);
                            var n
                        }))(e),
                        array: t => n((e => {
                            if (Array.isArray(e)) return n = t, e.reduce(((e, t) => {
                                if (void 0 === e) return;
                                const r = n(t);
                                return r.succeeded && void 0 !== r.value ? [...e, r.value] : void 0
                            }), []);
                            var n
                        }))(e)
                    }
                }
                const i = {
                    optional: r(!0),
                    required: r(!1)
                };

                function s(e, t, n, r) {
                    return new(n || (n = Promise))((function(i, s) {
                        function o(e) {
                            try {
                                l(r.next(e))
                            } catch (e) {
                                s(e)
                            }
                        }

                        function a(e) {
                            try {
                                l(r.throw(e))
                            } catch (e) {
                                s(e)
                            }
                        }

                        function l(e) {
                            var t;
                            e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                                e(t)
                            }))).then(o, a)
                        }
                        l((r = r.apply(e, t || [])).next())
                    }))
                }

                function o(e) {
                    return s(this, void 0, void 0, (function*() {
                        const t = new Image;
                        return t.crossOrigin = "anonymous", new Promise(((n, r) => {
                            t.src = e, t.onload = () => {
                                n(t)
                            }, t.onerror = r
                        }))
                    }))
                }
                const a = (l = "img", (e, n) => [t, "-", l, "v", e ? `_${e}` : "", n ? `-${n}` : ""].join(""));
                var l;
                class c {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(a()), t.viewProps.bindClassModifiers(this.element), this.input = e.createElement("input"), this.input.classList.add(a("input")), this.input.setAttribute("type", "file"), this.input.setAttribute("accept", t.extensions.join(",")), this.image_ = e.createElement("img"), this.image_.classList.add(a("image")), this.image_.classList.add(a(`image_${t.imageFit}`)), this.image_.crossOrigin = "anonymous", this.image_.onclick = e => {
                            t.clickCallback ? t.clickCallback(e, this.input) : this.input.click()
                        }, this.element.classList.add(a("area_root")), this.element.appendChild(this.image_), this.element.appendChild(this.input)
                    }
                    changeImage(e) {
                        this.image_.src = e
                    }
                    changeDraggingState(e) {
                        const t = this.element;
                        e ? null == t || t.classList.add(a("area_dragging")) : null == t || t.classList.remove(a("area_dragging"))
                    }
                }
                let u = null;
                class p {
                    constructor(e, t) {
                        this.value = t.value, this.viewProps = t.viewProps, this.view = new c(e, {
                            viewProps: this.viewProps,
                            extensions: t.extensions,
                            imageFit: t.imageFit,
                            clickCallback: t.clickCallback
                        }), this.onFile = this.onFile.bind(this), this.onDrop = this.onDrop.bind(this), this.onDragOver = this.onDragOver.bind(this), this.onDragLeave = this.onDragLeave.bind(this), this.view.input.addEventListener("change", this.onFile), this.view.element.addEventListener("drop", this.onDrop), this.view.element.addEventListener("dragover", this.onDragOver), this.view.element.addEventListener("dragleave", this.onDragLeave), this.viewProps.handleDispose((() => {
                            this.view.input.removeEventListener("change", this.onFile), this.view.input.removeEventListener("drop", this.onDrop), this.view.input.removeEventListener("dragover", this.onDragOver), this.view.input.removeEventListener("dragleave", this.onDragLeave)
                        })), this.value.emitter.on("change", this.handleValueChange.bind(this)), this.handleValueChange()
                    }
                    onFile(e) {
                        const t = (null == e ? void 0 : e.target).files;
                        if (!t || !t.length) return;
                        const n = t[0];
                        this.setValue(n)
                    }
                    onDrop(e) {
                        return s(this, void 0, void 0, (function*() {
                            e.preventDefault();
                            try {
                                const {
                                    dataTransfer: t
                                } = e, n = null == t ? void 0 : t.files[0];
                                if (n) this.setValue(n);
                                else {
                                    const e = null == t ? void 0 : t.getData("url");
                                    if (!e) throw new Error("No url");
                                    this.setValue(e)
                                }
                            } catch (e) {
                                console.error("Could not parse the dropped image", e)
                            } finally {
                                this.view.changeDraggingState(!1)
                            }
                        }))
                    }
                    onDragOver(e) {
                        e.preventDefault(), this.view.changeDraggingState(!0)
                    }
                    onDragLeave() {
                        this.view.changeDraggingState(!1)
                    }
                    handleImage(e) {
                        return s(this, void 0, void 0, (function*() {
                            e instanceof HTMLImageElement ? this.updateImage(e.src) : "string" != typeof e && e ? yield this.setValue(e): ("placeholder" !== e && e || (e = (yield this.handlePlaceholderImage()).src), this.updateImage(e))
                        }))
                    }
                    updateImage(e) {
                        this.view.changeImage(e)
                    }
                    setValue(e) {
                        return s(this, void 0, void 0, (function*() {
                            if (e instanceof HTMLImageElement) this.value.setRawValue(e);
                            else if (e instanceof File) {
                                const t = URL.createObjectURL(e) + "#" + e.name;
                                e.src = t;
                                const n = yield o(t).catch((() => {}));
                                this.value.setRawValue(n || e)
                            } else e ? this.value.setRawValue(yield o(e)) : this.value.setRawValue(yield this.handlePlaceholderImage())
                        }))
                    }
                    handleValueChange() {
                        this.handleImage(this.value.rawValue)
                    }
                    handlePlaceholderImage() {
                        return s(this, void 0, void 0, (function*() {
                            return u || (u = yield function() {
                                const e = document.createElement("canvas");
                                e.width = 320, e.height = 50;
                                const t = e.getContext("2d");
                                return t.fillStyle = "#00000004", t.fillRect(0, 0, e.width, e.height), t.fillStyle = "#eee", t.font = '1.25rem "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace', t.textAlign = "center", t.textBaseline = "middle", t.fillText("No image", .5 * e.width, .5 * e.height), new Promise((t => {
                                    e.toBlob((e => {
                                        const n = new Image;
                                        n.src = URL.createObjectURL(e), n.isPlaceholder = !0, n.onload = () => {
                                            t(n)
                                        }
                                    }))
                                }))
                            }()), u
                        }))
                    }
                }
                const h = [".jpg", ".png", ".gif"],
                    d = {
                        id: "input-image",
                        type: "input",
                        css: ".tp-imgv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-imgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-imgv:hover{background-color:var(--in-bg-h)}.tp-imgv:focus{background-color:var(--in-bg-f)}.tp-imgv:active{background-color:var(--in-bg-a)}.tp-imgv:disabled{opacity:0.5}:root{--tp-plugin-image-dragging-color: hsla(230, 100%, 66%, 1.00)}.tp-imgv{cursor:pointer;display:inline-flex;height:auto !important;max-height:calc(var(--bld-us) * 3);border-radius:4px;position:relative}.tp-imgv.tp-v-disabled{opacity:0.5}.tp-imgv_input{width:0;height:0;pointer-events:none;visibility:hidden}.tp-imgv_image{width:100%;height:-webkit-max-content;height:-moz-max-content;height:max-content;max-height:calc(var(--bld-us) * 3);border:0}.tp-imgv_image_contain{-o-object-fit:contain;object-fit:contain}.tp-imgv_image_cover{-o-object-fit:cover;object-fit:cover}.tp-imgv_area_root{transition:opacity 0.16s ease-in-out}.tp-imgv_area_dragging{border:2px dashed var(--tp-plugin-image-dragging-color);border-radius:4px;opacity:0.6}",
                        accept(e, t) {
                            if (!(e instanceof HTMLImageElement || "string" == typeof e)) return null;
                            const n = i,
                                r = function(e, t) {
                                    const n = i.required.object(t)(e);
                                    return n.succeeded ? n.value : void 0
                                }(t, {
                                    view: n.required.constant("input-image"),
                                    acceptUrl: n.optional.boolean,
                                    clickCallback: n.optional.function,
                                    imageFit: n.optional.custom((e => "contain" === e || "cover" === e ? e : void 0)),
                                    extensions: n.optional.array(n.required.string)
                                });
                            return r ? {
                                initialValue: e,
                                params: r
                            } : null
                        },
                        binding: {
                            reader: e => e => void 0 !== e.src ? "" === e.src ? "placeholder" : e.src : e,
                            writer: e => (e, t) => {
                                e.write(t)
                            }
                        },
                        controller(e) {
                            var t, n;
                            return new p(e.document, {
                                value: e.value,
                                imageFit: null !== (t = e.params.imageFit) && void 0 !== t ? t : "cover",
                                clickCallback: e.params.clickCallback,
                                viewProps: e.viewProps,
                                extensions: null !== (n = e.params.extensions) && void 0 !== n ? n : h
                            })
                        }
                    };
                e.plugin = d, Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }(t)
        },
        665: function(e, t) {
            ! function(e) {
                class t {
                    constructor(e) {
                        this.controller_ = e
                    }
                    get disabled() {
                        return this.controller_.viewProps.get("disabled")
                    }
                    set disabled(e) {
                        this.controller_.viewProps.set("disabled", e)
                    }
                    get hidden() {
                        return this.controller_.viewProps.get("hidden")
                    }
                    set hidden(e) {
                        this.controller_.viewProps.set("hidden", e)
                    }
                    dispose() {
                        this.controller_.viewProps.set("disposed", !0)
                    }
                }
                class n {
                    constructor(e) {
                        this.target = e
                    }
                }
                class r extends n {
                    constructor(e, t, n, r) {
                        super(e), this.value = t, this.presetKey = n, this.last = null == r || r
                    }
                }
                class i extends n {
                    constructor(e, t, n) {
                        super(e), this.value = t, this.presetKey = n
                    }
                }
                class s extends n {
                    constructor(e, t) {
                        super(e), this.expanded = t
                    }
                }

                function o(e) {
                    return null == e
                }

                function a(e, t) {
                    if (e.length !== t.length) return !1;
                    for (let n = 0; n < e.length; n++)
                        if (e[n] !== t[n]) return !1;
                    return !0
                }
                const l = {
                    alreadydisposed: () => "View has been already disposed",
                    invalidparams: e => `Invalid parameters for '${e.name}'`,
                    nomatchingcontroller: e => `No matching controller for '${e.key}'`,
                    nomatchingview: e => `No matching view for '${JSON.stringify(e.params)}'`,
                    notbindable: () => "Value is not bindable",
                    propertynotfound: e => `Property '${e.name}' not found`,
                    shouldneverhappen: () => "This error should never happen"
                };
                class c {
                    constructor(e) {
                        var t;
                        this.message = null !== (t = l[e.type](e.context)) && void 0 !== t ? t : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = e.type
                    }
                    static alreadyDisposed() {
                        return new c({
                            type: "alreadydisposed"
                        })
                    }
                    static notBindable() {
                        return new c({
                            type: "notbindable"
                        })
                    }
                    static propertyNotFound(e) {
                        return new c({
                            type: "propertynotfound",
                            context: {
                                name: e
                            }
                        })
                    }
                    static shouldNeverHappen() {
                        return new c({
                            type: "shouldneverhappen"
                        })
                    }
                }
                class u {
                    constructor(e, t, n) {
                        this.obj_ = e, this.key_ = t, this.presetKey_ = null != n ? n : t
                    }
                    static isBindable(e) {
                        return null !== e && "object" == typeof e
                    }
                    get key() {
                        return this.key_
                    }
                    get presetKey() {
                        return this.presetKey_
                    }
                    read() {
                        return this.obj_[this.key_]
                    }
                    write(e) {
                        this.obj_[this.key_] = e
                    }
                    writeProperty(e, t) {
                        const n = this.read();
                        if (!u.isBindable(n)) throw c.notBindable();
                        if (!(e in n)) throw c.propertyNotFound(e);
                        n[e] = t
                    }
                }
                class p extends t {
                    get label() {
                        return this.controller_.props.get("label")
                    }
                    set label(e) {
                        this.controller_.props.set("label", e)
                    }
                    get title() {
                        var e;
                        return null !== (e = this.controller_.valueController.props.get("title")) && void 0 !== e ? e : ""
                    }
                    set title(e) {
                        this.controller_.valueController.props.set("title", e)
                    }
                    on(e, t) {
                        const r = t.bind(this);
                        return this.controller_.valueController.emitter.on(e, (() => {
                            r(new n(this))
                        })), this
                    }
                }
                class h {
                    constructor() {
                        this.observers_ = {}
                    }
                    on(e, t) {
                        let n = this.observers_[e];
                        return n || (n = this.observers_[e] = []), n.push({
                            handler: t
                        }), this
                    }
                    off(e, t) {
                        const n = this.observers_[e];
                        return n && (this.observers_[e] = n.filter((e => e.handler !== t))), this
                    }
                    emit(e, t) {
                        const n = this.observers_[e];
                        n && n.forEach((e => {
                            e.handler(t)
                        }))
                    }
                }
                const d = "tp";

                function f(e) {
                    return (t, n) => [d, "-", e, "v", t ? `_${t}` : "", n ? `-${n}` : ""].join("")
                }

                function _(e) {
                    return e.rawValue
                }

                function m(e, t) {
                    var n, r;
                    e.emitter.on("change", (n = _, r = t, e => r(n(e)))), t(e.rawValue)
                }

                function g(e, t, n) {
                    m(e.value(t), n)
                }

                function v(e, t) {
                    return n => {
                        ! function(e, t, n) {
                            n ? e.classList.add(t) : e.classList.remove(t)
                        }(e, t, n)
                    }
                }

                function b(e, t) {
                    m(e, (e => {
                        t.textContent = null != e ? e : ""
                    }))
                }
                const x = f("btn");
                class y {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(x()), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("button");
                        n.classList.add(x("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
                        const r = e.createElement("div");
                        r.classList.add(x("t")), b(t.props.value("title"), r), this.buttonElement.appendChild(r)
                    }
                }
                class w {
                    constructor(e, t) {
                        this.emitter = new h, this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new y(e, {
                            props: this.props,
                            viewProps: this.viewProps
                        }), this.view.buttonElement.addEventListener("click", this.onClick_)
                    }
                    onClick_() {
                        this.emitter.emit("click", {
                            sender: this
                        })
                    }
                }
                class S {
                    constructor(e, t) {
                        var n;
                        this.constraint_ = null == t ? void 0 : t.constraint, this.equals_ = null !== (n = null == t ? void 0 : t.equals) && void 0 !== n ? n : (e, t) => e === t, this.emitter = new h, this.rawValue_ = e
                    }
                    get constraint() {
                        return this.constraint_
                    }
                    get rawValue() {
                        return this.rawValue_
                    }
                    set rawValue(e) {
                        this.setRawValue(e, {
                            forceEmit: !1,
                            last: !0
                        })
                    }
                    setRawValue(e, t) {
                        const n = null != t ? t : {
                                forceEmit: !1,
                                last: !0
                            },
                            r = this.constraint_ ? this.constraint_.constrain(e) : e;
                        (!this.equals_(this.rawValue_, r) || n.forceEmit) && (this.emitter.emit("beforechange", {
                            sender: this
                        }), this.rawValue_ = r, this.emitter.emit("change", {
                            options: n,
                            rawValue: r,
                            sender: this
                        }))
                    }
                }
                class M {
                    constructor(e) {
                        this.emitter = new h, this.value_ = e
                    }
                    get rawValue() {
                        return this.value_
                    }
                    set rawValue(e) {
                        this.setRawValue(e, {
                            forceEmit: !1,
                            last: !0
                        })
                    }
                    setRawValue(e, t) {
                        const n = null != t ? t : {
                            forceEmit: !1,
                            last: !0
                        };
                        (this.value_ !== e || n.forceEmit) && (this.emitter.emit("beforechange", {
                            sender: this
                        }), this.value_ = e, this.emitter.emit("change", {
                            options: n,
                            rawValue: this.value_,
                            sender: this
                        }))
                    }
                }

                function T(e, t) {
                    const n = null == t ? void 0 : t.constraint,
                        r = null == t ? void 0 : t.equals;
                    return n || r ? new S(e, t) : new M(e)
                }
                class E {
                    constructor(e) {
                        this.emitter = new h, this.valMap_ = e;
                        for (const e in this.valMap_) this.valMap_[e].emitter.on("change", (() => {
                            this.emitter.emit("change", {
                                key: e,
                                sender: this
                            })
                        }))
                    }
                    static createCore(e) {
                        return Object.keys(e).reduce(((t, n) => Object.assign(t, {
                            [n]: T(e[n])
                        })), {})
                    }
                    static fromObject(e) {
                        const t = this.createCore(e);
                        return new E(t)
                    }
                    get(e) {
                        return this.valMap_[e].rawValue
                    }
                    set(e, t) {
                        this.valMap_[e].rawValue = t
                    }
                    value(e) {
                        return this.valMap_[e]
                    }
                }

                function A(e) {
                    return t => n => {
                        if (!t && void 0 === n) return {
                            succeeded: !1,
                            value: void 0
                        };
                        if (t && void 0 === n) return {
                            succeeded: !0,
                            value: void 0
                        };
                        const r = e(n);
                        return void 0 !== r ? {
                            succeeded: !0,
                            value: r
                        } : {
                            succeeded: !1,
                            value: void 0
                        }
                    }
                }

                function C(e) {
                    return {
                        custom: t => A(t)(e),
                        boolean: A((e => "boolean" == typeof e ? e : void 0))(e),
                        number: A((e => "number" == typeof e ? e : void 0))(e),
                        string: A((e => "string" == typeof e ? e : void 0))(e),
                        function: A((e => "function" == typeof e ? e : void 0))(e),
                        constant: t => A((e => e === t ? t : void 0))(e),
                        raw: A((e => e))(e),
                        object: t => A((e => {
                            if (null !== (n = e) && "object" == typeof n) return function(e, t) {
                                return Object.keys(t).reduce(((n, r) => {
                                    if (void 0 === n) return;
                                    const i = (0, t[r])(e[r]);
                                    return i.succeeded ? Object.assign(Object.assign({}, n), {
                                        [r]: i.value
                                    }) : void 0
                                }), {})
                            }(e, t);
                            var n
                        }))(e),
                        array: t => A((e => {
                            if (Array.isArray(e)) return n = t, e.reduce(((e, t) => {
                                if (void 0 === e) return;
                                const r = n(t);
                                return r.succeeded && void 0 !== r.value ? [...e, r.value] : void 0
                            }), []);
                            var n
                        }))(e)
                    }
                }
                const R = {
                    optional: C(!0),
                    required: C(!1)
                };

                function k(e, t) {
                    const n = R.required.object(t)(e);
                    return n.succeeded ? n.value : void 0
                }
                const P = f(""),
                    D = {
                        veryfirst: "vfst",
                        first: "fst",
                        last: "lst",
                        verylast: "vlst"
                    };
                class O {
                    constructor(e) {
                        this.parent_ = null, this.blade = e.blade, this.view = e.view, this.viewProps = e.viewProps;
                        const t = this.view.element;
                        this.blade.value("positions").emitter.on("change", (() => {
                            ["veryfirst", "first", "last", "verylast"].forEach((e => {
                                t.classList.remove(P(void 0, D[e]))
                            })), this.blade.get("positions").forEach((e => {
                                t.classList.add(P(void 0, D[e]))
                            }))
                        })), this.viewProps.handleDispose((() => {
                            ! function(e) {
                                e && e.parentElement && e.parentElement.removeChild(e)
                            }(t)
                        }))
                    }
                    get parent() {
                        return this.parent_
                    }
                }
                const L = "http://www.w3.org/2000/svg";

                function I(e) {
                    e.offsetHeight
                }

                function F(e) {
                    return void 0 !== e.ontouchstart
                }

                function N() {
                    return new Function("return this")().document
                }
                const U = {
                    check: '<path d="M2 8l4 4l8 -8"/>',
                    dropdown: '<path d="M5 7h6l-3 3 z"/>',
                    p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
                };

                function B(e, t) {
                    const n = e.createElementNS(L, "svg");
                    return n.innerHTML = U[t], n
                }

                function j(e, t, n) {
                    e.insertBefore(t, e.children[n])
                }

                function z(e) {
                    e.parentElement && e.parentElement.removeChild(e)
                }

                function V(e) {
                    for (; e.children.length > 0;) e.removeChild(e.children[0])
                }

                function G(e) {
                    return e.relatedTarget ? e.relatedTarget : "explicitOriginalTarget" in e ? e.explicitOriginalTarget : null
                }
                const H = f("lbl");
                class W {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(H()), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("div");
                        n.classList.add(H("l")), g(t.props, "label", (t => {
                            o(t) ? this.element.classList.add(H(void 0, "nol")) : (this.element.classList.remove(H(void 0, "nol")), function(e) {
                                for (; e.childNodes.length > 0;) e.removeChild(e.childNodes[0])
                            }(n), n.appendChild(function(e, t) {
                                const n = e.createDocumentFragment();
                                return t.split("\n").map((t => e.createTextNode(t))).forEach(((t, r) => {
                                    r > 0 && n.appendChild(e.createElement("br")), n.appendChild(t)
                                })), n
                            }(e, t)))
                        })), this.element.appendChild(n), this.labelElement = n;
                        const r = e.createElement("div");
                        r.classList.add(H("v")), this.element.appendChild(r), this.valueElement = r
                    }
                }
                class K extends O {
                    constructor(e, t) {
                        const n = t.valueController.viewProps;
                        super(Object.assign(Object.assign({}, t), {
                            view: new W(e, {
                                props: t.props,
                                viewProps: n
                            }),
                            viewProps: n
                        })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
                    }
                }
                const X = {
                    id: "button",
                    type: "blade",
                    accept(e) {
                        const t = R,
                            n = k(e, {
                                title: t.required.string,
                                view: t.required.constant("button"),
                                label: t.optional.string
                            });
                        return n ? {
                            params: n
                        } : null
                    },
                    controller: e => new K(e.document, {
                        blade: e.blade,
                        props: E.fromObject({
                            label: e.params.label
                        }),
                        valueController: new w(e.document, {
                            props: E.fromObject({
                                title: e.params.title
                            }),
                            viewProps: e.viewProps
                        })
                    }),
                    api: e => e.controller instanceof K && e.controller.valueController instanceof w ? new p(e.controller) : null
                };
                class q extends O {
                    constructor(e) {
                        super(e), this.value = e.value
                    }
                }

                function Y() {
                    return new E({
                        positions: T([], {
                            equals: a
                        })
                    })
                }
                class Z extends E {
                    constructor(e) {
                        super(e)
                    }
                    static create(e) {
                        const t = {
                                completed: !0,
                                expanded: e,
                                expandedHeight: null,
                                shouldFixHeight: !1,
                                temporaryExpanded: null
                            },
                            n = E.createCore(t);
                        return new Z(n)
                    }
                    get styleExpanded() {
                        var e;
                        return null !== (e = this.get("temporaryExpanded")) && void 0 !== e ? e : this.get("expanded")
                    }
                    get styleHeight() {
                        if (!this.styleExpanded) return "0";
                        const e = this.get("expandedHeight");
                        return this.get("shouldFixHeight") && !o(e) ? `${e}px` : "auto"
                    }
                    bindExpandedClass(e, t) {
                        const n = () => {
                            this.styleExpanded ? e.classList.add(t) : e.classList.remove(t)
                        };
                        g(this, "expanded", n), g(this, "temporaryExpanded", n)
                    }
                    cleanUpTransition() {
                        this.set("shouldFixHeight", !1), this.set("expandedHeight", null), this.set("completed", !0)
                    }
                }

                function J(e, t) {
                    t.style.height = e.styleHeight
                }

                function $(e, t) {
                    e.value("expanded").emitter.on("beforechange", (() => {
                        e.set("completed", !1), o(e.get("expandedHeight")) && e.set("expandedHeight", function(e, t) {
                            let n = 0;
                            return function(e, t) {
                                const n = e.style.transition;
                                e.style.transition = "none", t(), e.style.transition = n
                            }(t, (() => {
                                e.set("expandedHeight", null), e.set("temporaryExpanded", !0), I(t), n = t.clientHeight, e.set("temporaryExpanded", null), I(t)
                            })), n
                        }(e, t)), e.set("shouldFixHeight", !0), I(t)
                    })), e.emitter.on("change", (() => {
                        J(e, t)
                    })), J(e, t), t.addEventListener("transitionend", (t => {
                        "height" === t.propertyName && e.cleanUpTransition()
                    }))
                }
                class Q extends t {
                    constructor(e, t) {
                        super(e), this.rackApi_ = t
                    }
                }
                class ee {
                    constructor(e) {
                        this.emitter = new h, this.items_ = [], this.cache_ = new Set, this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = e
                    }
                    get items() {
                        return this.items_
                    }
                    allItems() {
                        return Array.from(this.cache_)
                    }
                    find(e) {
                        for (const t of this.allItems())
                            if (e(t)) return t;
                        return null
                    }
                    includes(e) {
                        return this.cache_.has(e)
                    }
                    add(e, t) {
                        if (this.includes(e)) throw c.shouldNeverHappen();
                        const n = void 0 !== t ? t : this.items_.length;
                        this.items_.splice(n, 0, e), this.cache_.add(e);
                        const r = this.extract_(e);
                        r && (r.emitter.on("add", this.onSubListAdd_), r.emitter.on("remove", this.onSubListRemove_), r.allItems().forEach((e => {
                            this.cache_.add(e)
                        }))), this.emitter.emit("add", {
                            index: n,
                            item: e,
                            root: this,
                            target: this
                        })
                    }
                    remove(e) {
                        const t = this.items_.indexOf(e);
                        if (t < 0) return;
                        this.items_.splice(t, 1), this.cache_.delete(e);
                        const n = this.extract_(e);
                        n && (n.emitter.off("add", this.onSubListAdd_), n.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
                            index: t,
                            item: e,
                            root: this,
                            target: this
                        })
                    }
                    onSubListAdd_(e) {
                        this.cache_.add(e.item), this.emitter.emit("add", {
                            index: e.index,
                            item: e.item,
                            root: this,
                            target: e.target
                        })
                    }
                    onSubListRemove_(e) {
                        this.cache_.delete(e.item), this.emitter.emit("remove", {
                            index: e.index,
                            item: e.item,
                            root: this,
                            target: e.target
                        })
                    }
                }
                class te extends t {
                    constructor(e) {
                        super(e), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new h, this.controller_.binding.emitter.on("change", this.onBindingChange_)
                    }
                    get label() {
                        return this.controller_.props.get("label")
                    }
                    set label(e) {
                        this.controller_.props.set("label", e)
                    }
                    on(e, t) {
                        const n = t.bind(this);
                        return this.emitter_.on(e, (e => {
                            n(e.event)
                        })), this
                    }
                    refresh() {
                        this.controller_.binding.read()
                    }
                    onBindingChange_(e) {
                        const t = e.sender.target.read();
                        this.emitter_.emit("change", {
                            event: new r(this, t, this.controller_.binding.target.presetKey, e.options.last)
                        })
                    }
                }
                class ne extends K {
                    constructor(e, t) {
                        super(e, t), this.binding = t.binding
                    }
                }
                class re extends t {
                    constructor(e) {
                        super(e), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new h, this.controller_.binding.emitter.on("update", this.onBindingUpdate_)
                    }
                    get label() {
                        return this.controller_.props.get("label")
                    }
                    set label(e) {
                        this.controller_.props.set("label", e)
                    }
                    on(e, t) {
                        const n = t.bind(this);
                        return this.emitter_.on(e, (e => {
                            n(e.event)
                        })), this
                    }
                    refresh() {
                        this.controller_.binding.read()
                    }
                    onBindingUpdate_(e) {
                        const t = e.sender.target.read();
                        this.emitter_.emit("update", {
                            event: new i(this, t, this.controller_.binding.target.presetKey)
                        })
                    }
                }
                class ie extends K {
                    constructor(e, t) {
                        super(e, t), this.binding = t.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose((() => {
                            this.binding.dispose()
                        }))
                    }
                }

                function se(e) {
                    return e instanceof le ? e.apiSet_ : e instanceof Q ? e.rackApi_.apiSet_ : null
                }

                function oe(e, t) {
                    const n = e.find((e => e.controller_ === t));
                    if (!n) throw c.shouldNeverHappen();
                    return n
                }

                function ae(e, t, n) {
                    if (!u.isBindable(e)) throw c.notBindable();
                    return new u(e, t, n)
                }
                class le extends t {
                    constructor(e, t) {
                        super(e), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new h, this.apiSet_ = new ee(se), this.pool_ = t;
                        const n = this.controller_.rack;
                        n.emitter.on("add", this.onRackAdd_), n.emitter.on("remove", this.onRackRemove_), n.emitter.on("inputchange", this.onRackInputChange_), n.emitter.on("monitorupdate", this.onRackMonitorUpdate_), n.children.forEach((e => {
                            this.setUpApi_(e)
                        }))
                    }
                    get children() {
                        return this.controller_.rack.children.map((e => oe(this.apiSet_, e)))
                    }
                    addInput(e, t, n) {
                        const r = n || {},
                            i = this.controller_.view.element.ownerDocument,
                            s = this.pool_.createInput(i, ae(e, t, r.presetKey), r),
                            o = new te(s);
                        return this.add(o, r.index)
                    }
                    addMonitor(e, t, n) {
                        const r = n || {},
                            i = this.controller_.view.element.ownerDocument,
                            s = this.pool_.createMonitor(i, ae(e, t), r),
                            o = new re(s);
                        return this.add(o, r.index)
                    }
                    addFolder(e) {
                        return function(e, t) {
                            return e.addBlade(Object.assign(Object.assign({}, t), {
                                view: "folder"
                            }))
                        }(this, e)
                    }
                    addButton(e) {
                        return function(e, t) {
                            return e.addBlade(Object.assign(Object.assign({}, t), {
                                view: "button"
                            }))
                        }(this, e)
                    }
                    addSeparator(e) {
                        return function(e, t) {
                            const n = t || {};
                            return e.addBlade(Object.assign(Object.assign({}, n), {
                                view: "separator"
                            }))
                        }(this, e)
                    }
                    addTab(e) {
                        return function(e, t) {
                            return e.addBlade(Object.assign(Object.assign({}, t), {
                                view: "tab"
                            }))
                        }(this, e)
                    }
                    add(e, t) {
                        this.controller_.rack.add(e.controller_, t);
                        const n = this.apiSet_.find((t => t.controller_ === e.controller_));
                        return n && this.apiSet_.remove(n), this.apiSet_.add(e), e
                    }
                    remove(e) {
                        this.controller_.rack.remove(e.controller_)
                    }
                    addBlade(e) {
                        const t = this.controller_.view.element.ownerDocument,
                            n = this.pool_.createBlade(t, e),
                            r = this.pool_.createBladeApi(n);
                        return this.add(r, e.index)
                    }
                    on(e, t) {
                        const n = t.bind(this);
                        return this.emitter_.on(e, (e => {
                            n(e.event)
                        })), this
                    }
                    setUpApi_(e) {
                        this.apiSet_.find((t => t.controller_ === e)) || this.apiSet_.add(this.pool_.createBladeApi(e))
                    }
                    onRackAdd_(e) {
                        this.setUpApi_(e.bladeController)
                    }
                    onRackRemove_(e) {
                        if (e.isRoot) {
                            const t = oe(this.apiSet_, e.bladeController);
                            this.apiSet_.remove(t)
                        }
                    }
                    onRackInputChange_(e) {
                        const t = e.bladeController;
                        if (t instanceof ne) {
                            const n = oe(this.apiSet_, t),
                                i = t.binding;
                            this.emitter_.emit("change", {
                                event: new r(n, i.target.read(), i.target.presetKey, e.options.last)
                            })
                        } else if (t instanceof q) {
                            const n = oe(this.apiSet_, t);
                            this.emitter_.emit("change", {
                                event: new r(n, t.value.rawValue, void 0, e.options.last)
                            })
                        }
                    }
                    onRackMonitorUpdate_(e) {
                        if (!(e.bladeController instanceof ie)) throw c.shouldNeverHappen();
                        const t = oe(this.apiSet_, e.bladeController),
                            n = e.bladeController.binding;
                        this.emitter_.emit("update", {
                            event: new i(t, n.target.read(), n.target.presetKey)
                        })
                    }
                }
                class ce extends Q {
                    constructor(e, t) {
                        super(e, new le(e.rackController, t)), this.emitter_ = new h, this.controller_.foldable.value("expanded").emitter.on("change", (e => {
                            this.emitter_.emit("fold", {
                                event: new s(this, e.sender.rawValue)
                            })
                        })), this.rackApi_.on("change", (e => {
                            this.emitter_.emit("change", {
                                event: e
                            })
                        })), this.rackApi_.on("update", (e => {
                            this.emitter_.emit("update", {
                                event: e
                            })
                        }))
                    }
                    get expanded() {
                        return this.controller_.foldable.get("expanded")
                    }
                    set expanded(e) {
                        this.controller_.foldable.set("expanded", e)
                    }
                    get title() {
                        return this.controller_.props.get("title")
                    }
                    set title(e) {
                        this.controller_.props.set("title", e)
                    }
                    get children() {
                        return this.rackApi_.children
                    }
                    addInput(e, t, n) {
                        return this.rackApi_.addInput(e, t, n)
                    }
                    addMonitor(e, t, n) {
                        return this.rackApi_.addMonitor(e, t, n)
                    }
                    addFolder(e) {
                        return this.rackApi_.addFolder(e)
                    }
                    addButton(e) {
                        return this.rackApi_.addButton(e)
                    }
                    addSeparator(e) {
                        return this.rackApi_.addSeparator(e)
                    }
                    addTab(e) {
                        return this.rackApi_.addTab(e)
                    }
                    add(e, t) {
                        return this.rackApi_.add(e, t)
                    }
                    remove(e) {
                        this.rackApi_.remove(e)
                    }
                    addBlade(e) {
                        return this.rackApi_.addBlade(e)
                    }
                    on(e, t) {
                        const n = t.bind(this);
                        return this.emitter_.on(e, (e => {
                            n(e.event)
                        })), this
                    }
                }
                class ue extends O {
                    constructor(e) {
                        super({
                            blade: e.blade,
                            view: e.view,
                            viewProps: e.rackController.viewProps
                        }), this.rackController = e.rackController
                    }
                }
                class pe {
                    constructor(e, t) {
                        const n = f(t.viewName);
                        this.element = e.createElement("div"), this.element.classList.add(n()), t.viewProps.bindClassModifiers(this.element)
                    }
                }

                function he(e) {
                    return e instanceof _e ? e.rack : e instanceof ue ? e.rackController.rack : null
                }

                function de(e) {
                    const t = he(e);
                    return t ? t.bcSet_ : null
                }
                class fe {
                    constructor(e) {
                        var t;
                        this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new h, this.blade_ = null != e ? e : null, null === (t = this.blade_) || void 0 === t || t.value("positions").emitter.on("change", this.onBladePositionsChange_), this.bcSet_ = new ee(de), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_)
                    }
                    get children() {
                        return this.bcSet_.items
                    }
                    add(e, t) {
                        e.parent && e.parent.remove(e), e.parent_ = this, this.bcSet_.add(e, t)
                    }
                    remove(e) {
                        e.parent_ = null, this.bcSet_.remove(e)
                    }
                    find(e) {
                        return this.bcSet_.allItems().filter((t => t instanceof e))
                    }
                    onSetAdd_(e) {
                        this.updatePositions_();
                        const t = e.target === e.root;
                        if (this.emitter.emit("add", {
                                bladeController: e.item,
                                index: e.index,
                                isRoot: t,
                                sender: this
                            }), !t) return;
                        const n = e.item;
                        if (n.viewProps.emitter.on("change", this.onChildViewPropsChange_), n.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), n.viewProps.handleDispose(this.onChildDispose_), n instanceof ne) n.binding.emitter.on("change", this.onChildInputChange_);
                        else if (n instanceof ie) n.binding.emitter.on("update", this.onChildMonitorUpdate_);
                        else if (n instanceof q) n.value.emitter.on("change", this.onChildValueChange_);
                        else {
                            const e = he(n);
                            if (e) {
                                const t = e.emitter;
                                t.on("layout", this.onDescendantLayout_), t.on("inputchange", this.onDescendantInputChange_), t.on("monitorupdate", this.onDescendantMonitorUpdate_)
                            }
                        }
                    }
                    onSetRemove_(e) {
                        this.updatePositions_();
                        const t = e.target === e.root;
                        if (this.emitter.emit("remove", {
                                bladeController: e.item,
                                isRoot: t,
                                sender: this
                            }), !t) return;
                        const n = e.item;
                        if (n instanceof ne) n.binding.emitter.off("change", this.onChildInputChange_);
                        else if (n instanceof ie) n.binding.emitter.off("update", this.onChildMonitorUpdate_);
                        else if (n instanceof q) n.value.emitter.off("change", this.onChildValueChange_);
                        else {
                            const e = he(n);
                            if (e) {
                                const t = e.emitter;
                                t.off("layout", this.onDescendantLayout_), t.off("inputchange", this.onDescendantInputChange_), t.off("monitorupdate", this.onDescendantMonitorUpdate_)
                            }
                        }
                    }
                    updatePositions_() {
                        const e = this.bcSet_.items.filter((e => !e.viewProps.get("hidden"))),
                            t = e[0],
                            n = e[e.length - 1];
                        this.bcSet_.items.forEach((e => {
                            const r = [];
                            e === t && (r.push("first"), this.blade_ && !this.blade_.get("positions").includes("veryfirst") || r.push("veryfirst")), e === n && (r.push("last"), this.blade_ && !this.blade_.get("positions").includes("verylast") || r.push("verylast")), e.blade.set("positions", r)
                        }))
                    }
                    onChildPositionsChange_() {
                        this.updatePositions_(), this.emitter.emit("layout", {
                            sender: this
                        })
                    }
                    onChildViewPropsChange_(e) {
                        this.updatePositions_(), this.emitter.emit("layout", {
                            sender: this
                        })
                    }
                    onChildDispose_() {
                        this.bcSet_.items.filter((e => e.viewProps.get("disposed"))).forEach((e => {
                            this.bcSet_.remove(e)
                        }))
                    }
                    onChildInputChange_(e) {
                        const t = function(e, t) {
                            for (let n = 0; n < e.length; n++) {
                                const r = e[n];
                                if (r instanceof ne && r.binding === t) return r
                            }
                            return null
                        }(this.find(ne), e.sender);
                        if (!t) throw c.shouldNeverHappen();
                        this.emitter.emit("inputchange", {
                            bladeController: t,
                            options: e.options,
                            sender: this
                        })
                    }
                    onChildMonitorUpdate_(e) {
                        const t = function(e, t) {
                            for (let n = 0; n < e.length; n++) {
                                const r = e[n];
                                if (r instanceof ie && r.binding === t) return r
                            }
                            return null
                        }(this.find(ie), e.sender);
                        if (!t) throw c.shouldNeverHappen();
                        this.emitter.emit("monitorupdate", {
                            bladeController: t,
                            sender: this
                        })
                    }
                    onChildValueChange_(e) {
                        const t = function(e, t) {
                            for (let n = 0; n < e.length; n++) {
                                const r = e[n];
                                if (r instanceof q && r.value === t) return r
                            }
                            return null
                        }(this.find(q), e.sender);
                        if (!t) throw c.shouldNeverHappen();
                        this.emitter.emit("inputchange", {
                            bladeController: t,
                            options: e.options,
                            sender: this
                        })
                    }
                    onDescendantLayout_(e) {
                        this.updatePositions_(), this.emitter.emit("layout", {
                            sender: this
                        })
                    }
                    onDescendantInputChange_(e) {
                        this.emitter.emit("inputchange", {
                            bladeController: e.bladeController,
                            options: e.options,
                            sender: this
                        })
                    }
                    onDescendantMonitorUpdate_(e) {
                        this.emitter.emit("monitorupdate", {
                            bladeController: e.bladeController,
                            sender: this
                        })
                    }
                    onBladePositionsChange_() {
                        this.updatePositions_()
                    }
                }
                class _e extends O {
                    constructor(e, t) {
                        super(Object.assign(Object.assign({}, t), {
                            view: new pe(e, {
                                viewName: "brk",
                                viewProps: t.viewProps
                            })
                        })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
                        const n = new fe(t.root ? void 0 : t.blade);
                        n.emitter.on("add", this.onRackAdd_), n.emitter.on("remove", this.onRackRemove_), this.rack = n, this.viewProps.handleDispose((() => {
                            for (let e = this.rack.children.length - 1; e >= 0; e--) this.rack.children[e].viewProps.set("disposed", !0)
                        }))
                    }
                    onRackAdd_(e) {
                        e.isRoot && j(this.view.element, e.bladeController.view.element, e.index)
                    }
                    onRackRemove_(e) {
                        e.isRoot && z(e.bladeController.view.element)
                    }
                }
                const me = f("cnt");
                class ge {
                    constructor(e, t) {
                        this.className_ = f(t.viewName || "fld"), this.element = e.createElement("div"), this.element.classList.add(this.className_(), me()), t.viewProps.bindClassModifiers(this.element), this.foldable_ = t.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), g(this.foldable_, "completed", v(this.element, this.className_(void 0, "cpl")));
                        const n = e.createElement("button");
                        n.classList.add(this.className_("b")), g(t.props, "title", (e => {
                            o(e) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"))
                        })), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
                        const r = e.createElement("div");
                        r.classList.add(this.className_("t")), b(t.props.value("title"), r), this.buttonElement.appendChild(r), this.titleElement = r;
                        const i = e.createElement("div");
                        i.classList.add(this.className_("m")), this.buttonElement.appendChild(i);
                        const s = t.containerElement;
                        s.classList.add(this.className_("c")), this.element.appendChild(s), this.containerElement = s
                    }
                }
                class ve extends ue {
                    constructor(e, t) {
                        var n;
                        const r = Z.create(null === (n = t.expanded) || void 0 === n || n),
                            i = new _e(e, {
                                blade: t.blade,
                                root: t.root,
                                viewProps: t.viewProps
                            });
                        super(Object.assign(Object.assign({}, t), {
                            rackController: i,
                            view: new ge(e, {
                                containerElement: i.view.element,
                                foldable: r,
                                props: t.props,
                                viewName: t.root ? "rot" : void 0,
                                viewProps: t.viewProps
                            })
                        })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = t.props, this.foldable = r, $(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", (() => {
                            this.foldable.cleanUpTransition()
                        })), this.rackController.rack.emitter.on("remove", (() => {
                            this.foldable.cleanUpTransition()
                        })), this.view.buttonElement.addEventListener("click", this.onTitleClick_)
                    }
                    get document() {
                        return this.view.element.ownerDocument
                    }
                    onTitleClick_() {
                        this.foldable.set("expanded", !this.foldable.get("expanded"))
                    }
                }
                const be = {
                    id: "folder",
                    type: "blade",
                    accept(e) {
                        const t = R,
                            n = k(e, {
                                title: t.required.string,
                                view: t.required.constant("folder"),
                                expanded: t.optional.boolean
                            });
                        return n ? {
                            params: n
                        } : null
                    },
                    controller: e => new ve(e.document, {
                        blade: e.blade,
                        expanded: e.params.expanded,
                        props: E.fromObject({
                            title: e.params.title
                        }),
                        viewProps: e.viewProps
                    }),
                    api: e => e.controller instanceof ve ? new ce(e.controller, e.pool) : null
                };
                class xe extends q {
                    constructor(e, t) {
                        const n = t.valueController.viewProps;
                        super(Object.assign(Object.assign({}, t), {
                            value: t.valueController.value,
                            view: new W(e, {
                                props: t.props,
                                viewProps: n
                            }),
                            viewProps: n
                        })), this.props = t.props, this.valueController = t.valueController, this.view.valueElement.appendChild(this.valueController.view.element)
                    }
                }
                class ye extends t {}
                const we = f("spr");
                class Se {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(we()), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("hr");
                        n.classList.add(we("r")), this.element.appendChild(n)
                    }
                }
                class Me extends O {
                    constructor(e, t) {
                        super(Object.assign(Object.assign({}, t), {
                            view: new Se(e, {
                                viewProps: t.viewProps
                            })
                        }))
                    }
                }
                const Te = {
                        id: "separator",
                        type: "blade",
                        accept(e) {
                            const t = k(e, {
                                view: R.required.constant("separator")
                            });
                            return t ? {
                                params: t
                            } : null
                        },
                        controller: e => new Me(e.document, {
                            blade: e.blade,
                            viewProps: e.viewProps
                        }),
                        api: e => e.controller instanceof Me ? new ye(e.controller) : null
                    },
                    Ee = f("");

                function Ae(e, t) {
                    return v(e, Ee(void 0, t))
                }
                class Ce extends E {
                    constructor(e) {
                        super(e)
                    }
                    static create(e) {
                        var t, n;
                        const r = null != e ? e : {},
                            i = {
                                disabled: null !== (t = r.disabled) && void 0 !== t && t,
                                disposed: !1,
                                hidden: null !== (n = r.hidden) && void 0 !== n && n
                            },
                            s = E.createCore(i);
                        return new Ce(s)
                    }
                    bindClassModifiers(e) {
                        g(this, "disabled", Ae(e, "disabled")), g(this, "hidden", Ae(e, "hidden"))
                    }
                    bindDisabled(e) {
                        g(this, "disabled", (t => {
                            e.disabled = t
                        }))
                    }
                    bindTabIndex(e) {
                        g(this, "disabled", (t => {
                            e.tabIndex = t ? -1 : 0
                        }))
                    }
                    handleDispose(e) {
                        this.value("disposed").emitter.on("change", (t => {
                            t && e()
                        }))
                    }
                }
                const Re = f("tbi");
                class ke {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(Re()), t.viewProps.bindClassModifiers(this.element), g(t.props, "selected", (e => {
                            e ? this.element.classList.add(Re(void 0, "sel")) : this.element.classList.remove(Re(void 0, "sel"))
                        }));
                        const n = e.createElement("button");
                        n.classList.add(Re("b")), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.buttonElement = n;
                        const r = e.createElement("div");
                        r.classList.add(Re("t")), b(t.props.value("title"), r), this.buttonElement.appendChild(r), this.titleElement = r
                    }
                }
                class Pe {
                    constructor(e, t) {
                        this.emitter = new h, this.onClick_ = this.onClick_.bind(this), this.props = t.props, this.viewProps = t.viewProps, this.view = new ke(e, {
                            props: t.props,
                            viewProps: t.viewProps
                        }), this.view.buttonElement.addEventListener("click", this.onClick_)
                    }
                    onClick_() {
                        this.emitter.emit("click", {
                            sender: this
                        })
                    }
                }
                class De {
                    constructor(e, t) {
                        this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new Pe(e, {
                            props: t.itemProps,
                            viewProps: Ce.create()
                        }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new _e(e, {
                            blade: Y(),
                            viewProps: Ce.create()
                        }), this.props = t.props, g(this.props, "selected", (e => {
                            this.itemController.props.set("selected", e), this.contentController.viewProps.set("hidden", !e)
                        }))
                    }
                    get itemController() {
                        return this.ic_
                    }
                    get contentController() {
                        return this.cc_
                    }
                    onItemClick_() {
                        this.props.set("selected", !0)
                    }
                }
                class Oe {
                    constructor(e, t) {
                        this.controller_ = e, this.rackApi_ = t
                    }
                    get title() {
                        var e;
                        return null !== (e = this.controller_.itemController.props.get("title")) && void 0 !== e ? e : ""
                    }
                    set title(e) {
                        this.controller_.itemController.props.set("title", e)
                    }
                    get selected() {
                        return this.controller_.props.get("selected")
                    }
                    set selected(e) {
                        this.controller_.props.set("selected", e)
                    }
                    get children() {
                        return this.rackApi_.children
                    }
                    addButton(e) {
                        return this.rackApi_.addButton(e)
                    }
                    addFolder(e) {
                        return this.rackApi_.addFolder(e)
                    }
                    addSeparator(e) {
                        return this.rackApi_.addSeparator(e)
                    }
                    addTab(e) {
                        return this.rackApi_.addTab(e)
                    }
                    add(e, t) {
                        this.rackApi_.add(e, t)
                    }
                    remove(e) {
                        this.rackApi_.remove(e)
                    }
                    addInput(e, t, n) {
                        return this.rackApi_.addInput(e, t, n)
                    }
                    addMonitor(e, t, n) {
                        return this.rackApi_.addMonitor(e, t, n)
                    }
                    addBlade(e) {
                        return this.rackApi_.addBlade(e)
                    }
                }
                class Le extends Q {
                    constructor(e, t) {
                        super(e, new le(e.rackController, t)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.emitter_ = new h, this.pageApiMap_ = new Map, this.rackApi_.on("change", (e => {
                            this.emitter_.emit("change", {
                                event: e
                            })
                        })), this.rackApi_.on("update", (e => {
                            this.emitter_.emit("update", {
                                event: e
                            })
                        })), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((e => {
                            this.setUpPageApi_(e)
                        }))
                    }
                    get pages() {
                        return this.controller_.pageSet.items.map((e => {
                            const t = this.pageApiMap_.get(e);
                            if (!t) throw c.shouldNeverHappen();
                            return t
                        }))
                    }
                    addPage(e) {
                        const t = this.controller_.view.element.ownerDocument,
                            n = new De(t, {
                                itemProps: E.fromObject({
                                    selected: !1,
                                    title: e.title
                                }),
                                props: E.fromObject({
                                    selected: !1
                                })
                            });
                        this.controller_.add(n, e.index);
                        const r = this.pageApiMap_.get(n);
                        if (!r) throw c.shouldNeverHappen();
                        return r
                    }
                    removePage(e) {
                        this.controller_.remove(e)
                    }
                    on(e, t) {
                        const n = t.bind(this);
                        return this.emitter_.on(e, (e => {
                            n(e.event)
                        })), this
                    }
                    setUpPageApi_(e) {
                        const t = this.rackApi_.apiSet_.find((t => t.controller_ === e.contentController));
                        if (!t) throw c.shouldNeverHappen();
                        const n = new Oe(e, t);
                        this.pageApiMap_.set(e, n)
                    }
                    onPageAdd_(e) {
                        this.setUpPageApi_(e.item)
                    }
                    onPageRemove_(e) {
                        if (!this.pageApiMap_.get(e.item)) throw c.shouldNeverHappen();
                        this.pageApiMap_.delete(e.item)
                    }
                }
                const Ie = f("tab");
                class Fe {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(Ie(), me()), t.viewProps.bindClassModifiers(this.element), m(t.empty, v(this.element, Ie(void 0, "nop")));
                        const n = e.createElement("div");
                        n.classList.add(Ie("i")), this.element.appendChild(n), this.itemsElement = n;
                        const r = t.contentsElement;
                        r.classList.add(Ie("c")), this.element.appendChild(r), this.contentsElement = r
                    }
                }
                class Ne extends ue {
                    constructor(e, t) {
                        const n = new _e(e, {
                                blade: t.blade,
                                viewProps: t.viewProps
                            }),
                            r = T(!0);
                        super({
                            blade: t.blade,
                            rackController: n,
                            view: new Fe(e, {
                                contentsElement: n.view.element,
                                empty: r,
                                viewProps: t.viewProps
                            })
                        }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onPageSelectedChange_ = this.onPageSelectedChange_.bind(this), this.pageSet_ = new ee((() => null)), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.empty_ = r, this.applyPages_()
                    }
                    get pageSet() {
                        return this.pageSet_
                    }
                    add(e, t) {
                        this.pageSet_.add(e, null != t ? t : this.pageSet_.items.length)
                    }
                    remove(e) {
                        this.pageSet_.remove(this.pageSet_.items[e])
                    }
                    applyPages_() {
                        this.keepSelection_(), this.empty_.rawValue = 0 === this.pageSet_.items.length
                    }
                    onPageAdd_(e) {
                        const t = e.item;
                        j(this.view.itemsElement, t.itemController.view.element, e.index), this.rackController.rack.add(t.contentController, e.index), t.props.value("selected").emitter.on("change", this.onPageSelectedChange_), this.applyPages_()
                    }
                    onPageRemove_(e) {
                        const t = e.item;
                        z(t.itemController.view.element), this.rackController.rack.remove(t.contentController), t.props.value("selected").emitter.off("change", this.onPageSelectedChange_), this.applyPages_()
                    }
                    keepSelection_() {
                        if (0 === this.pageSet_.items.length) return;
                        const e = this.pageSet_.items.findIndex((e => e.props.get("selected")));
                        e < 0 ? this.pageSet_.items.forEach(((e, t) => {
                            e.props.set("selected", 0 === t)
                        })) : this.pageSet_.items.forEach(((t, n) => {
                            t.props.set("selected", n === e)
                        }))
                    }
                    onPageSelectedChange_(e) {
                        if (e.rawValue) {
                            const t = this.pageSet_.items.findIndex((t => t.props.value("selected") === e.sender));
                            this.pageSet_.items.forEach(((e, n) => {
                                e.props.set("selected", n === t)
                            }))
                        } else this.keepSelection_()
                    }
                }
                const Ue = {
                    id: "tab",
                    type: "blade",
                    accept(e) {
                        const t = R,
                            n = k(e, {
                                pages: t.required.array(t.required.object({
                                    title: t.required.string
                                })),
                                view: t.required.constant("tab")
                            });
                        return n && 0 !== n.pages.length ? {
                            params: n
                        } : null
                    },
                    controller(e) {
                        const t = new Ne(e.document, {
                            blade: e.blade,
                            viewProps: e.viewProps
                        });
                        return e.params.pages.forEach((n => {
                            const r = new De(e.document, {
                                itemProps: E.fromObject({
                                    selected: !1,
                                    title: n.title
                                }),
                                props: E.fromObject({
                                    selected: !1
                                })
                            });
                            t.add(r)
                        })), t
                    },
                    api: e => e.controller instanceof Ne ? new Le(e.controller, e.pool) : null
                };
                class Be {
                    constructor() {
                        this.disabled = !1, this.emitter = new h
                    }
                    dispose() {}
                    tick() {
                        this.disabled || this.emitter.emit("tick", {
                            sender: this
                        })
                    }
                }
                class je {
                    constructor(e, t) {
                        this.disabled_ = !1, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = e, this.emitter = new h, this.interval_ = t, this.setTimer_()
                    }
                    get disabled() {
                        return this.disabled_
                    }
                    set disabled(e) {
                        this.disabled_ = e, this.disabled_ ? this.clearTimer_() : this.setTimer_()
                    }
                    dispose() {
                        this.clearTimer_()
                    }
                    clearTimer_() {
                        if (null === this.timerId_) return;
                        const e = this.doc_.defaultView;
                        e && e.clearInterval(this.timerId_), this.timerId_ = null
                    }
                    setTimer_() {
                        if (this.clearTimer_(), this.interval_ <= 0) return;
                        const e = this.doc_.defaultView;
                        e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_))
                    }
                    onTick_() {
                        this.disabled_ || this.emitter.emit("tick", {
                            sender: this
                        })
                    }
                }
                class ze {
                    constructor(e) {
                        this.constraints = e
                    }
                    constrain(e) {
                        return this.constraints.reduce(((e, t) => t.constrain(e)), e)
                    }
                }

                function Ve(e, t) {
                    if (e instanceof t) return e;
                    if (e instanceof ze) {
                        const n = e.constraints.reduce(((e, n) => e || (n instanceof t ? n : null)), null);
                        if (n) return n
                    }
                    return null
                }
                class Ge {
                    constructor(e) {
                        this.options = e
                    }
                    constrain(e) {
                        const t = this.options;
                        return 0 === t.length || t.filter((t => t.value === e)).length > 0 ? e : t[0].value
                    }
                }
                class He {
                    constructor(e) {
                        this.maxValue = e.max, this.minValue = e.min
                    }
                    constrain(e) {
                        let t = e;
                        return o(this.minValue) || (t = Math.max(t, this.minValue)), o(this.maxValue) || (t = Math.min(t, this.maxValue)), t
                    }
                }
                class We {
                    constructor(e) {
                        this.step = e
                    }
                    constrain(e) {
                        return (e < 0 ? -Math.round(-e / this.step) : Math.round(e / this.step)) * this.step
                    }
                }
                const Ke = f("lst");
                class Xe {
                    constructor(e, t) {
                        this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = t.props, this.element = e.createElement("div"), this.element.classList.add(Ke()), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("select");
                        n.classList.add(Ke("s")), g(this.props_, "options", (t => {
                            V(n), t.forEach(((t, r) => {
                                const i = e.createElement("option");
                                i.dataset.index = String(r), i.textContent = t.text, i.value = String(t.value), n.appendChild(i)
                            }))
                        })), t.viewProps.bindDisabled(n), this.element.appendChild(n), this.selectElement = n;
                        const r = e.createElement("div");
                        r.classList.add(Ke("m")), r.appendChild(B(e, "dropdown")), this.element.appendChild(r), t.value.emitter.on("change", this.onValueChange_), this.value_ = t.value, this.update_()
                    }
                    update_() {
                        this.selectElement.value = String(this.value_.rawValue)
                    }
                    onValueChange_() {
                        this.update_()
                    }
                }
                class qe {
                    constructor(e, t) {
                        this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new Xe(e, {
                            props: this.props,
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.view.selectElement.addEventListener("change", this.onSelectChange_)
                    }
                    onSelectChange_(e) {
                        const t = e.currentTarget.selectedOptions.item(0);
                        if (!t) return;
                        const n = Number(t.dataset.index);
                        this.value.rawValue = this.props.get("options")[n].value
                    }
                }
                const Ye = f("pop");
                class Ze {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(Ye()), t.viewProps.bindClassModifiers(this.element), m(t.shows, v(this.element, Ye(void 0, "v")))
                    }
                }
                class Je {
                    constructor(e, t) {
                        this.shows = T(!1), this.viewProps = t.viewProps, this.view = new Ze(e, {
                            shows: this.shows,
                            viewProps: this.viewProps
                        })
                    }
                }
                const $e = f("txt");
                class Qe {
                    constructor(e, t) {
                        this.onChange_ = this.onChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add($e()), t.viewProps.bindClassModifiers(this.element), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_);
                        const n = e.createElement("input");
                        n.classList.add($e("i")), n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, t.value.emitter.on("change", this.onChange_), this.value_ = t.value, this.refresh()
                    }
                    refresh() {
                        const e = this.props_.get("formatter");
                        this.inputElement.value = e(this.value_.rawValue)
                    }
                    onChange_() {
                        this.refresh()
                    }
                }
                class et {
                    constructor(e, t) {
                        this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.view = new Qe(e, {
                            props: t.props,
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.view.inputElement.addEventListener("change", this.onInputChange_)
                    }
                    onInputChange_(e) {
                        const t = e.currentTarget.value,
                            n = this.parser_(t);
                        o(n) || (this.value.rawValue = n), this.view.refresh()
                    }
                }

                function tt(e) {
                    return "false" !== e && !!e
                }

                function nt(e) {
                    return function(e) {
                        return String(e)
                    }(e)
                }
                class rt {
                    constructor(e) {
                        this.text = e
                    }
                    evaluate() {
                        return Number(this.text)
                    }
                    toString() {
                        return this.text
                    }
                }
                const it = {
                    "**": (e, t) => Math.pow(e, t),
                    "*": (e, t) => e * t,
                    "/": (e, t) => e / t,
                    "%": (e, t) => e % t,
                    "+": (e, t) => e + t,
                    "-": (e, t) => e - t,
                    "<<": (e, t) => e << t,
                    ">>": (e, t) => e >> t,
                    ">>>": (e, t) => e >>> t,
                    "&": (e, t) => e & t,
                    "^": (e, t) => e ^ t,
                    "|": (e, t) => e | t
                };
                class st {
                    constructor(e, t, n) {
                        this.left = t, this.operator = e, this.right = n
                    }
                    evaluate() {
                        const e = it[this.operator];
                        if (!e) throw new Error(`unexpected binary operator: '${this.operator}`);
                        return e(this.left.evaluate(), this.right.evaluate())
                    }
                    toString() {
                        return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
                    }
                }
                const ot = {
                    "+": e => e,
                    "-": e => -e,
                    "~": e => ~e
                };
                class at {
                    constructor(e, t) {
                        this.operator = e, this.expression = t
                    }
                    evaluate() {
                        const e = ot[this.operator];
                        if (!e) throw new Error(`unexpected unary operator: '${this.operator}`);
                        return e(this.expression.evaluate())
                    }
                    toString() {
                        return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
                    }
                }

                function lt(e) {
                    return (t, n) => {
                        for (let r = 0; r < e.length; r++) {
                            const i = e[r](t, n);
                            if ("" !== i) return i
                        }
                        return ""
                    }
                }

                function ct(e, t) {
                    var n;
                    const r = e.substr(t).match(/^\s+/);
                    return null !== (n = r && r[0]) && void 0 !== n ? n : ""
                }

                function ut(e, t) {
                    var n;
                    const r = e.substr(t).match(/^[0-9]+/);
                    return null !== (n = r && r[0]) && void 0 !== n ? n : ""
                }

                function pt(e, t) {
                    const n = e.substr(t, 1);
                    if (t += 1, "e" !== n.toLowerCase()) return "";
                    const r = function(e, t) {
                        const n = ut(e, t);
                        if ("" !== n) return n;
                        const r = e.substr(t, 1);
                        if ("-" !== r && "+" !== r) return "";
                        const i = ut(e, t += 1);
                        return "" === i ? "" : r + i
                    }(e, t);
                    return "" === r ? "" : n + r
                }

                function ht(e, t) {
                    const n = e.substr(t, 1);
                    if ("0" === n) return n;
                    const r = function(e, t) {
                        const n = e.substr(t, 1);
                        return n.match(/^[1-9]$/) ? n : ""
                    }(e, t);
                    return t += r.length, "" === r ? "" : r + ut(e, t)
                }
                const dt = lt([function(e, t) {
                    const n = ht(e, t);
                    if (t += n.length, "" === n) return "";
                    const r = e.substr(t, 1);
                    if (t += r.length, "." !== r) return "";
                    const i = ut(e, t);
                    return n + r + i + pt(e, t += i.length)
                }, function(e, t) {
                    const n = e.substr(t, 1);
                    if (t += n.length, "." !== n) return "";
                    const r = ut(e, t);
                    return t += r.length, "" === r ? "" : n + r + pt(e, t)
                }, function(e, t) {
                    const n = ht(e, t);
                    return t += n.length, "" === n ? "" : n + pt(e, t)
                }]);
                const ft = lt([function(e, t) {
                        const n = e.substr(t, 2);
                        if (t += n.length, "0b" !== n.toLowerCase()) return "";
                        const r = function(e, t) {
                            var n;
                            const r = e.substr(t).match(/^[01]+/);
                            return null !== (n = r && r[0]) && void 0 !== n ? n : ""
                        }(e, t);
                        return "" === r ? "" : n + r
                    }, function(e, t) {
                        const n = e.substr(t, 2);
                        if (t += n.length, "0o" !== n.toLowerCase()) return "";
                        const r = function(e, t) {
                            var n;
                            const r = e.substr(t).match(/^[0-7]+/);
                            return null !== (n = r && r[0]) && void 0 !== n ? n : ""
                        }(e, t);
                        return "" === r ? "" : n + r
                    }, function(e, t) {
                        const n = e.substr(t, 2);
                        if (t += n.length, "0x" !== n.toLowerCase()) return "";
                        const r = function(e, t) {
                            var n;
                            const r = e.substr(t).match(/^[0-9a-f]+/i);
                            return null !== (n = r && r[0]) && void 0 !== n ? n : ""
                        }(e, t);
                        return "" === r ? "" : n + r
                    }]),
                    _t = lt([ft, dt]);

                function mt(e, t) {
                    return function(e, t) {
                        const n = _t(e, t);
                        return t += n.length, "" === n ? null : {
                            evaluable: new rt(n),
                            cursor: t
                        }
                    }(e, t) || function(e, t) {
                        const n = e.substr(t, 1);
                        if (t += n.length, "(" !== n) return null;
                        const r = bt(e, t);
                        if (!r) return null;
                        t = r.cursor, t += ct(e, t).length;
                        const i = e.substr(t, 1);
                        return t += i.length, ")" !== i ? null : {
                            evaluable: r.evaluable,
                            cursor: t
                        }
                    }(e, t)
                }

                function gt(e, t, n) {
                    n += ct(t, n).length;
                    const r = e.filter((e => t.startsWith(e, n)))[0];
                    return r ? (n += r.length, {
                        cursor: n += ct(t, n).length,
                        operator: r
                    }) : null
                }
                const vt = [
                    ["**"],
                    ["*", "/", "%"],
                    ["+", "-"],
                    ["<<", ">>>", ">>"],
                    ["&"],
                    ["^"],
                    ["|"]
                ].reduce(((e, t) => function(e, t) {
                    return (n, r) => {
                        const i = e(n, r);
                        if (!i) return null;
                        r = i.cursor;
                        let s = i.evaluable;
                        for (;;) {
                            const i = gt(t, n, r);
                            if (!i) break;
                            r = i.cursor;
                            const o = e(n, r);
                            if (!o) return null;
                            r = o.cursor, s = new st(i.operator, s, o.evaluable)
                        }
                        return s ? {
                            cursor: r,
                            evaluable: s
                        } : null
                    }
                }(e, t)), (function e(t, n) {
                    const r = mt(t, n);
                    if (r) return r;
                    const i = t.substr(n, 1);
                    if (n += i.length, "+" !== i && "-" !== i && "~" !== i) return null;
                    const s = e(t, n);
                    return s ? {
                        cursor: n = s.cursor,
                        evaluable: new at(i, s.evaluable)
                    } : null
                }));

                function bt(e, t) {
                    return t += ct(e, t).length, vt(e, t)
                }

                function xt(e) {
                    var t;
                    const n = function(e) {
                        const t = bt(e, 0);
                        return t ? t.cursor + ct(e, t.cursor).length !== e.length ? null : t.evaluable : null
                    }(e);
                    return null !== (t = null == n ? void 0 : n.evaluate()) && void 0 !== t ? t : null
                }

                function yt(e) {
                    if ("number" == typeof e) return e;
                    if ("string" == typeof e) {
                        const t = xt(e);
                        if (!o(t)) return t
                    }
                    return 0
                }

                function wt(e) {
                    return String(e)
                }

                function St(e) {
                    return t => t.toFixed(Math.max(Math.min(e, 20), 0))
                }
                const Mt = St(0);

                function Tt(e) {
                    return Mt(e) + "%"
                }

                function Et(e) {
                    return String(e)
                }

                function At(e) {
                    return e
                }

                function Ct(e, t) {
                    for (; e.length < t;) e.push(void 0)
                }

                function Rt(e) {
                    const t = [];
                    return Ct(t, e), T(t)
                }

                function kt(e) {
                    const t = e.indexOf(void 0);
                    return t < 0 ? e : e.slice(0, t)
                }

                function Pt({
                    primary: e,
                    secondary: t,
                    forward: n,
                    backward: r
                }) {
                    let i = !1;

                    function s(e) {
                        i || (i = !0, e(), i = !1)
                    }
                    e.emitter.on("change", (r => {
                        s((() => {
                            t.setRawValue(n(e, t), r.options)
                        }))
                    })), t.emitter.on("change", (i => {
                        s((() => {
                            e.setRawValue(r(e, t), i.options)
                        })), s((() => {
                            t.setRawValue(n(e, t), i.options)
                        }))
                    })), s((() => {
                        t.setRawValue(n(e, t), {
                            forceEmit: !1,
                            last: !0
                        })
                    }))
                }

                function Dt(e, t) {
                    const n = e * (t.altKey ? .1 : 1) * (t.shiftKey ? 10 : 1);
                    return t.upKey ? +n : t.downKey ? -n : 0
                }

                function Ot(e) {
                    return {
                        altKey: e.altKey,
                        downKey: "ArrowDown" === e.key,
                        shiftKey: e.shiftKey,
                        upKey: "ArrowUp" === e.key
                    }
                }

                function Lt(e) {
                    return {
                        altKey: e.altKey,
                        downKey: "ArrowLeft" === e.key,
                        shiftKey: e.shiftKey,
                        upKey: "ArrowRight" === e.key
                    }
                }

                function It(e) {
                    return function(e) {
                        return "ArrowUp" === e || "ArrowDown" === e
                    }(e) || "ArrowLeft" === e || "ArrowRight" === e
                }

                function Ft(e, t) {
                    const n = t.ownerDocument.defaultView,
                        r = t.getBoundingClientRect();
                    return {
                        x: e.pageX - ((n && n.scrollX || 0) + r.left),
                        y: e.pageY - ((n && n.scrollY || 0) + r.top)
                    }
                }
                class Nt {
                    constructor(e) {
                        this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = e, this.emitter = new h, e.addEventListener("touchstart", this.onTouchStart_, {
                            passive: !1
                        }), e.addEventListener("touchmove", this.onTouchMove_, {
                            passive: !0
                        }), e.addEventListener("touchend", this.onTouchEnd_), e.addEventListener("mousedown", this.onMouseDown_)
                    }
                    computePosition_(e) {
                        const t = this.elem_.getBoundingClientRect();
                        return {
                            bounds: {
                                width: t.width,
                                height: t.height
                            },
                            point: e ? {
                                x: e.x,
                                y: e.y
                            } : null
                        }
                    }
                    onMouseDown_(e) {
                        var t;
                        e.preventDefault(), null === (t = e.currentTarget) || void 0 === t || t.focus();
                        const n = this.elem_.ownerDocument;
                        n.addEventListener("mousemove", this.onDocumentMouseMove_), n.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
                            altKey: e.altKey,
                            data: this.computePosition_(Ft(e, this.elem_)),
                            sender: this,
                            shiftKey: e.shiftKey
                        })
                    }
                    onDocumentMouseMove_(e) {
                        this.emitter.emit("move", {
                            altKey: e.altKey,
                            data: this.computePosition_(Ft(e, this.elem_)),
                            sender: this,
                            shiftKey: e.shiftKey
                        })
                    }
                    onDocumentMouseUp_(e) {
                        const t = this.elem_.ownerDocument;
                        t.removeEventListener("mousemove", this.onDocumentMouseMove_), t.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
                            altKey: e.altKey,
                            data: this.computePosition_(Ft(e, this.elem_)),
                            sender: this,
                            shiftKey: e.shiftKey
                        })
                    }
                    onTouchStart_(e) {
                        e.preventDefault();
                        const t = e.targetTouches.item(0),
                            n = this.elem_.getBoundingClientRect();
                        this.emitter.emit("down", {
                            altKey: e.altKey,
                            data: this.computePosition_(t ? {
                                x: t.clientX - n.left,
                                y: t.clientY - n.top
                            } : void 0),
                            sender: this,
                            shiftKey: e.shiftKey
                        }), this.lastTouch_ = t
                    }
                    onTouchMove_(e) {
                        const t = e.targetTouches.item(0),
                            n = this.elem_.getBoundingClientRect();
                        this.emitter.emit("move", {
                            altKey: e.altKey,
                            data: this.computePosition_(t ? {
                                x: t.clientX - n.left,
                                y: t.clientY - n.top
                            } : void 0),
                            sender: this,
                            shiftKey: e.shiftKey
                        }), this.lastTouch_ = t
                    }
                    onTouchEnd_(e) {
                        var t;
                        const n = null !== (t = e.targetTouches.item(0)) && void 0 !== t ? t : this.lastTouch_,
                            r = this.elem_.getBoundingClientRect();
                        this.emitter.emit("up", {
                            altKey: e.altKey,
                            data: this.computePosition_(n ? {
                                x: n.clientX - r.left,
                                y: n.clientY - r.top
                            } : void 0),
                            sender: this,
                            shiftKey: e.shiftKey
                        })
                    }
                }

                function Ut(e, t, n, r, i) {
                    return r + (e - t) / (n - t) * (i - r)
                }

                function Bt(e) {
                    return String(e.toFixed(10)).split(".")[1].replace(/0+$/, "").length
                }

                function jt(e, t, n) {
                    return Math.min(Math.max(e, t), n)
                }

                function zt(e, t) {
                    return (e % t + t) % t
                }
                const Vt = f("txt");
                class Gt {
                    constructor(e, t) {
                        this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Vt(), Vt(void 0, "num")), t.arrayPosition && this.element.classList.add(Vt(void 0, t.arrayPosition)), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("input");
                        n.classList.add(Vt("i")), n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = t.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(Vt()), this.inputElement.classList.add(Vt("i"));
                        const r = e.createElement("div");
                        r.classList.add(Vt("k")), this.element.appendChild(r), this.knobElement = r;
                        const i = e.createElementNS(L, "svg");
                        i.classList.add(Vt("g")), this.knobElement.appendChild(i);
                        const s = e.createElementNS(L, "path");
                        s.classList.add(Vt("gb")), i.appendChild(s), this.guideBodyElem_ = s;
                        const o = e.createElementNS(L, "path");
                        o.classList.add(Vt("gh")), i.appendChild(o), this.guideHeadElem_ = o;
                        const a = e.createElement("div");
                        a.classList.add(f("tt")()), this.knobElement.appendChild(a), this.tooltipElem_ = a, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.refresh()
                    }
                    onDraggingChange_(e) {
                        if (null === e.rawValue) return void this.element.classList.remove(Vt(void 0, "drg"));
                        this.element.classList.add(Vt(void 0, "drg"));
                        const t = e.rawValue / this.props_.get("draggingScale"),
                            n = t + (t > 0 ? -1 : t < 0 ? 1 : 0),
                            r = jt(-n, -4, 4);
                        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${n+r},0 L${n},4 L${n+r},8`, `M ${t},-1 L${t},9`].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${t},4`);
                        const i = this.props_.get("formatter");
                        this.tooltipElem_.textContent = i(this.value.rawValue), this.tooltipElem_.style.left = `${t}px`
                    }
                    refresh() {
                        const e = this.props_.get("formatter");
                        this.inputElement.value = e(this.value.rawValue)
                    }
                    onChange_() {
                        this.refresh()
                    }
                }
                class Ht {
                    constructor(e, t) {
                        this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.parser_ = t.parser, this.props = t.props, this.value = t.value, this.viewProps = t.viewProps, this.dragging_ = T(null), this.view = new Gt(e, {
                            arrayPosition: t.arrayPosition,
                            dragging: this.dragging_,
                            props: this.props,
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
                        const n = new Nt(this.view.knobElement);
                        n.emitter.on("down", this.onPointerDown_), n.emitter.on("move", this.onPointerMove_), n.emitter.on("up", this.onPointerUp_)
                    }
                    onInputChange_(e) {
                        const t = e.currentTarget.value,
                            n = this.parser_(t);
                        o(n) || (this.value.rawValue = n), this.view.refresh()
                    }
                    onInputKeyDown_(e) {
                        const t = Dt(this.baseStep_, Ot(e));
                        0 !== t && this.value.setRawValue(this.value.rawValue + t, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onInputKeyUp_(e) {
                        0 !== Dt(this.baseStep_, Ot(e)) && this.value.setRawValue(this.value.rawValue, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                    onPointerDown_() {
                        this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0
                    }
                    computeDraggingValue_(e) {
                        if (!e.point) return null;
                        const t = e.point.x - e.bounds.width / 2;
                        return this.originRawValue_ + t * this.props.get("draggingScale")
                    }
                    onPointerMove_(e) {
                        const t = this.computeDraggingValue_(e.data);
                        null !== t && (this.value.setRawValue(t, {
                            forceEmit: !1,
                            last: !1
                        }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
                    }
                    onPointerUp_(e) {
                        const t = this.computeDraggingValue_(e.data);
                        null !== t && (this.value.setRawValue(t, {
                            forceEmit: !0,
                            last: !0
                        }), this.dragging_.rawValue = null)
                    }
                }
                const Wt = f("sld");
                class Kt {
                    constructor(e, t) {
                        this.onChange_ = this.onChange_.bind(this), this.props_ = t.props, this.props_.emitter.on("change", this.onChange_), this.element = e.createElement("div"), this.element.classList.add(Wt()), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("div");
                        n.classList.add(Wt("t")), t.viewProps.bindTabIndex(n), this.element.appendChild(n), this.trackElement = n;
                        const r = e.createElement("div");
                        r.classList.add(Wt("k")), this.trackElement.appendChild(r), this.knobElement = r, t.value.emitter.on("change", this.onChange_), this.value = t.value, this.update_()
                    }
                    update_() {
                        const e = jt(Ut(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
                        this.knobElement.style.width = `${e}%`
                    }
                    onChange_() {
                        this.update_()
                    }
                }
                class Xt {
                    constructor(e, t) {
                        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = t.baseStep, this.value = t.value, this.viewProps = t.viewProps, this.props = t.props, this.view = new Kt(e, {
                            props: this.props,
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.ptHandler_ = new Nt(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_)
                    }
                    handlePointerEvent_(e, t) {
                        e.point && this.value.setRawValue(Ut(jt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), t)
                    }
                    onPointerDownOrMove_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPointerUp_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                    onKeyDown_(e) {
                        const t = Dt(this.baseStep_, Lt(e));
                        0 !== t && this.value.setRawValue(this.value.rawValue + t, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onKeyUp_(e) {
                        0 !== Dt(this.baseStep_, Lt(e)) && this.value.setRawValue(this.value.rawValue, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                }
                const qt = f("sldtxt");
                class Yt {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(qt());
                        const n = e.createElement("div");
                        n.classList.add(qt("s")), this.sliderView_ = t.sliderView, n.appendChild(this.sliderView_.element), this.element.appendChild(n);
                        const r = e.createElement("div");
                        r.classList.add(qt("t")), this.textView_ = t.textView, r.appendChild(this.textView_.element), this.element.appendChild(r)
                    }
                }
                class Zt {
                    constructor(e, t) {
                        this.value = t.value, this.viewProps = t.viewProps, this.sliderC_ = new Xt(e, {
                            baseStep: t.baseStep,
                            props: t.sliderProps,
                            value: t.value,
                            viewProps: this.viewProps
                        }), this.textC_ = new Ht(e, {
                            baseStep: t.baseStep,
                            parser: t.parser,
                            props: t.textProps,
                            value: t.value,
                            viewProps: t.viewProps
                        }), this.view = new Yt(e, {
                            sliderView: this.sliderC_.view,
                            textView: this.textC_.view
                        })
                    }
                    get sliderController() {
                        return this.sliderC_
                    }
                    get textController() {
                        return this.textC_
                    }
                }

                function Jt(e, t) {
                    e.write(t)
                }

                function $t(e) {
                    const t = R;
                    return Array.isArray(e) ? t.required.array(t.required.object({
                        text: t.required.string,
                        value: t.required.raw
                    }))(e).value : "object" == typeof e ? t.required.raw(e).value : void 0
                }

                function Qt(e) {
                    if ("inline" === e || "popup" === e) return e
                }

                function en(e) {
                    const t = R;
                    return t.required.object({
                        max: t.optional.number,
                        min: t.optional.number,
                        step: t.optional.number
                    })(e).value
                }

                function tn(e) {
                    if (Array.isArray(e)) return e;
                    const t = [];
                    return Object.keys(e).forEach((n => {
                        t.push({
                            text: n,
                            value: e[n]
                        })
                    })), t
                }

                function nn(e) {
                    return o(e) ? null : new Ge(tn(e))
                }

                function rn(e) {
                    const t = e ? Ve(e, Ge) : null;
                    return t ? t.options : null
                }

                function sn(e, t) {
                    const n = e && Ve(e, We);
                    return n ? Bt(n.step) : Math.max(Bt(t), 2)
                }

                function on(e) {
                    const t = function(e) {
                        const t = e ? Ve(e, We) : null;
                        return t ? t.step : null
                    }(e);
                    return null != t ? t : 1
                }

                function an(e, t) {
                    var n;
                    const r = e && Ve(e, We),
                        i = Math.abs(null !== (n = null == r ? void 0 : r.step) && void 0 !== n ? n : t);
                    return 0 === i ? .1 : Math.pow(10, Math.floor(Math.log10(i)) - 1)
                }
                const ln = f("ckb");
                class cn {
                    constructor(e, t) {
                        this.onValueChange_ = this.onValueChange_.bind(this), this.element = e.createElement("div"), this.element.classList.add(ln()), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("label");
                        n.classList.add(ln("l")), this.element.appendChild(n);
                        const r = e.createElement("input");
                        r.classList.add(ln("i")), r.type = "checkbox", n.appendChild(r), this.inputElement = r, t.viewProps.bindDisabled(this.inputElement);
                        const i = e.createElement("div");
                        i.classList.add(ln("w")), n.appendChild(i);
                        const s = B(e, "check");
                        i.appendChild(s), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_()
                    }
                    update_() {
                        this.inputElement.checked = this.value.rawValue
                    }
                    onValueChange_() {
                        this.update_()
                    }
                }
                class un {
                    constructor(e, t) {
                        this.onInputChange_ = this.onInputChange_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new cn(e, {
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.view.inputElement.addEventListener("change", this.onInputChange_)
                    }
                    onInputChange_(e) {
                        const t = e.currentTarget;
                        this.value.rawValue = t.checked
                    }
                }
                const pn = {
                        id: "input-bool",
                        type: "input",
                        accept: (e, t) => {
                            if ("boolean" != typeof e) return null;
                            const n = k(t, {
                                options: R.optional.custom($t)
                            });
                            return n ? {
                                initialValue: e,
                                params: n
                            } : null
                        },
                        binding: {
                            reader: e => tt,
                            constraint: e => function(e) {
                                const t = [],
                                    n = nn(e.options);
                                return n && t.push(n), new ze(t)
                            }(e.params),
                            writer: e => Jt
                        },
                        controller: e => {
                            var t;
                            const n = e.document,
                                r = e.value,
                                i = e.constraint;
                            return i && Ve(i, Ge) ? new qe(n, {
                                props: E.fromObject({
                                    options: null !== (t = rn(i)) && void 0 !== t ? t : []
                                }),
                                value: r,
                                viewProps: e.viewProps
                            }) : new un(n, {
                                value: r,
                                viewProps: e.viewProps
                            })
                        }
                    },
                    hn = f("col");
                class dn {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(hn()), t.foldable.bindExpandedClass(this.element, hn(void 0, "expanded")), g(t.foldable, "completed", v(this.element, hn(void 0, "cpl")));
                        const n = e.createElement("div");
                        n.classList.add(hn("h")), this.element.appendChild(n);
                        const r = e.createElement("div");
                        r.classList.add(hn("s")), n.appendChild(r), this.swatchElement = r;
                        const i = e.createElement("div");
                        if (i.classList.add(hn("t")), n.appendChild(i), this.textElement = i, "inline" === t.pickerLayout) {
                            const t = e.createElement("div");
                            t.classList.add(hn("p")), this.element.appendChild(t), this.pickerElement = t
                        } else this.pickerElement = null
                    }
                }

                function fn(e, t, n) {
                    const r = zt(e, 360),
                        i = jt(t / 100, 0, 1),
                        s = jt(n / 100, 0, 1),
                        o = s * i,
                        a = o * (1 - Math.abs(r / 60 % 2 - 1)),
                        l = s - o;
                    let c, u, p;
                    return [c, u, p] = r >= 0 && r < 60 ? [o, a, 0] : r >= 60 && r < 120 ? [a, o, 0] : r >= 120 && r < 180 ? [0, o, a] : r >= 180 && r < 240 ? [0, a, o] : r >= 240 && r < 300 ? [a, 0, o] : [o, 0, a], [255 * (c + l), 255 * (u + l), 255 * (p + l)]
                }

                function _n(e) {
                    return [e[0], e[1], e[2]]
                }

                function mn(e, t) {
                    return [e[0], e[1], e[2], t]
                }
                const gn = {
                    hsl: {
                        hsl: (e, t, n) => [e, t, n],
                        hsv: function(e, t, n) {
                            const r = n + t * (100 - Math.abs(2 * n - 100)) / 200;
                            return [e, 0 !== r ? t * (100 - Math.abs(2 * n - 100)) / r : 0, n + t * (100 - Math.abs(2 * n - 100)) / 200]
                        },
                        rgb: function(e, t, n) {
                            const r = (e % 360 + 360) % 360,
                                i = jt(t / 100, 0, 1),
                                s = jt(n / 100, 0, 1),
                                o = (1 - Math.abs(2 * s - 1)) * i,
                                a = o * (1 - Math.abs(r / 60 % 2 - 1)),
                                l = s - o / 2;
                            let c, u, p;
                            return [c, u, p] = r >= 0 && r < 60 ? [o, a, 0] : r >= 60 && r < 120 ? [a, o, 0] : r >= 120 && r < 180 ? [0, o, a] : r >= 180 && r < 240 ? [0, a, o] : r >= 240 && r < 300 ? [a, 0, o] : [o, 0, a], [255 * (c + l), 255 * (u + l), 255 * (p + l)]
                        }
                    },
                    hsv: {
                        hsl: function(e, t, n) {
                            const r = 100 - Math.abs(n * (200 - t) / 100 - 100);
                            return [e, 0 !== r ? t * n / r : 0, n * (200 - t) / 200]
                        },
                        hsv: (e, t, n) => [e, t, n],
                        rgb: fn
                    },
                    rgb: {
                        hsl: function(e, t, n) {
                            const r = jt(e / 255, 0, 1),
                                i = jt(t / 255, 0, 1),
                                s = jt(n / 255, 0, 1),
                                o = Math.max(r, i, s),
                                a = Math.min(r, i, s),
                                l = o - a;
                            let c = 0,
                                u = 0;
                            const p = (a + o) / 2;
                            return 0 !== l && (u = l / (1 - Math.abs(o + a - 1)), c = r === o ? (i - s) / l : i === o ? 2 + (s - r) / l : 4 + (r - i) / l, c = c / 6 + (c < 0 ? 1 : 0)), [360 * c, 100 * u, 100 * p]
                        },
                        hsv: function(e, t, n) {
                            const r = jt(e / 255, 0, 1),
                                i = jt(t / 255, 0, 1),
                                s = jt(n / 255, 0, 1),
                                o = Math.max(r, i, s),
                                a = o - Math.min(r, i, s);
                            let l;
                            return l = 0 === a ? 0 : o === r ? ((i - s) / a % 6 + 6) % 6 * 60 : o === i ? 60 * ((s - r) / a + 2) : 60 * ((r - i) / a + 4), [l, 100 * (0 === o ? 0 : a / o), 100 * o]
                        },
                        rgb: (e, t, n) => [e, t, n]
                    }
                };
                const vn = {
                    hsl: e => {
                        var t;
                        return [zt(e[0], 360), jt(e[1], 0, 100), jt(e[2], 0, 100), jt(null !== (t = e[3]) && void 0 !== t ? t : 1, 0, 1)]
                    },
                    hsv: e => {
                        var t;
                        return [zt(e[0], 360), jt(e[1], 0, 100), jt(e[2], 0, 100), jt(null !== (t = e[3]) && void 0 !== t ? t : 1, 0, 1)]
                    },
                    rgb: e => {
                        var t;
                        return [jt(e[0], 0, 255), jt(e[1], 0, 255), jt(e[2], 0, 255), jt(null !== (t = e[3]) && void 0 !== t ? t : 1, 0, 1)]
                    }
                };

                function bn(e, t) {
                    return "object" == typeof e && !o(e) && t in e && "number" == typeof e[t]
                }
                class xn {
                    constructor(e, t) {
                        this.mode_ = t, this.comps_ = vn[t](e)
                    }
                    static black() {
                        return new xn([0, 0, 0], "rgb")
                    }
                    static fromObject(e) {
                        const t = "a" in e ? [e.r, e.g, e.b, e.a] : [e.r, e.g, e.b];
                        return new xn(t, "rgb")
                    }
                    static toRgbaObject(e) {
                        return e.toRgbaObject()
                    }
                    static isRgbColorObject(e) {
                        return bn(e, "r") && bn(e, "g") && bn(e, "b")
                    }
                    static isRgbaColorObject(e) {
                        return this.isRgbColorObject(e) && bn(e, "a")
                    }
                    static isColorObject(e) {
                        return this.isRgbColorObject(e)
                    }
                    static equals(e, t) {
                        if (e.mode_ !== t.mode_) return !1;
                        const n = e.comps_,
                            r = t.comps_;
                        for (let e = 0; e < n.length; e++)
                            if (n[e] !== r[e]) return !1;
                        return !0
                    }
                    get mode() {
                        return this.mode_
                    }
                    getComponents(e) {
                        return mn((t = _n(this.comps_), n = this.mode_, r = e || this.mode_, gn[n][r](...t)), this.comps_[3]);
                        var t, n, r
                    }
                    toRgbaObject() {
                        const e = this.getComponents("rgb");
                        return {
                            r: e[0],
                            g: e[1],
                            b: e[2],
                            a: e[3]
                        }
                    }
                }
                const yn = f("colp");
                class wn {
                    constructor(e, t) {
                        this.alphaViews_ = null, this.element = e.createElement("div"), this.element.classList.add(yn());
                        const n = e.createElement("div");
                        n.classList.add(yn("hsv"));
                        const r = e.createElement("div");
                        r.classList.add(yn("sv")), this.svPaletteView_ = t.svPaletteView, r.appendChild(this.svPaletteView_.element), n.appendChild(r);
                        const i = e.createElement("div");
                        i.classList.add(yn("h")), this.hPaletteView_ = t.hPaletteView, i.appendChild(this.hPaletteView_.element), n.appendChild(i), this.element.appendChild(n);
                        const s = e.createElement("div");
                        if (s.classList.add(yn("rgb")), this.textView_ = t.textView, s.appendChild(this.textView_.element), this.element.appendChild(s), t.alphaViews) {
                            this.alphaViews_ = {
                                palette: t.alphaViews.palette,
                                text: t.alphaViews.text
                            };
                            const n = e.createElement("div");
                            n.classList.add(yn("a"));
                            const r = e.createElement("div");
                            r.classList.add(yn("ap")), r.appendChild(this.alphaViews_.palette.element), n.appendChild(r);
                            const i = e.createElement("div");
                            i.classList.add(yn("at")), i.appendChild(this.alphaViews_.text.element), n.appendChild(i), this.element.appendChild(n)
                        }
                    }
                    get allFocusableElements() {
                        const e = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map((e => e.inputElement))];
                        return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e
                    }
                }

                function Sn(e) {
                    const t = R;
                    return k(e, {
                        alpha: t.optional.boolean,
                        expanded: t.optional.boolean,
                        picker: t.optional.custom(Qt)
                    })
                }

                function Mn(e) {
                    return e ? .1 : 1
                }

                function Tn(e, t) {
                    const n = e.match(/^(.+)%$/);
                    return n ? Math.min(.01 * parseFloat(n[1]) * t, t) : Math.min(parseFloat(e), t)
                }
                const En = {
                    deg: e => e,
                    grad: e => 360 * e / 400,
                    rad: e => 360 * e / (2 * Math.PI),
                    turn: e => 360 * e
                };

                function An(e) {
                    const t = e.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
                    if (!t) return parseFloat(e);
                    const n = parseFloat(t[1]),
                        r = t[2];
                    return En[r](n)
                }
                const Cn = {
                    "func.rgb": e => {
                        const t = e.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                        if (!t) return null;
                        const n = [Tn(t[1], 255), Tn(t[2], 255), Tn(t[3], 255)];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : new xn(n, "rgb")
                    },
                    "func.rgba": e => {
                        const t = e.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                        if (!t) return null;
                        const n = [Tn(t[1], 255), Tn(t[2], 255), Tn(t[3], 255), Tn(t[4], 1)];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : new xn(n, "rgb")
                    },
                    "func.hsl": e => {
                        const t = e.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                        if (!t) return null;
                        const n = [An(t[1]), Tn(t[2], 100), Tn(t[3], 100)];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : new xn(n, "hsl")
                    },
                    "func.hsla": e => {
                        const t = e.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                        if (!t) return null;
                        const n = [An(t[1]), Tn(t[2], 100), Tn(t[3], 100), Tn(t[4], 1)];
                        return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : new xn(n, "hsl")
                    },
                    "hex.rgb": e => {
                        const t = e.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
                        if (t) return new xn([parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)], "rgb");
                        const n = e.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
                        return n ? new xn([parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16)], "rgb") : null
                    },
                    "hex.rgba": e => {
                        const t = e.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
                        if (t) return new xn([parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16), Ut(parseInt(t[4] + t[4], 16), 0, 255, 0, 1)], "rgb");
                        const n = e.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
                        return n ? new xn([parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16), Ut(parseInt(n[4], 16), 0, 255, 0, 1)], "rgb") : null
                    }
                };

                function Rn(e) {
                    return Object.keys(Cn).reduce(((t, n) => t || ((0, Cn[n])(e) ? n : null)), null)
                }
                const kn = e => {
                    const t = Rn(e);
                    return t ? Cn[t](e) : null
                };

                function Pn(e) {
                    return "func.hsla" === e || "func.rgba" === e || "hex.rgba" === e
                }

                function Dn(e) {
                    if ("string" == typeof e) {
                        const t = kn(e);
                        if (t) return t
                    }
                    return xn.black()
                }

                function On(e) {
                    const t = jt(Math.floor(e), 0, 255).toString(16);
                    return 1 === t.length ? `0${t}` : t
                }

                function Ln(e, t = "#") {
                    return `${t}${_n(e.getComponents("rgb")).map(On).join("")}`
                }

                function In(e, t = "#") {
                    const n = e.getComponents("rgb");
                    return `${t}${[n[0],n[1],n[2],255*n[3]].map(On).join("")}`
                }

                function Fn(e) {
                    const t = St(0);
                    return `rgb(${_n(e.getComponents("rgb")).map((e=>t(e))).join(", ")})`
                }

                function Nn(e) {
                    const t = St(2),
                        n = St(0);
                    return `rgba(${e.getComponents("rgb").map(((e,r)=>(3===r?t:n)(e))).join(", ")})`
                }
                const Un = {
                    "func.hsl": function(e) {
                        const t = [St(0), Tt, Tt];
                        return `hsl(${_n(e.getComponents("hsl")).map(((e,n)=>t[n](e))).join(", ")})`
                    },
                    "func.hsla": function(e) {
                        const t = [St(0), Tt, Tt, St(2)];
                        return `hsla(${e.getComponents("hsl").map(((e,n)=>t[n](e))).join(", ")})`
                    },
                    "func.rgb": Fn,
                    "func.rgba": Nn,
                    "hex.rgb": Ln,
                    "hex.rgba": In
                };

                function Bn(e) {
                    return Un[e]
                }
                const jn = f("apl");
                class zn {
                    constructor(e, t) {
                        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(jn()), t.viewProps.bindTabIndex(this.element);
                        const n = e.createElement("div");
                        n.classList.add(jn("b")), this.element.appendChild(n);
                        const r = e.createElement("div");
                        r.classList.add(jn("c")), n.appendChild(r), this.colorElem_ = r;
                        const i = e.createElement("div");
                        i.classList.add(jn("m")), this.element.appendChild(i), this.markerElem_ = i;
                        const s = e.createElement("div");
                        s.classList.add(jn("p")), this.markerElem_.appendChild(s), this.previewElem_ = s, this.update_()
                    }
                    update_() {
                        const e = this.value.rawValue,
                            t = e.getComponents("rgb"),
                            n = new xn([t[0], t[1], t[2], 0], "rgb"),
                            r = new xn([t[0], t[1], t[2], 255], "rgb"),
                            i = ["to right", Nn(n), Nn(r)];
                        this.colorElem_.style.background = `linear-gradient(${i.join(",")})`, this.previewElem_.style.backgroundColor = Nn(e);
                        const s = Ut(t[3], 0, 1, 0, 100);
                        this.markerElem_.style.left = `${s}%`
                    }
                    onValueChange_() {
                        this.update_()
                    }
                }
                class Vn {
                    constructor(e, t) {
                        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new zn(e, {
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.ptHandler_ = new Nt(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
                    }
                    handlePointerEvent_(e, t) {
                        if (!e.point) return;
                        const n = e.point.x / e.bounds.width,
                            r = this.value.rawValue,
                            [i, s, o] = r.getComponents("hsv");
                        this.value.setRawValue(new xn([i, s, o, n], "hsv"), t)
                    }
                    onPointerDown_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPointerMove_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPointerUp_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                    onKeyDown_(e) {
                        const t = Dt(Mn(!0), Lt(e));
                        if (0 === t) return;
                        const n = this.value.rawValue,
                            [r, i, s, o] = n.getComponents("hsv");
                        this.value.setRawValue(new xn([r, i, s, o + t], "hsv"), {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onKeyUp_(e) {
                        0 !== Dt(Mn(!0), Lt(e)) && this.value.setRawValue(this.value.rawValue, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                }
                const Gn = f("coltxt");
                class Hn {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(Gn());
                        const n = e.createElement("div");
                        n.classList.add(Gn("m")), this.modeElem_ = function(e) {
                            const t = e.createElement("select");
                            return t.appendChild([{
                                text: "RGB",
                                value: "rgb"
                            }, {
                                text: "HSL",
                                value: "hsl"
                            }, {
                                text: "HSV",
                                value: "hsv"
                            }].reduce(((t, n) => {
                                const r = e.createElement("option");
                                return r.textContent = n.text, r.value = n.value, t.appendChild(r), t
                            }), e.createDocumentFragment())), t
                        }(e), this.modeElem_.classList.add(Gn("ms")), n.appendChild(this.modeSelectElement);
                        const r = e.createElement("div");
                        r.classList.add(Gn("mm")), r.appendChild(B(e, "dropdown")), n.appendChild(r), this.element.appendChild(n);
                        const i = e.createElement("div");
                        i.classList.add(Gn("w")), this.element.appendChild(i), this.textsElem_ = i, this.textViews_ = t.textViews, this.applyTextViews_(), m(t.colorMode, (e => {
                            this.modeElem_.value = e
                        }))
                    }
                    get modeSelectElement() {
                        return this.modeElem_
                    }
                    get textViews() {
                        return this.textViews_
                    }
                    set textViews(e) {
                        this.textViews_ = e, this.applyTextViews_()
                    }
                    applyTextViews_() {
                        V(this.textsElem_);
                        const e = this.element.ownerDocument;
                        this.textViews_.forEach((t => {
                            const n = e.createElement("div");
                            n.classList.add(Gn("c")), n.appendChild(t.element), this.textsElem_.appendChild(n)
                        }))
                    }
                }
                const Wn = St(0),
                    Kn = {
                        rgb: () => new He({
                            min: 0,
                            max: 255
                        }),
                        hsl: e => new He(0 === e ? {
                            min: 0,
                            max: 360
                        } : {
                            min: 0,
                            max: 100
                        }),
                        hsv: e => new He(0 === e ? {
                            min: 0,
                            max: 360
                        } : {
                            min: 0,
                            max: 100
                        })
                    };

                function Xn(e, t, n) {
                    return new Ht(e, {
                        arrayPosition: 0 === n ? "fst" : 2 === n ? "lst" : "mid",
                        baseStep: Mn(!1),
                        parser: t.parser,
                        props: E.fromObject({
                            draggingScale: 1,
                            formatter: Wn
                        }),
                        value: T(0, {
                            constraint: Kn[t.colorMode](n)
                        }),
                        viewProps: t.viewProps
                    })
                }
                class qn {
                    constructor(e, t) {
                        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.parser_ = t.parser, this.value = t.value, this.viewProps = t.viewProps, this.colorMode = T(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(e), this.view = new Hn(e, {
                            colorMode: this.colorMode,
                            textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
                        }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_)
                    }
                    createComponentControllers_(e) {
                        const t = {
                                colorMode: this.colorMode.rawValue,
                                parser: this.parser_,
                                viewProps: this.viewProps
                            },
                            n = [Xn(e, t, 0), Xn(e, t, 1), Xn(e, t, 2)];
                        return n.forEach(((e, t) => {
                            Pt({
                                primary: this.value,
                                secondary: e.value,
                                forward: e => e.rawValue.getComponents(this.colorMode.rawValue)[t],
                                backward: (e, n) => {
                                    const r = this.colorMode.rawValue,
                                        i = e.rawValue.getComponents(r);
                                    return i[t] = n.rawValue, new xn(mn(_n(i), i[3]), r)
                                }
                            })
                        })), n
                    }
                    onModeSelectChange_(e) {
                        const t = e.currentTarget;
                        this.colorMode.rawValue = t.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
                    }
                }
                const Yn = f("hpl");
                class Zn {
                    constructor(e, t) {
                        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add(Yn()), t.viewProps.bindTabIndex(this.element);
                        const n = e.createElement("div");
                        n.classList.add(Yn("c")), this.element.appendChild(n);
                        const r = e.createElement("div");
                        r.classList.add(Yn("m")), this.element.appendChild(r), this.markerElem_ = r, this.update_()
                    }
                    update_() {
                        const e = this.value.rawValue,
                            [t] = e.getComponents("hsv");
                        this.markerElem_.style.backgroundColor = Fn(new xn([t, 100, 100], "hsv"));
                        const n = Ut(t, 0, 360, 0, 100);
                        this.markerElem_.style.left = `${n}%`
                    }
                    onValueChange_() {
                        this.update_()
                    }
                }
                class Jn {
                    constructor(e, t) {
                        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Zn(e, {
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.ptHandler_ = new Nt(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
                    }
                    handlePointerEvent_(e, t) {
                        if (!e.point) return;
                        const n = Ut(jt(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 359),
                            r = this.value.rawValue,
                            [, i, s, o] = r.getComponents("hsv");
                        this.value.setRawValue(new xn([n, i, s, o], "hsv"), t)
                    }
                    onPointerDown_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPointerMove_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPointerUp_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                    onKeyDown_(e) {
                        const t = Dt(Mn(!1), Lt(e));
                        if (0 === t) return;
                        const n = this.value.rawValue,
                            [r, i, s, o] = n.getComponents("hsv");
                        this.value.setRawValue(new xn([r + t, i, s, o], "hsv"), {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onKeyUp_(e) {
                        0 !== Dt(Mn(!1), Lt(e)) && this.value.setRawValue(this.value.rawValue, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                }
                const $n = f("svp");
                class Qn {
                    constructor(e, t) {
                        this.onValueChange_ = this.onValueChange_.bind(this), this.value = t.value, this.value.emitter.on("change", this.onValueChange_), this.element = e.createElement("div"), this.element.classList.add($n()), t.viewProps.bindTabIndex(this.element);
                        const n = e.createElement("canvas");
                        n.height = 64, n.width = 64, n.classList.add($n("c")), this.element.appendChild(n), this.canvasElement = n;
                        const r = e.createElement("div");
                        r.classList.add($n("m")), this.element.appendChild(r), this.markerElem_ = r, this.update_()
                    }
                    update_() {
                        const e = function(e) {
                            const t = e.ownerDocument.defaultView;
                            return t && "document" in t ? e.getContext("2d") : null
                        }(this.canvasElement);
                        if (!e) return;
                        const t = this.value.rawValue.getComponents("hsv"),
                            n = this.canvasElement.width,
                            r = this.canvasElement.height,
                            i = e.getImageData(0, 0, n, r),
                            s = i.data;
                        for (let e = 0; e < r; e++)
                            for (let i = 0; i < n; i++) {
                                const o = Ut(i, 0, n, 0, 100),
                                    a = Ut(e, 0, r, 100, 0),
                                    l = fn(t[0], o, a),
                                    c = 4 * (e * n + i);
                                s[c] = l[0], s[c + 1] = l[1], s[c + 2] = l[2], s[c + 3] = 255
                            }
                        e.putImageData(i, 0, 0);
                        const o = Ut(t[1], 0, 100, 0, 100);
                        this.markerElem_.style.left = `${o}%`;
                        const a = Ut(t[2], 0, 100, 100, 0);
                        this.markerElem_.style.top = `${a}%`
                    }
                    onValueChange_() {
                        this.update_()
                    }
                }
                class er {
                    constructor(e, t) {
                        this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.view = new Qn(e, {
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.ptHandler_ = new Nt(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_)
                    }
                    handlePointerEvent_(e, t) {
                        if (!e.point) return;
                        const n = Ut(e.point.x, 0, e.bounds.width, 0, 100),
                            r = Ut(e.point.y, 0, e.bounds.height, 100, 0),
                            [i, , , s] = this.value.rawValue.getComponents("hsv");
                        this.value.setRawValue(new xn([i, n, r, s], "hsv"), t)
                    }
                    onPointerDown_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPointerMove_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPointerUp_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                    onKeyDown_(e) {
                        It(e.key) && e.preventDefault();
                        const [t, n, r, i] = this.value.rawValue.getComponents("hsv"), s = Mn(!1), o = Dt(s, Lt(e)), a = Dt(s, Ot(e));
                        0 === o && 0 === a || this.value.setRawValue(new xn([t, n + o, r + a, i], "hsv"), {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onKeyUp_(e) {
                        const t = Mn(!1),
                            n = Dt(t, Lt(e)),
                            r = Dt(t, Ot(e));
                        0 === n && 0 === r || this.value.setRawValue(this.value.rawValue, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                }
                class tr {
                    constructor(e, t) {
                        this.value = t.value, this.viewProps = t.viewProps, this.hPaletteC_ = new Jn(e, {
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.svPaletteC_ = new er(e, {
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.alphaIcs_ = t.supportsAlpha ? {
                            palette: new Vn(e, {
                                value: this.value,
                                viewProps: this.viewProps
                            }),
                            text: new Ht(e, {
                                parser: xt,
                                baseStep: .1,
                                props: E.fromObject({
                                    draggingScale: .01,
                                    formatter: St(2)
                                }),
                                value: T(0, {
                                    constraint: new He({
                                        min: 0,
                                        max: 1
                                    })
                                }),
                                viewProps: this.viewProps
                            })
                        } : null, this.alphaIcs_ && Pt({
                            primary: this.value,
                            secondary: this.alphaIcs_.text.value,
                            forward: e => e.rawValue.getComponents()[3],
                            backward: (e, t) => {
                                const n = e.rawValue.getComponents();
                                return n[3] = t.rawValue, new xn(n, e.rawValue.mode)
                            }
                        }), this.textC_ = new qn(e, {
                            parser: xt,
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.view = new wn(e, {
                            alphaViews: this.alphaIcs_ ? {
                                palette: this.alphaIcs_.palette.view,
                                text: this.alphaIcs_.text.view
                            } : null,
                            hPaletteView: this.hPaletteC_.view,
                            supportsAlpha: t.supportsAlpha,
                            svPaletteView: this.svPaletteC_.view,
                            textView: this.textC_.view
                        })
                    }
                    get textController() {
                        return this.textC_
                    }
                }
                const nr = f("colsw");
                class rr {
                    constructor(e, t) {
                        this.onValueChange_ = this.onValueChange_.bind(this), t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.element = e.createElement("div"), this.element.classList.add(nr()), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("div");
                        n.classList.add(nr("sw")), this.element.appendChild(n), this.swatchElem_ = n;
                        const r = e.createElement("button");
                        r.classList.add(nr("b")), t.viewProps.bindDisabled(r), this.element.appendChild(r), this.buttonElement = r, this.update_()
                    }
                    update_() {
                        const e = this.value.rawValue;
                        this.swatchElem_.style.backgroundColor = In(e)
                    }
                    onValueChange_() {
                        this.update_()
                    }
                }
                class ir {
                    constructor(e, t) {
                        this.value = t.value, this.viewProps = t.viewProps, this.view = new rr(e, {
                            value: this.value,
                            viewProps: this.viewProps
                        })
                    }
                }
                class sr {
                    constructor(e, t) {
                        this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Z.create(t.expanded), this.swatchC_ = new ir(e, {
                            value: this.value,
                            viewProps: this.viewProps
                        });
                        const n = this.swatchC_.view.buttonElement;
                        n.addEventListener("blur", this.onButtonBlur_), n.addEventListener("click", this.onButtonClick_), this.textC_ = new et(e, {
                            parser: t.parser,
                            props: E.fromObject({
                                formatter: t.formatter
                            }),
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.view = new dn(e, {
                            foldable: this.foldable_,
                            pickerLayout: t.pickerLayout
                        }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = "popup" === t.pickerLayout ? new Je(e, {
                            viewProps: this.viewProps
                        }) : null;
                        const r = new tr(e, {
                            supportsAlpha: t.supportsAlpha,
                            value: this.value,
                            viewProps: this.viewProps
                        });
                        r.view.allFocusableElements.forEach((e => {
                            e.addEventListener("blur", this.onPopupChildBlur_), e.addEventListener("keydown", this.onPopupChildKeydown_)
                        })), this.pickerC_ = r, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(r.view.element), Pt({
                            primary: this.foldable_.value("expanded"),
                            secondary: this.popC_.shows,
                            forward: e => e.rawValue,
                            backward: (e, t) => t.rawValue
                        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), $(this.foldable_, this.view.pickerElement))
                    }
                    get textController() {
                        return this.textC_
                    }
                    onButtonBlur_(e) {
                        if (!this.popC_) return;
                        const t = this.view.element,
                            n = e.relatedTarget;
                        n && t.contains(n) || (this.popC_.shows.rawValue = !1)
                    }
                    onButtonClick_() {
                        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
                    }
                    onPopupChildBlur_(e) {
                        if (!this.popC_) return;
                        const t = this.popC_.view.element,
                            n = G(e);
                        n && t.contains(n) || n && n === this.swatchC_.view.buttonElement && !F(t.ownerDocument) || (this.popC_.shows.rawValue = !1)
                    }
                    onPopupChildKeydown_(e) {
                        this.popC_ ? "Escape" === e.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === e.key && this.swatchC_.view.buttonElement.focus()
                    }
                }

                function or(e) {
                    return xn.isColorObject(e) ? xn.fromObject(e) : xn.black()
                }

                function ar(e) {
                    return _n(e.getComponents("rgb")).reduce(((e, t) => e << 8 | 255 & Math.floor(t)), 0)
                }

                function lr(e) {
                    return e.getComponents("rgb").reduce(((e, t, n) => e << 8 | 255 & Math.floor(3 === n ? 255 * t : t)), 0) >>> 0
                }

                function cr(e) {
                    return "number" != typeof e ? xn.black() : new xn([(t = e) >> 16 & 255, t >> 8 & 255, 255 & t], "rgb");
                    var t
                }

                function ur(e) {
                    return "number" != typeof e ? xn.black() : new xn([(t = e) >> 24 & 255, t >> 16 & 255, t >> 8 & 255, Ut(255 & t, 0, 255, 0, 1)], "rgb");
                    var t
                }

                function pr(e, t) {
                    const n = t.toRgbaObject();
                    e.writeProperty("r", n.r), e.writeProperty("g", n.g), e.writeProperty("b", n.b), e.writeProperty("a", n.a)
                }

                function hr(e, t) {
                    const n = t.toRgbaObject();
                    e.writeProperty("r", n.r), e.writeProperty("g", n.g), e.writeProperty("b", n.b)
                }

                function dr(e) {
                    return "alpha" in e && !0 === e.alpha
                }

                function fr(e) {
                    return e ? e => In(e, "0x") : e => Ln(e, "0x")
                }
                const _r = {
                    id: "input-color-number",
                    type: "input",
                    accept: (e, t) => {
                        if ("number" != typeof e) return null;
                        if (!("view" in t)) return null;
                        if ("color" !== t.view) return null;
                        const n = Sn(t);
                        return n ? {
                            initialValue: e,
                            params: n
                        } : null
                    },
                    binding: {
                        reader: e => dr(e.params) ? ur : cr,
                        equals: xn.equals,
                        writer: e => function(e) {
                            const t = e ? lr : ar;
                            return (e, n) => {
                                Jt(e, t(n))
                            }
                        }(dr(e.params))
                    },
                    controller: e => {
                        const t = dr(e.params),
                            n = "expanded" in e.params ? e.params.expanded : void 0,
                            r = "picker" in e.params ? e.params.picker : void 0;
                        return new sr(e.document, {
                            expanded: null != n && n,
                            formatter: fr(t),
                            parser: kn,
                            pickerLayout: null != r ? r : "popup",
                            supportsAlpha: t,
                            value: e.value,
                            viewProps: e.viewProps
                        })
                    }
                };
                const mr = {
                        id: "input-color-object",
                        type: "input",
                        accept: (e, t) => {
                            if (!xn.isColorObject(e)) return null;
                            const n = Sn(t);
                            return n ? {
                                initialValue: e,
                                params: n
                            } : null
                        },
                        binding: {
                            reader: e => or,
                            equals: xn.equals,
                            writer: e => {
                                return t = e.initialValue, xn.isRgbaColorObject(t) ? pr : hr;
                                var t
                            }
                        },
                        controller: e => {
                            const t = xn.isRgbaColorObject(e.initialValue),
                                n = "expanded" in e.params ? e.params.expanded : void 0,
                                r = "picker" in e.params ? e.params.picker : void 0,
                                i = t ? In : Ln;
                            return new sr(e.document, {
                                expanded: null != n && n,
                                formatter: i,
                                parser: kn,
                                pickerLayout: null != r ? r : "popup",
                                supportsAlpha: t,
                                value: e.value,
                                viewProps: e.viewProps
                            })
                        }
                    },
                    gr = {
                        id: "input-color-string",
                        type: "input",
                        accept: (e, t) => {
                            if ("string" != typeof e) return null;
                            if ("view" in t && "text" === t.view) return null;
                            if (!Rn(e)) return null;
                            const n = Sn(t);
                            return n ? {
                                initialValue: e,
                                params: n
                            } : null
                        },
                        binding: {
                            reader: e => Dn,
                            equals: xn.equals,
                            writer: e => {
                                const t = Rn(e.initialValue);
                                if (!t) throw c.shouldNeverHappen();
                                return function(e) {
                                    const t = Bn(e);
                                    return (e, n) => {
                                        Jt(e, t(n))
                                    }
                                }(t)
                            }
                        },
                        controller: e => {
                            const t = Rn(e.initialValue);
                            if (!t) throw c.shouldNeverHappen();
                            const n = Bn(t),
                                r = "expanded" in e.params ? e.params.expanded : void 0,
                                i = "picker" in e.params ? e.params.picker : void 0;
                            return new sr(e.document, {
                                expanded: null != r && r,
                                formatter: n,
                                parser: kn,
                                pickerLayout: null != i ? i : "popup",
                                supportsAlpha: Pn(t),
                                value: e.value,
                                viewProps: e.viewProps
                            })
                        }
                    };
                class vr {
                    constructor(e) {
                        this.components = e.components, this.asm_ = e.assembly
                    }
                    constrain(e) {
                        const t = this.asm_.toComponents(e).map(((e, t) => {
                            var n, r;
                            return null !== (r = null === (n = this.components[t]) || void 0 === n ? void 0 : n.constrain(e)) && void 0 !== r ? r : e
                        }));
                        return this.asm_.fromComponents(t)
                    }
                }
                const br = f("pndtxt");
                class xr {
                    constructor(e, t) {
                        this.textViews = t.textViews, this.element = e.createElement("div"), this.element.classList.add(br()), this.textViews.forEach((t => {
                            const n = e.createElement("div");
                            n.classList.add(br("a")), n.appendChild(t.element), this.element.appendChild(n)
                        }))
                    }
                }
                class yr {
                    constructor(e, t) {
                        this.value = t.value, this.viewProps = t.viewProps, this.acs_ = t.axes.map(((n, r) => function(e, t, n) {
                            return new Ht(e, {
                                arrayPosition: 0 === n ? "fst" : n === t.axes.length - 1 ? "lst" : "mid",
                                baseStep: t.axes[n].baseStep,
                                parser: t.parser,
                                props: t.axes[n].textProps,
                                value: T(0, {
                                    constraint: t.axes[n].constraint
                                }),
                                viewProps: t.viewProps
                            })
                        }(e, t, r))), this.acs_.forEach(((e, n) => {
                            Pt({
                                primary: this.value,
                                secondary: e.value,
                                forward: e => t.assembly.toComponents(e.rawValue)[n],
                                backward: (e, r) => {
                                    const i = t.assembly.toComponents(e.rawValue);
                                    return i[n] = r.rawValue, t.assembly.fromComponents(i)
                                }
                            })
                        })), this.view = new xr(e, {
                            textViews: this.acs_.map((e => e.view))
                        })
                    }
                }

                function wr(e) {
                    const t = [],
                        n = function(e) {
                            return "step" in e && !o(e.step) ? new We(e.step) : null
                        }(e);
                    n && t.push(n);
                    const r = function(e) {
                        return "max" in e && !o(e.max) || "min" in e && !o(e.min) ? new He({
                            max: e.max,
                            min: e.min
                        }) : null
                    }(e);
                    r && t.push(r);
                    const i = nn(e.options);
                    return i && t.push(i), new ze(t)
                }

                function Sr(e) {
                    const [t, n] = function(e) {
                        const t = e ? Ve(e, He) : null;
                        return t ? [t.minValue, t.maxValue] : [void 0, void 0]
                    }(e);
                    return [null != t ? t : 0, null != n ? n : 100]
                }
                const Mr = {
                    id: "input-number",
                    type: "input",
                    accept: (e, t) => {
                        if ("number" != typeof e) return null;
                        const n = R,
                            r = k(t, {
                                format: n.optional.function,
                                max: n.optional.number,
                                min: n.optional.number,
                                options: n.optional.custom($t),
                                step: n.optional.number
                            });
                        return r ? {
                            initialValue: e,
                            params: r
                        } : null
                    },
                    binding: {
                        reader: e => yt,
                        constraint: e => wr(e.params),
                        writer: e => Jt
                    },
                    controller: e => {
                        var t, n;
                        const r = e.value,
                            i = e.constraint;
                        if (i && Ve(i, Ge)) return new qe(e.document, {
                            props: E.fromObject({
                                options: null !== (t = rn(i)) && void 0 !== t ? t : []
                            }),
                            value: r,
                            viewProps: e.viewProps
                        });
                        const s = null !== (n = "format" in e.params ? e.params.format : void 0) && void 0 !== n ? n : St(sn(i, r.rawValue));
                        if (i && Ve(i, He)) {
                            const [t, n] = Sr(i);
                            return new Zt(e.document, {
                                baseStep: on(i),
                                parser: xt,
                                sliderProps: E.fromObject({
                                    maxValue: n,
                                    minValue: t
                                }),
                                textProps: E.fromObject({
                                    draggingScale: an(i, r.rawValue),
                                    formatter: s
                                }),
                                value: r,
                                viewProps: e.viewProps
                            })
                        }
                        return new Ht(e.document, {
                            baseStep: on(i),
                            parser: xt,
                            props: E.fromObject({
                                draggingScale: an(i, r.rawValue),
                                formatter: s
                            }),
                            value: r,
                            viewProps: e.viewProps
                        })
                    }
                };
                class Tr {
                    constructor(e = 0, t = 0) {
                        this.x = e, this.y = t
                    }
                    getComponents() {
                        return [this.x, this.y]
                    }
                    static isObject(e) {
                        if (o(e)) return !1;
                        const t = e.x,
                            n = e.y;
                        return "number" == typeof t && "number" == typeof n
                    }
                    static equals(e, t) {
                        return e.x === t.x && e.y === t.y
                    }
                    toObject() {
                        return {
                            x: this.x,
                            y: this.y
                        }
                    }
                }
                const Er = {
                        toComponents: e => e.getComponents(),
                        fromComponents: e => new Tr(...e)
                    },
                    Ar = f("p2d");
                class Cr {
                    constructor(e, t) {
                        this.element = e.createElement("div"), this.element.classList.add(Ar()), t.viewProps.bindClassModifiers(this.element), m(t.expanded, v(this.element, Ar(void 0, "expanded")));
                        const n = e.createElement("div");
                        n.classList.add(Ar("h")), this.element.appendChild(n);
                        const r = e.createElement("button");
                        r.classList.add(Ar("b")), r.appendChild(B(e, "p2dpad")), t.viewProps.bindDisabled(r), n.appendChild(r), this.buttonElement = r;
                        const i = e.createElement("div");
                        if (i.classList.add(Ar("t")), n.appendChild(i), this.textElement = i, "inline" === t.pickerLayout) {
                            const t = e.createElement("div");
                            t.classList.add(Ar("p")), this.element.appendChild(t), this.pickerElement = t
                        } else this.pickerElement = null
                    }
                }
                const Rr = f("p2dp");
                class kr {
                    constructor(e, t) {
                        this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = t.invertsY, this.maxValue_ = t.maxValue, this.element = e.createElement("div"), this.element.classList.add(Rr()), "popup" === t.layout && this.element.classList.add(Rr(void 0, "p"));
                        const n = e.createElement("div");
                        n.classList.add(Rr("p")), t.viewProps.bindTabIndex(n), this.element.appendChild(n), this.padElement = n;
                        const r = e.createElementNS(L, "svg");
                        r.classList.add(Rr("g")), this.padElement.appendChild(r), this.svgElem_ = r;
                        const i = e.createElementNS(L, "line");
                        i.classList.add(Rr("ax")), i.setAttributeNS(null, "x1", "0"), i.setAttributeNS(null, "y1", "50%"), i.setAttributeNS(null, "x2", "100%"), i.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(i);
                        const s = e.createElementNS(L, "line");
                        s.classList.add(Rr("ax")), s.setAttributeNS(null, "x1", "50%"), s.setAttributeNS(null, "y1", "0"), s.setAttributeNS(null, "x2", "50%"), s.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(s);
                        const o = e.createElementNS(L, "line");
                        o.classList.add(Rr("l")), o.setAttributeNS(null, "x1", "50%"), o.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(o), this.lineElem_ = o;
                        const a = e.createElement("div");
                        a.classList.add(Rr("m")), this.padElement.appendChild(a), this.markerElem_ = a, t.value.emitter.on("change", this.onValueChange_), this.value = t.value, this.update_()
                    }
                    get allFocusableElements() {
                        return [this.padElement]
                    }
                    update_() {
                        const [e, t] = this.value.rawValue.getComponents(), n = this.maxValue_, r = Ut(e, -n, +n, 0, 100), i = Ut(t, -n, +n, 0, 100), s = this.invertsY_ ? 100 - i : i;
                        this.lineElem_.setAttributeNS(null, "x2", `${r}%`), this.lineElem_.setAttributeNS(null, "y2", `${s}%`), this.markerElem_.style.left = `${r}%`, this.markerElem_.style.top = `${s}%`
                    }
                    onValueChange_() {
                        this.update_()
                    }
                    onFoldableChange_() {
                        this.update_()
                    }
                }

                function Pr(e, t, n) {
                    return [Dt(t[0], Lt(e)), Dt(t[1], Ot(e)) * (n ? 1 : -1)]
                }
                class Dr {
                    constructor(e, t) {
                        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.baseSteps_ = t.baseSteps, this.maxValue_ = t.maxValue, this.invertsY_ = t.invertsY, this.view = new kr(e, {
                            invertsY: this.invertsY_,
                            layout: t.layout,
                            maxValue: this.maxValue_,
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.ptHandler_ = new Nt(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_)
                    }
                    handlePointerEvent_(e, t) {
                        if (!e.point) return;
                        const n = this.maxValue_,
                            r = Ut(e.point.x, 0, e.bounds.width, -n, +n),
                            i = Ut(this.invertsY_ ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -n, +n);
                        this.value.setRawValue(new Tr(r, i), t)
                    }
                    onPointerDown_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPointerMove_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPointerUp_(e) {
                        this.handlePointerEvent_(e.data, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                    onPadKeyDown_(e) {
                        It(e.key) && e.preventDefault();
                        const [t, n] = Pr(e, this.baseSteps_, this.invertsY_);
                        0 === t && 0 === n || this.value.setRawValue(new Tr(this.value.rawValue.x + t, this.value.rawValue.y + n), {
                            forceEmit: !1,
                            last: !1
                        })
                    }
                    onPadKeyUp_(e) {
                        const [t, n] = Pr(e, this.baseSteps_, this.invertsY_);
                        0 === t && 0 === n || this.value.setRawValue(this.value.rawValue, {
                            forceEmit: !0,
                            last: !0
                        })
                    }
                }
                class Or {
                    constructor(e, t) {
                        var n, r;
                        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.foldable_ = Z.create(t.expanded), this.popC_ = "popup" === t.pickerLayout ? new Je(e, {
                            viewProps: this.viewProps
                        }) : null;
                        const i = new Dr(e, {
                            baseSteps: [t.axes[0].baseStep, t.axes[1].baseStep],
                            invertsY: t.invertsY,
                            layout: t.pickerLayout,
                            maxValue: t.maxValue,
                            value: this.value,
                            viewProps: this.viewProps
                        });
                        i.view.allFocusableElements.forEach((e => {
                            e.addEventListener("blur", this.onPopupChildBlur_), e.addEventListener("keydown", this.onPopupChildKeydown_)
                        })), this.pickerC_ = i, this.textC_ = new yr(e, {
                            assembly: Er,
                            axes: t.axes,
                            parser: t.parser,
                            value: this.value,
                            viewProps: this.viewProps
                        }), this.view = new Cr(e, {
                            expanded: this.foldable_.value("expanded"),
                            pickerLayout: t.pickerLayout,
                            viewProps: this.viewProps
                        }), this.view.textElement.appendChild(this.textC_.view.element), null === (n = this.view.buttonElement) || void 0 === n || n.addEventListener("blur", this.onPadButtonBlur_), null === (r = this.view.buttonElement) || void 0 === r || r.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Pt({
                            primary: this.foldable_.value("expanded"),
                            secondary: this.popC_.shows,
                            forward: e => e.rawValue,
                            backward: (e, t) => t.rawValue
                        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), $(this.foldable_, this.view.pickerElement))
                    }
                    onPadButtonBlur_(e) {
                        if (!this.popC_) return;
                        const t = this.view.element,
                            n = e.relatedTarget;
                        n && t.contains(n) || (this.popC_.shows.rawValue = !1)
                    }
                    onPadButtonClick_() {
                        this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
                    }
                    onPopupChildBlur_(e) {
                        if (!this.popC_) return;
                        const t = this.popC_.view.element,
                            n = G(e);
                        n && t.contains(n) || n && n === this.view.buttonElement && !F(t.ownerDocument) || (this.popC_.shows.rawValue = !1)
                    }
                    onPopupChildKeydown_(e) {
                        this.popC_ ? "Escape" === e.key && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && "Escape" === e.key && this.view.buttonElement.focus()
                    }
                }

                function Lr(e) {
                    return Tr.isObject(e) ? new Tr(e.x, e.y) : new Tr
                }

                function Ir(e, t) {
                    e.writeProperty("x", t.x), e.writeProperty("y", t.y)
                }

                function Fr(e) {
                    if (!e) return;
                    const t = [];
                    return o(e.step) || t.push(new We(e.step)), o(e.max) && o(e.min) || t.push(new He({
                        max: e.max,
                        min: e.min
                    })), new ze(t)
                }

                function Nr(e, t) {
                    const n = e && Ve(e, He);
                    if (n) return Math.max(Math.abs(n.minValue || 0), Math.abs(n.maxValue || 0));
                    const r = on(e);
                    return Math.max(10 * Math.abs(r), 10 * Math.abs(t))
                }

                function Ur(e, t) {
                    const n = t instanceof vr ? t.components[0] : void 0,
                        r = t instanceof vr ? t.components[1] : void 0,
                        i = Nr(n, e.x),
                        s = Nr(r, e.y);
                    return Math.max(i, s)
                }

                function Br(e, t) {
                    return {
                        baseStep: on(t),
                        constraint: t,
                        textProps: E.fromObject({
                            draggingScale: an(t, e),
                            formatter: St(sn(t, e))
                        })
                    }
                }

                function jr(e) {
                    if (!("y" in e)) return !1;
                    const t = e.y;
                    return !!t && "inverted" in t && !!t.inverted
                }
                const zr = {
                    id: "input-point2d",
                    type: "input",
                    accept: (e, t) => {
                        if (!Tr.isObject(e)) return null;
                        const n = R,
                            r = k(t, {
                                expanded: n.optional.boolean,
                                picker: n.optional.custom(Qt),
                                x: n.optional.custom(en),
                                y: n.optional.object({
                                    inverted: n.optional.boolean,
                                    max: n.optional.number,
                                    min: n.optional.number,
                                    step: n.optional.number
                                })
                            });
                        return r ? {
                            initialValue: e,
                            params: r
                        } : null
                    },
                    binding: {
                        reader: e => Lr,
                        constraint: e => {
                            return t = e.params, new vr({
                                assembly: Er,
                                components: [Fr("x" in t ? t.x : void 0), Fr("y" in t ? t.y : void 0)]
                            });
                            var t
                        },
                        equals: Tr.equals,
                        writer: e => Ir
                    },
                    controller: e => {
                        const t = e.document,
                            n = e.value,
                            r = e.constraint;
                        if (!(r instanceof vr)) throw c.shouldNeverHappen();
                        const i = "expanded" in e.params ? e.params.expanded : void 0,
                            s = "picker" in e.params ? e.params.picker : void 0;
                        return new Or(t, {
                            axes: [Br(n.rawValue.x, r.components[0]), Br(n.rawValue.y, r.components[1])],
                            expanded: null != i && i,
                            invertsY: jr(e.params),
                            maxValue: Ur(n.rawValue, r),
                            parser: xt,
                            pickerLayout: null != s ? s : "popup",
                            value: n,
                            viewProps: e.viewProps
                        })
                    }
                };
                class Vr {
                    constructor(e = 0, t = 0, n = 0) {
                        this.x = e, this.y = t, this.z = n
                    }
                    getComponents() {
                        return [this.x, this.y, this.z]
                    }
                    static isObject(e) {
                        if (o(e)) return !1;
                        const t = e.x,
                            n = e.y,
                            r = e.z;
                        return "number" == typeof t && "number" == typeof n && "number" == typeof r
                    }
                    static equals(e, t) {
                        return e.x === t.x && e.y === t.y && e.z === t.z
                    }
                    toObject() {
                        return {
                            x: this.x,
                            y: this.y,
                            z: this.z
                        }
                    }
                }
                const Gr = {
                    toComponents: e => e.getComponents(),
                    fromComponents: e => new Vr(...e)
                };

                function Hr(e) {
                    return Vr.isObject(e) ? new Vr(e.x, e.y, e.z) : new Vr
                }

                function Wr(e, t) {
                    e.writeProperty("x", t.x), e.writeProperty("y", t.y), e.writeProperty("z", t.z)
                }

                function Kr(e) {
                    if (!e) return;
                    const t = [];
                    return o(e.step) || t.push(new We(e.step)), o(e.max) && o(e.min) || t.push(new He({
                        max: e.max,
                        min: e.min
                    })), new ze(t)
                }

                function Xr(e, t) {
                    return {
                        baseStep: on(t),
                        constraint: t,
                        textProps: E.fromObject({
                            draggingScale: an(t, e),
                            formatter: St(sn(t, e))
                        })
                    }
                }
                const qr = {
                    id: "input-point3d",
                    type: "input",
                    accept: (e, t) => {
                        if (!Vr.isObject(e)) return null;
                        const n = R,
                            r = k(t, {
                                x: n.optional.custom(en),
                                y: n.optional.custom(en),
                                z: n.optional.custom(en)
                            });
                        return r ? {
                            initialValue: e,
                            params: r
                        } : null
                    },
                    binding: {
                        reader: e => Hr,
                        constraint: e => {
                            return t = e.params, new vr({
                                assembly: Gr,
                                components: [Kr("x" in t ? t.x : void 0), Kr("y" in t ? t.y : void 0), Kr("z" in t ? t.z : void 0)]
                            });
                            var t
                        },
                        equals: Vr.equals,
                        writer: e => Wr
                    },
                    controller: e => {
                        const t = e.value,
                            n = e.constraint;
                        if (!(n instanceof vr)) throw c.shouldNeverHappen();
                        return new yr(e.document, {
                            assembly: Gr,
                            axes: [Xr(t.rawValue.x, n.components[0]), Xr(t.rawValue.y, n.components[1]), Xr(t.rawValue.z, n.components[2])],
                            parser: xt,
                            value: t,
                            viewProps: e.viewProps
                        })
                    }
                };
                class Yr {
                    constructor(e = 0, t = 0, n = 0, r = 0) {
                        this.x = e, this.y = t, this.z = n, this.w = r
                    }
                    getComponents() {
                        return [this.x, this.y, this.z, this.w]
                    }
                    static isObject(e) {
                        if (o(e)) return !1;
                        const t = e.x,
                            n = e.y,
                            r = e.z,
                            i = e.w;
                        return "number" == typeof t && "number" == typeof n && "number" == typeof r && "number" == typeof i
                    }
                    static equals(e, t) {
                        return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
                    }
                    toObject() {
                        return {
                            x: this.x,
                            y: this.y,
                            z: this.z,
                            w: this.w
                        }
                    }
                }
                const Zr = {
                    toComponents: e => e.getComponents(),
                    fromComponents: e => new Yr(...e)
                };

                function Jr(e) {
                    return Yr.isObject(e) ? new Yr(e.x, e.y, e.z, e.w) : new Yr
                }

                function $r(e, t) {
                    e.writeProperty("x", t.x), e.writeProperty("y", t.y), e.writeProperty("z", t.z), e.writeProperty("w", t.w)
                }

                function Qr(e) {
                    if (!e) return;
                    const t = [];
                    return o(e.step) || t.push(new We(e.step)), o(e.max) && o(e.min) || t.push(new He({
                        max: e.max,
                        min: e.min
                    })), new ze(t)
                }
                const ei = {
                    id: "input-point4d",
                    type: "input",
                    accept: (e, t) => {
                        if (!Yr.isObject(e)) return null;
                        const n = R,
                            r = k(t, {
                                x: n.optional.custom(en),
                                y: n.optional.custom(en),
                                z: n.optional.custom(en),
                                w: n.optional.custom(en)
                            });
                        return r ? {
                            initialValue: e,
                            params: r
                        } : null
                    },
                    binding: {
                        reader: e => Jr,
                        constraint: e => {
                            return t = e.params, new vr({
                                assembly: Zr,
                                components: [Qr("x" in t ? t.x : void 0), Qr("y" in t ? t.y : void 0), Qr("z" in t ? t.z : void 0), Qr("w" in t ? t.w : void 0)]
                            });
                            var t
                        },
                        equals: Yr.equals,
                        writer: e => $r
                    },
                    controller: e => {
                        const t = e.value,
                            n = e.constraint;
                        if (!(n instanceof vr)) throw c.shouldNeverHappen();
                        return new yr(e.document, {
                            assembly: Zr,
                            axes: t.rawValue.getComponents().map(((e, t) => {
                                return r = e, {
                                    baseStep: on(i = n.components[t]),
                                    constraint: i,
                                    textProps: E.fromObject({
                                        draggingScale: an(i, r),
                                        formatter: St(sn(i, r))
                                    })
                                };
                                var r, i
                            })),
                            parser: xt,
                            value: t,
                            viewProps: e.viewProps
                        })
                    }
                };
                const ti = {
                        id: "input-string",
                        type: "input",
                        accept: (e, t) => {
                            if ("string" != typeof e) return null;
                            const n = k(t, {
                                options: R.optional.custom($t)
                            });
                            return n ? {
                                initialValue: e,
                                params: n
                            } : null
                        },
                        binding: {
                            reader: e => Et,
                            constraint: e => function(e) {
                                const t = [],
                                    n = nn(e.options);
                                return n && t.push(n), new ze(t)
                            }(e.params),
                            writer: e => Jt
                        },
                        controller: e => {
                            var t;
                            const n = e.document,
                                r = e.value,
                                i = e.constraint;
                            return i && Ve(i, Ge) ? new qe(n, {
                                props: E.fromObject({
                                    options: null !== (t = rn(i)) && void 0 !== t ? t : []
                                }),
                                value: r,
                                viewProps: e.viewProps
                            }) : new et(n, {
                                parser: e => e,
                                props: E.fromObject({
                                    formatter: At
                                }),
                                value: r,
                                viewProps: e.viewProps
                            })
                        }
                    },
                    ni = {
                        defaultInterval: 200,
                        defaultLineCount: 3
                    },
                    ri = f("mll");
                class ii {
                    constructor(e, t) {
                        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(ri()), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("textarea");
                        n.classList.add(ri("i")), n.style.height = `calc(var(--bld-us) * ${t.lineCount})`, n.readOnly = !0, t.viewProps.bindDisabled(n), this.element.appendChild(n), this.textareaElem_ = n, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_()
                    }
                    update_() {
                        const e = this.textareaElem_,
                            t = e.scrollTop === e.scrollHeight - e.clientHeight,
                            n = [];
                        this.value.rawValue.forEach((e => {
                            void 0 !== e && n.push(this.formatter_(e))
                        })), e.textContent = n.join("\n"), t && (e.scrollTop = e.scrollHeight)
                    }
                    onValueUpdate_() {
                        this.update_()
                    }
                }
                class si {
                    constructor(e, t) {
                        this.value = t.value, this.viewProps = t.viewProps, this.view = new ii(e, {
                            formatter: t.formatter,
                            lineCount: t.lineCount,
                            value: this.value,
                            viewProps: this.viewProps
                        })
                    }
                }
                const oi = f("sgl");
                class ai {
                    constructor(e, t) {
                        this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = t.formatter, this.element = e.createElement("div"), this.element.classList.add(oi()), t.viewProps.bindClassModifiers(this.element);
                        const n = e.createElement("input");
                        n.classList.add(oi("i")), n.readOnly = !0, n.type = "text", t.viewProps.bindDisabled(n), this.element.appendChild(n), this.inputElement = n, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_()
                    }
                    update_() {
                        const e = this.value.rawValue,
                            t = e[e.length - 1];
                        this.inputElement.value = void 0 !== t ? this.formatter_(t) : ""
                    }
                    onValueUpdate_() {
                        this.update_()
                    }
                }
                class li {
                    constructor(e, t) {
                        this.value = t.value, this.viewProps = t.viewProps, this.view = new ai(e, {
                            formatter: t.formatter,
                            value: this.value,
                            viewProps: this.viewProps
                        })
                    }
                }
                const ci = {
                    id: "monitor-bool",
                    type: "monitor",
                    accept: (e, t) => {
                        if ("boolean" != typeof e) return null;
                        const n = k(t, {
                            lineCount: R.optional.number
                        });
                        return n ? {
                            initialValue: e,
                            params: n
                        } : null
                    },
                    binding: {
                        reader: e => tt
                    },
                    controller: e => {
                        var t;
                        return 1 === e.value.rawValue.length ? new li(e.document, {
                            formatter: nt,
                            value: e.value,
                            viewProps: e.viewProps
                        }) : new si(e.document, {
                            formatter: nt,
                            lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ni.defaultLineCount,
                            value: e.value,
                            viewProps: e.viewProps
                        })
                    }
                };
                class ui {
                    constructor() {
                        this.emitter = new h, this.index_ = -1
                    }
                    get index() {
                        return this.index_
                    }
                    set index(e) {
                        this.index_ !== e && (this.index_ = e, this.emitter.emit("change", {
                            index: e,
                            sender: this
                        }))
                    }
                }
                const pi = f("grl");
                class hi {
                    constructor(e, t) {
                        this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = e.createElement("div"), this.element.classList.add(pi()), t.viewProps.bindClassModifiers(this.element), this.formatter_ = t.formatter, this.minValue_ = t.minValue, this.maxValue_ = t.maxValue, this.cursor_ = t.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
                        const n = e.createElementNS(L, "svg");
                        n.classList.add(pi("g")), n.style.height = `calc(var(--bld-us) * ${t.lineCount})`, this.element.appendChild(n), this.svgElem_ = n;
                        const r = e.createElementNS(L, "polyline");
                        this.svgElem_.appendChild(r), this.lineElem_ = r;
                        const i = e.createElement("div");
                        i.classList.add(pi("t"), f("tt")()), this.element.appendChild(i), this.tooltipElem_ = i, t.value.emitter.on("change", this.onValueUpdate_), this.value = t.value, this.update_()
                    }
                    get graphElement() {
                        return this.svgElem_
                    }
                    update_() {
                        const e = this.svgElem_.getBoundingClientRect(),
                            t = this.value.rawValue.length - 1,
                            n = this.minValue_,
                            r = this.maxValue_,
                            i = [];
                        this.value.rawValue.forEach(((s, o) => {
                            if (void 0 === s) return;
                            const a = Ut(o, 0, t, 0, e.width),
                                l = Ut(s, n, r, e.height, 0);
                            i.push([a, l].join(","))
                        })), this.lineElem_.setAttributeNS(null, "points", i.join(" "));
                        const s = this.tooltipElem_,
                            o = this.value.rawValue[this.cursor_.index];
                        if (void 0 === o) return void s.classList.remove(pi("t", "a"));
                        const a = Ut(this.cursor_.index, 0, t, 0, e.width),
                            l = Ut(o, n, r, e.height, 0);
                        s.style.left = `${a}px`, s.style.top = `${l}px`, s.textContent = `${this.formatter_(o)}`, s.classList.contains(pi("t", "a")) || (s.classList.add(pi("t", "a"), pi("t", "in")), I(s), s.classList.remove(pi("t", "in")))
                    }
                    onValueUpdate_() {
                        this.update_()
                    }
                    onCursorChange_() {
                        this.update_()
                    }
                }
                class di {
                    constructor(e, t) {
                        if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.value = t.value, this.viewProps = t.viewProps, this.cursor_ = new ui, this.view = new hi(e, {
                                cursor: this.cursor_,
                                formatter: t.formatter,
                                lineCount: t.lineCount,
                                maxValue: t.maxValue,
                                minValue: t.minValue,
                                value: this.value,
                                viewProps: this.viewProps
                            }), F(e)) {
                            const e = new Nt(this.view.element);
                            e.emitter.on("down", this.onGraphPointerDown_), e.emitter.on("move", this.onGraphPointerMove_), e.emitter.on("up", this.onGraphPointerUp_)
                        } else this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_)
                    }
                    onGraphMouseLeave_() {
                        this.cursor_.index = -1
                    }
                    onGraphMouseMove_(e) {
                        const t = this.view.element.getBoundingClientRect();
                        this.cursor_.index = Math.floor(Ut(e.offsetX, 0, t.width, 0, this.value.rawValue.length))
                    }
                    onGraphPointerDown_(e) {
                        this.onGraphPointerMove_(e)
                    }
                    onGraphPointerMove_(e) {
                        e.data.point ? this.cursor_.index = Math.floor(Ut(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length)) : this.cursor_.index = -1
                    }
                    onGraphPointerUp_() {
                        this.cursor_.index = -1
                    }
                }

                function fi(e) {
                    return "format" in e && !o(e.format) ? e.format : St(2)
                }

                function _i(e) {
                    return "view" in e && "graph" === e.view
                }
                const mi = {
                        id: "monitor-number",
                        type: "monitor",
                        accept: (e, t) => {
                            if ("number" != typeof e) return null;
                            const n = R,
                                r = k(t, {
                                    format: n.optional.function,
                                    lineCount: n.optional.number,
                                    max: n.optional.number,
                                    min: n.optional.number,
                                    view: n.optional.string
                                });
                            return r ? {
                                initialValue: e,
                                params: r
                            } : null
                        },
                        binding: {
                            defaultBufferSize: e => _i(e) ? 64 : 1,
                            reader: e => yt
                        },
                        controller: e => _i(e.params) ? function(e) {
                            var t, n, r;
                            return new di(e.document, {
                                formatter: fi(e.params),
                                lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ni.defaultLineCount,
                                maxValue: null !== (n = "max" in e.params ? e.params.max : null) && void 0 !== n ? n : 100,
                                minValue: null !== (r = "min" in e.params ? e.params.min : null) && void 0 !== r ? r : 0,
                                value: e.value,
                                viewProps: e.viewProps
                            })
                        }(e) : function(e) {
                            var t;
                            return 1 === e.value.rawValue.length ? new li(e.document, {
                                formatter: fi(e.params),
                                value: e.value,
                                viewProps: e.viewProps
                            }) : new si(e.document, {
                                formatter: fi(e.params),
                                lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ni.defaultLineCount,
                                value: e.value,
                                viewProps: e.viewProps
                            })
                        }(e)
                    },
                    gi = {
                        id: "monitor-string",
                        type: "monitor",
                        accept: (e, t) => {
                            if ("string" != typeof e) return null;
                            const n = R,
                                r = k(t, {
                                    lineCount: n.optional.number,
                                    multiline: n.optional.boolean
                                });
                            return r ? {
                                initialValue: e,
                                params: r
                            } : null
                        },
                        binding: {
                            reader: e => Et
                        },
                        controller: e => {
                            var t;
                            const n = e.value;
                            return n.rawValue.length > 1 || "multiline" in e.params && e.params.multiline ? new si(e.document, {
                                formatter: At,
                                lineCount: null !== (t = e.params.lineCount) && void 0 !== t ? t : ni.defaultLineCount,
                                value: n,
                                viewProps: e.viewProps
                            }) : new li(e.document, {
                                formatter: At,
                                value: n,
                                viewProps: e.viewProps
                            })
                        }
                    };
                class vi {
                    constructor(e) {
                        this.onValueChange_ = this.onValueChange_.bind(this), this.reader = e.reader, this.writer = e.writer, this.emitter = new h, this.value = e.value, this.value.emitter.on("change", this.onValueChange_), this.target = e.target, this.read()
                    }
                    read() {
                        const e = this.target.read();
                        void 0 !== e && (this.value.rawValue = this.reader(e))
                    }
                    write_(e) {
                        this.writer(this.target, e)
                    }
                    onValueChange_(e) {
                        this.write_(e.rawValue), this.emitter.emit("change", {
                            options: e.options,
                            rawValue: e.rawValue,
                            sender: this
                        })
                    }
                }
                class bi {
                    constructor(e) {
                        this.onTick_ = this.onTick_.bind(this), this.reader_ = e.reader, this.target = e.target, this.emitter = new h, this.value = e.value, this.ticker = e.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read()
                    }
                    dispose() {
                        this.ticker.dispose()
                    }
                    read() {
                        const e = this.target.read();
                        if (void 0 === e) return;
                        const t = this.value.rawValue,
                            n = this.reader_(e);
                        this.value.rawValue = function(e, t) {
                            const n = [...kt(e), t];
                            return n.length > e.length ? n.splice(0, n.length - e.length) : Ct(n, e.length), n
                        }(t, n), this.emitter.emit("update", {
                            rawValue: n,
                            sender: this
                        })
                    }
                    onTick_(e) {
                        this.read()
                    }
                }

                function xi(e, t) {
                    return 0 === t ? new Be : new je(e, null != t ? t : ni.defaultInterval)
                }
                class yi {
                    constructor() {
                        this.pluginsMap_ = {
                            blades: [],
                            inputs: [],
                            monitors: []
                        }
                    }
                    getAll() {
                        return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors]
                    }
                    register(e) {
                        "blade" === e.type ? this.pluginsMap_.blades.unshift(e) : "input" === e.type ? this.pluginsMap_.inputs.unshift(e) : "monitor" === e.type && this.pluginsMap_.monitors.unshift(e)
                    }
                    createInput(e, t, n) {
                        if (o(t.read())) throw new c({
                            context: {
                                key: t.key
                            },
                            type: "nomatchingcontroller"
                        });
                        const r = this.pluginsMap_.inputs.reduce(((r, i) => r || function(e, t) {
                            const n = e.accept(t.target.read(), t.params);
                            if (o(n)) return null;
                            const r = R,
                                i = {
                                    target: t.target,
                                    initialValue: n.initialValue,
                                    params: n.params
                                },
                                s = e.binding.reader(i),
                                a = e.binding.constraint ? e.binding.constraint(i) : void 0,
                                l = T(s(n.initialValue), {
                                    constraint: a,
                                    equals: e.binding.equals
                                }),
                                c = new vi({
                                    reader: s,
                                    target: t.target,
                                    value: l,
                                    writer: e.binding.writer(i)
                                }),
                                u = r.optional.boolean(t.params.disabled).value,
                                p = r.optional.boolean(t.params.hidden).value,
                                h = e.controller({
                                    constraint: a,
                                    document: t.document,
                                    initialValue: n.initialValue,
                                    params: n.params,
                                    value: c.value,
                                    viewProps: Ce.create({
                                        disabled: u,
                                        hidden: p
                                    })
                                }),
                                d = r.optional.string(t.params.label).value;
                            return new ne(t.document, {
                                binding: c,
                                blade: Y(),
                                props: E.fromObject({
                                    label: d || t.target.key
                                }),
                                valueController: h
                            })
                        }(i, {
                            document: e,
                            target: t,
                            params: n
                        })), null);
                        if (r) return r;
                        throw new c({
                            context: {
                                key: t.key
                            },
                            type: "nomatchingcontroller"
                        })
                    }
                    createMonitor(e, t, n) {
                        const r = this.pluginsMap_.monitors.reduce(((r, i) => r || function(e, t) {
                            var n, r, i;
                            const s = R,
                                a = e.accept(t.target.read(), t.params);
                            if (o(a)) return null;
                            const l = {
                                    target: t.target,
                                    initialValue: a.initialValue,
                                    params: a.params
                                },
                                c = e.binding.reader(l),
                                u = null !== (r = null !== (n = s.optional.number(t.params.bufferSize).value) && void 0 !== n ? n : e.binding.defaultBufferSize && e.binding.defaultBufferSize(a.params)) && void 0 !== r ? r : 1,
                                p = s.optional.number(t.params.interval).value,
                                h = new bi({
                                    reader: c,
                                    target: t.target,
                                    ticker: xi(t.document, p),
                                    value: Rt(u)
                                }),
                                d = s.optional.boolean(t.params.disabled).value,
                                f = s.optional.boolean(t.params.hidden).value,
                                _ = e.controller({
                                    document: t.document,
                                    params: a.params,
                                    value: h.value,
                                    viewProps: Ce.create({
                                        disabled: d,
                                        hidden: f
                                    })
                                }),
                                m = null !== (i = s.optional.string(t.params.label).value) && void 0 !== i ? i : t.target.key;
                            return new ie(t.document, {
                                binding: h,
                                blade: Y(),
                                props: E.fromObject({
                                    label: m
                                }),
                                valueController: _
                            })
                        }(i, {
                            document: e,
                            params: n,
                            target: t
                        })), null);
                        if (r) return r;
                        throw new c({
                            context: {
                                key: t.key
                            },
                            type: "nomatchingcontroller"
                        })
                    }
                    createBlade(e, t) {
                        const n = this.pluginsMap_.blades.reduce(((n, r) => n || function(e, t) {
                            const n = e.accept(t.params);
                            if (!n) return null;
                            const r = R.optional.boolean(t.params.disabled).value,
                                i = R.optional.boolean(t.params.hidden).value;
                            return e.controller({
                                blade: Y(),
                                document: t.document,
                                params: Object.assign(Object.assign({}, n.params), {
                                    disabled: r,
                                    hidden: i
                                }),
                                viewProps: Ce.create({
                                    disabled: r,
                                    hidden: i
                                })
                            })
                        }(r, {
                            document: e,
                            params: t
                        })), null);
                        if (!n) throw new c({
                            type: "nomatchingview",
                            context: {
                                params: t
                            }
                        });
                        return n
                    }
                    createBladeApi(e) {
                        if (e instanceof ne) return new te(e);
                        if (e instanceof ie) return new re(e);
                        if (e instanceof _e) return new le(e, this);
                        const t = this.pluginsMap_.blades.reduce(((t, n) => t || n.api({
                            controller: e,
                            pool: this
                        })), null);
                        if (!t) throw c.shouldNeverHappen();
                        return t
                    }
                }
                class wi extends t {
                    constructor(e) {
                        super(e), this.emitter_ = new h, this.controller_.valueController.value.emitter.on("change", (e => {
                            this.emitter_.emit("change", {
                                event: new r(this, e.rawValue)
                            })
                        }))
                    }
                    get label() {
                        return this.controller_.props.get("label")
                    }
                    set label(e) {
                        this.controller_.props.set("label", e)
                    }
                    get options() {
                        return this.controller_.valueController.props.get("options")
                    }
                    set options(e) {
                        this.controller_.valueController.props.set("options", e)
                    }
                    get value() {
                        return this.controller_.valueController.value.rawValue
                    }
                    set value(e) {
                        this.controller_.valueController.value.rawValue = e
                    }
                    on(e, t) {
                        const n = t.bind(this);
                        return this.emitter_.on(e, (e => {
                            n(e.event)
                        })), this
                    }
                }
                class Si extends t {
                    constructor(e) {
                        super(e), this.emitter_ = new h, this.controller_.valueController.value.emitter.on("change", (e => {
                            this.emitter_.emit("change", {
                                event: new r(this, e.rawValue)
                            })
                        }))
                    }
                    get label() {
                        return this.controller_.props.get("label")
                    }
                    set label(e) {
                        this.controller_.props.set("label", e)
                    }
                    get maxValue() {
                        return this.controller_.valueController.sliderController.props.get("maxValue")
                    }
                    set maxValue(e) {
                        this.controller_.valueController.sliderController.props.set("maxValue", e)
                    }
                    get minValue() {
                        return this.controller_.valueController.sliderController.props.get("minValue")
                    }
                    set minValue(e) {
                        this.controller_.valueController.sliderController.props.set("minValue", e)
                    }
                    get value() {
                        return this.controller_.valueController.value.rawValue
                    }
                    set value(e) {
                        this.controller_.valueController.value.rawValue = e
                    }
                    on(e, t) {
                        const n = t.bind(this);
                        return this.emitter_.on(e, (e => {
                            n(e.event)
                        })), this
                    }
                }
                class Mi extends t {
                    constructor(e) {
                        super(e), this.emitter_ = new h, this.controller_.valueController.value.emitter.on("change", (e => {
                            this.emitter_.emit("change", {
                                event: new r(this, e.rawValue)
                            })
                        }))
                    }
                    get label() {
                        return this.controller_.props.get("label")
                    }
                    set label(e) {
                        this.controller_.props.set("label", e)
                    }
                    get formatter() {
                        return this.controller_.valueController.props.get("formatter")
                    }
                    set formatter(e) {
                        this.controller_.valueController.props.set("formatter", e)
                    }
                    get value() {
                        return this.controller_.valueController.value.rawValue
                    }
                    set value(e) {
                        this.controller_.valueController.value.rawValue = e
                    }
                    on(e, t) {
                        const n = t.bind(this);
                        return this.emitter_.on(e, (e => {
                            n(e.event)
                        })), this
                    }
                }
                const Ti = {
                    id: "list",
                    type: "blade",
                    accept(e) {
                        const t = R,
                            n = k(e, {
                                options: t.required.custom($t),
                                value: t.required.raw,
                                view: t.required.constant("list"),
                                label: t.optional.string
                            });
                        return n ? {
                            params: n
                        } : null
                    },
                    controller(e) {
                        const t = new qe(e.document, {
                            props: E.fromObject({
                                options: tn(e.params.options)
                            }),
                            value: T(e.params.value),
                            viewProps: e.viewProps
                        });
                        return new xe(e.document, {
                            blade: e.blade,
                            props: E.fromObject({
                                label: e.params.label
                            }),
                            valueController: t
                        })
                    },
                    api: e => e.controller instanceof xe && e.controller.valueController instanceof qe ? new wi(e.controller) : null
                };
                class Ei extends ce {
                    constructor(e, t) {
                        super(e, t)
                    }
                    get element() {
                        return this.controller_.view.element
                    }
                    importPreset(e) {
                        (function(e, t) {
                            e.forEach((e => {
                                const n = t[e.presetKey];
                                void 0 !== n && e.write(n)
                            }))
                        })(this.controller_.rackController.rack.find(ne).map((e => e.binding.target)), e), this.refresh()
                    }
                    exportPreset() {
                        return this.controller_.rackController.rack.find(ne).map((e => e.binding.target)).reduce(((e, t) => Object.assign(e, {
                            [t.presetKey]: t.read()
                        })), {})
                    }
                    refresh() {
                        this.controller_.rackController.rack.find(ne).forEach((e => {
                            e.binding.read()
                        })), this.controller_.rackController.rack.find(ie).forEach((e => {
                            e.binding.read()
                        }))
                    }
                }
                class Ai extends ve {
                    constructor(e, t) {
                        super(e, {
                            expanded: t.expanded,
                            blade: t.blade,
                            props: t.props,
                            root: !0,
                            viewProps: t.viewProps
                        })
                    }
                }
                const Ci = {
                        id: "slider",
                        type: "blade",
                        accept(e) {
                            const t = R,
                                n = k(e, {
                                    max: t.required.number,
                                    min: t.required.number,
                                    view: t.required.constant("slider"),
                                    format: t.optional.function,
                                    label: t.optional.string,
                                    value: t.optional.number
                                });
                            return n ? {
                                params: n
                            } : null
                        },
                        controller(e) {
                            var t, n;
                            const r = null !== (t = e.params.value) && void 0 !== t ? t : 0,
                                i = new Zt(e.document, {
                                    baseStep: 1,
                                    parser: xt,
                                    sliderProps: E.fromObject({
                                        maxValue: e.params.max,
                                        minValue: e.params.min
                                    }),
                                    textProps: E.fromObject({
                                        draggingScale: an(void 0, r),
                                        formatter: null !== (n = e.params.format) && void 0 !== n ? n : wt
                                    }),
                                    value: T(r),
                                    viewProps: e.viewProps
                                });
                            return new xe(e.document, {
                                blade: e.blade,
                                props: E.fromObject({
                                    label: e.params.label
                                }),
                                valueController: i
                            })
                        },
                        api: e => e.controller instanceof xe && e.controller.valueController instanceof Zt ? new Si(e.controller) : null
                    },
                    Ri = {
                        id: "text",
                        type: "blade",
                        accept(e) {
                            const t = R,
                                n = k(e, {
                                    parse: t.required.function,
                                    value: t.required.raw,
                                    view: t.required.constant("text"),
                                    format: t.optional.function,
                                    label: t.optional.string
                                });
                            return n ? {
                                params: n
                            } : null
                        },
                        controller(e) {
                            var t;
                            const n = new et(e.document, {
                                parser: e.params.parse,
                                props: E.fromObject({
                                    formatter: null !== (t = e.params.format) && void 0 !== t ? t : e => String(e)
                                }),
                                value: T(e.params.value),
                                viewProps: e.viewProps
                            });
                            return new xe(e.document, {
                                blade: e.blade,
                                props: E.fromObject({
                                    label: e.params.label
                                }),
                                valueController: n
                            })
                        },
                        api: e => e.controller instanceof xe && e.controller.valueController instanceof et ? new Mi(e.controller) : null
                    };

                function ki(e, t, n) {
                    if (e.querySelector(`style[data-tp-style=${t}]`)) return;
                    const r = e.createElement("style");
                    r.dataset.tpStyle = t, r.textContent = n, e.head.appendChild(r)
                }
                const Pi = new class {
                    constructor(e) {
                        const [t, n] = e.split("-"), r = t.split(".");
                        this.major = parseInt(r[0], 10), this.minor = parseInt(r[1], 10), this.patch = parseInt(r[2], 10), this.prerelease = null != n ? n : null
                    }
                    toString() {
                        const e = [this.major, this.minor, this.patch].join(".");
                        return null !== this.prerelease ? [e, this.prerelease].join("-") : e
                    }
                }("3.0.8");
                e.BladeApi = t, e.ButtonApi = p, e.FolderApi = ce, e.InputBindingApi = te, e.ListApi = wi, e.MonitorBindingApi = re, e.Pane = class extends Ei {
                    constructor(e) {
                        var t;
                        const n = e || {},
                            r = null !== (t = n.document) && void 0 !== t ? t : N(),
                            i = function() {
                                const e = new yi;
                                return [zr, qr, ei, ti, Mr, gr, mr, _r, pn, ci, gi, mi, X, be, Te, Ue].forEach((t => {
                                    e.register(t)
                                })), e
                            }();
                        super(new Ai(r, {
                            expanded: n.expanded,
                            blade: Y(),
                            props: E.fromObject({
                                title: n.title
                            }),
                            viewProps: Ce.create()
                        }), i), this.pool_ = i, this.containerElem_ = n.container || function(e) {
                            const t = e.createElement("div");
                            return t.classList.add(f("dfw")()), e.body && e.body.appendChild(t), t
                        }(r), this.containerElem_.appendChild(this.element), this.doc_ = r, this.usesDefaultWrapper_ = !n.container, this.setUpDefaultPlugins_()
                    }
                    get document() {
                        if (!this.doc_) throw c.alreadyDisposed();
                        return this.doc_
                    }
                    dispose() {
                        const e = this.containerElem_;
                        if (!e) throw c.alreadyDisposed();
                        if (this.usesDefaultWrapper_) {
                            const t = e.parentElement;
                            t && t.removeChild(e)
                        }
                        this.containerElem_ = null, this.doc_ = null, super.dispose()
                    }
                    registerPlugin(e) {
                        ("plugin" in e ? [e.plugin] : "plugins" in e ? e.plugins : []).forEach((e => {
                            this.pool_.register(e), this.embedPluginStyle_(e)
                        }))
                    }
                    embedPluginStyle_(e) {
                        e.css && ki(this.document, `plugin-${e.id}`, e.css)
                    }
                    setUpDefaultPlugins_() {
                        ki(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor transparent;scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:transparent}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:transparent solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, #28292e);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, #adafb8);--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, #28292e);--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, #bbbcc4);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, #bbbcc4);--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_i,.tp-fldv_c>.tp-tabv>.tp-tabv_i{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a:before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_c{border-left:var(--cnt-bg) solid 4px}.tp-fldv_b:hover+.tp-fldv_c{border-left-color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_c{border-left-color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_c{border-left-color:var(--cnt-bg-a)}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv.tp-v-disabled{opacity:.5}.tp-tabv_i{align-items:flex-end;display:flex;overflow:hidden}.tp-tabv.tp-tabv-nop .tp-tabv_i{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_i::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{border-left:var(--cnt-bg) solid 4px;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p)}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:-2px;position:absolute;width:2px}.tp-tbiv_b{background-color:var(--cnt-bg);display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);width:100%}.tp-tbiv_b:hover{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active{background-color:var(--cnt-bg-a)}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) transparent transparent transparent;border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c,.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_i{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((e => {
                            this.embedPluginStyle_(e)
                        })), this.registerPlugin({
                            plugins: [Ci, Ti, Ue, Ri]
                        })
                    }
                }, e.SeparatorApi = ye, e.SliderApi = Si, e.TabApi = Le, e.TabPageApi = Oe, e.TextApi = Mi, e.TpChangeEvent = r, e.VERSION = Pi, Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }(t)
        },
        23: function(__unused_webpack_module, __webpackgi_exports__, __webpackgi_require__) {
            __webpackgi_require__.d(__webpackgi_exports__, {
                Q: function() {
                    return DRACOLoader2
                }
            });
            var three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpackgi_require__(365),
                three__WEBPACK_IMPORTED_MODULE_1__ = __webpackgi_require__(927);
            class DRACOLoader2 extends three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__._ {
                constructor(e) {
                    super(e), this.encoderPending = null, this.encoderConfig = {
                        type: "js"
                    }, this.setDecoderPath("https://cdn.jsdelivr.net/gh/google/draco@1.4.1/javascript/"), this.setDecoderConfig({
                        type: "js"
                    })
                }
                async loadAsync(e, t) {
                    const n = await super.loadAsync(e, t);
                    return n ? new three__WEBPACK_IMPORTED_MODULE_1__.Kj0(n, new three__WEBPACK_IMPORTED_MODULE_1__.Wid) : void 0
                }
                preload(e = !0, t = !1) {
                    return e && super.preload(), t && this.initEncoder(), this
                }
                async initEncoder() {
                    if (this.encoderPending) return this.encoderPending;
                    const useJS = "object" != typeof WebAssembly || "js" === this.encoderConfig.type,
                        librariesPending = [],
                        libLoader = this._loadLibrary.bind(this);
                    return useJS ? librariesPending.push(libLoader("draco_encoder.js", "text")) : (librariesPending.push(libLoader("draco_wasm_wrapper.js", "text")), librariesPending.push(libLoader("draco_encoder.wasm", "arraybuffer"))), this.encoderPending = Promise.all(librariesPending).then((libraries => {
                        var _a;
                        const jsContent = libraries[0];
                        return useJS || (this.encoderConfig.wasmBinary = libraries[1]), null === (_a = eval(jsContent + "\nDracoEncoderModule;")) || void 0 === _a ? void 0 : _a()
                    })), this.encoderPending
                }
                async initDecoder() {
                    var _a;
                    await this._initDecoder();
                    const jsContent = await fetch(this.workerSourceURL).then((async e => e.text())).then((e => {
                        const t = e.indexOf("/* worker */");
                        if (t < 1) throw new Error("unable to load decoder module");
                        return e.substring(0, t - 1)
                    }));
                    return null === (_a = eval(jsContent + "\nDracoDecoderModule;")) || void 0 === _a ? void 0 : _a()
                }
            }
        }
    },
    __webpackgi_module_cache__ = {};

function __webpackgi_require__(e) {
    var t = __webpackgi_module_cache__[e];
    if (void 0 !== t) return t.exports;
    var n = __webpackgi_module_cache__[e] = {
        id: e,
        exports: {}
    };
    return __webpackgi_modules__[e].call(n.exports, n, n.exports, __webpackgi_require__), n.exports
}
__webpackgi_require__.n = function(e) {
    var t = e && e.__esModule ? function() {
        return e.default
    } : function() {
        return e
    };
    return __webpackgi_require__.d(t, {
        a: t
    }), t
}, __webpackgi_require__.d = function(e, t) {
    for (var n in t) __webpackgi_require__.o(t, n) && !__webpackgi_require__.o(e, n) && Object.defineProperty(e, n, {
        enumerable: !0,
        get: t[n]
    })
}, __webpackgi_require__.o = function(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}, __webpackgi_require__.r = function(e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }), Object.defineProperty(e, "__esModule", {
        value: !0
    })
};
var __webpackgi_exports__ = {};
! function() {
    __webpackgi_require__.d(__webpackgi_exports__, {
        LY2: function() {
            return i.LY2
        },
        HRj: function() {
            return Zt
        },
        li4: function() {
            return XM
        },
        FO5: function() {
            return qM
        },
        Nlh: function() {
            return VM
        },
        QvI: function() {
            return Gs
        },
        JHp: function() {
            return so
        },
        bGH: function() {
            return i.bGH
        },
        NDo: function() {
            return i.NDo
        },
        gSk: function() {
            return i.gSk
        },
        WMw: function() {
            return i.WMw
        },
        OTo: function() {
            return i.OTo
        },
        Se2: function() {
            return i.Se2
        },
        cum: function() {
            return i.cum
        },
        Mig: function() {
            return i.Mig
        },
        B$7: function() {
            return Ns
        },
        i_9: function() {
            return i.i_9
        },
        m7l: function() {
            return i.m7l
        },
        sYA: function() {
            return i.sYA
        },
        Xcj: function() {
            return i.Xcj
        },
        mzJ: function() {
            return i.mzJ
        },
        ZZA: function() {
            return i.ZZA
        },
        $Ph: function() {
            return kc
        },
        T__: function() {
            return i.T__
        },
        HkE: function() {
            return i.HkE
        },
        tGC: function() {
            return i.tGC
        },
        g1S: function() {
            return Dx
        },
        I$C: function() {
            return jx
        },
        _HT: function() {
            return Dm
        },
        QIH: function() {
            return Us
        },
        ksm: function() {
            return Vs
        },
        jl_: function() {
            return ji
        },
        b7R: function() {
            return ns
        },
        BDV: function() {
            return Di
        },
        Ea_: function() {
            return Hi
        },
        qff: function() {
            return ji
        },
        tmC: function() {
            return Fi
        },
        BON: function() {
            return Rs
        },
        P40: function() {
            return $i
        },
        wLL: function() {
            return Ss
        },
        iHO: function() {
            return qi
        },
        BbS: function() {
            return i.BbS
        },
        kqm: function() {
            return i.kqm
        },
        Hmr: function() {
            return i.Hmr
        },
        SJI: function() {
            return i.SJI
        },
        mTL: function() {
            return i.mTL
        },
        y8_: function() {
            return i.y8_
        },
        _Li: function() {
            return i._Li
        },
        g56: function() {
            return q_
        },
        bj3: function() {
            return Y
        },
        z81: function() {
            return i.z81
        },
        _MY: function() {
            return i._MY
        },
        yEv: function() {
            return sx
        },
        dFZ: function() {
            return Cc
        },
        N$j: function() {
            return i.N$j
        },
        _YM: function() {
            return i._YM
        },
        TUj: function() {
            return i.TUj
        },
        ZzF: function() {
            return i.ZzF
        },
        qzb: function() {
            return P
        },
        GQ: function() {
            return i.GQ
        },
        nvb: function() {
            return i.nvb
        },
        DvJ: function() {
            return i.DvJ
        },
        fQA: function() {
            return i.fQA
        },
        cPz: function() {
            return Ta
        },
        TlE: function() {
            return i.TlE
        },
        u9r: function() {
            return i.u9r
        },
        s4_: function() {
            return i.s4_
        },
        T95: function() {
            return i.T95
        },
        CtF: function() {
            return i.CtF
        },
        V1s: function() {
            return i.V1s
        },
        jOv: function() {
            return nt
        },
        Rki: function() {
            return i.Rki
        },
        itZ: function() {
            return jc
        },
        qKx: function() {
            return zc
        },
        vlJ: function() {
            return $M
        },
        nPO: function() {
            return eT
        },
        zcQ: function() {
            return Ic
        },
        GH1: function() {
            return Nc
        },
        ROQ: function() {
            return i.ROQ
        },
        YN5: function() {
            return i.YN5
        },
        BVQ: function() {
            return i.BVQ
        },
        YT8: function() {
            return i.YT8
        },
        YGz: function() {
            return i.YGz
        },
        trn: function() {
            return i.trn
        },
        zf8: function() {
            return i.zf8
        },
        uWy: function() {
            return i.uWy
        },
        SUY: function() {
            return i.SUY
        },
        Ilk: function() {
            return i.Ilk
        },
        R2R: function() {
            return i.R2R
        },
        epp: function() {
            return i.epp
        },
        GD$: function() {
            return Bi
        },
        EB7: function() {
            return i.EB7
        },
        DqL: function() {
            return i.DqL
        },
        _3: function() {
            return i._3
        },
        b_z: function() {
            return i.b_z
        },
        OCn: function() {
            return iT
        },
        _am: function() {
            return i._am
        },
        kB7: function() {
            return Po
        },
        fY$: function() {
            return i.fY$
        },
        vxC: function() {
            return i.vxC
        },
        BtG: function() {
            return i.BtG
        },
        cBK: function() {
            return i.cBK
        },
        g8_: function() {
            return i.g8_
        },
        AXT: function() {
            return i.AXT
        },
        yj7: function() {
            return i.yj7
        },
        dYG: function() {
            return i.dYG
        },
        tm_: function() {
            return i.tm_
        },
        S2y: function() {
            return i.S2y
        },
        B02: function() {
            return i.B02
        },
        PeU: function() {
            return i.PeU
        },
        Hyl: function() {
            return i.Hyl
        },
        Wqd: function() {
            return i.Wqd
        },
        Xaj: function() {
            return i.Xaj
        },
        DUb: function() {
            return dm
        },
        dZ3: function() {
            return i.dZ3
        },
        m_w: function() {
            return i.m_w
        },
        fHI: function() {
            return i.fHI
        },
        LBq: function() {
            return i.LBq
        },
        dHf: function() {
            return BM
        },
        Qww: function() {
            return hr.Q
        },
        CGV: function() {
            return jM
        },
        JUT: function() {
            return i.JUT
        },
        p3g: function() {
            return i.p3g
        },
        IEO: function() {
            return i.IEO
        },
        CN8: function() {
            return i.CN8
        },
        zob: function() {
            return i.zob
        },
        yxD: function() {
            return i.yxD
        },
        CUS: function() {
            return ox
        },
        A5E: function() {
            return i.A5E
        },
        zqG: function() {
            return j_
        },
        PfX: function() {
            return us
        },
        Q1o: function() {
            return ts
        },
        jfJ: function() {
            return i.jfJ
        },
        T_J: function() {
            return i.T_J
        },
        tEQ: function() {
            return i.tEQ
        },
        gb4: function() {
            return Pi
        },
        qkB: function() {
            return i.qkB
        },
        cvk: function() {
            return mu
        },
        HWo: function() {
            return vu
        },
        brP: function() {
            return i.brP
        },
        $YQ: function() {
            return i.$YQ
        },
        yNB: function() {
            return Fo
        },
        h7x: function() {
            return Pa
        },
        Ox3: function() {
            return i.Ox3
        },
        qtn: function() {
            return Is
        },
        cBI: function() {
            return i.cBI
        },
        cU9: function() {
            return i.cU9
        },
        DT1: function() {
            return i.DT1
        },
        Kgo: function() {
            return i.Kgo
        },
        ehD: function() {
            return i.ehD
        },
        fhJ: function() {
            return cm
        },
        y1s: function() {
            return um
        },
        fSK: function() {
            return i.fSK
        },
        Vdb: function() {
            return i.Vdb
        },
        l8J: function() {
            return i.l8J
        },
        dj0: function() {
            return i.dj0
        },
        QM0: function() {
            return i.QM0
        },
        OIS: function() {
            return ab
        },
        q8b: function() {
            return fc
        },
        TOt: function() {
            return i.TOt
        },
        xaN: function() {
            return f
        },
        Ny0: function() {
            return i.Ny0
        },
        Zof: function() {
            return ps
        },
        eD: function() {
            return i.eD
        },
        jwo: function() {
            return i.jwo
        },
        dSO: function() {
            return i.dSO
        },
        Bf4: function() {
            return i.Bf4
        },
        USm: function() {
            return i.USm
        },
        pBf: function() {
            return i.pBf
        },
        $Vf: function() {
            return i.$Vf
        },
        O7d: function() {
            return i.O7d
        },
        ksq: function() {
            return Ob
        },
        gXf: function() {
            return z_
        },
        hH6: function() {
            return i.hH6
        },
        esl: function() {
            return i.esl
        },
        e62: function() {
            return i.e62
        },
        a$l: function() {
            return i.a$l
        },
        OM3: function() {
            return i.OM3
        },
        VzW: function() {
            return i.VzW
        },
        ybr: function() {
            return i.ybr
        },
        yo9: function() {
            return i.yo9
        },
        Zxw: function() {
            return i.Zxw
        },
        JfN: function() {
            return i.JfN
        },
        $Bt: function() {
            return Ea
        },
        Wzm: function() {
            return i.Wzm
        },
        Wl3: function() {
            return i.Wl3
        },
        iWj: function() {
            return i.iWj
        },
        DNz: function() {
            return $_
        },
        m1M: function() {
            return Ys
        },
        ylh: function() {
            return i.ylh
        },
        v9Y: function() {
            return i.v9Y
        },
        LSk: function() {
            return i.LSk
        },
        LHE: function() {
            return wc
        },
        KE0: function() {
            return bM
        },
        KCF: function() {
            return vM
        },
        a4n: function() {
            return Px
        },
        zIH: function() {
            return qn
        },
        Hfk: function() {
            return ar
        },
        png: function() {
            return or
        },
        Eb_: function() {
            return lr
        },
        BT2: function() {
            return Bb
        },
        _8p: function() {
            return kx
        },
        hkn: function() {
            return Ut
        },
        GFY: function() {
            return Ws
        },
        w$m: function() {
            return i.w$m
        },
        ksN: function() {
            return i.ksN
        },
        j4z: function() {
            return i.j4z
        },
        OAl: function() {
            return i.OAl
        },
        VLJ: function() {
            return i.VLJ
        },
        C73: function() {
            return Z_
        },
        ZAu: function() {
            return i.ZAu
        },
        ibP: function() {
            return Gi
        },
        _fI: function() {
            return Bi
        },
        hUN: function() {
            return tu
        },
        cLu: function() {
            return i.cLu
        },
        vmT: function() {
            return i.vmT
        },
        Qpg: function() {
            return i.Qpg
        },
        So8: function() {
            return i.So8
        },
        eOv: function() {
            return DC
        },
        Wjw: function() {
            return i.Wjw
        },
        cJO: function() {
            return i.cJO
        },
        QRU: function() {
            return i.QRU
        },
        S3k: function() {
            return i.S3k
        },
        PpQ: function() {
            return i.PpQ
        },
        AHu: function() {
            return i.AHu
        },
        q_9: function() {
            return $t
        },
        ZRs: function() {
            return i.ZRs
        },
        oqc: function() {
            return i.oqc
        },
        T_x: function() {
            return Ii
        },
        lb7: function() {
            return i.lb7
        },
        L5s: function() {
            return i.L5s
        },
        $TI: function() {
            return i.$TI
        },
        SPe: function() {
            return i.SPe
        },
        aVm: function() {
            return i.aVm
        },
        j87: function() {
            return i.j87
        },
        RNb: function() {
            return i.RNb
        },
        Kz5: function() {
            return i.Kz5
        },
        vpT: function() {
            return i.vpT
        },
        kB5: function() {
            return i.kB5
        },
        _C8: function() {
            return i._C8
        },
        Syv: function() {
            return i.Syv
        },
        NMF: function() {
            return i.NMF
        },
        pIN: function() {
            return i.pIN
        },
        eMJ: function() {
            return i.eMJ
        },
        rN7: function() {
            return O_
        },
        iUp: function() {
            return L_
        },
        GFd: function() {
            return ix
        },
        x5V: function() {
            return i.x5V
        },
        tUh: function() {
            return i.tUh
        },
        z8B: function() {
            return i.z8B
        },
        GZb: function() {
            return i.GZb
        },
        p7y: function() {
            return i.p7y
        },
        S9g: function() {
            return i.S9g
        },
        Zr5: function() {
            return i.Zr5
        },
        vCF: function() {
            return i.vCF
        },
        yt0: function() {
            return i.yt0
        },
        uXU: function() {
            return i.uXU
        },
        _kC: function() {
            return i._kC
        },
        lk7: function() {
            return i.lk7
        },
        x12: function() {
            return i.x12
        },
        Zzh: function() {
            return i.Zzh
        },
        nls: function() {
            return i.nls
        },
        g_z: function() {
            return i.g_z
        },
        U7: function() {
            return i.U7
        },
        FT0: function() {
            return i.FT0
        },
        blk: function() {
            return i.blk
        },
        ejS: function() {
            return i.ejS
        },
        rnI: function() {
            return i.rnI
        },
        wem: function() {
            return i.wem
        },
        lfu: function() {
            return i.lfu
        },
        FDw: function() {
            return i.FDw
        },
        lRj: function() {
            return i.lRj
        },
        D1R: function() {
            return i.D1R
        },
        qyh: function() {
            return i.qyh
        },
        GUF: function() {
            return i.GUF
        },
        EoG: function() {
            return i.EoG
        },
        aNw: function() {
            return i.aNw
        },
        Zp0: function() {
            return i.Zp0
        },
        lLk: function() {
            return i.lLk
        },
        jAl: function() {
            return i.jAl
        },
        uEv: function() {
            return i.uEv
        },
        YKA: function() {
            return i.YKA
        },
        cRx: function() {
            return i.cRx
        },
        Y8D: function() {
            return i.Y8D
        },
        RsA: function() {
            return i.RsA
        },
        Y0m: function() {
            return Vb
        },
        F5T: function() {
            return i.F5T
        },
        EDU: function() {
            return lT
        },
        z$Q: function() {
            return RA
        },
        KA8: function() {
            return Vt
        },
        XUj: function() {
            return kA
        },
        Me$: function() {
            return PA
        },
        u7G: function() {
            return i.u7G
        },
        PEk: function() {
            return Jt
        },
        BG4: function() {
            return aT
        },
        M8C: function() {
            return i.M8C
        },
        Vkp: function() {
            return i.Vkp
        },
        yGw: function() {
            return i.yGw
        },
        Sm8: function() {
            return i.Sm8
        },
        Kj0: function() {
            return i.Kj0
        },
        vBJ: function() {
            return i.vBJ
        },
        lRF: function() {
            return i.lRF
        },
        Lun: function() {
            return i.Lun
        },
        YBo: function() {
            return i.YBo
        },
        kaV: function() {
            return i.kaV
        },
        RSm: function() {
            return i.RSm
        },
        xoR: function() {
            return i.xoR
        },
        EJi: function() {
            return i.EJi
        },
        Wid: function() {
            return i.Wid
        },
        iuj: function() {
            return Kt
        },
        IKL: function() {
            return i.IKL
        },
        r_: function() {
            return i.r_
        },
        OoA: function() {
            return i.OoA
        },
        qhX: function() {
            return i.qhX
        },
        qPT: function() {
            return oo
        },
        M5h: function() {
            return i.M5h
        },
        Ns1: function() {
            return i.Ns1
        },
        TyD: function() {
            return i.TyD
        },
        vZf: function() {
            return i.vZf
        },
        HTd: function() {
            return i.HTd
        },
        aH4: function() {
            return i.aH4
        },
        YLQ: function() {
            return i.YLQ
        },
        BVF: function() {
            return i.BVF
        },
        MyG: function() {
            return i.MyG
        },
        jFi: function() {
            return i.jFi
        },
        aCh: function() {
            return i.aCh
        },
        uL9: function() {
            return i.uL9
        },
        TNj: function() {
            return xu
        },
        IFH: function() {
            return i.IFH
        },
        bdR: function() {
            return i.bdR
        },
        kM_: function() {
            return Do
        },
        M6v: function() {
            return i.M6v
        },
        RvT: function() {
            return i.RvT
        },
        dUE: function() {
            return i.dUE
        },
        oe_: function() {
            return ex
        },
        BuN: function() {
            return tx
        },
        Tme: function() {
            return i.Tme
        },
        N9P: function() {
            return it
        },
        Gql: function() {
            return i.Gql
        },
        $XY: function() {
            return Zn
        },
        O9d: function() {
            return No
        },
        zEO: function() {
            return rt
        },
        qfx: function() {
            return FA
        },
        PA7: function() {
            return i.PA7
        },
        REq: function() {
            return i.REq
        },
        pQR: function() {
            return i.pQR
        },
        ghN: function() {
            return i.ghN
        },
        Hy8: function() {
            return i.Hy8
        },
        Wpd: function() {
            return i.Wpd
        },
        LgZ: function() {
            return i.LgZ
        },
        iWC: function() {
            return i.iWC
        },
        mqn: function() {
            return WC
        },
        iKG: function() {
            return i.iKG
        },
        _iA: function() {
            return i._iA
        },
        ntZ: function() {
            return i.ntZ
        },
        anP: function() {
            return i.anP
        },
        X2e: function() {
            return NM
        },
        FCo: function() {
            return BA
        },
        jjw: function() {
            return i.jjw
        },
        y$t: function() {
            return i.y$t
        },
        cPb: function() {
            return i.cPb
        },
        lmx: function() {
            return Ca
        },
        JOQ: function() {
            return i.JOQ
        },
        BKK: function() {
            return i.BKK
        },
        _12: function() {
            return i._12
        },
        tJx: function() {
            return i.tJx
        },
        cek: function() {
            return i.cek
        },
        xG9: function() {
            return i.xG9
        },
        woe: function() {
            return i.woe
        },
        UY4: function() {
            return i.UY4
        },
        aq0: function() {
            return i.aq0
        },
        ujx: function() {
            return i.ujx
        },
        Uol: function() {
            return i.Uol
        },
        JiH: function() {
            return KA
        },
        VYz: function() {
            return i.VYz
        },
        EsW: function() {
            return co
        },
        iUV: function() {
            return i.iUV
        },
        tf: function() {
            return i.tf
        },
        ZQ6: function() {
            return i.ZQ6
        },
        mXe: function() {
            return i.mXe
        },
        _fP: function() {
            return i._fP
        },
        iLg: function() {
            return i.iLg
        },
        zbs: function() {
            return i.zbs
        },
        UZH: function() {
            return i.UZH
        },
        mSO: function() {
            return i.mSO
        },
        wk1: function() {
            return i.wk1
        },
        E2K: function() {
            return i.E2K
        },
        FUD: function() {
            return i.FUD
        },
        pKu: function() {
            return i.pKu
        },
        GG6: function() {
            return i.GG6
        },
        Gih: function() {
            return i.Gih
        },
        iiP: function() {
            return i.iiP
        },
        SvJ: function() {
            return i.SvJ
        },
        ptH: function() {
            return i.ptH
        },
        jZA: function() {
            return i.jZA
        },
        y2t: function() {
            return i.y2t
        },
        gi4: function() {
            return i.gi4
        },
        Djp: function() {
            return i.Djp
        },
        BG$: function() {
            return i.BG$
        },
        NYV: function() {
            return i.NYV
        },
        xJs: function() {
            return i.xJs
        },
        bsb: function() {
            return i.bsb
        },
        ekQ: function() {
            return i.ekQ
        },
        CaW: function() {
            return i.CaW
        },
        eaV: function() {
            return i.eaV
        },
        BFQ: function() {
            return i.BFQ
        },
        v3W: function() {
            return i.v3W
        },
        ILR: function() {
            return i.ILR
        },
        UCm: function() {
            return i.UCm
        },
        Inb: function() {
            return i.Inb
        },
        LgE: function() {
            return i.LgE
        },
        fto: function() {
            return i.fto
        },
        l0P: function() {
            return i.l0P
        },
        vCx: function() {
            return i.vCx
        },
        _AM: function() {
            return i._AM
        },
        wuA: function() {
            return i.wuA
        },
        av9: function() {
            return i.av9
        },
        CtA: function() {
            return i.CtA
        },
        BvQ: function() {
            return Yc
        },
        FZJ: function() {
            return $c
        },
        FIo: function() {
            return i.FIo
        },
        zHn: function() {
            return i.zHn
        },
        iMs: function() {
            return i.iMs
        },
        T_f: function() {
            return i.T_f
        },
        hEm: function() {
            return i.hEm
        },
        D9w: function() {
            return i.D9w
        },
        sHH: function() {
            return K_
        },
        CdI: function() {
            return i.CdI
        },
        rpg: function() {
            return i.rpg
        },
        ce8: function() {
            return i.ce8
        },
        rOj: function() {
            return i.rOj
        },
        P6m: function() {
            return Ub
        },
        JA6: function() {
            return Nb
        },
        V4E: function() {
            return i.V4E
        },
        o8S: function() {
            return i.o8S
        },
        flB: function() {
            return _t
        },
        DUH: function() {
            return UM
        },
        KI_: function() {
            return i.KI_
        },
        iLN: function() {
            return ko
        },
        jsw: function() {
            return tm
        },
        i6Z: function() {
            return To
        },
        vfv: function() {
            return zb
        },
        xsS: function() {
            return i.xsS
        },
        ov0: function() {
            return Ma
        },
        cQH: function() {
            return tt
        },
        WdD: function() {
            return i.WdD
        },
        Vj0: function() {
            return i.Vj0
        },
        jyz: function() {
            return i.jyz
        },
        Mn1: function() {
            return Lt
        },
        Hlq: function() {
            return Ft
        },
        Fi7: function() {
            return H_
        },
        Tn7: function() {
            return i.Tn7
        },
        bnF: function() {
            return i.bnF
        },
        HW6: function() {
            return i.HW6
        },
        oa8: function() {
            return i.oa8
        },
        T_1: function() {
            return i.T_1
        },
        zHJ: function() {
            return HA
        },
        iDF: function() {
            return i.iDF
        },
        iAb: function() {
            return i.iAb
        },
        d4E: function() {
            return Nm
        },
        lBg: function() {
            return RC
        },
        JeJ: function() {
            return Um
        },
        FKY: function() {
            return r
        },
        zlZ: function() {
            return ax
        },
        vkg: function() {
            return tn
        },
        brh: function() {
            return lx
        },
        kZK: function() {
            return sC
        },
        puG: function() {
            return kC
        },
        OdW: function() {
            return i.OdW
        },
        _YX: function() {
            return i._YX
        },
        TUv: function() {
            return i.TUv
        },
        wcA: function() {
            return i.wcA
        },
        Hw6: function() {
            return i.Hw6
        },
        aLr: function() {
            return i.aLr
        },
        Aip: function() {
            return i.Aip
        },
        xo$: function() {
            return i.xo$
        },
        bIn: function() {
            return KC
        },
        $V: function() {
            return i.$V
        },
        lDi: function() {
            return i.lDi
        },
        gti: function() {
            return i.gti
        },
        PMe: function() {
            return i.PMe
        },
        iwP: function() {
            return Fs
        },
        FvO: function() {
            return i.FvO
        },
        jyi: function() {
            return i.jyi
        },
        xeV: function() {
            return i.xeV
        },
        k74: function() {
            return i.k74
        },
        RlZ: function() {
            return i.RlZ
        },
        KhW: function() {
            return i.KhW
        },
        HgB: function() {
            return i.HgB
        },
        W2J: function() {
            return i.W2J
        },
        JWc: function() {
            return i.JWc
        },
        u37: function() {
            return i.u37
        },
        Z6B: function() {
            return i.Z6B
        },
        QZ1: function() {
            return i.QZ1
        },
        Ir4: function() {
            return i.Ir4
        },
        NwF: function() {
            return i.NwF
        },
        Wbm: function() {
            return i.Wbm
        },
        N4l: function() {
            return i.N4l
        },
        ej9: function() {
            return jA
        },
        QmN: function() {
            return i.QmN
        },
        IOt: function() {
            return i.IOt
        },
        NOD: function() {
            return Lc
        },
        L5g: function() {
            return i.L5g
        },
        H$k: function() {
            return i.H$k
        },
        MP$: function() {
            return i.MP$
        },
        cuP: function() {
            return nC
        },
        xEZ: function() {
            return i.xEZ
        },
        dpR: function() {
            return i.dpR
        },
        wOD: function() {
            return ru
        },
        KNb: function() {
            return zs
        },
        Rk2: function() {
            return ho
        },
        IiN: function() {
            return fo
        },
        Cne: function() {
            return i.Cne
        },
        XvJ: function() {
            return i.XvJ
        },
        XZw: function() {
            return i.XZw
        },
        FE5: function() {
            return i.FE5
        },
        lVp: function() {
            return Ra
        },
        CJI: function() {
            return i.CJI
        },
        z$h: function() {
            return i.z$h
        },
        UlW: function() {
            return i.UlW
        },
        WwZ: function() {
            return i.WwZ
        },
        Lcc: function() {
            return i.Lcc
        },
        WXh: function() {
            return i.WXh
        },
        Vjr: function() {
            return zA
        },
        LuM: function() {
            return CC
        },
        LP5: function() {
            return bC
        },
        xfE: function() {
            return i.xfE
        },
        qlB: function() {
            return i.qlB
        },
        lCJ: function() {
            return i.lCJ
        },
        WTc: function() {
            return i.WTc
        },
        rAo: function() {
            return i.rAo
        },
        LZj: function() {
            return po
        },
        xWb: function() {
            return i.xWb
        },
        gH0: function() {
            return i.gH0
        },
        rBU: function() {
            return i.rBU
        },
        rDY: function() {
            return i.rDY
        },
        ywz: function() {
            return i.ywz
        },
        wJv: function() {
            return i.wJv
        },
        JQ4: function() {
            return i.JQ4
        },
        k0A: function() {
            return i.k0A
        },
        irR: function() {
            return i.irR
        },
        LsT: function() {
            return i.LsT
        },
        q5h: function() {
            return ks
        },
        TKh: function() {
            return Cs
        },
        tyg: function() {
            return As
        },
        Ro5: function() {
            return Ji
        },
        dwk: function() {
            return i.dwk
        },
        FM8: function() {
            return i.FM8
        },
        Pa4: function() {
            return i.Pa4
        },
        Ltg: function() {
            return i.Ltg
        },
        yC1: function() {
            return i.yC1
        },
        lHq: function() {
            return B_
        },
        fO1: function() {
            return i.fO1
        },
        oMA: function() {
            return ro
        },
        JzW: function() {
            return t
        },
        b5g: function() {
            return i.b5g
        },
        Ywn: function() {
            return i.Ywn
        },
        GVz: function() {
            return i.GVz
        },
        oAp: function() {
            return i.oAp
        },
        kFz: function() {
            return i.kFz
        },
        p7A: function() {
            return i.p7A
        },
        dd2: function() {
            return i.dd2
        },
        CP7: function() {
            return i.CP7
        },
        fQK: function() {
            return i.fQK
        },
        Wd$: function() {
            return Fm
        },
        Uk6: function() {
            return i.Uk6
        },
        _sL: function() {
            return i._sL
        },
        Pnf: function() {
            return i.Pnf
        },
        c8b: function() {
            return i.c8b
        },
        _lf: function() {
            return i._lf
        },
        ad5: function() {
            return i.ad5
        },
        sZV: function() {
            return Ms
        },
        TfA: function() {
            return ws
        },
        sKX: function() {
            return Os
        },
        UdM: function() {
            return ys
        },
        P0y: function() {
            return Xi
        },
        L_r: function() {
            return i.L_r
        },
        Bve: function() {
            return Om
        },
        UeO: function() {
            return dr
        },
        $nx: function() {
            return Ox
        },
        Bk6: function() {
            return $n
        },
        y4l: function() {
            return rn
        },
        pQ0: function() {
            return Ls
        },
        wXW: function() {
            return nE
        },
        r5x: function() {
            return QT
        },
        MSI: function() {
            return sE
        },
        jtH: function() {
            return dc
        },
        T0T: function() {
            return bc
        },
        gAb: function() {
            return YC
        },
        iwT: function() {
            return Vc
        },
        je_: function() {
            return ZC
        },
        wBP: function() {
            return vc
        },
        Zs7: function() {
            return SE
        },
        x7s: function() {
            return UE
        },
        d73: function() {
            return zT
        },
        RG9: function() {
            return X
        },
        mvg: function() {
            return VT
        },
        XMc: function() {
            return eE
        },
        N7M: function() {
            return JT
        },
        iv: function() {
            return rE
        },
        n55: function() {
            return bt
        },
        IaC: function() {
            return UT
        },
        $MY: function() {
            return eo
        },
        wJl: function() {
            return $s
        },
        zVI: function() {
            return WT
        },
        DpF: function() {
            return fu
        },
        nNb: function() {
            return zi
        },
        cqZ: function() {
            return Vi
        },
        KlC: function() {
            return Oo
        },
        KVn: function() {
            return L
        },
        oau: function() {
            return wE
        },
        aw9: function() {
            return qt
        },
        leS: function() {
            return pt
        },
        Dxg: function() {
            return y
        },
        O5A: function() {
            return mt
        },
        wCn: function() {
            return wt
        },
        Bi6: function() {
            return St
        },
        fi_: function() {
            return VE
        },
        TT: function() {
            return hE
        },
        q2Z: function() {
            return OC
        },
        NyK: function() {
            return Z
        },
        bgu: function() {
            return Tt
        },
        kcS: function() {
            return Mt
        },
        ivY: function() {
            return T
        },
        _HO: function() {
            return H
        },
        tpL: function() {
            return W
        },
        LjN: function() {
            return rs
        },
        iFs: function() {
            return is
        },
        qTg: function() {
            return v
        },
        Wtl: function() {
            return Oi
        },
        DmK: function() {
            return Li
        },
        Hx7: function() {
            return Te
        },
        imt: function() {
            return Se
        },
        US6: function() {
            return LE
        },
        vZs: function() {
            return Lo
        },
        lmu: function() {
            return vt
        },
        SvO: function() {
            return xt
        },
        omp: function() {
            return qA
        },
        utz: function() {
            return HT
        },
        TFV: function() {
            return io
        },
        hrz: function() {
            return w
        },
        JKM: function() {
            return fE
        },
        jZf: function() {
            return XC
        },
        RjL: function() {
            return xC
        },
        RRI: function() {
            return IE
        },
        RUq: function() {
            return rC
        },
        _t4: function() {
            return Je
        },
        YHh: function() {
            return $e
        },
        R8g: function() {
            return I
        },
        Bbl: function() {
            return en
        },
        V9r: function() {
            return b
        },
        PZ2: function() {
            return x
        },
        w7A: function() {
            return _
        },
        N6S: function() {
            return U
        },
        Uxp: function() {
            return B
        },
        tAz: function() {
            return N
        },
        R$F: function() {
            return z
        },
        N33: function() {
            return j
        },
        gw2: function() {
            return Bs
        },
        KlU: function() {
            return F
        },
        wo6: function() {
            return kt
        },
        H4P: function() {
            return M
        },
        swA: function() {
            return Wi
        },
        _Z3: function() {
            return Ki
        },
        ivc: function() {
            return zi
        },
        rZ1: function() {
            return Vi
        },
        CpZ: function() {
            return zE
        },
        dyc: function() {
            return E
        },
        MxZ: function() {
            return ZA
        },
        btp: function() {
            return JA
        },
        mXy: function() {
            return YA
        },
        Ej0: function() {
            return ct
        },
        ep4: function() {
            return Xt
        },
        DQP: function() {
            return ut
        },
        V7q: function() {
            return Et
        },
        zEk: function() {
            return Ot
        },
        qfq: function() {
            return At
        },
        piB: function() {
            return R
        },
        rrF: function() {
            return Ni
        },
        naq: function() {
            return Ui
        },
        p5I: function() {
            return gc
        },
        GpE: function() {
            return m
        },
        t$v: function() {
            return jT
        },
        tdn: function() {
            return Hc
        },
        Y9t: function() {
            return Wc
        },
        DH3: function() {
            return tE
        },
        uxM: function() {
            return cT
        },
        zH3: function() {
            return uT
        },
        MLs: function() {
            return Hs
        },
        le6: function() {
            return ot
        },
        s6f: function() {
            return st
        },
        YM4: function() {
            return mc
        },
        B3r: function() {
            return qC
        },
        iAx: function() {
            return pT
        },
        lDn: function() {
            return G
        },
        TIc: function() {
            return Rt
        },
        xsC: function() {
            return oE
        },
        zOc: function() {
            return Ct
        },
        r46: function() {
            return ME
        },
        z2C: function() {
            return C
        },
        _X$: function() {
            return Qt
        },
        _yn: function() {
            return It
        },
        Dyg: function() {
            return gt
        },
        cUc: function() {
            return Wt
        },
        Ctq: function() {
            return ZT
        },
        k5b: function() {
            return XT
        },
        kZl: function() {
            return pE
        },
        OCg: function() {
            return bE
        },
        YjH: function() {
            return NE
        },
        Ui8: function() {
            return cx
        },
        ij3: function() {
            return $T
        },
        YPW: function() {
            return qT
        },
        Bg1: function() {
            return FC
        },
        kon: function() {
            return S
        },
        F2z: function() {
            return BT
        },
        pJF: function() {
            return OA
        },
        knz: function() {
            return i.knz
        },
        Ejo: function() {
            return g
        },
        BgY: function() {
            return Ae
        },
        qCG: function() {
            return xe
        },
        HD9: function() {
            return Me
        },
        fEB: function() {
            return ye
        },
        Udc: function() {
            return dt
        },
        ZQg: function() {
            return ht
        },
        ofC: function() {
            return K
        },
        yRy: function() {
            return Pt
        },
        _NL: function() {
            return Lm
        },
        LCA: function() {
            return lt
        },
        j1w: function() {
            return at
        },
        i8J: function() {
            return nR
        },
        p7C: function() {
            return V_
        },
        ZAS: function() {
            return Xc
        },
        VWG: function() {
            return oT
        },
        pQ7: function() {
            return Gc
        },
        jc8: function() {
            return Ht
        },
        BL_: function() {
            return GT
        },
        T8U: function() {
            return ds
        },
        TD6: function() {
            return hs
        },
        akS: function() {
            return hT
        },
        QKE: function() {
            return dT
        },
        dKx: function() {
            return A
        },
        OvX: function() {
            return JC
        },
        VsW: function() {
            return _c
        },
        aPg: function() {
            return q
        },
        LFn: function() {
            return Dt
        },
        wey: function() {
            return NT
        },
        MaE: function() {
            return Xe
        },
        s4x: function() {
            return Ye
        },
        FJA: function() {
            return ze
        },
        vIA: function() {
            return Ke
        },
        Spv: function() {
            return Qe
        },
        w8l: function() {
            return Ze
        },
        riG: function() {
            return qe
        },
        Kbh: function() {
            return Ge
        },
        t8K: function() {
            return He
        },
        Q7n: function() {
            return Ve
        },
        KGF: function() {
            return We
        },
        e5: function() {
            return V
        },
        Rik: function() {
            return Ps
        },
        GZo: function() {
            return Ds
        },
        Bds: function() {
            return Qi
        },
        HTu: function() {
            return es
        },
        cTq: function() {
            return yt
        },
        X_Y: function() {
            return Qs
        },
        dA8: function() {
            return Js
        },
        bwS: function() {
            return YT
        },
        P4F: function() {
            return JM
        },
        Pd0: function() {
            return Jn
        },
        Pjo: function() {
            return KT
        },
        Tum: function() {
            return Qn
        },
        dRH: function() {
            return tr
        },
        RX0: function() {
            return er
        },
        cWm: function() {
            return iE
        },
        NC9: function() {
            return ZM
        },
        $Re: function() {
            return Ts
        },
        Xo9: function() {
            return Es
        },
        LNO: function() {
            return Yi
        },
        iZP: function() {
            return Zi
        }
    });
    var e = {};
    __webpackgi_require__.r(e), __webpackgi_require__.d(e, {
        KHR_DF_CHANNEL_RGBSDA_ALPHA: function() {
            return wp
        },
        KHR_DF_CHANNEL_RGBSDA_BLUE: function() {
            return bp
        },
        KHR_DF_CHANNEL_RGBSDA_DEPTH: function() {
            return yp
        },
        KHR_DF_CHANNEL_RGBSDA_GREEN: function() {
            return vp
        },
        KHR_DF_CHANNEL_RGBSDA_RED: function() {
            return gp
        },
        KHR_DF_CHANNEL_RGBSDA_STENCIL: function() {
            return xp
        },
        KHR_DF_FLAG_ALPHA_PREMULTIPLIED: function() {
            return Bu
        },
        KHR_DF_FLAG_ALPHA_STRAIGHT: function() {
            return Uu
        },
        KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT: function() {
            return Ru
        },
        KHR_DF_MODEL_ASTC: function() {
            return Fu
        },
        KHR_DF_MODEL_ETC1: function() {
            return Lu
        },
        KHR_DF_MODEL_ETC1S: function() {
            return Nu
        },
        KHR_DF_MODEL_ETC2: function() {
            return Iu
        },
        KHR_DF_MODEL_RGBSDA: function() {
            return Ou
        },
        KHR_DF_MODEL_UNSPECIFIED: function() {
            return Du
        },
        KHR_DF_PRIMARIES_ACES: function() {
            return pp
        },
        KHR_DF_PRIMARIES_ACESCC: function() {
            return hp
        },
        KHR_DF_PRIMARIES_ADOBERGB: function() {
            return mp
        },
        KHR_DF_PRIMARIES_BT2020: function() {
            return cp
        },
        KHR_DF_PRIMARIES_BT601_EBU: function() {
            return ap
        },
        KHR_DF_PRIMARIES_BT601_SMPTE: function() {
            return lp
        },
        KHR_DF_PRIMARIES_BT709: function() {
            return op
        },
        KHR_DF_PRIMARIES_CIEXYZ: function() {
            return up
        },
        KHR_DF_PRIMARIES_DISPLAYP3: function() {
            return _p
        },
        KHR_DF_PRIMARIES_NTSC1953: function() {
            return dp
        },
        KHR_DF_PRIMARIES_PAL525: function() {
            return fp
        },
        KHR_DF_PRIMARIES_UNSPECIFIED: function() {
            return sp
        },
        KHR_DF_SAMPLE_DATATYPE_EXPONENT: function() {
            return Tp
        },
        KHR_DF_SAMPLE_DATATYPE_FLOAT: function() {
            return Sp
        },
        KHR_DF_SAMPLE_DATATYPE_LINEAR: function() {
            return Ep
        },
        KHR_DF_SAMPLE_DATATYPE_SIGNED: function() {
            return Mp
        },
        KHR_DF_TRANSFER_ACESCC: function() {
            return np
        },
        KHR_DF_TRANSFER_ACESCCT: function() {
            return rp
        },
        KHR_DF_TRANSFER_ADOBERGB: function() {
            return ip
        },
        KHR_DF_TRANSFER_BT1886: function() {
            return Xu
        },
        KHR_DF_TRANSFER_DCIP3: function() {
            return $u
        },
        KHR_DF_TRANSFER_HLG_EOTF: function() {
            return Yu
        },
        KHR_DF_TRANSFER_HLG_OETF: function() {
            return qu
        },
        KHR_DF_TRANSFER_ITU: function() {
            return Gu
        },
        KHR_DF_TRANSFER_LINEAR: function() {
            return zu
        },
        KHR_DF_TRANSFER_NTSC: function() {
            return Hu
        },
        KHR_DF_TRANSFER_PAL625_EOTF: function() {
            return ep
        },
        KHR_DF_TRANSFER_PAL_OETF: function() {
            return Qu
        },
        KHR_DF_TRANSFER_PQ_EOTF: function() {
            return Zu
        },
        KHR_DF_TRANSFER_PQ_OETF: function() {
            return Ju
        },
        KHR_DF_TRANSFER_SLOG: function() {
            return Wu
        },
        KHR_DF_TRANSFER_SLOG2: function() {
            return Ku
        },
        KHR_DF_TRANSFER_SRGB: function() {
            return Vu
        },
        KHR_DF_TRANSFER_ST240: function() {
            return tp
        },
        KHR_DF_TRANSFER_UNSPECIFIED: function() {
            return ju
        },
        KHR_DF_VENDORID_KHRONOS: function() {
            return ku
        },
        KHR_DF_VERSION: function() {
            return Pu
        },
        KHR_SUPERCOMPRESSION_BASISLZ: function() {
            return Eu
        },
        KHR_SUPERCOMPRESSION_NONE: function() {
            return Tu
        },
        KHR_SUPERCOMPRESSION_ZLIB: function() {
            return Cu
        },
        KHR_SUPERCOMPRESSION_ZSTD: function() {
            return Au
        },
        KTX2Container: function() {
            return e_
        },
        VK_FORMAT_A1R5G5B5_UNORM_PACK16: function() {
            return Ip
        },
        VK_FORMAT_A2B10G10R10_SINT_PACK32: function() {
            return bh
        },
        VK_FORMAT_A2B10G10R10_SNORM_PACK32: function() {
            return gh
        },
        VK_FORMAT_A2B10G10R10_UINT_PACK32: function() {
            return vh
        },
        VK_FORMAT_A2B10G10R10_UNORM_PACK32: function() {
            return mh
        },
        VK_FORMAT_A2R10G10B10_SINT_PACK32: function() {
            return _h
        },
        VK_FORMAT_A2R10G10B10_SNORM_PACK32: function() {
            return dh
        },
        VK_FORMAT_A2R10G10B10_UINT_PACK32: function() {
            return fh
        },
        VK_FORMAT_A2R10G10B10_UNORM_PACK32: function() {
            return hh
        },
        VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: function() {
            return Qf
        },
        VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: function() {
            return $f
        },
        VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: function() {
            return Yf
        },
        VK_FORMAT_ASTC_10x10_SRGB_BLOCK: function() {
            return _f
        },
        VK_FORMAT_ASTC_10x10_UNORM_BLOCK: function() {
            return ff
        },
        VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: function() {
            return Kf
        },
        VK_FORMAT_ASTC_10x5_SRGB_BLOCK: function() {
            return cf
        },
        VK_FORMAT_ASTC_10x5_UNORM_BLOCK: function() {
            return lf
        },
        VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: function() {
            return Xf
        },
        VK_FORMAT_ASTC_10x6_SRGB_BLOCK: function() {
            return pf
        },
        VK_FORMAT_ASTC_10x6_UNORM_BLOCK: function() {
            return uf
        },
        VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: function() {
            return qf
        },
        VK_FORMAT_ASTC_10x8_SRGB_BLOCK: function() {
            return df
        },
        VK_FORMAT_ASTC_10x8_UNORM_BLOCK: function() {
            return hf
        },
        VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: function() {
            return Zf
        },
        VK_FORMAT_ASTC_12x10_SRGB_BLOCK: function() {
            return gf
        },
        VK_FORMAT_ASTC_12x10_UNORM_BLOCK: function() {
            return mf
        },
        VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: function() {
            return Jf
        },
        VK_FORMAT_ASTC_12x12_SRGB_BLOCK: function() {
            return bf
        },
        VK_FORMAT_ASTC_12x12_UNORM_BLOCK: function() {
            return vf
        },
        VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: function() {
            return Uf
        },
        VK_FORMAT_ASTC_4x4_SRGB_BLOCK: function() {
            return Kd
        },
        VK_FORMAT_ASTC_4x4_UNORM_BLOCK: function() {
            return Wd
        },
        VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: function() {
            return Bf
        },
        VK_FORMAT_ASTC_5x4_SRGB_BLOCK: function() {
            return qd
        },
        VK_FORMAT_ASTC_5x4_UNORM_BLOCK: function() {
            return Xd
        },
        VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: function() {
            return jf
        },
        VK_FORMAT_ASTC_5x5_SRGB_BLOCK: function() {
            return Zd
        },
        VK_FORMAT_ASTC_5x5_UNORM_BLOCK: function() {
            return Yd
        },
        VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: function() {
            return zf
        },
        VK_FORMAT_ASTC_6x5_SRGB_BLOCK: function() {
            return $d
        },
        VK_FORMAT_ASTC_6x5_UNORM_BLOCK: function() {
            return Jd
        },
        VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: function() {
            return Vf
        },
        VK_FORMAT_ASTC_6x6_SRGB_BLOCK: function() {
            return ef
        },
        VK_FORMAT_ASTC_6x6_UNORM_BLOCK: function() {
            return Qd
        },
        VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: function() {
            return Gf
        },
        VK_FORMAT_ASTC_8x5_SRGB_BLOCK: function() {
            return nf
        },
        VK_FORMAT_ASTC_8x5_UNORM_BLOCK: function() {
            return tf
        },
        VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: function() {
            return Hf
        },
        VK_FORMAT_ASTC_8x6_SRGB_BLOCK: function() {
            return sf
        },
        VK_FORMAT_ASTC_8x6_UNORM_BLOCK: function() {
            return rf
        },
        VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: function() {
            return Wf
        },
        VK_FORMAT_ASTC_8x8_SRGB_BLOCK: function() {
            return af
        },
        VK_FORMAT_ASTC_8x8_UNORM_BLOCK: function() {
            return of
        },
        VK_FORMAT_B10G11R11_UFLOAT_PACK32: function() {
            return ud
        },
        VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: function() {
            return Mf
        },
        VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: function() {
            return Rf
        },
        VK_FORMAT_B4G4R4A4_UNORM_PACK16: function() {
            return kp
        },
        VK_FORMAT_B5G5R5A1_UNORM_PACK16: function() {
            return Lp
        },
        VK_FORMAT_B5G6R5_UNORM_PACK16: function() {
            return Dp
        },
        VK_FORMAT_B8G8R8A8_SINT: function() {
            return uh
        },
        VK_FORMAT_B8G8R8A8_SNORM: function() {
            return lh
        },
        VK_FORMAT_B8G8R8A8_SRGB: function() {
            return ph
        },
        VK_FORMAT_B8G8R8A8_UINT: function() {
            return ch
        },
        VK_FORMAT_B8G8R8A8_UNORM: function() {
            return ah
        },
        VK_FORMAT_B8G8R8_SINT: function() {
            return eh
        },
        VK_FORMAT_B8G8R8_SNORM: function() {
            return $p
        },
        VK_FORMAT_B8G8R8_SRGB: function() {
            return th
        },
        VK_FORMAT_B8G8R8_UINT: function() {
            return Qp
        },
        VK_FORMAT_B8G8R8_UNORM: function() {
            return Jp
        },
        VK_FORMAT_BC1_RGBA_SRGB_BLOCK: function() {
            return wd
        },
        VK_FORMAT_BC1_RGBA_UNORM_BLOCK: function() {
            return yd
        },
        VK_FORMAT_BC1_RGB_SRGB_BLOCK: function() {
            return xd
        },
        VK_FORMAT_BC1_RGB_UNORM_BLOCK: function() {
            return bd
        },
        VK_FORMAT_BC2_SRGB_BLOCK: function() {
            return Md
        },
        VK_FORMAT_BC2_UNORM_BLOCK: function() {
            return Sd
        },
        VK_FORMAT_BC3_SRGB_BLOCK: function() {
            return Ed
        },
        VK_FORMAT_BC3_UNORM_BLOCK: function() {
            return Td
        },
        VK_FORMAT_BC4_SNORM_BLOCK: function() {
            return Cd
        },
        VK_FORMAT_BC4_UNORM_BLOCK: function() {
            return Ad
        },
        VK_FORMAT_BC5_SNORM_BLOCK: function() {
            return kd
        },
        VK_FORMAT_BC5_UNORM_BLOCK: function() {
            return Rd
        },
        VK_FORMAT_BC6H_SFLOAT_BLOCK: function() {
            return Dd
        },
        VK_FORMAT_BC6H_UFLOAT_BLOCK: function() {
            return Pd
        },
        VK_FORMAT_BC7_SRGB_BLOCK: function() {
            return Ld
        },
        VK_FORMAT_BC7_UNORM_BLOCK: function() {
            return Od
        },
        VK_FORMAT_D16_UNORM: function() {
            return hd
        },
        VK_FORMAT_D16_UNORM_S8_UINT: function() {
            return md
        },
        VK_FORMAT_D24_UNORM_S8_UINT: function() {
            return gd
        },
        VK_FORMAT_D32_SFLOAT: function() {
            return fd
        },
        VK_FORMAT_D32_SFLOAT_S8_UINT: function() {
            return vd
        },
        VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: function() {
            return pd
        },
        VK_FORMAT_EAC_R11G11_SNORM_BLOCK: function() {
            return Hd
        },
        VK_FORMAT_EAC_R11G11_UNORM_BLOCK: function() {
            return Gd
        },
        VK_FORMAT_EAC_R11_SNORM_BLOCK: function() {
            return Vd
        },
        VK_FORMAT_EAC_R11_UNORM_BLOCK: function() {
            return zd
        },
        VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: function() {
            return Ud
        },
        VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: function() {
            return Nd
        },
        VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: function() {
            return jd
        },
        VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: function() {
            return Bd
        },
        VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: function() {
            return Fd
        },
        VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: function() {
            return Id
        },
        VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: function() {
            return Sf
        },
        VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: function() {
            return Cf
        },
        VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: function() {
            return Lf
        },
        VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: function() {
            return kf
        },
        VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: function() {
            return If
        },
        VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: function() {
            return Pf
        },
        VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: function() {
            return Ff
        },
        VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: function() {
            return Df
        },
        VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: function() {
            return Nf
        },
        VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: function() {
            return Of
        },
        VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: function() {
            return wf
        },
        VK_FORMAT_R10X6G10X6_UNORM_2PACK16: function() {
            return yf
        },
        VK_FORMAT_R10X6_UNORM_PACK16: function() {
            return xf
        },
        VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: function() {
            return Af
        },
        VK_FORMAT_R12X4G12X4_UNORM_2PACK16: function() {
            return Ef
        },
        VK_FORMAT_R12X4_UNORM_PACK16: function() {
            return Tf
        },
        VK_FORMAT_R16G16B16A16_SFLOAT: function() {
            return Bh
        },
        VK_FORMAT_R16G16B16A16_SINT: function() {
            return Uh
        },
        VK_FORMAT_R16G16B16A16_SNORM: function() {
            return Fh
        },
        VK_FORMAT_R16G16B16A16_UINT: function() {
            return Nh
        },
        VK_FORMAT_R16G16B16A16_UNORM: function() {
            return Ih
        },
        VK_FORMAT_R16G16B16_SFLOAT: function() {
            return Lh
        },
        VK_FORMAT_R16G16B16_SINT: function() {
            return Oh
        },
        VK_FORMAT_R16G16B16_SNORM: function() {
            return Ph
        },
        VK_FORMAT_R16G16B16_UINT: function() {
            return Dh
        },
        VK_FORMAT_R16G16B16_UNORM: function() {
            return kh
        },
        VK_FORMAT_R16G16_SFLOAT: function() {
            return Rh
        },
        VK_FORMAT_R16G16_SINT: function() {
            return Ch
        },
        VK_FORMAT_R16G16_SNORM: function() {
            return Eh
        },
        VK_FORMAT_R16G16_UINT: function() {
            return Ah
        },
        VK_FORMAT_R16G16_UNORM: function() {
            return Th
        },
        VK_FORMAT_R16_SFLOAT: function() {
            return Mh
        },
        VK_FORMAT_R16_SINT: function() {
            return Sh
        },
        VK_FORMAT_R16_SNORM: function() {
            return yh
        },
        VK_FORMAT_R16_UINT: function() {
            return wh
        },
        VK_FORMAT_R16_UNORM: function() {
            return xh
        },
        VK_FORMAT_R32G32B32A32_SFLOAT: function() {
            return Jh
        },
        VK_FORMAT_R32G32B32A32_SINT: function() {
            return Zh
        },
        VK_FORMAT_R32G32B32A32_UINT: function() {
            return Yh
        },
        VK_FORMAT_R32G32B32_SFLOAT: function() {
            return qh
        },
        VK_FORMAT_R32G32B32_SINT: function() {
            return Xh
        },
        VK_FORMAT_R32G32B32_UINT: function() {
            return Kh
        },
        VK_FORMAT_R32G32_SFLOAT: function() {
            return Wh
        },
        VK_FORMAT_R32G32_SINT: function() {
            return Hh
        },
        VK_FORMAT_R32G32_UINT: function() {
            return Gh
        },
        VK_FORMAT_R32_SFLOAT: function() {
            return Vh
        },
        VK_FORMAT_R32_SINT: function() {
            return zh
        },
        VK_FORMAT_R32_UINT: function() {
            return jh
        },
        VK_FORMAT_R4G4B4A4_UNORM_PACK16: function() {
            return Rp
        },
        VK_FORMAT_R4G4_UNORM_PACK8: function() {
            return Cp
        },
        VK_FORMAT_R5G5B5A1_UNORM_PACK16: function() {
            return Op
        },
        VK_FORMAT_R5G6B5_UNORM_PACK16: function() {
            return Pp
        },
        VK_FORMAT_R64G64B64A64_SFLOAT: function() {
            return cd
        },
        VK_FORMAT_R64G64B64A64_SINT: function() {
            return ld
        },
        VK_FORMAT_R64G64B64A64_UINT: function() {
            return ad
        },
        VK_FORMAT_R64G64B64_SFLOAT: function() {
            return od
        },
        VK_FORMAT_R64G64B64_SINT: function() {
            return sd
        },
        VK_FORMAT_R64G64B64_UINT: function() {
            return id
        },
        VK_FORMAT_R64G64_SFLOAT: function() {
            return rd
        },
        VK_FORMAT_R64G64_SINT: function() {
            return nd
        },
        VK_FORMAT_R64G64_UINT: function() {
            return td
        },
        VK_FORMAT_R64_SFLOAT: function() {
            return ed
        },
        VK_FORMAT_R64_SINT: function() {
            return Qh
        },
        VK_FORMAT_R64_UINT: function() {
            return $h
        },
        VK_FORMAT_R8G8B8A8_SINT: function() {
            return sh
        },
        VK_FORMAT_R8G8B8A8_SNORM: function() {
            return rh
        },
        VK_FORMAT_R8G8B8A8_SRGB: function() {
            return oh
        },
        VK_FORMAT_R8G8B8A8_UINT: function() {
            return ih
        },
        VK_FORMAT_R8G8B8A8_UNORM: function() {
            return nh
        },
        VK_FORMAT_R8G8B8_SINT: function() {
            return Yp
        },
        VK_FORMAT_R8G8B8_SNORM: function() {
            return Xp
        },
        VK_FORMAT_R8G8B8_SRGB: function() {
            return Zp
        },
        VK_FORMAT_R8G8B8_UINT: function() {
            return qp
        },
        VK_FORMAT_R8G8B8_UNORM: function() {
            return Kp
        },
        VK_FORMAT_R8G8_SINT: function() {
            return Hp
        },
        VK_FORMAT_R8G8_SNORM: function() {
            return Vp
        },
        VK_FORMAT_R8G8_SRGB: function() {
            return Wp
        },
        VK_FORMAT_R8G8_UINT: function() {
            return Gp
        },
        VK_FORMAT_R8G8_UNORM: function() {
            return zp
        },
        VK_FORMAT_R8_SINT: function() {
            return Bp
        },
        VK_FORMAT_R8_SNORM: function() {
            return Np
        },
        VK_FORMAT_R8_SRGB: function() {
            return jp
        },
        VK_FORMAT_R8_UINT: function() {
            return Up
        },
        VK_FORMAT_R8_UNORM: function() {
            return Fp
        },
        VK_FORMAT_S8_UINT: function() {
            return _d
        },
        VK_FORMAT_UNDEFINED: function() {
            return Ap
        },
        VK_FORMAT_X8_D24_UNORM_PACK32: function() {
            return dd
        },
        read: function() {
            return a_
        },
        write: function() {
            return u_
        }
    });
    var t, n = {};
    __webpackgi_require__.r(n), __webpackgi_require__.d(n, {
            AsyncCompress: function() {
                return dv
            },
            AsyncDecompress: function() {
                return Rv
            },
            AsyncDeflate: function() {
                return sv
            },
            AsyncGunzip: function() {
                return gv
            },
            AsyncGzip: function() {
                return dv
            },
            AsyncInflate: function() {
                return cv
            },
            AsyncUnzipInflate: function() {
                return nb
            },
            AsyncUnzlib: function() {
                return Tv
            },
            AsyncZipDeflate: function() {
                return Zv
            },
            AsyncZlib: function() {
                return yv
            },
            Compress: function() {
                return hv
            },
            DecodeUTF8: function() {
                return Nv
            },
            Decompress: function() {
                return Cv
            },
            Deflate: function() {
                return iv
            },
            EncodeUTF8: function() {
                return Uv
            },
            Gunzip: function() {
                return mv
            },
            Gzip: function() {
                return hv
            },
            Inflate: function() {
                return lv
            },
            Unzip: function() {
                return rb
            },
            UnzipInflate: function() {
                return tb
            },
            UnzipPassThrough: function() {
                return eb
            },
            Unzlib: function() {
                return Mv
            },
            Zip: function() {
                return Jv
            },
            ZipDeflate: function() {
                return Yv
            },
            ZipPassThrough: function() {
                return qv
            },
            Zlib: function() {
                return xv
            },
            compress: function() {
                return fv
            },
            compressSync: function() {
                return _v
            },
            decompress: function() {
                return kv
            },
            decompressSync: function() {
                return Pv
            },
            deflate: function() {
                return ov
            },
            deflateSync: function() {
                return av
            },
            gunzip: function() {
                return vv
            },
            gunzipSync: function() {
                return bv
            },
            gzip: function() {
                return fv
            },
            gzipSync: function() {
                return _v
            },
            inflate: function() {
                return uv
            },
            inflateSync: function() {
                return pv
            },
            strFromU8: function() {
                return jv
            },
            strToU8: function() {
                return Bv
            },
            unzip: function() {
                return ib
            },
            unzipSync: function() {
                return sb
            },
            unzlib: function() {
                return Ev
            },
            unzlibSync: function() {
                return Av
            },
            zip: function() {
                return $v
            },
            zipSync: function() {
                return Qv
            },
            zlib: function() {
                return wv
            },
            zlibSync: function() {
                return Sv
            }
        }),
        function(e) {
            e[e.Error = -2] = "Error", e[e.Destroyed = -1] = "Destroyed", e[e.None = 0] = "None", e[e.Running = 1] = "Running", e[e.Paused = 2] = "Paused"
        }(t || (t = {}));
    class r {
        constructor() {
            this._eventListeners = {}, this.dispatchEvent = this.dispatchEvent.bind(this), this.addEventListener = this.addEventListener.bind(this), this.removeEventListener = this.removeEventListener.bind(this), this.hasEventListener = this.hasEventListener.bind(this)
        }
        addEventListener(e, t) {
            const n = this._eventListeners;
            void 0 === n[e] && (n[e] = []), n[e].includes(t) || n[e].push(t)
        }
        hasEventListener(e, t) {
            const n = this._eventListeners;
            return void 0 !== n[e] && n[e].includes(t)
        }
        removeEventListener(e, t) {
            const n = this._eventListeners[e];
            if (void 0 !== n) {
                const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
            }
        }
        dispatchEvent(e) {
            const t = this._eventListeners[e.type];
            if (void 0 !== t) {
                e.target = this;
                const n = t.slice(0);
                for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e)
            }
        }
    }
    var i = __webpackgi_require__(927);
    const s = {
        uniforms: {
            tDiffuse: {
                value: null
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"
    };
    class o {
        constructor() {
            this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
        }
        setSize() {}
        render() {
            console.error("THREE.Pass: .render() must be implemented in derived pass.")
        }
    }
    const a = new i.iKG(-1, 1, 1, -1, 0, 1),
        l = new i.u9r;
    l.setAttribute("position", new i.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), l.setAttribute("uv", new i.a$l([0, 2, 0, 0, 2, 0], 2));
    class c {
        constructor(e) {
            this._mesh = new i.Kj0(l, e)
        }
        dispose() {
            this._mesh.geometry.dispose()
        }
        render(e) {
            e.render(this._mesh, a)
        }
        get material() {
            return this._mesh.material
        }
        set material(e) {
            this._mesh.material = e
        }
    }
    class u extends o {
        constructor(e, t) {
            super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof i.jyz ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = i.rDY.clone(e.uniforms), this.material = new i.jyz({
                defines: Object.assign({}, e.defines),
                uniforms: this.uniforms,
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader
            })), this.fsQuad = new c(this.material), this.useExistingRenderTarget = !1
        }
        render(e, t, n) {
            this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (this.useExistingRenderTarget || e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e))
        }
    }
    class p extends o {
        constructor(e, t) {
            super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1
        }
        render(e, t, n) {
            const r = e.getContext(),
                i = e.state;
            let s, o;
            i.buffers.color.setMask(!1), i.buffers.depth.setMask(!1), i.buffers.color.setLocked(!0), i.buffers.depth.setLocked(!0), this.inverse ? (s = 0, o = 1) : (s = 1, o = 0), i.buffers.stencil.setTest(!0), i.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), i.buffers.stencil.setFunc(r.ALWAYS, s, 4294967295), i.buffers.stencil.setClear(o), i.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), i.buffers.color.setLocked(!1), i.buffers.depth.setLocked(!1), i.buffers.stencil.setLocked(!1), i.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), i.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), i.buffers.stencil.setLocked(!0)
        }
    }
    class h extends o {
        constructor() {
            super(), this.needsSwap = !1
        }
        render(e) {
            e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1)
        }
    }
    new i.iKG(-1, 1, 1, -1, 0, 1);
    const d = new i.u9r;
    d.setAttribute("position", new i.a$l([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), d.setAttribute("uv", new i.a$l([0, 2, 0, 0, 2, 0], 2));
    class f extends class {
        constructor(e, t) {
            if (this.renderer = e, void 0 === t) {
                const n = e.getSize(new i.FM8);
                this._pixelRatio = e.getPixelRatio(), this._width = n.width, this._height = n.height, (t = new i.dd2(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1"
            } else this._pixelRatio = 1, this._width = t.width, this._height = t.height;
            this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === s && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === u && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new u(s), this.clock = new i.SUY
        }
        swapBuffers() {
            const e = this.readBuffer;
            this.readBuffer = this.writeBuffer, this.writeBuffer = e
        }
        addPass(e) {
            this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }
        insertPass(e, t) {
            this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }
        removePass(e) {
            const t = this.passes.indexOf(e); - 1 !== t && this.passes.splice(t, 1)
        }
        isLastEnabledPass(e) {
            for (let t = e + 1; t < this.passes.length; t++)
                if (this.passes[t].enabled) return !1;
            return !0
        }
        render(e) {
            void 0 === e && (e = this.clock.getDelta());
            const t = this.renderer.getRenderTarget();
            let n = !1;
            for (let t = 0, r = this.passes.length; t < r; t++) {
                const r = this.passes[t];
                if (!1 !== r.enabled) {
                    if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t), r.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), r.needsSwap) {
                        if (n) {
                            const t = this.renderer.getContext(),
                                n = this.renderer.state.buffers.stencil;
                            n.setFunc(t.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), n.setFunc(t.EQUAL, 1, 4294967295)
                        }
                        this.swapBuffers()
                    }
                    void 0 !== p && (r instanceof p ? n = !0 : r instanceof h && (n = !1))
                }
            }
            this.renderer.setRenderTarget(t)
        }
        reset(e) {
            if (void 0 === e) {
                const t = this.renderer.getSize(new i.FM8);
                this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
        }
        setSize(e, t) {
            this._width = e, this._height = t;
            const n = this._width * this._pixelRatio,
                r = this._height * this._pixelRatio;
            this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
            for (let e = 0; e < this.passes.length; e++) this.passes[e].setSize(n, r)
        }
        setPixelRatio(e) {
            this._pixelRatio = e, this.setSize(this._width, this._height)
        }
    } {
        constructor(e, t) {
            super(e, t)
        }
        setPixelRatio(e, t = !0) {
            const n = this.setSize;
            t || (this.setSize = () => {}), super.setPixelRatio(e), t || (this.setSize = n)
        }
    }

    function _(e, t) {
        let n;
        do {
            n = Object.getOwnPropertyDescriptor(e, t)
        } while (!n && (e = Object.getPrototypeOf(e)));
        return n
    }

    function m(e, t, n = !1, r = !1) {
        const i = _(e, t);
        return !!(null == i ? void 0 : i.set) || n && !1 !== (null == i ? void 0 : i.writable) && void 0 === (null == i ? void 0 : i.get) || r && !i
    }

    function g(e, t, n, r = !1, i = !1) {
        return !(!e || !m(e, t, r, i) || (e[t] = n, 0))
    }

    function v(e, t) {
        for (; e.length > 0;) {
            if (!t) return;
            const n = e.splice(0, 1)[0];
            if (!(n.length < 1)) {
                if (!(n in t)) return console.error("invalid access, check", n, t), t;
                t = t[n]
            }
        }
        return t
    }

    function b(e, t) {
        return Object.keys(e).find((n => e[n] === t))
    }

    function x(e, ...t) {
        return "function" == typeof e && (e = e(...t)), e
    }

    function y(e, t, n) {
        for (const r of n) {
            const n = e[r];
            void 0 !== n && g(t, r, n, !0)
        }
    }

    function w(e) {
        return e.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1")
    }

    function S(e, t, n) {
        return e.replace(new RegExp(w(t), "g"), n)
    }
    String.raw;
    const M = (e, ...t) => String.raw({
            raw: e
        }, ...t),
        T = (e, ...t) => String.raw({
            raw: e
        }, ...t),
        E = (e, ...t) => String.raw({
            raw: e
        }, ...t),
        A = (e, ...t) => {
            let n = String.raw({
                raw: e
            }, ...t);
            return n = S(n, "%", "%25"), n = S(n, "> <", "><"), n = S(n, "; }", ";}"), n = S(n, "<", "%3c"), n = S(n, ">", "%3e"), n = S(n, '"', "'"), n = S(n, "#", "%23"), n = S(n, "{", "%7b"), n = S(n, "}", "%7d"), n = S(n, "|", "%7c"), n = S(n, "^", "%5e"), n = S(n, "`", "%60"), n = S(n, "@", "%40"), n = S(n, "&", "&amp;"), "data:image/svg+xml;charset=UTF-8," + n
        };

    function C(e) {
        if (!e) throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
        return (t, n) => {
            let r;
            Object.defineProperty(t, n, {
                get: () => r,
                set(t) {
                    var i;
                    if (r === t) return;
                    r = t;
                    const s = [n, t];
                    if ("string" == typeof e) null === (i = this[e]) || void 0 === i || i.call(this, ...s);
                    else if ("function" == typeof e) {
                        let t = !1;
                        if (e.name) {
                            let n = this;
                            for (; n;) {
                                if (n[e.name] === e) {
                                    e.call(this, ...s), t = !0;
                                    break
                                }
                                n = Object.getPrototypeOf(n)
                            }
                        }
                        t || (e.name && this[e.name].name === `bound ${e.name}` ? this[e.name](...s) : e(...s))
                    }
                }
            })
        }
    }

    function R(e, t) {
        for (const n of t)
            if (!e.includes(n)) return !1;
        return !0
    }
    String.prototype.replaceAll || (String.prototype.replaceAll = function(e, t) {
        return "[object regexp]" === Object.prototype.toString.call(e).toLowerCase() ? this.replace(e, t) : this.replace(new RegExp(e, "g"), t)
    });
    class k {
        constructor(e = 0, t = 0) {
            k.prototype.isVector2 = !0, this.x = e, this.y = t
        }
        get width() {
            return this.x
        }
        set width(e) {
            this.x = e
        }
        get height() {
            return this.y
        }
        set height(e) {
            this.y = e
        }
        set(e, t) {
            return this.x = e, this.y = t, this
        }
        setScalar(e) {
            return this.x = e, this.y = e, this
        }
        setX(e) {
            return this.x = e, this
        }
        setY(e) {
            return this.y = e, this
        }
        setComponent(e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y)
        }
        copy(e) {
            return this.x = e.x, this.y = e.y, this
        }
        add(e) {
            return this.x += e.x, this.y += e.y, this
        }
        addScalar(e) {
            return this.x += e, this.y += e, this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        }
        sub(e) {
            return this.x -= e.x, this.y -= e.y, this
        }
        subScalar(e) {
            return this.x -= e, this.y -= e, this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        }
        multiply(e) {
            return this.x *= e.x, this.y *= e.y, this
        }
        multiplyScalar(e) {
            return this.x *= e, this.y *= e, this
        }
        divide(e) {
            return this.x /= e.x, this.y /= e.y, this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        applyMatrix3(e) {
            const t = this.x,
                n = this.y,
                r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y
        }
        cross(e) {
            return this.x * e.y - this.y * e.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x,
                n = this.y - e.y;
            return t * t + n * n
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y
        }
        fromArray(e, t = 0) {
            return this.x = e[t], this.y = e[t + 1], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.x, e[t + 1] = this.y, e
        }
        fromBufferAttribute(e, t) {
            return this.x = e.getX(t), this.y = e.getY(t), this
        }
        rotateAround(e, t) {
            const n = Math.cos(t),
                r = Math.sin(t),
                i = this.x - e.x,
                s = this.y - e.y;
            return this.x = i * n - s * r + e.x, this.y = i * r + s * n + e.y, this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this
        }*[Symbol.iterator]() {
            yield this.x, yield this.y
        }
    }
    class P extends i.ZzF {
        expandByObject(e, t = !1, n = !1) {
            var r;
            if (!1 === (null === (r = e.userData) || void 0 === r ? void 0 : r.bboxVisible)) return this;
            if (!e.visible && n) return this;
            e.updateWorldMatrix(!1, !1);
            const i = e.geometry;
            if (void 0 !== i)
                if (t && null != i.attributes && void 0 !== i.attributes.position) {
                    const t = i.attributes.position;
                    for (let n = 0, r = t.count; n < r; n++) O.fromBufferAttribute(t, n).applyMatrix4(e.matrixWorld), this.expandByPoint(O)
                } else null === i.boundingBox && i.computeBoundingBox(), D.copy(i.boundingBox), D.applyMatrix4(e.matrixWorld), this.union(D);
            const s = e.children;
            for (let e = 0, r = s.length; e < r; e++) this.expandByObject(s[e], t, n);
            return this
        }
        expandByObjects(e, t = !1, n = !1) {
            for (let r = 0, i = e.length; r < i; r++) this.expandByObject(e[r], t, n);
            return this
        }
        getPoints() {
            return [new i.Pa4(this.min.x, this.min.y, this.min.z), new i.Pa4(this.min.x, this.min.y, this.max.z), new i.Pa4(this.min.x, this.max.y, this.min.z), new i.Pa4(this.min.x, this.max.y, this.max.z), new i.Pa4(this.max.x, this.min.y, this.min.z), new i.Pa4(this.max.x, this.min.y, this.max.z), new i.Pa4(this.max.x, this.max.y, this.min.z), new i.Pa4(this.max.x, this.max.y, this.max.z)]
        }
        getScreenSpaceBounds(e) {
            const t = this.getPoints(),
                n = new i.TUj;
            for (const r of t) {
                const t = r.project(e);
                n.min.min(t), n.max.max(t)
            }
            return n
        }
    }
    const D = new P,
        O = new i.Pa4;

    function L(e, t) {
        let n, r;
        if (Array.isArray(e))
            for (const i of e) {
                const e = L(i, t);
                void 0 === n || void 0 === r ? (n = e.min.clone(), r = e.max.clone()) : (n.min(e.min), r.max(e.max))
            }
        const s = e;
        if (void 0 !== s.geometry) {
            const o = s.geometry.vertices;
            if (void 0 === o && void 0 !== s.geometry.attributes && "position" in s.geometry.attributes) {
                const o = new i.Pa4,
                    a = s.geometry.attributes.position;
                for (let i = 0; i < a.count * a.itemSize; i += a.itemSize) {
                    o.set(a.array[i], a.array[i + 1], a.array[3]);
                    const s = o.applyMatrix4(e.matrixWorld).project(t),
                        l = new k(s.x, s.y);
                    void 0 === n || void 0 === r ? (n = l.clone(), r = l.clone()) : (n.min(l), r.max(l))
                }
            } else
                for (const i of o) {
                    const s = i.clone().applyMatrix4(e.matrixWorld).project(t),
                        o = new k(s.x, s.y);
                    void 0 === n || void 0 === r ? (n = o.clone(), r = o.clone()) : (n.min(o), r.max(o))
                }
        }
        if (void 0 !== e.children)
            for (const i of e.children) {
                const e = L(i, t);
                void 0 === n || void 0 === r ? (n = e.min.clone(), r = e.max.clone()) : (n.min(e.min), r.max(e.max))
            }
        return new i.TUj(n, r)
    }

    function I(e) {
        switch (e) {
            case i.rnI:
                return ["Linear", "( value )"];
            case i.knz:
                return ["sRGB", "( value )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            default:
                return console.warn("utils: Unsupported encoding:", e), ["Linear", "( value )"]
        }
    }

    function F(e, t) {
        let n;
        return e && e.isTexture ? n = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = i.rnI, t && e && e.isTexture && e.format === i.wk1 && e.type === i.ywz && e.encoding === i.knz && (n = i.rnI), n
    }

    function N(e, t) {
        const n = I(t);
        return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function U(e, t, n) {
        return N(e + "TexelToLinear", F(t, n)) + "\n"
    }

    function B(e, t) {
        return N(e + "TexelToLinear", t) + "\n"
    }

    function j(e, t) {
        const n = I(t);
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }

    function z(e, t, n) {
        return j(e, F(t, n))
    }

    function V({
        uniforms: e,
        propKey: t,
        thisTarget: n = !1
    } = {}) {
        const r = !!e,
            i = !!t,
            s = n;
        return (n, o) => {
            const a = n => {
                const a = s ? n : r ? e : n.uniforms || n._uniforms;
                let l = i ? t : o;
                s && (l = "_" + l);
                let c = a[l];
                return c || (c = {
                    value: null
                }, a[l] = c), c
            };
            Object.defineProperty(n, o, {
                get() {
                    return a(this).value
                },
                set(e) {
                    a(this).value = e, g(this, "uniformsNeedUpdate", !0, !0)
                }
            })
        }
    }

    function G(e, t, n = !1, r) {
        const i = !!t,
            s = !!e;
        return (o, a) => {
            const l = n => ({
                t: i ? t : n.defines || n._defines,
                p: s ? e : a
            });
            Object.defineProperty(o, a, {
                get() {
                    const {
                        t: e,
                        p: t
                    } = l(n ? this : this.material);
                    return e[t]
                },
                set(e) {
                    const {
                        t: t,
                        p: i
                    } = l(n ? this : this.material);
                    if (g(t, i, e, !0), "function" == typeof r) {
                        const t = [i, e];
                        if (r.name) {
                            const e = this[r.name];
                            e === r ? r.call(this, ...t) : e.name === `bound ${r.name}` ? e(...t) : r(...t)
                        } else r(...t)
                    } else g(n ? this : this.material, "needsUpdate", !0, !0)
                }
            })
        }
    }

    function H(e) {
        const t = new i.IEO(new Uint8Array([Math.floor(255 * e.r), Math.floor(255 * e.g), Math.floor(255 * e.b), 255]), 1, 1, i.wk1, i.ywz);
        return t.needsUpdate = !0, t.encoding = i.rnI, t
    }

    function W(e) {
        const t = new i.IEO(new Uint8Array([Math.floor(255 * e.x), Math.floor(255 * e.y), Math.floor(255 * e.z), Math.floor(255 * e.w)]), 1, 1, i.wk1, i.ywz);
        return t.needsUpdate = !0, t
    }

    function K(e, t, n) {
        const r = e.userData,
            {
                backgroundRender: i,
                transparentRender: s,
                shadowMapRender: o,
                mainRenderPass: a,
                opaqueRender: l,
                transmissionRender: c,
                sceneRender: u,
                screenSpaceRendering: p
            } = r;
        void 0 !== t.backgroundRender && (r.backgroundRender = t.backgroundRender), void 0 !== t.transparentRender && (r.transparentRender = t.transparentRender), void 0 !== t.shadowMapRender && (r.shadowMapRender = t.shadowMapRender), void 0 !== t.mainRenderPass && (r.mainRenderPass = t.mainRenderPass), void 0 !== t.opaqueRender && (r.opaqueRender = t.opaqueRender), void 0 !== t.sceneRender && (r.sceneRender = t.sceneRender), void 0 !== t.transmissionRender && (r.transmissionRender = t.transmissionRender), void 0 !== t.screenSpaceRendering && (r.screenSpaceRendering = t.screenSpaceRendering), n(), r.backgroundRender = i, r.transparentRender = s, r.shadowMapRender = o, r.mainRenderPass = a, r.opaqueRender = l, r.sceneRender = u, r.transmissionRender = c, r.screenSpaceRendering = p
    }

    function X(e, t) {
        const n = .5 * (new P).expandByObject(e, !0, !0).getSize(new i.Pa4).length();
        void 0 === t && (t = e.userData.autoScaleRadius || 1);
        const r = t / n;
        return isFinite(r) && (e.userData.pseudoCentered ? e.children.forEach((e => {
            e.scale.multiplyScalar(r)
        })) : e.scale.multiplyScalar(r)), e.userData.autoScaled = !0, e.userData.autoScaleRadius = t, e.dispatchEvent({
            type: "objectUpdate"
        }), e
    }

    function q(e, t = -1) {
        return function(e, t = 1e-4) {
            const n = t > 0;
            t = Math.max(t, Number.EPSILON);
            const r = {},
                s = e.getIndex(),
                o = e.getAttribute("position"),
                a = s ? s.count : o.count;
            let l = 0;
            const c = Object.keys(e.attributes),
                u = {},
                p = {},
                h = [],
                d = ["getX", "getY", "getZ", "getW"];
            for (let t = 0, n = c.length; t < n; t++) {
                const n = c[t];
                u[n] = [];
                const r = e.morphAttributes[n];
                r && (p[n] = new Array(r.length).fill().map((() => [])))
            }
            const f = Math.log10(1 / t),
                _ = Math.pow(10, f);
            for (let t = 0; t < a; t++) {
                const i = s ? s.getX(t) : t;
                let o = "";
                for (let t = 0, r = c.length; t < r && n; t++) {
                    const n = c[t],
                        r = e.getAttribute(n),
                        s = r.itemSize;
                    for (let e = 0; e < s; e++) o += ~~(r[d[e]](i) * _) + ","
                }
                if (n && o in r) h.push(r[o]);
                else {
                    for (let t = 0, n = c.length; t < n; t++) {
                        const n = c[t],
                            r = e.getAttribute(n),
                            s = e.morphAttributes[n],
                            o = r.itemSize,
                            a = u[n],
                            l = p[n];
                        for (let e = 0; e < o; e++) {
                            const t = d[e];
                            if (a.push(r[t](i)), s)
                                for (let e = 0, n = s.length; e < n; e++) l[e].push(s[e][t](i))
                        }
                    }
                    n && (r[o] = l), h.push(l), l++
                }
            }
            const m = e.clone();
            for (let t = 0, n = c.length; t < n; t++) {
                const n = c[t],
                    r = e.getAttribute(n),
                    s = new r.array.constructor(u[n]),
                    o = new i.TlE(s, r.itemSize, r.normalized);
                if (m.setAttribute(n, o), n in p)
                    for (let t = 0; t < p[n].length; t++) {
                        const r = e.morphAttributes[n][t],
                            s = new r.array.constructor(p[n][t]),
                            o = new i.TlE(s, r.itemSize, r.normalized);
                        m.morphAttributes[n][t] = o
                    }
            }
            return m.setIndex(h), m
        }(e, t)
    }
    class Y extends r {
        constructor({
            animationLoop: e,
            canvas: t,
            alpha: n = !0,
            targetOptions: r
        }) {
            super(), this._isWebGL2 = !1, this._trackedTargets = [], this.dirty = !0, this._lastTime = 0, this.frameWaitTime = 0, this._passes = [], this._pipeline = [], this._passesNeedsUpdate = !0, this._displayCanvasScaling = 1, this._renderSize = new i.FM8(512, 512), this._frameCount = 0, this._tempTargets = {}, this.maxTempPerKey = 5, this._animationLoop = this._animationLoop.bind(this), this._processNewTarget = this._processNewTarget.bind(this), this._processNewTempTarget = this._processNewTempTarget.bind(this), this.trackTarget = this.trackTarget.bind(this), this.disposeTarget = this.disposeTarget.bind(this), this.createTarget = this.createTarget.bind(this), this.createTargetCustom = this.createTargetCustom.bind(this), this._renderer = new i.CP7({
                canvas: t,
                antialias: !0,
                alpha: n,
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !0
            }), this._renderer.baseRenderer = this, this._renderer.setAnimationLoop(this._animationLoop), this._context = this._renderer.getContext(), this._isWebGL2 = this._renderer.capabilities.isWebGL2, this._renderSize = new i.FM8(t.clientWidth, t.clientHeight), this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1), this._renderer.setPixelRatio(this._displayCanvasScaling), this._renderer.toneMapping = i.uL9, this._renderer.toneMappingExposure = 1, this._renderer.outputEncoding = i.rnI, this._renderer.shadowMap.enabled = !0, this._renderer.shadowMap.type = i._MY, this._renderer.shadowMap.autoUpdate = !1, this.resetShadows(), r.isAntialiased = r.isAntialiased && this.isWebGL2, this._composerTarget = this.createTarget(r, !1), this._composerTarget.texture.name = "EffectComposer.rt1", this._composer = new f(this._renderer, this._composerTarget), e && this.addEventListener("animationLoop", e)
        }
        get composer() {
            return this._composer
        }
        get passes() {
            return this._passes
        }
        get isWebGL2() {
            return this._isWebGL2
        }
        get composerTarget() {
            return this._composerTarget
        }
        get renderSize() {
            return this._renderSize
        }
        get displayCanvasScaling() {
            return this._displayCanvasScaling
        }
        set displayCanvasScaling(e) {
            e !== this._displayCanvasScaling && (this._displayCanvasScaling = e, this.setSize(void 0, void 0, !0))
        }
        get frameCount() {
            return this._frameCount
        }
        set pipeline(e) {
            this._pipeline = e, this._passesNeedsUpdate = !0
        }
        get pipeline() {
            return this._pipeline
        }
        refreshPipeline() {
            var e, t, n;
            const r = this._passes,
                i = [],
                s = {};
            for (const i of r) {
                if (!1 === i.enabled) continue;
                const r = {
                    after: null !== (e = i.after) && void 0 !== e ? e : [],
                    before: null !== (t = i.before) && void 0 !== t ? t : [],
                    dependencies: new Set(null !== (n = i.required) && void 0 !== n ? n : [])
                };
                s[i.passId] = r
            }
            for (const [e, t] of Object.entries(s)) {
                const n = new Set([...t.after, ...t.before]);
                t.dependencies.forEach((e => n.has(e) && n.delete(e))), n.forEach((n => {
                    const r = s[n];
                    if (r) {
                        if (r.dependencies.has(e)) throw console.error("cyclic", e, n), "Cyclic dependency";
                        t.dependencies.add(n)
                    }
                }))
            }
            for (;;) {
                let e = !1;
                const t = [...Object.entries(s)];
                for (const [n, o] of t)
                    if (!i.includes(n) && R(i, o.dependencies.values())) {
                        const t = Math.max(-1, ...o.after.map((e => i.indexOf(e)))),
                            a = Math.min(i.length, ...o.before.map((e => {
                                const t = i.indexOf(e);
                                return t < 0 ? i.length : t
                            })));
                        if (t >= a) throw console.error(o, r, i, t, a), "Not possible";
                        i.splice(o.after.length > 0 ? t + 1 : a, 0, n), e = !0, delete s[n]
                    }
                if (Object.keys(s).length < 1) break;
                if (!e) throw console.log(t, s, i), "Not possible 2"
            }
            return this.pipeline = i, this.pipeline
        }
        get context() {
            return this._context
        }
        get rendererObject() {
            return this._renderer
        }
        _animationLoop(e, t) {
            const n = e - this._lastTime;
            this._lastTime = e, this.frameWaitTime -= n, this.frameWaitTime > 0 || (this.frameWaitTime = 0, this.dispatchEvent({
                type: "animationLoop",
                deltaTime: n,
                time: e,
                renderer: this,
                xrFrame: t
            }))
        }
        get clock() {
            return this._composer.clock
        }
        registerPass(e, t = !0) {
            var n;
            if (t)
                for (const t of [...this._passes]) e.passId === t.passId && this.unregisterPass(t);
            this._passes.push(e), null === (n = e.onRegister) || void 0 === n || n.call(e, this), this._passesNeedsUpdate = !0, this._updated()
        }
        unregisterPass(e) {
            var t;
            const n = this._passes.indexOf(e);
            n >= 0 && (null === (t = e.onUnregister) || void 0 === t || t.call(e, this), this._passes.splice(n, 1), this._passesNeedsUpdate = !0, this._updated())
        }
        setSize(e, t, n = !1) {
            !n && (e ? Math.abs(e - this._renderSize.width) : 0) + (t ? Math.abs(t - this._renderSize.height) : 0) < .1 || (e && (this._renderSize.width = e), t && (this._renderSize.height = t), this.rendererObject.xr.enabled || (this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1), this._renderer.setPixelRatio(this._displayCanvasScaling)), this._composer.setPixelRatio(this._displayCanvasScaling, !1), this._composer.setSize(this._renderSize.width, this._renderSize.height), this._trackedTargets.forEach((e => {
                const t = e,
                    n = t.sizeMultiplier;
                if (n) {
                    const e = this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * n);
                    t.setSize(e.width, e.height)
                }
            })), this.dispatchEvent({
                type: "resize"
            }), this._updated(), this.reset())
        }
        blit(e, t, {
            viewport: n,
            material: r,
            shader: s,
            pass: o,
            clear: a = !0
        } = {}) {
            const l = this._composer.copyPass,
                {
                    renderToScreen: c,
                    material: u,
                    uniforms: p,
                    clear: h
                } = l;
            r && (l.material = r);
            const d = this._renderer.getViewport(new i.Ltg),
                f = this._renderer.autoClear,
                _ = this._renderer.getRenderTarget();
            n && this._renderer.setViewport((new i.Ltg).fromArray(n)), this._renderer.autoClear = !1, l.uniforms = l.material.uniforms, l.renderToScreen = !1, l.clear = a, K(this._renderer, {
                sceneRender: !0,
                opaqueRender: !0,
                shadowMapRender: !1,
                backgroundRender: !1,
                transparentRender: !0,
                transmissionRender: !1
            }, (() => {
                l.render(this._renderer, null != t ? t : null, {
                    texture: e
                }, 0, !1)
            })), l.renderToScreen = c, l.clear = h, l.material = u, l.uniforms = p, this._renderer.autoClear = f, n && this._renderer.setViewport(d), this._renderer.setRenderTarget(_)
        }
        clearColor({
            r: e,
            g: t,
            b: n,
            a: r,
            target: s,
            depth: o = !0,
            stencil: a = !0
        }) {
            var l;
            const c = this._renderer.getClearColor(new i.Ilk),
                u = this._renderer.getClearAlpha();
            this._renderer.setClearAlpha(null != r ? r : u), this._renderer.setClearColor(new i.Ilk(null != e ? e : c.r, null != t ? t : c.g, null != n ? n : c.b));
            const p = this._renderer.getRenderTarget(),
                h = this._renderer.getActiveCubeFace(),
                d = this._renderer.getActiveMipmapLevel();
            this._renderer.setRenderTarget(null !== (l = s) && void 0 !== l ? l : null), this._renderer.clear(!0, o, a), this._renderer.setRenderTarget(p, h, d), this._renderer.setClearColor(c), this._renderer.setClearAlpha(u)
        }
        renderModel(e, t) {
            this._renderer.render(e.modelObject, t.cameraObject)
        }
        renderScene(e) {
            const t = e.activeCamera;
            t && this.renderModel(e, t)
        }
        _updated() {
            this.dispatchEvent({
                type: "update"
            })
        }
        render() {
            var e;
            this._passesNeedsUpdate && this.refreshPasses();
            for (const t of this._passes) t.passObject.enabled && (null === (e = t.update) || void 0 === e || e.call(t));
            this._composer.render(), this._frameCount += 1, this.dirty = !1
        }
        updateDirty() {
            this.dirty = this.dirty || this._passes.findIndex((e => e.dirty)) >= 0
        }
        reset() {
            this._frameCount = 0, this.dirty = !0
        }
        resetShadows() {
            this._renderer.shadowMap.needsUpdate = !0
        }
        refreshPasses() {
            if (!this._passesNeedsUpdate) return;
            this._passesNeedsUpdate = !1;
            const e = [];
            for (const t of this._pipeline) {
                const n = this._passes.find((e => e.passId === t));
                n ? e.push(n.passObject) : console.warn("Unable to find pass: ", t)
            }
            this._composer.passes.forEach((e => this._composer.removePass(e))), e.forEach((e => this._composer.addPass(e))), this._updated()
        }
        dispose() {
            this._renderer.dispose()
        }
        trackTarget(e) {
            this._trackedTargets.push(e)
        }
        removeTrackedTarget(e) {
            const t = this._trackedTargets.indexOf(e);
            t >= 0 && this._trackedTargets.splice(t, 1)
        }
        createTarget({
            sizeMultiplier: e,
            isAntialiased: t = !1,
            encoding: n = i.rnI,
            type: r = i.ywz,
            format: s = i.wk1,
            depthBuffer: o = !0,
            depthTexture: a = !1,
            size: l,
            textureCount: c = 1,
            ...u
        } = {}, p = !0) {
            t = t && this.isWebGL2, void 0 !== e && void 0 !== l && console.error("Both sizeMultiplier and size are defined. sizeMultiplier will be ignored."), l = l || this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * (e = e || 1));
            const h = a ? new i.$YQ(l.width, l.height, i.ywz) : void 0,
                d = this.createTargetCustom(c > 1 ? {
                    width: l.width,
                    height: l.height,
                    count: c
                } : l, {
                    encoding: n,
                    type: r,
                    format: s,
                    depthBuffer: o,
                    depthTexture: h
                }, c > 1 ? i.kFz : i.dd2);
            return this._processNewTarget(d, e, p), this._setTargetOptions(d, u), d
        }
        _processNewTarget(e, t, n) {
            return void 0 !== t && (e.sizeMultiplier = t), n && this.trackTarget(e), e
        }
        disposeTarget(e) {
            if (e) {
                if (e.isTemporary) return this.releaseTempTarget(e);
                this.removeTrackedTarget(e), e.dispose()
            }
        }
        createTargetCustom({
            width: e,
            height: t,
            count: n
        }, r = {}, s) {
            var o;
            const a = this._processNewTarget;
            let l = [e, t];
            if (n && n > 1 && l.push(n), (null == s ? void 0 : s.prototype) === i.oAp.prototype) {
                if (e !== t) throw "Width and height of cube render target must be equal";
                l = [e]
            }
            r = {
                format: i.wk1,
                minFilter: i.wem,
                magFilter: i.wem,
                generateMipmaps: !1,
                type: i.ywz,
                encoding: i.rnI,
                ...r
            };
            const c = [...l, r];
            return new class extends(null !== (o = s) && void 0 !== o ? o : i.dd2) {
                constructor(...e) {
                    super(...e), Array.isArray(this.texture) ? this.texture.forEach((e => {
                        e.encoding = r.encoding, e.toJSON = () => ({})
                    })) : this.texture.toJSON = () => ({})
                }
                clone(e = !0) {
                    if (this.isTemporary) throw "Cloning temporary render targets not supported";
                    if (Array.isArray(this.texture)) throw "Cloning multiple render targets not supported";
                    const t = super.clone();
                    return t.texture.isRenderTargetTexture = !0, a(t, this.sizeMultiplier || 1, e)
                }
            }(...c)
        }
        getTempTarget(e = {}) {
            var t;
            const n = Z(e);
            let r;
            return (null === (t = this._tempTargets[n]) || void 0 === t ? void 0 : t.length) && (r = this._tempTargets[n].pop()), r ? this._setTargetOptions(r, e) : (r = this.createTarget(e), this._processNewTempTarget(r, n)), r
        }
        _processNewTempTarget(e, t) {
            return e.isTemporary = !0, e.targetKey = t, void 0 === this._tempTargets[t] && (this._tempTargets[t] = []), e
        }
        releaseTempTarget(e) {
            const t = e.targetKey;
            if (!t || !e.isTemporary) throw "Not a temp target";
            this._tempTargets[t].length > this.maxTempPerKey ? e.dispose() : this._tempTargets[t].push(e)
        }
        updateShaderProperties(e) {
            return e.uniforms.frameCount ? e.uniforms.frameCount.value = this.frameCount : console.warn("BaseRenderer: no uniform: frameCount"), this
        }
        _setTargetOptions(e, t) {
            var n, r, s;
            e.texture.minFilter = null !== (n = t.minFilter) && void 0 !== n ? n : i.wem, e.texture.magFilter = null !== (r = t.magFilter) && void 0 !== r ? r : i.wem, e.texture.generateMipmaps = null !== (s = t.generateMipmaps) && void 0 !== s && s, e.texture.generateMipmaps && e.texture.minFilter === i.wem && (e.texture.minFilter = i.FDw), e.texture.generateMipmaps || e.texture.minFilter !== i.FDw || (e.texture.minFilter = i.wem)
        }
    }

    function Z(e = {}) {
        var t, n;
        return [e.sizeMultiplier, e.isAntialiased, e.encoding, e.type, e.format, e.depthBuffer, e.depthTexture, null === (t = e.size) || void 0 === t ? void 0 : t.width, null === (n = e.size) || void 0 === n ? void 0 : n.height].join(";")
    }
    const J = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];

    function $() {
        const e = 4294967295 * Math.random() | 0,
            t = 4294967295 * Math.random() | 0,
            n = 4294967295 * Math.random() | 0,
            r = 4294967295 * Math.random() | 0;
        return (J[255 & e] + J[e >> 8 & 255] + J[e >> 16 & 255] + J[e >> 24 & 255] + "-" + J[255 & t] + J[t >> 8 & 255] + "-" + J[t >> 16 & 15 | 64] + J[t >> 24 & 255] + "-" + J[63 & n | 128] + J[n >> 8 & 255] + "-" + J[n >> 16 & 255] + J[n >> 24 & 255] + J[255 & r] + J[r >> 8 & 255] + J[r >> 16 & 255] + J[r >> 24 & 255]).toLowerCase()
    }

    function Q(e, t, n) {
        return Math.max(t, Math.min(n, e))
    }

    function ee(e, t, n) {
        return (1 - n) * e + n * t
    }
    Math.PI, Math.PI;
    const te = 0,
        ne = 1,
        re = 3,
        ie = 4,
        se = 1006,
        oe = "srgb",
        ae = "srgb-linear";

    function le(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }

    function ce(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }
    const ue = {
            [oe]: {
                [ae]: le
            },
            [ae]: {
                [oe]: ce
            }
        },
        pe = {
            legacyMode: !0,
            get workingColorSpace() {
                return ae
            },
            set workingColorSpace(e) {
                console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
            },
            convert: function(e, t, n) {
                if (this.legacyMode || t === n || !t || !n) return e;
                if (ue[t] && void 0 !== ue[t][n]) {
                    const r = ue[t][n];
                    return e.r = r(e.r), e.g = r(e.g), e.b = r(e.b), e
                }
                throw new Error("Unsupported color space conversion.")
            },
            fromWorkingColorSpace: function(e, t) {
                return this.convert(e, this.workingColorSpace, t)
            },
            toWorkingColorSpace: function(e, t) {
                return this.convert(e, t, this.workingColorSpace)
            }
        },
        he = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        },
        de = {
            r: 0,
            g: 0,
            b: 0
        },
        fe = {
            h: 0,
            s: 0,
            l: 0
        },
        _e = {
            h: 0,
            s: 0,
            l: 0
        };

    function me(e, t, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
    }

    function ge(e, t) {
        return t.r = e.r, t.g = e.g, t.b = e.b, t
    }
    class ve {
        constructor(e, t, n) {
            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
        }
        set(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        }
        setScalar(e) {
            return this.r = e, this.g = e, this.b = e, this
        }
        setHex(e, t = "srgb") {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, pe.toWorkingColorSpace(this, t), this
        }
        setRGB(e, t, n, r = "srgb-linear") {
            return this.r = e, this.g = t, this.b = n, pe.toWorkingColorSpace(this, r), this
        }
        setHSL(e, t, n, r = "srgb-linear") {
            if (e = function(e, t) {
                    return (e % t + t) % t
                }(e, 1), t = Q(t, 0, 1), n = Q(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
            else {
                const r = n <= .5 ? n * (1 + t) : n + t - n * t,
                    i = 2 * n - r;
                this.r = me(i, r, e + 1 / 3), this.g = me(i, r, e), this.b = me(i, r, e - 1 / 3)
            }
            return pe.toWorkingColorSpace(this, r), this
        }
        setStyle(e, t = "srgb") {
            function n(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            let r;
            if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                let e;
                const i = r[1],
                    s = r[2];
                switch (i) {
                    case "rgb":
                    case "rgba":
                        if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, pe.toWorkingColorSpace(this, t), n(e[4]), this;
                        if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, pe.toWorkingColorSpace(this, t), n(e[4]), this;
                        break;
                    case "hsl":
                    case "hsla":
                        if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                            const r = parseFloat(e[1]) / 360,
                                i = parseInt(e[2], 10) / 100,
                                s = parseInt(e[3], 10) / 100;
                            return n(e[4]), this.setHSL(r, i, s, t)
                        }
                }
            } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const e = r[1],
                    n = e.length;
                if (3 === n) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, pe.toWorkingColorSpace(this, t), this;
                if (6 === n) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, pe.toWorkingColorSpace(this, t), this
            }
            return e && e.length > 0 ? this.setColorName(e, t) : this
        }
        setColorName(e, t = "srgb") {
            const n = he[e.toLowerCase()];
            return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b)
        }
        copy(e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        }
        copySRGBToLinear(e) {
            return this.r = le(e.r), this.g = le(e.g), this.b = le(e.b), this
        }
        copyLinearToSRGB(e) {
            return this.r = ce(e.r), this.g = ce(e.g), this.b = ce(e.b), this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this
        }
        getHex(e = "srgb") {
            return pe.fromWorkingColorSpace(ge(this, de), e), Q(255 * de.r, 0, 255) << 16 ^ Q(255 * de.g, 0, 255) << 8 ^ Q(255 * de.b, 0, 255) << 0
        }
        getHexString(e = "srgb") {
            return ("000000" + this.getHex(e).toString(16)).slice(-6)
        }
        getHSL(e, t = "srgb-linear") {
            pe.fromWorkingColorSpace(ge(this, de), t);
            const n = de.r,
                r = de.g,
                i = de.b,
                s = Math.max(n, r, i),
                o = Math.min(n, r, i);
            let a, l;
            const c = (o + s) / 2;
            if (o === s) a = 0, l = 0;
            else {
                const e = s - o;
                switch (l = c <= .5 ? e / (s + o) : e / (2 - s - o), s) {
                    case n:
                        a = (r - i) / e + (r < i ? 6 : 0);
                        break;
                    case r:
                        a = (i - n) / e + 2;
                        break;
                    case i:
                        a = (n - r) / e + 4
                }
                a /= 6
            }
            return e.h = a, e.s = l, e.l = c, e
        }
        getRGB(e, t = "srgb-linear") {
            return pe.fromWorkingColorSpace(ge(this, de), t), e.r = de.r, e.g = de.g, e.b = de.b, e
        }
        getStyle(e = "srgb") {
            return pe.fromWorkingColorSpace(ge(this, de), e), e !== oe ? `color(${e} ${de.r} ${de.g} ${de.b})` : `rgb(${255*de.r|0},${255*de.g|0},${255*de.b|0})`
        }
        offsetHSL(e, t, n) {
            return this.getHSL(fe), fe.h += e, fe.s += t, fe.l += n, this.setHSL(fe.h, fe.s, fe.l), this
        }
        add(e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        }
        addColors(e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        }
        addScalar(e) {
            return this.r += e, this.g += e, this.b += e, this
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        }
        multiply(e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        }
        multiplyScalar(e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
        }
        lerpHSL(e, t) {
            this.getHSL(fe), e.getHSL(_e);
            const n = ee(fe.h, _e.h, t),
                r = ee(fe.s, _e.s, t),
                i = ee(fe.l, _e.l, t);
            return this.setHSL(n, r, i), this
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }
        fromArray(e, t = 0) {
            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        }
        toArray(e = [], t = 0) {
            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
        }
        toJSON() {
            return this.getHex()
        }*[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b
        }
    }
    ve.NAMES = he;
    const be = new Map;

    function xe(e) {
        return (t, n) => {
            const r = t.constructor;
            if (r === Object) throw new Error("All properties in an object are serialized by default");
            be.has(r) || be.set(r, []), be.get(r).push([e || n, n])
        }
    }
    const ye = {
            obj: (e, t) => Object.fromEntries(Object.entries(e).map((([e, n]) => [e, Me(n, !1, t)]))),
            vec4: e => ({
                x: e.x,
                y: e.y,
                z: e.z,
                w: e.w,
                isVector4: !0
            }),
            vec3: e => ({
                x: e.x,
                y: e.y,
                z: e.z,
                isVector3: !0
            }),
            vec2: e => ({
                x: e.x,
                y: e.y,
                isVector2: !0
            }),
            color: e => ({
                r: e.r,
                g: e.g,
                b: e.b,
                isColor: !0
            }),
            quat: e => ({
                x: e.x,
                y: e.y,
                z: e.z,
                w: e.w,
                isQuaternion: !0
            }),
            texture: (e, t) => {
                if (!(null == e ? void 0 : e.isTexture)) throw new Error("Expected a texture");
                if (e.isRenderTargetTexture) return;
                if (null == t ? void 0 : t.textures[e.uuid]) return {
                    uuid: e.uuid,
                    resource: "textures"
                };
                const n = e.source.data;
                e.userData.rootPath && (e.source.data = null);
                let r = e.toJSON(t);
                return e.userData.rootPath && (delete t.images[e.source.uuid], e.source.data = n), (null == t ? void 0 : t.textures) && (t.textures[r.uuid] || (t.textures[r.uuid] = r), r = {
                    uuid: r.uuid,
                    resource: "textures"
                }), r
            },
            material: (e, t) => {
                var n;
                if (!(null == e ? void 0 : e.isMaterial)) throw new Error("Expected a material");
                if (null == t ? void 0 : t.materials[e.uuid]) return {
                    uuid: e.uuid,
                    resource: "materials"
                };
                e.userData.rootPath && console.error("TODO: handle material with root path");
                const r = null != t ? t : {
                        textures: {},
                        images: {}
                    },
                    i = {},
                    s = {};
                for (const [t, o] of Object.entries(e))
                    if ((null === (n = o) || void 0 === n ? void 0 : n.isTexture) && !t.startsWith("_")) {
                        const n = ye.texture(o, r);
                        i[t] = n, s[t] = o, e[t] = n ? {
                            isTexture: !0,
                            toJSON: () => n
                        } : null
                    }
                let o = e.toJSON(t);
                for (const [t, n] of Object.entries(s)) e[t] = n, delete s[t];
                if (t) {
                    for (const [e, t] of Object.entries(i)) t && (o[e] = t);
                    (null == t ? void 0 : t.materials) && (t.materials[o.uuid] || (t.materials[o.uuid] = o), o = {
                        uuid: o.uuid,
                        resource: "materials"
                    })
                } else {
                    for (const [e, t] of Object.entries(i)) o[e] = t.uuid;
                    o.textures = Object.values(r.textures), o.images = Object.values(r.images)
                }
                return o
            }
        },
        we = e => (t, n) => {
            var r, i;
            return null !== (i = null === (r = null == n ? void 0 : n.copy) || void 0 === r ? void 0 : r.call(n, t)) && void 0 !== i ? i : (new e).copy(t)
        },
        Se = {
            obj: (e, t, n) => Object.assign(t, Object.fromEntries(Object.entries(e).map((([e, r]) => [e, Te(r, null == t ? void 0 : t[e], !1, n)])))),
            vec4: we(i.Ltg),
            vec3: we(i.Pa4),
            vec2: we(k),
            color: we(ve),
            quat: we(i._fP)
        };

    function Me(e, t, n) {
        var r, i;
        if ("function" == typeof e) return;
        if (Array.isArray(e)) return e.map((e => Me(e, !1, n)));
        if ("object" != typeof e) {
            if ("number" == typeof e) {
                if (e === 1 / 0) return "Infinity";
                if (e === -1 / 0) return "-Infinity";
                if (isNaN(e)) return "NaN"
            }
            return e
        }
        if (!e) return e;
        let s = null !== (r = e.constructor) && void 0 !== r ? r : Object;
        if (s === Object) return ye.obj(e, n);
        if (e.isVector2) return ye.vec2(e);
        if (e.isVector3) return ye.vec3(e);
        if (e.isVector4) return ye.vec4(e);
        if (e.isColor) return ye.color(e);
        if (e.isQuaternion) return ye.quat(e);
        if (e.isTexture) return ye.texture(e, n);
        if (e.isMaterial) return ye.material(e, n);
        if (!t && "function" == typeof e.toJSON) return e.toJSON(n);
        const o = {};
        for (; s && s !== Object;) null === (i = be.get(s)) || void 0 === i || i.forEach((([t, r]) => {
            const i = e[r];
            o[t] = Me(i, !1, n)
        })), s = Object.getPrototypeOf(s);
        return e.serializableClassId && (o.serializableClassId = e.serializableClassId), o
    }

    function Te(e, t, n, r) {
        var i, s, o;
        let a = t;
        if (void 0 === e) return a;
        if ("number" == typeof t) return "Infinity" === e ? 1 / 0 : "-Infinity" === e ? -1 / 0 : "NaN" === e ? NaN : e;
        if (Array.isArray(e)) {
            const t = e.length;
            Array.isArray(a) || (a = []);
            for (let n = 0; n < t; n++) {
                const t = e[n],
                    i = a.length > n ? Te(t, a[n], !1, r) : Te(t, void 0, !1, r);
                a.length <= n ? a.push(i) : a[n] = i
            }
            return a
        }
        let l = !1;
        if (e && e.resource && "string" == typeof e.resource && (e = null === (i = r[e.resource]) || void 0 === i ? void 0 : i[e.uuid], l = !0), !a && e)
            if (e.serializableClassId) {
                const t = Ee.get(e.serializableClassId);
                t && (a = new t)
            } else "object" != typeof e || e.constructor && e.constructor !== Object || (a = {});
        if ("function" == typeof a) return console.error("cannot deserialize over function", a, e), a;
        if (e && "object" == typeof e) {
            if (e.isVector2) return Se.vec2(e, a);
            if (e.isVector3) return Se.vec3(e, a);
            if (e.isVector4) return Se.vec4(e, a);
            if (e.isColor) return Se.color(e, a);
            if (e.isQuaternion) return Se.quat(e, a)
        }
        if (null == e || null == a || "object" != typeof a || a.isTexture) return l && (e ? e.__useCount = e.__useCount ? e.__useCount + 1 : 1 : console.warn("probable error deserialize: resource not found.")), e;
        let c = null !== (s = a.constructor) && void 0 !== s ? s : Object;
        if (c === Object) return Se.obj(e, a, r);
        if (!n && "function" == typeof a.fromJSON) return a.isMaterial && Object.entries(e).forEach((([t, n]) => {
            var i;
            if (!n || !n.resource || "string" != typeof n.resource) return;
            const s = null === (i = r[n.resource]) || void 0 === i ? void 0 : i[n.uuid];
            e[t] = s || null
        })), a.fromJSON(e, r), a;
        for (; c && c !== Object;) null === (o = be.get(c)) || void 0 === o || o.forEach((([t, n]) => {
            const i = a[n],
                s = Te(e[t], i, !1, r);
            s !== i && g(a, n, s, !0)
        })), c = Object.getPrototypeOf(c);
        return a
    }
    const Ee = new Map;

    function Ae(e) {
        return t => (t = class extends t {
            constructor() {
                super(...arguments), this.serializableClassId = e
            }
        }, Ee.set(e, t), t)
    }
    const Ce = {
            type: "change"
        },
        Re = {
            type: "start"
        },
        ke = {
            type: "end"
        };
    class Pe extends i.pBf {
        constructor(e, t) {
            super(), void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new i.Pa4, this.minDistance = .01, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.maxZoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
                LEFT: "ArrowLeft",
                UP: "ArrowUp",
                RIGHT: "ArrowRight",
                BOTTOM: "ArrowDown"
            }, this.mouseButtons = {
                LEFT: i.RsA.ROTATE,
                MIDDLE: i.RsA.DOLLY,
                RIGHT: i.RsA.PAN
            }, this.touches = {
                ONE: i.QmN.ROTATE,
                TWO: i.QmN.DOLLY_PAN
            }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
                return a.phi
            }, this.getAzimuthalAngle = function() {
                return a.theta
            }, this.getDistance = function() {
                return this.object.position.distanceTo(this.target)
            }, this.listenToKeyEvents = function(e) {
                e.addEventListener("keydown", H), this._domElementKeyEvents = e
            }, this.saveState = function() {
                n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
            }, this.reset = function() {
                n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(Ce), n.update(), s = r.NONE
            }, this.update = function() {
                const t = new i.Pa4,
                    h = (new i._fP).setFromUnitVectors(e.up, new i.Pa4(0, 1, 0)),
                    d = h.clone().invert(),
                    f = new i.Pa4,
                    _ = new i._fP,
                    m = 2 * Math.PI;
                return function() {
                    const e = n.object.position;
                    t.copy(e).sub(n.target), t.applyQuaternion(h), a.setFromVector3(t), n.autoRotate && s === r.NONE && M(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (a.theta += l.theta * n.dampingFactor, a.phi += l.phi * n.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
                    let i = n.minAzimuthAngle,
                        g = n.maxAzimuthAngle;
                    isFinite(i) && isFinite(g) && (i < -Math.PI ? i += m : i > Math.PI && (i -= m), g < -Math.PI ? g += m : g > Math.PI && (g -= m), a.theta = i <= g ? Math.max(i, Math.min(g, a.theta)) : a.theta > (i + g) / 2 ? Math.max(i, a.theta) : Math.min(g, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), n.enableDamping && (a.radius *= 1 + l.radius * n.dampingFactor), a.radius *= c, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), !0 === n.enableDamping ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), t.setFromSpherical(a), t.applyQuaternion(d), e.copy(n.target).add(t), n.object.lookAt(n.target);
                    let v = !1;
                    return !0 === n.enableDamping && Math.abs(l.theta) + Math.abs(l.phi) + Math.abs(l.radius) + u.length() > .001 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, l.radius *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor), v = !0) : (l.set(0, 0, 0), u.set(0, 0, 0)), c = 1, !!(p || v || f.distanceToSquared(n.object.position) > o || 8 * (1 - _.dot(n.object.quaternion)) > o) && (n.dispatchEvent(Ce), f.copy(n.object.position), _.copy(n.object.quaternion), p = !1, !0)
                }
            }(), this.stopDamping = function() {
                l.set(0, 0, 0), u.set(0, 0, 0)
            }, this.dispose = function() {
                n.domElement.removeEventListener("contextmenu", W), n.domElement.removeEventListener("pointerdown", B), n.domElement.removeEventListener("pointercancel", V), n.domElement.removeEventListener("wheel", G), n.domElement.removeEventListener("pointermove", j), n.domElement.removeEventListener("pointerup", z), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", H)
            };
            const n = this,
                r = {
                    NONE: -1,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                    TOUCH_ROTATE: 3,
                    TOUCH_PAN: 4,
                    TOUCH_DOLLY_PAN: 5,
                    TOUCH_DOLLY_ROTATE: 6
                };
            let s = r.NONE;
            const o = 1e-6,
                a = new i.$V,
                l = new i.$V;
            let c = 1;
            const u = new i.Pa4;
            let p = !1;
            const h = new i.FM8,
                d = new i.FM8,
                f = new i.FM8,
                _ = new i.FM8,
                m = new i.FM8,
                g = new i.FM8,
                v = new i.FM8,
                b = new i.FM8,
                x = new i.FM8,
                y = [],
                w = {};

            function S() {
                return n.enableDamping ? 1 : Math.pow(.95, n.zoomSpeed)
            }

            function M(e) {
                l.theta -= e
            }

            function T(e) {
                l.phi -= e
            }
            this.rotateUp = T, this.rotateLeft = M;
            const E = function() {
                    const e = new i.Pa4;
                    return function(t, n) {
                        e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), u.add(e)
                    }
                }(),
                A = function() {
                    const e = new i.Pa4;
                    return function(t, r) {
                        !0 === n.screenSpacePanning ? e.setFromMatrixColumn(r, 1) : (e.setFromMatrixColumn(r, 0), e.crossVectors(n.object.up, e)), e.multiplyScalar(t), u.add(e)
                    }
                }(),
                C = function() {
                    const e = new i.Pa4;
                    return function(t, r) {
                        const i = n.domElement;
                        if (n.object.isPerspectiveCamera) {
                            const s = n.object.position;
                            e.copy(s).sub(n.target);
                            let o = e.length();
                            o *= Math.tan(n.object.fov / 2 * Math.PI / 180), E(2 * t * o / i.clientHeight, n.object.matrix), A(2 * r * o / i.clientHeight, n.object.matrix)
                        } else n.object.isOrthographicCamera ? (E(t * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), A(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                    }
                }();

            function R(e, t = 0) {
                n.object.isPerspectiveCamera ? (c /= e, l.radius -= t, l.radius = Math.max(-n.maxZoomSpeed, Math.min(n.maxZoomSpeed, l.radius))) : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * e)), n.object.updateProjectionMatrix(), p = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
            }

            function k(e, t = 0) {
                n.object.isPerspectiveCamera ? (c *= e, l.radius += t, l.radius = Math.max(-n.maxZoomSpeed, Math.min(n.maxZoomSpeed, l.radius))) : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / e)), n.object.updateProjectionMatrix(), p = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
            }

            function P(e) {
                h.set(e.clientX, e.clientY)
            }

            function D(e) {
                _.set(e.clientX, e.clientY)
            }

            function O() {
                if (1 === y.length) h.set(y[0].pageX, y[0].pageY);
                else {
                    const e = .5 * (y[0].pageX + y[1].pageX),
                        t = .5 * (y[0].pageY + y[1].pageY);
                    h.set(e, t)
                }
            }

            function L() {
                if (1 === y.length) _.set(y[0].pageX, y[0].pageY);
                else {
                    const e = .5 * (y[0].pageX + y[1].pageX),
                        t = .5 * (y[0].pageY + y[1].pageY);
                    _.set(e, t)
                }
            }

            function I() {
                const e = y[0].pageX - y[1].pageX,
                    t = y[0].pageY - y[1].pageY,
                    n = Math.sqrt(e * e + t * t);
                v.set(0, n)
            }

            function F(e) {
                if (1 == y.length) d.set(e.pageX, e.pageY);
                else {
                    const t = q(e),
                        n = .5 * (e.pageX + t.x),
                        r = .5 * (e.pageY + t.y);
                    d.set(n, r)
                }
                f.subVectors(d, h).multiplyScalar(n.rotateSpeed);
                const t = n.domElement;
                M(2 * Math.PI * f.x / t.clientHeight), T(2 * Math.PI * f.y / t.clientHeight), h.copy(d)
            }

            function N(e) {
                if (1 === y.length) m.set(e.pageX, e.pageY);
                else {
                    const t = q(e),
                        n = .5 * (e.pageX + t.x),
                        r = .5 * (e.pageY + t.y);
                    m.set(n, r)
                }
                g.subVectors(m, _).multiplyScalar(n.panSpeed), C(g.x, g.y), _.copy(m)
            }

            function U(e) {
                const t = q(e),
                    r = e.pageX - t.x,
                    i = e.pageY - t.y,
                    s = Math.sqrt(r * r + i * i);
                b.set(0, s), x.set(0, Math.pow(b.y / v.y, n.zoomSpeed)), R(x.y), v.copy(b)
            }

            function B(e) {
                !1 !== n.enabled && (0 === y.length && (n.domElement.setPointerCapture(e.pointerId), n.domElement.addEventListener("pointermove", j), n.domElement.addEventListener("pointerup", z)), function(e) {
                    y.push(e)
                }(e), "touch" === e.pointerType ? function(e) {
                    switch (X(e), y.length) {
                        case 1:
                            switch (n.touches.ONE) {
                                case i.QmN.ROTATE:
                                    if (!1 === n.enableRotate) return;
                                    O(), s = r.TOUCH_ROTATE;
                                    break;
                                case i.QmN.PAN:
                                    if (!1 === n.enablePan) return;
                                    L(), s = r.TOUCH_PAN;
                                    break;
                                default:
                                    s = r.NONE
                            }
                            break;
                        case 2:
                            switch (n.touches.TWO) {
                                case i.QmN.DOLLY_PAN:
                                    if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                    n.enableZoom && I(), n.enablePan && L(), s = r.TOUCH_DOLLY_PAN;
                                    break;
                                case i.QmN.DOLLY_ROTATE:
                                    if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                    n.enableZoom && I(), n.enableRotate && O(), s = r.TOUCH_DOLLY_ROTATE;
                                    break;
                                default:
                                    s = r.NONE
                            }
                            break;
                        default:
                            s = r.NONE
                    }
                    s !== r.NONE && n.dispatchEvent(Re)
                }(e) : function(e) {
                    let t;
                    switch (e.button) {
                        case 0:
                            t = n.mouseButtons.LEFT;
                            break;
                        case 1:
                            t = n.mouseButtons.MIDDLE;
                            break;
                        case 2:
                            t = n.mouseButtons.RIGHT;
                            break;
                        default:
                            t = -1
                    }
                    switch (t) {
                        case i.RsA.DOLLY:
                            if (!1 === n.enableZoom) return;
                            ! function(e) {
                                v.set(e.clientX, e.clientY)
                            }(e), s = r.DOLLY;
                            break;
                        case i.RsA.ROTATE:
                            if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                if (!1 === n.enablePan) return;
                                D(e), s = r.PAN
                            } else {
                                if (!1 === n.enableRotate) return;
                                P(e), s = r.ROTATE
                            }
                            break;
                        case i.RsA.PAN:
                            if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                if (!1 === n.enableRotate) return;
                                P(e), s = r.ROTATE
                            } else {
                                if (!1 === n.enablePan) return;
                                D(e), s = r.PAN
                            }
                            break;
                        default:
                            s = r.NONE
                    }
                    s !== r.NONE && n.dispatchEvent(Re)
                }(e))
            }

            function j(e) {
                !1 !== n.enabled && ("touch" === e.pointerType ? function(e) {
                    switch (X(e), s) {
                        case r.TOUCH_ROTATE:
                            if (!1 === n.enableRotate) return;
                            F(e), n.update();
                            break;
                        case r.TOUCH_PAN:
                            if (!1 === n.enablePan) return;
                            N(e), n.update();
                            break;
                        case r.TOUCH_DOLLY_PAN:
                            if (!1 === n.enableZoom && !1 === n.enablePan) return;
                            ! function(e) {
                                n.enableZoom && U(e), n.enablePan && N(e)
                            }(e), n.update();
                            break;
                        case r.TOUCH_DOLLY_ROTATE:
                            if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                            ! function(e) {
                                n.enableZoom && U(e), n.enableRotate && F(e)
                            }(e), n.update();
                            break;
                        default:
                            s = r.NONE
                    }
                }(e) : function(e) {
                    switch (s) {
                        case r.ROTATE:
                            if (!1 === n.enableRotate) return;
                            ! function(e) {
                                d.set(e.clientX, e.clientY), f.subVectors(d, h).multiplyScalar(n.rotateSpeed);
                                const t = n.domElement;
                                M(2 * Math.PI * f.x / t.clientHeight), T(2 * Math.PI * f.y / t.clientHeight), h.copy(d), n.update()
                            }(e);
                            break;
                        case r.DOLLY:
                            if (!1 === n.enableZoom) return;
                            ! function(e) {
                                b.set(e.clientX, e.clientY), x.subVectors(b, v), x.y > 0 ? R(S()) : x.y < 0 && k(S()), v.copy(b), n.update()
                            }(e);
                            break;
                        case r.PAN:
                            if (!1 === n.enablePan) return;
                            ! function(e) {
                                m.set(e.clientX, e.clientY), g.subVectors(m, _).multiplyScalar(n.panSpeed), C(g.x, g.y), _.copy(m), n.update()
                            }(e)
                    }
                }(e))
            }

            function z(e) {
                K(e), 0 === y.length && (n.domElement.releasePointerCapture(e.pointerId), n.domElement.removeEventListener("pointermove", j), n.domElement.removeEventListener("pointerup", z)), n.dispatchEvent(ke), s = r.NONE
            }

            function V(e) {
                K(e)
            }

            function G(e) {
                !1 !== n.enabled && !1 !== n.enableZoom && s === r.NONE && (e.preventDefault(), n.dispatchEvent(Re), function(e) {
                    let t = 0;
                    switch (e.deltaMode) {
                        case 2:
                            t += 1 * e.deltaY;
                            break;
                        case 1:
                            t += .4 * e.deltaY;
                            break;
                        default:
                            t += .01 * e.deltaY
                    }
                    e.deltaY < 0 ? k(S(), t * n.zoomSpeed) : e.deltaY > 0 && R(S(), -t * n.zoomSpeed), n.update()
                }(e), n.dispatchEvent(ke))
            }

            function H(e) {
                !1 !== n.enabled && !1 !== n.enablePan && function(e) {
                    let t = !1;
                    switch (e.code) {
                        case n.keys.UP:
                            C(0, n.keyPanSpeed), t = !0;
                            break;
                        case n.keys.BOTTOM:
                            C(0, -n.keyPanSpeed), t = !0;
                            break;
                        case n.keys.LEFT:
                            C(n.keyPanSpeed, 0), t = !0;
                            break;
                        case n.keys.RIGHT:
                            C(-n.keyPanSpeed, 0), t = !0
                    }
                    t && (e.preventDefault(), n.update())
                }(e)
            }

            function W(e) {
                !1 !== n.enabled && e.preventDefault()
            }

            function K(e) {
                delete w[e.pointerId];
                for (let t = 0; t < y.length; t++)
                    if (y[t].pointerId == e.pointerId) return void y.splice(t, 1)
            }

            function X(e) {
                let t = w[e.pointerId];
                void 0 === t && (t = new i.FM8, w[e.pointerId] = t), t.set(e.pageX, e.pageY)
            }

            function q(e) {
                const t = e.pointerId === y[0].pointerId ? y[1] : y[0];
                return w[t.pointerId]
            }
            this.zoomIn = function(e) {
                R(S(), e * n.zoomSpeed)
            }, this.zoomOut = function(e) {
                k(S(), e * n.zoomSpeed)
            }, n.domElement.addEventListener("contextmenu", W), n.domElement.addEventListener("pointerdown", B), n.domElement.addEventListener("pointercancel", V), n.domElement.addEventListener("wheel", G, {
                passive: !1
            }), this.update()
        }
    }
    var De, Oe = new Uint8Array(16);

    function Le() {
        if (!De && !(De = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return De(Oe)
    }
    for (var Ie = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i, Fe = function(e) {
            return "string" == typeof e && Ie.test(e)
        }, Ne = [], Ue = 0; Ue < 256; ++Ue) Ne.push((Ue + 256).toString(16).substr(1));
    var Be = function(e, t, n) {
        var r = (e = e || {}).random || (e.rng || Le)();
        if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
            n = n || 0;
            for (var i = 0; i < 16; ++i) t[n + i] = r[i];
            return t
        }
        return function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = (Ne[e[t + 0]] + Ne[e[t + 1]] + Ne[e[t + 2]] + Ne[e[t + 3]] + "-" + Ne[e[t + 4]] + Ne[e[t + 5]] + "-" + Ne[e[t + 6]] + Ne[e[t + 7]] + "-" + Ne[e[t + 8]] + Ne[e[t + 9]] + "-" + Ne[e[t + 10]] + Ne[e[t + 11]] + Ne[e[t + 12]] + Ne[e[t + 13]] + Ne[e[t + 14]] + Ne[e[t + 15]]).toLowerCase();
            if (!Fe(n)) throw TypeError("Stringified UUID is invalid");
            return n
        }(r)
    };
    const je = new Map;

    function ze(e, t) {
        return (n, r) => {
            const i = n.constructor;
            if (i === Object) throw new Error("All properties in an object are serialized by default");
            je.has(i) || je.set(i, []);
            const s = je.get(i);
            if (!(s.findIndex((e => e.propKey === r)) < 0)) throw new Error(`Property ${r} already has a uiConfig decorator`);
            s.push({
                params: t || {},
                propKey: r,
                uiType: e
            })
        }
    }

    function Ve(e, t) {
        return ze("checkbox", {
            label: e,
            params: t
        })
    }

    function Ge(e, t) {
        return ze("monitor", {
            label: e,
            params: t
        })
    }

    function He(e, t, n, r) {
        return ze("slider", {
            label: e,
            bounds: t,
            stepSize: n,
            params: r
        })
    }

    function We(e, t, n, r) {
        return ze("vec", {
            label: e,
            bounds: t,
            stepSize: n,
            params: r
        })
    }

    function Ke(e, t, n) {
        return ze("dropdown", {
            label: e,
            children: t,
            params: n
        })
    }

    function Xe(e, t) {
        return ze("button", {
            label: e,
            params: t
        })
    }

    function qe(e, t) {
        return ze("input", {
            label: e,
            params: t
        })
    }

    function Ye(e, t) {
        return ze("color", {
            label: e,
            params: t
        })
    }

    function Ze(e, t) {
        return ze("image", {
            label: e,
            params: t
        })
    }

    function Je(e) {
        let t = null == e ? void 0 : e.constructor;
        if (!e || !t) return [];
        const n = [],
            r = [];
        for (; t && t !== Object;) r.push(t), t = Object.getPrototypeOf(t);
        return r.reverse().forEach((t => {
            var r;
            null === (r = je.get(t)) || void 0 === r || r.forEach((({
                params: t,
                propKey: r,
                uiType: i
            }) => {
                var s;
                let o;
                if (i || (o = null === (s = e[r]) || void 0 === s ? void 0 : s.uiConfig), o || (o = {
                        property: [e, r],
                        type: i || "input"
                    }), t) {
                    const n = "function" == typeof t.params ? t.params(e) : t.params || {};
                    delete t.params, Object.assign(o, { ...t,
                        ...n
                    })
                }
                n.push(o)
            }))
        })), n
    }

    function $e(e, t, n = {}) {
        return {
            type: "folder",
            label: e,
            children: Je(t),
            uuid: Be(),
            ...n
        }
    }

    function Qe(e, t) {
        return n => class extends n {
            constructor() {
                super(...arguments), this.uiConfig = $e(e, this, t || {})
            }
        }
    }
    var et = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let tt = class extends Pe {
        constructor() {
            super(...arguments), this.type = "OrbitControls", this.enableDamping = !0, this.dampingFactor = .08, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableZoom = !0, this.zoomSpeed = .15, this.maxZoomSpeed = .2, this.enableRotate = !0, this.rotateSpeed = 2, this.enablePan = !0, this.panSpeed = 1, this.minDistance = .01, this.maxDistance = 1e3, this.minZoom = .01, this.maxZoom = 1e3, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1e4, this.maxAzimuthAngle = 1e4, this.screenSpacePanning = !0, this.keyPanSpeed = 7
        }
        zoomIn(e) {
            super.zoomIn(e)
        }
        zoomOut(e) {
            super.zoomOut(e)
        }
    };
    et([xe()], tt.prototype, "type", void 0), et([Ve(), xe()], tt.prototype, "enableDamping", void 0), et([qe(), xe()], tt.prototype, "dampingFactor", void 0), et([Ve(), xe()], tt.prototype, "autoRotate", void 0), et([qe(), xe()], tt.prototype, "autoRotateSpeed", void 0), et([Ve(), xe()], tt.prototype, "enableZoom", void 0), et([qe(), xe()], tt.prototype, "zoomSpeed", void 0), et([qe(), xe()], tt.prototype, "maxZoomSpeed", void 0), et([Ve(), xe()], tt.prototype, "enableRotate", void 0), et([qe(), xe()], tt.prototype, "rotateSpeed", void 0), et([Ve(), xe()], tt.prototype, "enablePan", void 0), et([qe(), xe()], tt.prototype, "panSpeed", void 0), et([qe(), xe()], tt.prototype, "minDistance", void 0), et([qe(), xe()], tt.prototype, "maxDistance", void 0), et([qe(), xe()], tt.prototype, "minZoom", void 0), et([qe(), xe()], tt.prototype, "maxZoom", void 0), et([qe(), xe()], tt.prototype, "minPolarAngle", void 0), et([qe(), xe()], tt.prototype, "maxPolarAngle", void 0), et([qe(), xe()], tt.prototype, "minAzimuthAngle", void 0), et([qe(), xe()], tt.prototype, "maxAzimuthAngle", void 0), et([xe()], tt.prototype, "screenSpacePanning", void 0), et([xe()], tt.prototype, "keyPanSpeed", void 0), tt = et([Qe("Orbit Controls")], tt);
    class nt extends r {
        constructor(e, t, n) {
            super(), this._controlsMode = "", this._isActiveCamera = !1, this._interactionsEnabled = !0, this.autoLookAtTarget = !0, this.near = .01, this.far = 50, this._options = {
                type: "PerspectiveCamera",
                aspect: "auto",
                focus: 10,
                fov: 25,
                zoom: 1,
                frustumSize: 1,
                top: 1,
                bottom: -1,
                left: -1,
                right: 1,
                controlsMode: "orbit",
                controlsEnabled: !0
            }, this._position = new i.Pa4(0, 0, 10), this._target = new i.Pa4(0, 0, 0), this.uiConfig = {
                type: "folder",
                label: "Camera",
                limitedUi: !0,
                children: [{
                    type: "input",
                    property: [this._options, "fov"],
                    onChange: () => {
                        this.refreshCameraOptions()
                    },
                    limitedUi: !0
                }, {
                    type: "button",
                    label: "Zoom in",
                    value: () => {
                        var e;
                        null === (e = this._controls) || void 0 === e || e.zoomIn(1)
                    }
                }, {
                    type: "button",
                    label: "Zoom out",
                    value: () => {
                        var e;
                        null === (e = this._controls) || void 0 === e || e.zoomOut(1)
                    }
                }, () => {
                    var e;
                    return null === (e = this._controls) || void 0 === e ? void 0 : e.uiConfig
                }]
            }, this.assetType = "model", this.setDirty = this.setDirty.bind(this), this.targetUpdated = this.targetUpdated.bind(this), this._refreshCameraOptions = this._refreshCameraOptions.bind(this), this._container = null != n ? n : document.body, this._camera = null != e ? e : "OrthographicCamera" === (null == t ? void 0 : t.type) ? new i.iKG(-1, 1, 1, -1) : new i.cPb, this._camera.userData.iCamera = this;
            const r = null != t ? t : this._options,
                s = e;
            e && (s.isPerspectiveCamera ? (r.fov = s.fov, r.focus = s.focus, r.aspect = s.aspect <= 0 || s.userData.autoAspect ? "auto" : s.aspect, r.zoom = s.zoom) : s.isOrthographicCamera && (r.left = s.left, r.right = s.right, r.top = s.top, r.bottom = s.bottom, r.zoom = s.zoom), r.near = s.near, r.far = s.far, this._position.copy(e.position), this.refreshTarget()), this.positionUpdated(!1), e || this.targetUpdated(!1), this.setCameraOptions(r), n && (n.style.touchAction = "none")
        }
        get controls() {
            return this._controls
        }
        get target() {
            return this._target
        }
        set target(e) {
            const t = this._target.sub(e).length() > .01;
            this._target.copy(e), t && this.targetUpdated()
        }
        get position() {
            return this._position
        }
        set position(e) {
            const t = this._position.sub(e).length() > .01;
            this._position.copy(e), t && this.positionUpdated()
        }
        getCameraOptions() {
            return { ...this._options
            }
        }
        setCameraOptions(e, t = !0) {
            const n = { ...e
            };
            Object.keys(n).forEach((e => "frustumSize" !== e && void 0 === n[e] && delete n[e])), Object.assign(this._options, n), this._refreshCameraOptions(!1), this.refreshCameraControls(!1), t && this.setDirty()
        }
        _refreshCameraOptions(e = !0) {
            let t = this._camera,
                n = this._options.aspect;
            if ("auto" === n && (n = this._container.clientWidth / this._container.clientHeight), "PerspectiveCamera" === this._options.type && (t = t, t.fov = this._options.fov, t.focus = this._options.focus, t.aspect = n), "OrthographicCamera" === this._options.type) {
                t = t;
                const e = this._options.frustumSize;
                void 0 !== e ? (t.top = e / 2, t.bottom = -e / 2, t.left = n * e / 2, t.right = -n * e / 2) : (t.top = this._options.top, t.bottom = this._options.bottom, t.left = this._options.left, t.right = this._options.right)
            }
            t.zoom = this._options.zoom, this._nearFarChanged(), e && this.setDirty()
        }
        get interactionsEnabled() {
            return this._interactionsEnabled && this._isActiveCamera && this._options.controlsEnabled
        }
        set interactionsEnabled(e) {
            this._interactionsEnabled !== e && (this._interactionsEnabled = e, this.refreshCameraControls(!0))
        }
        _nearFarChanged() {
            this._camera && (this._camera.near = this.near, this._camera.far = this.far, this._camera.updateProjectionMatrix())
        }
        refreshAspect(e = !0) {
            "auto" === this._options.aspect && this._refreshCameraOptions(e)
        }
        refreshTarget() {
            var e;
            (null === (e = this._controls) || void 0 === e ? void 0 : e.enabled) ? this._target.copy(this._controls.target): this._target.set(0, 0, -1).applyQuaternion(this._camera.getWorldQuaternion(new i._fP))
        }
        _initCameraControls() {
            const e = this._options.controlsMode;
            switch (e) {
                case "orbit":
                    this._controls = new tt(this._camera, this._container), this._controls.screenSpacePanning = !0, this._controls.addEventListener("change", this.setDirty)
            }
            this._controlsMode = e
        }
        _disposeCameraControls() {
            var e;
            switch (this._controlsMode) {
                case "orbit":
                    null === (e = this._controls) || void 0 === e || e.dispose()
            }
            this._controlsMode = "", this._controls = void 0
        }
        refreshCameraControls(e = !0) {
            if (this._options.controlsEnabled) {
                const e = this._options.controlsMode;
                this._controls ? this._controlsMode !== e && (this._disposeCameraControls(), this._initCameraControls()) : this._initCameraControls(), this._controlsMode = e
            }
            if (this._controls) {
                const e = this.interactionsEnabled;
                this._controls.enabled = e, e && this._camera.up.copy(i.Tme.DefaultUp)
            }
            e && this.setDirty()
        }
        setDirty() {
            this._position.copy(this._camera.position), this._controls && this._controls.enabled && this._target.copy(this._controls.target), this.dispatchEvent({
                type: "update"
            })
        }
        activateMain() {
            this._isActiveCamera || (this._isActiveCamera = !0, this.cameraObject.userData.__lastScale = this.cameraObject.scale.clone(), this.cameraObject.scale.divide(this.cameraObject.getWorldScale(new i.Pa4)), this.refreshCameraControls(!0), this.refreshAspect())
        }
        deactivateMain() {
            this._isActiveCamera && (this._isActiveCamera = !1, this.cameraObject.userData.__lastScale && (this.cameraObject.scale.copy(this.cameraObject.userData.__lastScale), delete this.cameraObject.userData.__lastScale), this.refreshCameraControls(!0))
        }
        get cameraObject() {
            return this._camera
        }
        get modelObject() {
            return this._camera
        }
        dispose() {}
        targetUpdated(e = !0) {
            var t;
            const n = this.target;
            null === (t = this._controls) || void 0 === t || t.target.set(n.x, n.y, n.z), this._controls && this._controls.enabled ? (this._controls.update(), e && this.setDirty()) : this._camera && (this.autoLookAtTarget && this._camera.lookAt(n), e && this.setDirty())
        }
        positionUpdated(e = !0) {
            const t = this.position;
            this._camera.position.set(t.x, t.y, t.z), e && this.setDirty()
        }
        updateShaderProperties(e) {
            var t;
            return (null === (t = e.uniforms.cameraPositionWorld) || void 0 === t ? void 0 : t.value) && this._camera.getWorldPosition(e.uniforms.cameraPositionWorld.value), e.uniforms.cameraNearFar ? e.uniforms.cameraNearFar.value.set(this._camera.near, this._camera.far) : console.warn("BaseRenderer: no uniform: cameraNearFar"), e.uniforms.projection && (e.uniforms.projection.value = this._camera.projectionMatrix), e.defines.PERSPECTIVE_CAMERA = "PerspectiveCamera" === this._camera.type ? "1" : "0", e.defines.ORTHOGRAPHIC_CAMERA = "OrthographicCamera" === this._camera.type ? "1" : "0", this
        }
        toJSON(e) {
            return Object.assign({}, Me(this, !0, e))
        }
        fromJSON(e, t) {
            return Te(e, this, !0, t), this.positionUpdated(!1), this.targetUpdated(!1), this.refreshCameraOptions(), this
        }
        refreshCameraOptions(e = !0) {
            this.setCameraOptions(this._options, e)
        }
    }
    et([xe("camControls")], nt.prototype, "_controls", void 0), et([C(nt.prototype._nearFarChanged)], nt.prototype, "near", void 0), et([C(nt.prototype._nearFarChanged)], nt.prototype, "far", void 0), et([xe("camOptions")], nt.prototype, "_options", void 0), et([xe("position")], nt.prototype, "_position", void 0), et([xe("target")], nt.prototype, "_target", void 0);
    class rt {
        constructor() {
            this._processors = new Map
        }
        add(e, t) {
            var n;
            this._processors.has(e) || this._processors.set(e, []), null === (n = this._processors.get(e)) || void 0 === n || n.push(t)
        }
        remove(e, t) {
            const n = this._processors.get(e),
                r = (null == n ? void 0 : n.indexOf(t)) || (null == n ? void 0 : n.findIndex((e => e.process && e.process === t.process || e.processAsync && e.processAsync === t.processAsync)));
            !n || !r || r < 0 || n.splice(r, 1)
        }
        get(e) {
            var t;
            return null !== (t = this._processors.get(e)) && void 0 !== t ? t : []
        }
        async process(e, t, n) {
            var r, i, s, o;
            const a = this.get(e),
                l = t.assetType;
            for (const e of a) e.forAssetType === l && (t = null !== (i = null === (r = e.process) || void 0 === r ? void 0 : r.call(e, t, n)) && void 0 !== i ? i : t, t = null !== (o = await (null === (s = e.processAsync) || void 0 === s ? void 0 : s.call(e, t, n))) && void 0 !== o ? o : t);
            return t
        }
        dispose() {
            this._processors.clear()
        }
    }
    class it {
        constructor(e, {
            pseudoCenter: t = !1,
            autoScale: n = !1,
            autoScaleRadius: r = 2,
            license: s = "",
            ...o
        } = {}) {
            if (this.assetType = "model", this._modelObject = new i.Tme, this.setDirty = this.setDirty.bind(this), this.updateBounds = this.updateBounds.bind(this), n ? e && !e.userData.autoScaled && X(e, e.userData.autoScaleRadius || r) : e.userData.autoScaled = !0, e && t && !e.userData.pseudoCentered) {
                const t = (new P).expandByObject(e, !0, !0).getCenter(new i.Pa4);
                this._modelObject.position.copy(t).negate(), this._modelObject.updateMatrix(), this._modelObject.add(e), this._modelObject.name = e.name + "-centered", this._modelObject.userData.pseudoCentered = !0
            } else t || (e.userData.pseudoCentered = !0), this._modelObject = e;
            this._modelObject.userData.iModel = this, this._modelObject.userData.setDirty = this.setDirty, this._modelObject.userData.updateBounds = this.updateBounds, this._modelObject.addEventListener("added", this.updateBounds), this._modelObject.addEventListener("removed", this.updateBounds), this.license = s, this.updateBounds()
        }
        get modelObject() {
            return this._modelObject
        }
        get license() {
            return this._modelObject.userData.license
        }
        set license(e) {
            this._modelObject.userData.license = e
        }
        addEventListener(e, t) {
            this._modelObject.addEventListener(e, t)
        }
        dispatchEvent(e) {
            this._modelObject.dispatchEvent(e)
        }
        hasEventListener(e, t) {
            return this._modelObject.hasEventListener(e, t)
        }
        removeEventListener(e, t) {
            this._modelObject.removeEventListener(e, t)
        }
        dispose() {
            const e = this._modelObject.userData.dispose;
            e && "function" == typeof e ? e() : this._modelObject.removeFromParent()
        }
        setDirty(e) {
            var t, n;
            this.dispatchEvent({ ...e,
                type: "objectUpdate"
            }), null === (n = null === (t = this._uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === n || n.call(t, "postFrame", !0)
        }
        updateBounds() {
            this.setDirty()
        }
        get uiConfig() {
            return this._uiConfig || (this._uiConfig = st(this._modelObject, !1)), this._uiConfig
        }
        clone() {
            return new it(this._modelObject.clone(), {
                pseudoCenter: !1,
                autoScale: !1
            })
        }
    }

    function st(e, t) {
        const n = {
                type: "folder",
                label: e.name || "unnamed",
                expanded: !0,
                limitedUi: !0,
                children: [{
                    type: "checkbox",
                    label: "Visible",
                    property: [e, "visible"],
                    limitedUi: !0
                }, {
                    type: "button",
                    label: "Pick/Focus",
                    value: () => {
                        e.dispatchEvent({
                            type: "select",
                            ui: !0,
                            value: e
                        })
                    }
                }, {
                    type: "button",
                    label: "Pick Parent",
                    hidden: () => !e.parent,
                    value: () => {
                        const t = e.parent;
                        t && t.dispatchEvent({
                            type: "select",
                            ui: !0,
                            value: t
                        })
                    }
                }, {
                    type: "input",
                    label: "Name",
                    property: [e, "name"]
                }, {
                    type: "checkbox",
                    label: "Casts Shadow",
                    hidden: () => !e.isMesh,
                    property: [e, "castShadow"]
                }, {
                    type: "checkbox",
                    label: "Receive Shadow",
                    hidden: () => !e.isMesh,
                    property: [e, "receiveShadow"]
                }, {
                    type: "vec3",
                    label: "Position",
                    property: [e, "position"],
                    limitedUi: !0
                }, {
                    type: "vec3",
                    label: "Rotation",
                    property: [e, "rotation"],
                    limitedUi: !0
                }, {
                    type: "vec3",
                    label: "Scale",
                    property: [e, "scale"]
                }, {
                    type: "button",
                    label: "Auto Scale",
                    value: () => {
                        const t = parseFloat(prompt("Auto Scale Radius", e.userData.autoScaleRadius || "2") || "0");
                        Math.abs(t) > 1e-4 && X(e, t)
                    }
                }, void 0 !== e.userData.license ? {
                    type: "input",
                    label: "License/Credits",
                    property: [e.userData, "license"],
                    limitedUi: !0
                } : {}]
            },
            r = e;
        if ((null == r ? void 0 : r.isMesh) && !1 !== t) {
            const e = [() => {
                var e;
                return null === (e = r.geometry) || void 0 === e ? void 0 : e.uiConfig
            }, () => {
                var e;
                return Array.isArray(r.material) ? r.material.length < 1 ? void 0 : {
                    label: "Materials",
                    type: "folder",
                    children: r.material.map((e => null == e ? void 0 : e.uiConfig)).filter((e => e))
                } : null === (e = r.material) || void 0 === e ? void 0 : e.uiConfig
            }];
            n.children.push(...e)
        }
        return n
    }

    function ot(e) {
        return {
            label: "Geometry",
            type: "folder",
            children: [{
                type: "input",
                property: [e, "uuid"],
                disabled: !0
            }, {
                type: "button",
                label: "Create uv2 from uv",
                value: () => {
                    e.hasAttribute("uv2") && !confirm("uv2 already exists, replace with uv data?") || e.setAttribute("uv2", e.getAttribute("uv"))
                }
            }, {
                type: "input",
                label: "Mesh count",
                get value() {
                    var t, n, r;
                    return null !== (r = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.appliedMeshes) || void 0 === n ? void 0 : n.size) && void 0 !== r ? r : 0
                },
                set value(e) {},
                disabled: !0
            }]
        }
    }

    function at(e, t) {
        const n = e.modelObject;
        return n.traverse((r => {
            lt(r, r !== n ? e : void 0, t)
        })), e
    }

    function lt(e, t, n) {
        var r;
        if (!e) return void console.warn("setupIModel: object is undefined");
        if (e.userData || (e.userData = {}), e.userData.__iModelSetup && e.modelObject) return e;
        e.userData.__iModelSetup = !0;
        const i = [];
        if (i.push((() => {
                e.parent && e.removeFromParent()
            })), e.isLight && !e.assetType ? (e.assetType = "light", e.lightObject = e) : e.isCamera ? (e.assetType = "camera", e.cameraObject = e) : e.assetType || (e.assetType = "model"), e.modelObject || (e.modelObject = e), !e.userData.setDirty) {
            e.userData.setDirty = t => {
                var n, r;
                e.dispatchEvent({ ...t,
                    type: "objectUpdate"
                }), null === (r = null === (n = e.uiConfig) || void 0 === n ? void 0 : n.uiRefresh) || void 0 === r || r.call(n, "postFrame", !0)
            };
            const t = t => {
                    var n, r, i, s;
                    const o = null !== (r = null === (n = e.parent) || void 0 === n ? void 0 : n.userData.parentRoot) && void 0 !== r ? r : e.parent;
                    o !== e.userData.parentRoot && e.traverse((e => {
                        e.userData.parentRoot = o
                    })), null === (s = (i = e.userData).setDirty) || void 0 === s || s.call(i)
                },
                n = () => {
                    var t, n;
                    void 0 !== e.userData.parentRoot && e.traverse((e => {
                        e.userData.parentRoot = void 0
                    })), null === (n = (t = e.userData).setDirty) || void 0 === n || n.call(t)
                };
            e.addEventListener("added", t), e.addEventListener("removed", n), i.push((() => {
                e.removeEventListener("added", t), e.removeEventListener("removed", n)
            }))
        }
        e.userData.dispose ? console.warn("onDispose already set, disposing might be buggy.") : e.userData.dispose = () => i.forEach((e => e()));
        const s = e;
        s.isMesh && !s.userData.__meshSetup && (s.userData.setMaterial || (s.userData.setMaterial = e => ht(s, e)), s.userData.setGeometry || (s.userData.setGeometry = (e, t = !1) => dt(s, e, t), s.userData.setGeometry(s.geometry, !0)), e.userData.__keepShadowDef || (e.castShadow = !0, e.receiveShadow = !0, e.userData.__keepShadowDef = !0), i.push((() => {
            const e = s.userData.setMaterial(void 0),
                t = s.userData.setGeometry(void 0);
            for (const t of e);
            t && 0 === t.userData.appliedMeshes.size && !1 !== t.userData.disposeOnIdle && t.dispose()
        })), s.userData.__meshSetup = !0), e.uiConfig || "model" !== e.assetType || (e.uiConfig = st(e), i.push((() => {
            e.uiConfig = void 0
        }))), t && (e.userData.parentRoot = t), i.push((() => {
            delete e.userData.parentRoot
        }));
        const o = t => {
            var n;
            const r = null !== (n = e.userData.parentRoot) && void 0 !== n ? n : e.parent;
            (null == r ? void 0 : r.modelObject) && r.dispatchEvent(t)
        };
        e.addEventListener("objectUpdate", o), e.addEventListener("materialUpdate", o), e.addEventListener("select", o), i.push((() => {
            e.removeEventListener("objectUpdate", o), e.removeEventListener("materialUpdate", o), e.removeEventListener("select", o)
        }));
        const a = e.clone;
        e.clone = (...t) => {
            const r = e.userData,
                i = {};
            Object.entries(r).forEach((([e, t]) => {
                (!t || "function" == typeof t || t.isObject3D || t.isTexture || t.isMaterial || null != t.assetType || e.startsWith("__") || ut.includes(e)) && (i[e] = t, delete r[e])
            }));
            let s = a.call(e, ...t);
            Object.entries(i).forEach((([e, t]) => {
                r[e] = t, delete i[e]
            }));
            const o = e.userData.parentRoot;
            return o && "model" !== o.assetType && console.warn("Cloning an object with a parent that is not an IModel is not supported"), s = lt(s, o, n), s.userData.cloneParent = e.uuid, s
        }, i.push((() => {
            e.clone = a
        }));
        const l = e.add;
        return e.add = (...t) => (t.forEach((t => lt(t, e.userData.parentRoot || e, n))), l.call(e, ...t)), i.push((() => {
            e.add = l
        })), e = null !== (r = null == n ? void 0 : n(e)) && void 0 !== r ? r : e, i.push((() => {
            e.modelObject = void 0, e.userData = {}
        })), e
    }
    const ct = ["appliedMeshes"],
        ut = ["parentRoot", "iCamera"];

    function pt(e, t) {
        if (t)
            for (const n of Object.keys(t)) ut.includes(n) || n.startsWith("__") || "function" != typeof e[n] && "function" != typeof t[n] && (e[n] = t[n]);
        return e
    }

    function ht(e, t) {
        var n, r, i, s;
        const o = (Array.isArray(t) ? t : [t]).map((e => null == e ? void 0 : e.materialObject)).filter((e => e));
        if (e.material == o || 1 === o.length && e.material === o[0]) return [];
        e.userData.__materialUpdater || (e.userData.__materialUpdater = () => {
            e.dispatchEvent({
                type: "materialUpdate"
            })
        });
        const a = Array.isArray(e.material) ? [...e.material] : [e.material];
        for (const t of a) t && (t.removeEventListener("materialUpdate", e.userData.__materialUpdater), null === (r = null === (n = t.userData) || void 0 === n ? void 0 : n.appliedMeshes) || void 0 === r || r.delete(e));
        const l = [];
        for (const t of o) t.userData.appliedMeshes || (t.userData.appliedMeshes = new Set), l.push(t), t && (t.addEventListener("materialUpdate", e.userData.__materialUpdater), t.userData.appliedMeshes.add(e));
        return e.material = 1 !== l.length ? l : l[0], e.traverseAncestors((t => {
            t.isRootScene && t.refreshEnvMapIntensity(e)
        })), e.dispatchEvent({
            type: "materialChanged",
            material: t
        }), null === (s = null === (i = e.uiConfig) || void 0 === i ? void 0 : i.uiRefresh) || void 0 === s || s.call(i, "postFrame", !0), a
    }

    function dt(e, t, n = !1) {
        var r, i, s, o, a, l;
        e.userData.__objectUpdater || (e.userData.__objectUpdater = t => {
            e.dispatchEvent({ ...t,
                type: "objectUpdate"
            })
        });
        let c = e.geometry;
        const u = c;
        return (c !== t || n) && (c && (c.removeEventListener("geometryUpdate", e.userData.__objectUpdater), null === (i = null === (r = c.userData) || void 0 === r ? void 0 : r.appliedMeshes) || void 0 === i || i.delete(e)), c = t, c && !c.userData.appliedMeshes && (c.userData.appliedMeshes = new Set), e.geometry = c, c && (c.addEventListener("geometryUpdate", e.userData.__objectUpdater), null === (o = null === (s = c.userData) || void 0 === s ? void 0 : s.appliedMeshes) || void 0 === o || o.add(e))), t.uiConfig || (t.uiConfig = ot(e.geometry)), e.dispatchEvent({
            type: "geometryChanged",
            geometry: t
        }), null === (l = null === (a = e.uiConfig) || void 0 === a ? void 0 : a.uiRefresh) || void 0 === l || l.call(a, "postFrame", !0), u === c ? void 0 : u
    }
    var ft = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class _t extends i.xsS {
        constructor(e) {
            super(), this.isRootScene = !0, this.assetType = "model", this._sceneBounds = new P, this._sceneBoundingRadius = 0, this._processors = new rt, this._cameras = [], this._activeCamera = -1, this.envMapIntensity = 1, this._dummyCam = new nt(new i.cPb, {
                controlsMode: "",
                controlsEnabled: !1
            }), this.environment = null, this.background = null, this.minNearDistance = .2, this.setDirty = this.setDirty.bind(this), this.refreshActiveCameraNearFar = this.refreshActiveCameraNearFar.bind(this), this._activeCameraUpdate = this._activeCameraUpdate.bind(this), this._onSceneMaterialUpdate = this._onSceneMaterialUpdate.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this.addEventListener("materialUpdate", this._onSceneMaterialUpdate), this.addEventListener("objectUpdate", this._onSceneUpdate), this.defaultCamera = e, this.modelRoot = lt(new i.ZAu, void 0), this.modelRoot.userData.rootSceneModelRoot = !0, this.modelRoot.name = "Scene", this.modelRoot.addEventListener("update", this.setDirty), this.addSceneObject(this.modelRoot, {
                addToRoot: !0,
                autoScale: !1
            }), this.addSceneObject(this.defaultCamera, {
                addToRoot: !0
            }), this.activeCamera = this.defaultCamera, this.boxHelper = new i.GQ(this.getBounds())
        }
        refreshEnvMapIntensity(e) {
            return (null == e ? void 0 : e.isObject3D) || (e = this), (null != e ? e : this).traverse((e => {
                const t = e.material;
                t && void 0 !== t.envMapIntensity && !t.userData.separateEnvMapIntensity && (t.envMapIntensity = this.envMapIntensity, t.needsUpdate = !0)
            })), this.setDirty(), this
        }
        get activeCamera() {
            return this._activeCamera >= 0 ? this._cameras[this._activeCamera] : this._dummyCam
        }
        set activeCamera(e) {
            const t = this.activeCamera;
            if (e || (e = this.defaultCamera), t !== e) {
                if (t && (t.deactivateMain(), t.removeEventListener("update", this._activeCameraUpdate)), e) {
                    e.activateMain(), e.addEventListener("update", this._activeCameraUpdate);
                    let t = this._cameras.indexOf(e);
                    t < 0 && (this._cameras.push(e), t = this._cameras.length - 1), this._activeCamera = t
                } else this._activeCamera = -1;
                this.dispatchEvent({
                    type: "activeCameraChange"
                }), this.setDirty()
            }
        }
        get modelObject() {
            return this
        }
        addModel(e, t = {}) {
            return "model" !== e.assetType && console.error("Invalid asset type for ", e, ", adding anyway"), this.addSceneObject(e, t)
        }
        addWidget(e, t = {}) {
            "widget" !== e.assetType && console.warn("Invalid asset type for ", e, ", adding anyway"), this.add(e.modelObject)
        }
        _addModel(e, t = {}) {
            return this._addObject3D(null == e ? void 0 : e.modelObject, t)
        }
        addSceneObject(e, t) {
            if (!e) return e;
            const n = e.assetType;
            let r = !1;
            switch (n) {
                case "model":
                    r = e.modelObject.isCamera, r && (t = { ...t,
                        autoScale: !1
                    }), this._addModel(e, t);
                    break;
                case "material":
                    break;
                case "texture":
                    this.dispatchEvent({
                        type: "textureAdded",
                        texture: e
                    });
                    break;
                case "light":
                    this._addLight(e, t);
                    break;
                default:
                    console.warn("Unknown asset imported", e, n)
            }
            return this.dispatchEvent({
                type: "addSceneObject",
                object: e
            }), e
        }
        _addObject3D(e, {
            autoScale: t = !0,
            autoScaleRadius: n = 2,
            addToRoot: r = !1
        } = {}) {
            const i = e;
            i ? (t && !i.userData.autoScaled && X(i, i.userData.autoScaleRadius || n), i.traverse((e => {
                e.isMesh && !e.userData.__keepShadowDef && (e.castShadow = !0, e.receiveShadow = !0, e.userData.__keepShadowDef = !0)
            })), this.refreshEnvMapIntensity(i), r ? this.modelObject.add(i) : this.modelRoot.add(i), this.setDirty()) : console.error("Invalid Model, cannot add.")
        }
        _onEnvironmentChange() {
            this.dispatchEvent({
                type: "environmentChanged",
                environment: this.getEnvironment()
            }), this._onSceneUpdate()
        }
        add(...e) {
            return super.add(...e), this._onSceneUpdate(), this
        }
        async setEnvironment(e) {
            if (!e) return this.environment = null, this.dispatchEvent({
                type: "environmentChanged"
            }), void this._onSceneUpdate();
            if ("texture" !== (null == e ? void 0 : e.assetType)) return void console.error("Unknown Environment type", e);
            e.mapping === i.xfE && (e.mapping = i.dSO, e.needsUpdate = !0);
            const t = (e = await this.processors.process("environment", e, {})).textureObject || e;
            this.environment = t, this._onEnvironmentChange()
        }
        getEnvironment() {
            return this.environment
        }
        async setBackground(e) {
            var t;
            let n;
            if (!e || "texture" === e.assetType || e.isColor || e.isVector4) n = "texture" === (null === (t = e) || void 0 === t ? void 0 : t.assetType) && (e = await this.processors.process("background", e, {})).textureObject || e;
            else {
                if ("string" != typeof e && "number" != typeof e) return void console.error("Unknown Background type", e);
                n = new i.Ilk(e)
            }
            this.background = n, this._onSceneUpdate({
                geometryChanged: !1
            })
        }
        getBackground() {
            return this.background
        }
        get processors() {
            return this._processors
        }
        setDirty(e) {
            return (null == e ? void 0 : e.sceneUpdate) ? this._onSceneUpdate(e) : this.dispatchEvent({
                type: "update"
            }), this
        }
        _activeCameraUpdate() {
            this.setDirty(), this.refreshActiveCameraNearFar(), this.dispatchEvent({
                type: "activeCameraUpdate"
            })
        }
        _onSceneUpdate(e = {}) {
            var t, n, r;
            this.refreshActiveCameraNearFar(), this._sceneBounds = this.getBounds(!1, !0), null === (r = null === (n = null === (t = this.boxHelper) || void 0 === t ? void 0 : t.box) || void 0 === n ? void 0 : n.copy) || void 0 === r || r.call(n, this._sceneBounds), this._sceneBoundingRadius = this._sceneBounds.getSize(new i.Pa4).length() / 2, this.dispatchEvent({ ...e,
                type: "sceneUpdate"
            })
        }
        _onSceneMaterialUpdate() {
            this.dispatchEvent({
                type: "sceneMaterialUpdate"
            })
        }
        dispose() {
            this.clear()
        }
        findObjectsByName(e, t) {
            const n = [];
            return (null != t ? t : this.modelObject).traverse((t => {
                t.name === e && n.push(t)
            })), n
        }
        addLight(e, t = {}) {
            this.addSceneObject(e, t)
        }
        _addLight(e, {
            setDefaultLayer: t = !0,
            addToRoot: n = !1,
            ...r
        } = {}) {
            var i;
            const s = e.lightObject;
            s && (null === (i = s.children) || void 0 === i || i.length, n ? this.add(s) : this.modelRoot.add(s))
        }
        getBounds(e = !1, t = !0) {
            return (new P).expandByObject(this.modelObject, e, t)
        }
        refreshActiveCameraNearFar() {
            const e = this.activeCamera;
            if (!e) return;
            const t = this.getBounds(!1),
                n = e.cameraObject.getWorldPosition(new i.Pa4).sub(t.getCenter(new i.Pa4)),
                r = 1.5 * t.getSize(new i.Pa4).length() / 2,
                s = n.length(),
                o = Math.max(this.minNearDistance, s - r),
                a = Math.max(o + 1, s + r);
            e.near = o, e.far = a
        }
        updateShaderProperties(e) {
            return e.uniforms.sceneBoundingRadius ? e.uniforms.sceneBoundingRadius.value = this._sceneBoundingRadius : console.warn("BaseRenderer: no uniform: frameCount"), this
        }
        toJSON(e) {
            return Me(this, !0, e)
        }
        fromJSON(e, t) {
            const n = e.environment;
            return void 0 !== n && (this.setEnvironment(Te(n, this.getEnvironment(), !1, t)), delete e.environment), Te(e, this, !0, t), e.environment = n, this
        }
    }

    function mt() {
        const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        return e.style.display = "block", e
    }

    function gt(e, t) {
        const n = t || "/";
        return new RegExp(n + "{1,}", "g"), e.join(n)
    }

    function vt(e, t) {
        const n = window.URL.createObjectURL(e),
            r = document.createElement("a");
        r.style.display = "none", r.href = n, r.download = t, document.body.appendChild(r), r.click(), setTimeout((() => {
            document.body.removeChild(r), window.URL.revokeObjectURL(n)
        }), 1e3)
    }
    async function bt(e) {
        return new Promise(((t, n) => {
            const r = new FileReader;
            r.onload = e => t(r.result), r.onerror = e => n(r.error), r.onabort = e => n(new Error("Read aborted")), r.readAsDataURL(e)
        }))
    }

    function xt(e, t) {
        return vt(e, null != t ? t : e.name)
    }
    async function yt(e = !1, t = !1, n) {
        const r = document.createElement("input");
        r.type = "file", r.multiple = e, r.accept = n || "*", r.webkitdirectory = t, r.style.display = "none", document.body.appendChild(r), r.click();
        const i = await new Promise((e => {
            r.onchange = t => {
                e(Array.from(r.files || []))
            }
        }));
        return document.body.removeChild(r), i
    }

    function wt({
        innerHTML: e = "",
        id: t,
        classList: n,
        addToBody: r = !0,
        elementTag: i = "div"
    }) {
        const s = document.createElement(i);
        return t && (s.id = t), s.innerHTML = e, n && s.classList.add(...n), r && document.body.appendChild(s), s
    }
    async function St(e) {
        return new Promise(((t, n) => {
            const r = new Image;
            r.onload = () => t(r), r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "sync", r.src = e
        }))
    }

    function Mt(e) {
        const t = document.createElement("style");
        return t.type = "text/css", t.innerText = e, document.head.appendChild(t), t
    }
    async function Tt(e) {
        return new Promise(((t, n) => {
            const r = document.createElement("script");
            r.setAttribute("src", e), r.addEventListener("load", t), r.addEventListener("error", n), document.body.appendChild(r)
        }))
    }

    function Et(e, t = 8192) {
        var n;
        if (!e.width || !e.height) return "";
        const r = document.createElement("canvas");
        r.width = Math.min(t, e.width), r.height = Math.floor(1 + r.width * e.height / e.width);
        const i = e instanceof ImageBitmap && Math.abs(r.width - e.width) < .5 ? r.getContext("bitmaprenderer") : void 0;
        i ? i.transferFromImageBitmap(e) : null === (n = r.getContext("2d")) || void 0 === n || n.drawImage(e, 0, 0, r.width, r.height);
        const s = r.toDataURL("image/png");
        return r.remove(), s
    }
    async function At(e) {
        return new Promise(((t, n) => {
            const r = new Image;
            r.addEventListener("load", (() => {
                const e = document.createElement("canvas");
                e.width = r.width, e.height = r.height;
                const i = e.getContext("2d");
                if (!i) return void n(new Error("Could not get 2d context"));
                i.drawImage(r, 0, 0, e.width, e.height);
                const s = i.getImageData(0, 0, e.width, e.height);
                t(s), e.remove(), r.remove()
            }), !1), r.addEventListener("error", (e => {
                r.remove(), n(e)
            }), !1), r.src = e
        }))
    }

    function Ct() {
        return ("undefined" == typeof performance ? Date : performance).now()
    }

    function Rt() {
        let e = !1;
        return function(t) {
            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0)
        }(navigator.userAgent || navigator.vendor || window.opera), e
    }

    function kt(e) {
        return new URL(window.location.href).searchParams.get(e)
    }

    function Pt(e, t, n = !1) {
        const r = new URLSearchParams(location.search);
        null == t ? r.has(e) && r.delete(e) : r.set(e, t), n ? window.location.search = r.toString() : window.history.replaceState({}, "", "?" + r.toString())
    }

    function Dt(e) {
        return e.replace(/\w\S*/g, (function(e) {
            return e.charAt(0).toUpperCase() + e.substr(1).toLowerCase()
        }))
    }

    function Ot(e, {
        backgroundColor: t = "",
        displayPixelRatio: n = 1,
        width: r = 512,
        height: i = 512
    }) {
        const s = document.createElement("canvas"),
            o = s.getContext("2d"),
            a = n,
            l = r,
            c = i;
        return s.width = l * a, s.height = c * a, s.style.width = `${l}`, s.style.height = `${c}`, (null == t ? void 0 : t.length) > 0 && (o.fillStyle = t, o.fillRect(0, 0, s.width, s.height)), o.drawImage(e, 0, 0, s.width, s.height), s
    }
    ft([xe()], _t.prototype, "defaultCamera", void 0), ft([C(_t.prototype.refreshEnvMapIntensity), xe()], _t.prototype, "envMapIntensity", void 0), ft([xe()], _t.prototype, "environment", void 0), ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function(e, t) {
        const n = new Uint8Array(this);
        null == t && (t = n.length);
        const r = new ArrayBuffer(t - e),
            i = new Uint8Array(r);
        for (let t = 0; t < i.length; t++) i[t] = n[t + e];
        return r
    });
    class Lt extends i.jyz {
        constructor(e, t) {
            super(e), this.typeSlug = "shaderMat", this.assetType = "material", this.materialObject = this, this.textures = [], this.setTextureIds(t)
        }
        setTextureIds(e) {
            this.textures.map((e => e.id)).join(";") !== e.join(";") && (this.textures = e.map((e => ({
                id: e,
                encoding: i.rnI
            }))), this.needsUpdate = !0)
        }
        _setUniformTexSize(e, t) {
            var n, r, i, s;
            if (!t || !e) return;
            const o = null !== (r = null === (n = t.image) || void 0 === n ? void 0 : n.width) && void 0 !== r ? r : 512,
                a = null !== (s = null === (i = t.image) || void 0 === i ? void 0 : i.height) && void 0 !== s ? s : 512,
                l = e.value;
            l.isVector2 || console.warn("uniform is not a Vector2"), l && Math.abs(l.x - o) + Math.abs(l.y - a) > .1 && (l.x = o, l.y = a, this.uniformsNeedUpdate = !0)
        }
        onBeforeRender(e, t, n, r, i) {
            var s, o;
            this._setUniformTexSize(this.uniforms.screenSize, null === (s = e.getRenderTarget()) || void 0 === s ? void 0 : s.texture);
            for (const e of this.textures) {
                const t = e.id,
                    n = null === (o = this.uniforms[t]) || void 0 === o ? void 0 : o.value;
                n && (this._setUniformTexSize(this.uniforms[t + "Size"], n), n.encoding !== e.encoding && (e.encoding = n.encoding, this.needsUpdate = !0))
            }
            super.onBeforeRender(e, t, n, r, i)
        }
        onBeforeCompile(e, t) {
            e.fragmentShader = this.textures.map((e => {
                var t, n;
                return `uniform sampler2D ${e.id}; \n` + B(null !== (t = e.id) && void 0 !== t ? t : "input", null !== (n = e.encoding) && void 0 !== n ? n : i.rnI)
            })).join("\n") + e.fragmentShader, super.onBeforeCompile(e, t)
        }
        customProgramCacheKey() {
            return super.customProgramCacheKey() + this.textures.map((e => e.id + e.encoding)).join(";")
        }
        toJSON(e) {
            throw new Error("Method not supported for this material.")
        }
        fromJSON(e, t) {
            throw new Error("Method not supported for this material.")
        }
        copyProps(e) {
            throw new Error("Method not supported for this material.")
        }
    }

    function It(e, ...t) {
        const n = e.fragmentShader;
        return new Lt({
            defines: Object.assign({}, e.defines),
            uniforms: e.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: n
        }, t)
    }
    class Ft extends u {
        constructor(e, ...t) {
            super(It(e, ...t), t.length < 1 ? Ft.DEFAULT_TEX_ID : t[0]), this.onDirty = [], this.enabled = !0, this.setDirty = this.setDirty.bind(this)
        }
        dispose() {
            var e, t, n, r;
            null === (t = null === (e = this.material) || void 0 === e ? void 0 : e.dispose) || void 0 === t || t.call(e), null === (r = null === (n = this.fsQuad) || void 0 === n ? void 0 : n.dispose) || void 0 === r || r.call(n), this.onDirty = []
        }
        setDirty() {
            this.onDirty.forEach((e => e()))
        }
        updateShaderProperties(e) {
            e && (Array.isArray(e) || (e = [e]), e.forEach((e => null == e ? void 0 : e.updateShaderProperties(this.material))))
        }
        render(e, t, n, r, i) {
            this.enabled && super.render(e, t, n, r, i)
        }
    }
    Ft.DEFAULT_TEX_ID = "tDiffuse",
        function(e, t, n, r) {
            var i, s = arguments.length,
                o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
            else
                for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
            s > 3 && o && Object.defineProperty(t, n, o)
        }([Ve("Enabled"), xe()], Ft.prototype, "enabled", void 0);
    class Nt extends o {
        constructor(e, t, n, r, s) {
            super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== s ? s : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new i.Ilk
        }
        render(e, t, n, r, i, s) {
            const o = e.autoClear;
            let a, l;
            if (e.autoClear = !1, void 0 !== this.overrideMaterial && (l = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), a = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), s) {
                const t = e.getContext();
                t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, s)
            }
            if (this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), s) {
                const t = e.getContext();
                t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, null)
            }
            this.clearColor && e.setClearColor(this._oldClearColor, a), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = l), e.autoClear = o
        }
    }
    class Ut extends Ft {
        constructor(e, t = "c = a + b;", n = "", r) {
            super({
                vertexShader: s.vertexShader,
                fragmentShader: M `
                varying vec2 vUv;
                
                ${n}
                
                void blend(in vec4 a, in vec4 b, inout vec4 c){
                
                ${t}
                
                }
                void main() {
                    vec4 texel = vec4(0);
                    blend(tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ), tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), texel);
                    texel = clamp(texel, vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `,
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    tDiffuse2: {
                        value: r
                    },
                    ...e
                }
            }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0
        }
    }
    class Bt extends i.jyz {
        constructor(e = !0) {
            super({
                vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV\n#endif\n#include <uv_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nout vec3 vViewPosition;void main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;}",
                fragmentShader: "#ifdef USE_ALPHAMAP\n#define USE_UV\n#include <packing>\nuniform float alphaTest;\n#endif\n#ifndef gl_FragColor \nlayout(location=0)out vec4 gDepthNormal;layout(location=1)out vec4 gFlags;\n#endif\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <alphamap_pars_fragment>\nuniform vec2 cameraNearFar;uniform vec4 flags;in vec3 vViewPosition;vec2 pack16(float value){float sMax=65535.;int v=int(clamp(value,0.,1.)*sMax+0.5);int digit0=v/256;int digit1=v-digit0*256;return vec2(float(digit0)/255.,float(digit1)/255.);}vec2 packNormal(vec3 n){float p=sqrt(n.z*8.+8.);return vec2(n.xy/p+0.5);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}void main(){\n#ifdef USE_ALPHAMAP\n#ifdef ALPHA_I_RGBA_PACKING\nif(1.-unpackRGBAToDepth(texture2D(alphaMap,vUv))<alphaTest)discard;\n#else\nif(texture2D(alphaMap,vUv).g<alphaTest)discard;\n#endif\n#endif\n#include <normal_fragment_begin>\nfloat linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);vec2 packedZ=pack16(pow(linearZ,0.5));vec2 packedNormal=packNormal(normal);\n#ifndef gl_FragColor \ngDepthNormal=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);gFlags=flags;\n#else\ngl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);\n#endif\n}",
                uniforms: {
                    cameraNearFar: {
                        value: new i.FM8(.1, 1e3)
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: null
                    },
                    flags: {
                        value: new i.Ltg(1, 1, 1, 1)
                    }
                },
                glslVersion: e ? i.LSk : i.v9Y
            })
        }
        onBeforeRender(e, t, n, r, s) {
            var o, a;
            let l = s.material;
            Array.isArray(l) && (l = l[0]), this.uniforms.alphaMap.value = null !== (o = null == l ? void 0 : l.alphaMap) && void 0 !== o ? o : null, this.uniforms.alphaTest.value = !l || !l.alphaTest || l.alphaTest < 1e-7 ? .001 : l.alphaTest, this.uniforms.flags.value.x = !1 === (null == l ? void 0 : l.userData.postTonemap) ? 0 : 1;
            let c = this.uniforms.alphaMap.value ? 1 : void 0;
            c !== this.defines.USE_ALPHAMAP && (this.defines.USE_ALPHAMAP = c, this.needsUpdate = !0), c = l.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, c !== this.defines.ALPHA_I_RGBA_PACKING && (this.defines.ALPHA_I_RGBA_PACKING = c, this.needsUpdate = !0), this.side = null !== (a = l.side) && void 0 !== a ? a : i.ehD
        }
    }
    var jt = "#ifndef UNPACK_GBUFFER_SNIPPET\n#define UNPACK_GBUFFER_SNIPPET\nuniform sampler2D tNormalDepth;float unpack16(vec2 value){return(value.x*0.996108949416342426275150501169264316558837890625+value.y*0.00389105058365758760263730664519243873655796051025390625);}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}float unpackDepth(vec2 uncodedDepth){float x=unpack16(uncodedDepth.xy);return x*x;}float getDepth(vec2 uv){vec4 uncodedDepth=texture2D(tNormalDepth,uv);return unpackDepth(uncodedDepth.xy);}void getDepthNormal(const in vec2 uv,out float depth,out vec3 normal){vec4 uncodedDepth=texture2D(tNormalDepth,uv);depth=unpackDepth(uncodedDepth.xy);normal=unpackNormal(uncodedDepth.zw);}vec3 getViewNormal(const in vec2 uv){return unpackNormal(texture2D(tNormalDepth,uv).zw);}\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nuniform sampler2D tGBufferFlags;\n#endif\nvec4 getGBufferFlags(const in vec2 uv){\n#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1\nreturn texture2D(tGBufferFlags,uv);\n#else\nreturn vec4(1.);\n#endif\n}\n#endif\n",
        zt = i.M8C.generateUUID;
    class Vt {
        static ApplyMaterialExtensions(e, t, n, r) {
            for (const i of n) this.ApplyMaterialExtension(e, t, i, r)
        }
        static ApplyMaterialExtension(e, t, n, r) {
            var i, s;
            let o = null !== (i = x(n.parsFragmentSnippet, r, e)) && void 0 !== i ? i : "";
            o.length && (t.fragmentShader = t.fragmentShader.replace(this.FragVoidMain, `\n${o}\n${this.FragVoidMain}`)), o = null !== (s = x(n.parsVertexSnippet, r, e)) && void 0 !== s ? s : "", o.length && (t.vertexShader = t.vertexShader.replace(this.VertVoidMain, `\n${o}\n${this.VertVoidMain}`)), n.extraUniforms && (t.uniforms = Object.assign(t.uniforms, n.extraUniforms)), n.shaderExtender && n.shaderExtender(t, e, r), e.lastShader = t
        }
        static CacheKeyForExtensions(e, t) {
            let n = "";
            for (const r of t) n += this.CacheKeyForExtension(e, r);
            return n
        }
        static CacheKeyForExtension(e, t) {
            let n = "";
            return t.customCacheKey && (n += t.customCacheKey), t.computeCacheKey && (n += t.computeCacheKey(e)), n
        }
        static RegisterExtensions(e, t) {
            const n = [];
            if (t)
                for (const r of t) r.uuid || (r.uuid = zt()), r.setDirty || (r.setDirty = () => {
                    r.updateVersion || (r.updateVersion = 0), r.updateVersion++
                }), r.isCompatible && r.isCompatible(e) && n.push(r);
            return e.onObjectRenderExtension || (e.onObjectRenderExtension = (n, r) => {
                var i, s;
                null === (s = null !== (i = e.materialExtensions) && void 0 !== i ? i : t) || void 0 === s || s.forEach((t => {
                    var i, s;
                    null === (i = t.onObjectRender) || void 0 === i || i.call(t, n, e, r), e.lastShader && (null === (s = x(t.updaters)) || void 0 === s || s.forEach((t => null == t ? void 0 : t.updateShaderProperties(e.lastShader)))), t.updateVersion !== e.materialObject.userData["_" + t.uuid + "_version"] && (e.materialObject.userData["_" + t.uuid + "_version"] = t.updateVersion, e.materialObject.needsUpdate = !0)
                }))
            }), n
        }
        static MaterialBeforeRender(e, t, n) {
            var r, i;
            null === (i = (r = e).onObjectRenderExtension) || void 0 === i || i.call(r, t, n)
        }
    }
    Vt.FragVoidMain = "void main() {", Vt.VertVoidMain = "void main() {";
    const Gt = {
            name: "",
            fog: !0,
            blending: i.bdR,
            side: i.Wl3,
            vertexColors: !1,
            opacity: 1,
            transparent: !1,
            blendSrc: i.k74,
            blendDst: i.LgZ,
            blendEquation: i.bGH,
            blendSrcAlpha: null,
            blendDstAlpha: null,
            blendEquationAlpha: null,
            depthFunc: i.vCF,
            depthTest: !0,
            depthWrite: !0,
            stencilWriteMask: 255,
            stencilFunc: i.cum,
            stencilRef: 0,
            stencilFuncMask: 255,
            stencilFail: i.x5V,
            stencilZFail: i.x5V,
            stencilZPass: i.x5V,
            stencilWrite: !1,
            clippingPlanes: null,
            clipIntersection: !1,
            clipShadows: !1,
            shadowSide: null,
            colorWrite: !0,
            precision: null,
            polygonOffset: !1,
            polygonOffsetFactor: 0,
            polygonOffsetUnits: 0,
            dithering: !1,
            alphaTest: 0,
            alphaToCoverage: !1,
            premultipliedAlpha: !1,
            visible: !0,
            toneMapped: !0,
            userData: {},
            wireframeLinecap: "round",
            wireframeLinejoin: "round"
        },
        Ht = { ...Gt,
            color: "#000000",
            roughness: 0,
            metalness: 0,
            map: null,
            lightMap: null,
            lightMapIntensity: 0,
            aoMap: null,
            aoMapIntensity: 0,
            emissive: "#000000",
            emissiveIntensity: 0,
            emissiveMap: null,
            bumpMap: null,
            bumpScale: 0,
            normalMap: null,
            normalMapType: i.IOt,
            normalScale: new i.FM8(1, 1),
            displacementMap: null,
            displacementScale: 0,
            displacementBias: 0,
            roughnessMap: null,
            metalnessMap: null,
            alphaMap: null,
            envMap: null,
            envMapIntensity: 0,
            refractionRatio: 0,
            wireframe: !1,
            wireframeLinewidth: 0,
            skinning: !1,
            morphTargets: !1,
            morphNormals: !1,
            flatShading: !1,
            glossiness: 0,
            glossinessMap: null,
            specularColor: new ve(0),
            specularColorMap: null
        },
        Wt = { ...Ht,
            clearcoat: 0,
            clearcoatMap: null,
            clearcoatRoughness: 0,
            clearcoatRoughnessMap: null,
            clearcoatNormalScale: new i.FM8(1, 1),
            clearcoatNormalMap: null,
            reflectivity: .5,
            sheen: 0,
            sheenColor: new ve(0),
            sheenColorMap: null,
            sheenRoughness: 1,
            sheenRoughnessMap: null,
            specularIntensity: 1,
            specularIntensityMap: null,
            specularColor: new ve(1, 1, 1),
            specularColorMap: null,
            transmission: 0,
            transmissionMap: null,
            thickness: 0,
            thicknessMap: null,
            attenuationDistance: 0,
            attenuationColor: new ve(1, 1, 1)
        };
    class Kt extends i.EJi {
        constructor(e) {
            var t;
            super(e), this.typeSlug = Kt.TypeSlug, this.isMeshStandardMaterial2 = !0, this.extraUniformsToUpload = {}, this.assetType = "material", this.materialObject = this, this.fog = !1, this.userData.setDirty = () => {
                var e, t;
                this.needsUpdate = !0, this.dispatchEvent({
                    type: "materialUpdate"
                }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0)
            }, this.materialExtensions = Vt.RegisterExtensions(this, null !== (t = null == e ? void 0 : e.customMaterialExtensions) && void 0 !== t ? t : [])
        }
        registerMaterialExtensions(e) {
            this.materialExtensions = [...this.materialExtensions, ...Vt.RegisterExtensions(this, e)]
        }
        unregisterMaterialExtensions(e) {}
        _makeSamplerUi(e = "map") {
            const t = "map" === e;
            return {
                type: "folder",
                label: e + " Sampler",
                hidden: () => !this[e],
                children: [() => {
                    var n;
                    return {
                        type: "vec2",
                        label: "Repeat",
                        hidden: () => !t && this.map,
                        bounds: [0, 100],
                        stepSize: .001,
                        property: [this[e], "repeat"],
                        onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
                    }
                }, () => {
                    var n;
                    return {
                        type: "vec2",
                        label: "Offset",
                        hidden: () => !t && this.map,
                        bounds: [0, 2],
                        property: [this[e], "offset"],
                        onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
                    }
                }, () => {
                    var n;
                    return {
                        type: "vec2",
                        label: "Center",
                        hidden: () => !t && this.map,
                        bounds: [-2, 2],
                        property: [this[e], "center"],
                        onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
                    }
                }, () => {
                    var n;
                    return {
                        type: "input",
                        label: "Rotation",
                        hidden: () => !t && this.map,
                        bounds: [-Math.PI, Math.PI],
                        property: [this[e], "rotation"],
                        onChange: null === (n = this.userData) || void 0 === n ? void 0 : n.setDirty
                    }
                }, () => {
                    var t;
                    return {
                        type: "dropdown",
                        label: "Encoding",
                        property: [this[e], "encoding"],
                        children: [
                            ["Linear", i.rnI],
                            ["sRGB", i.knz]
                        ].map((e => ({
                            label: e[0],
                            value: e[1]
                        }))),
                        onChange: [() => {
                            const t = this[e];
                            t && (t.needsUpdate = !0, this[e] = t.clone(), this[e].uuid = t.uuid, t.dispose())
                        }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
                    }
                }, () => {
                    var t;
                    return {
                        type: "checkbox",
                        label: "Flip Y",
                        property: [this[e], "flipY"],
                        onChange: [() => {
                            const t = this[e];
                            t && (t.needsUpdate = !0, this[e] = t.clone(), this[e].uuid = t.uuid, t.dispose())
                        }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
                    }
                }, () => {
                    var t;
                    return {
                        type: "dropdown",
                        label: "Wrap S",
                        property: [this[e], "wrapS"],
                        children: [
                            ["ClampToEdge", i.uWy],
                            ["MirroredRepeat", i.OoA],
                            ["Repeat", i.rpg]
                        ].map((e => ({
                            label: e[0],
                            value: e[1]
                        }))),
                        onChange: [() => {
                            this[e] && (this[e].needsUpdate = !0)
                        }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
                    }
                }, () => {
                    var t;
                    return {
                        type: "dropdown",
                        label: "Wrap T",
                        property: [this[e], "wrapT"],
                        children: [
                            ["ClampToEdge", i.uWy],
                            ["MirroredRepeat", i.OoA],
                            ["Repeat", i.rpg]
                        ].map((e => ({
                            label: e[0],
                            value: e[1]
                        }))),
                        onChange: [() => {
                            this[e] && (this[e].needsUpdate = !0)
                        }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
                    }
                }, () => {
                    var t;
                    return {
                        type: "input",
                        label: "Anisotropy",
                        bounds: [1, 6],
                        stepSize: 1,
                        property: [this[e], "anisotropy"],
                        onChange: [() => {
                            this[e] && (this[e].needsUpdate = !0), this.needsUpdate = !0
                        }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
                    }
                }, () => {
                    var t;
                    return {
                        type: "dropdown",
                        label: "Min Filter",
                        property: [this[e], "minFilter"],
                        children: [
                            ["Linear", se],
                            ["Nearest", i.TyD]
                        ].map((e => ({
                            label: e[0],
                            value: e[1]
                        }))),
                        onChange: [() => {
                            this[e] && (this[e].needsUpdate = !0)
                        }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
                    }
                }, () => {
                    var t;
                    return {
                        type: "dropdown",
                        label: "Mag Filter",
                        property: [this[e], "magFilter"],
                        children: [
                            ["Linear", se],
                            ["Nearest", i.TyD]
                        ].map((e => ({
                            label: e[0],
                            value: e[1]
                        }))),
                        onChange: [() => {
                            this[e] && (this[e].needsUpdate = !0)
                        }, null === (t = this.userData) || void 0 === t ? void 0 : t.setDirty]
                    }
                }]
            }
        }
        get uiConfig() {
            return this._uiConfigChildren || (this._uiConfigChildren = [{
                type: "input",
                property: [this, "name"]
            }, {
                type: "checkbox",
                property: [this, "wireframe"]
            }, {
                type: "color",
                property: [this, "color"],
                limitedUi: !0
            }, {
                type: "image",
                property: [this, "map"]
            }, this._makeSamplerUi("map"), {
                type: "folder",
                label: "Rough/Metal",
                limitedUi: !0,
                children: [{
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "roughness"],
                    limitedUi: !0
                }, {
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "metalness"],
                    limitedUi: !0
                }, {
                    type: "image",
                    property: [this, "roughnessMap"]
                }, this._makeSamplerUi("roughnessMap"), {
                    type: "image",
                    property: [this, "metalnessMap"]
                }, this._makeSamplerUi("metalnessMap")]
            }, {
                type: "folder",
                label: "Bump/Normal",
                limitedUi: !0,
                children: [{
                    type: "slider",
                    bounds: [0, .2],
                    stepSize: .001,
                    property: [this, "bumpScale"],
                    hidden: () => !this.bumpMap
                }, {
                    type: "image",
                    property: [this, "bumpMap"]
                }, this._makeSamplerUi("bumpMap"), {
                    type: "image",
                    property: [this, "normalMap"]
                }, {
                    type: "vec2",
                    property: [this, "normalScale"],
                    hidden: () => !this.normalMap
                }, {
                    type: "dropdown",
                    hidden: () => !this.normalMap,
                    property: [this, "normalMapType"],
                    children: [
                        ["TangentSpace", i.IOt],
                        ["ObjectSpace", i.PA7]
                    ].map((e => ({
                        label: e[0],
                        value: e[1]
                    })))
                }, this._makeSamplerUi("normalMap"), {
                    type: "slider",
                    bounds: [0, 10],
                    stepSize: .001,
                    property: [this, "displacementScale"],
                    hidden: () => !this.displacementMap
                }, {
                    type: "image",
                    property: [this, "displacementMap"]
                }, this._makeSamplerUi("displacementMap")]
            }, {
                type: "folder",
                label: "Sheen",
                children: [{
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "sheen"]
                }, {
                    type: "color",
                    hidden: () => this.sheen < .001,
                    property: [this, "sheenColor"]
                }, {
                    type: "image",
                    property: [this, "sheenColorMap"]
                }, this._makeSamplerUi("sheenColorMap"), {
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "sheenRoughness"]
                }, {
                    type: "image",
                    property: [this, "sheenRoughnessMap"]
                }, this._makeSamplerUi("sheenRoughnessMap")]
            }, {
                type: "folder",
                label: "Clearcoat",
                children: [{
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "clearcoat"]
                }, {
                    type: "slider",
                    bounds: [0, 1],
                    hidden: () => this.clearcoat < .001,
                    property: [this, "clearcoatRoughness"]
                }, {
                    type: "image",
                    property: [this, "clearcoatMap"]
                }, this._makeSamplerUi("clearcoatMap"), {
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "clearcoatRoughness"]
                }, {
                    type: "image",
                    property: [this, "clearcoatRoughnessMap"]
                }, this._makeSamplerUi("clearcoatRoughnessMap"), {
                    type: "image",
                    property: [this, "clearcoatNormalMap"]
                }, {
                    type: "vec2",
                    property: [this, "clearcoatNormalScale"],
                    hidden: () => !this.clearcoatNormalMap
                }, this._makeSamplerUi("clearcoatNormalMap")]
            }, {
                type: "folder",
                label: "Emission",
                children: [{
                    type: "color",
                    property: [this, "emissive"]
                }, {
                    type: "slider",
                    bounds: [0, 10],
                    property: [this, "emissiveIntensity"]
                }, {
                    type: "image",
                    property: [this, "emissiveMap"]
                }, this._makeSamplerUi("emissiveMap")]
            }, {
                type: "folder",
                label: "Refraction",
                children: [{
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "reflectivity"]
                }, {
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "transmission"],
                    limitedUi: !0
                }, {
                    type: "slider",
                    bounds: [0, 1],
                    stepSize: .001,
                    property: [this, "thickness"]
                }, {
                    type: "image",
                    property: [this, "transmissionMap"]
                }, this._makeSamplerUi("transmissionMap"), {
                    type: "image",
                    property: [this, "thicknessMap"]
                }, this._makeSamplerUi("thicknessMap")]
            }, {
                type: "folder",
                label: "Blending",
                children: [{
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "opacity"]
                }, {
                    type: "checkbox",
                    property: [this, "transparent"],
                    onChange: () => {
                        var e, t;
                        null === (t = (e = this.userData).setDirty) || void 0 === t || t.call(e)
                    }
                }, {
                    type: "checkbox",
                    property: [this, "depthWrite"],
                    onChange: () => {
                        var e, t;
                        null === (t = (e = this.userData).setDirty) || void 0 === t || t.call(e)
                    }
                }, {
                    type: "slider",
                    bounds: [0, 1],
                    property: [this, "alphaTest"]
                }, {
                    type: "checkbox",
                    property: [this, "dithering"]
                }, {
                    type: "dropdown",
                    label: "Blending",
                    property: [this, "blending"],
                    children: [
                        ["None", te],
                        ["Normal", ne],
                        ["Additive", i.WMw],
                        ["Subtractive", re],
                        ["Multiply", ie]
                    ].map((e => ({
                        label: e[0],
                        value: e[1]
                    })))
                }, {
                    type: "image",
                    property: [this, "alphaMap"]
                }, this._makeSamplerUi("alphaMap"), {
                    type: "checkbox",
                    label: "Render to Depth",
                    hidden: () => !this.transparent && this.transmission < .001,
                    getValue: () => !0 === this.userData.renderToDepth,
                    setValue: e => {
                        var t, n;
                        this.userData.renderToDepth = e || void 0, null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t)
                    }
                }, {
                    type: "checkbox",
                    label: "Inverse AlphaMap",
                    hidden: () => !this.transparent,
                    getValue: () => !0 === this.userData.inverseAlphaMap,
                    setValue: e => {
                        var t, n;
                        this.userData.inverseAlphaMap = e || void 0, null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t)
                    }
                }]
            }, {
                type: "folder",
                label: "AO/Lightmap",
                children: [{
                    type: "slider",
                    bounds: [0, 2],
                    property: [this, "aoMapIntensity"]
                }, {
                    type: "image",
                    property: [this, "aoMap"]
                }, this._makeSamplerUi("aoMap"), {
                    type: "slider",
                    bounds: [0, 2],
                    property: [this, "lightMapIntensity"]
                }, {
                    type: "image",
                    property: [this, "lightMap"]
                }, this._makeSamplerUi("lightMap")]
            }, {
                type: "dropdown",
                label: "Side",
                property: [this, "side"],
                children: [
                    ["Front", i.Wl3],
                    ["Back", i._Li],
                    ["Double", i.ehD]
                ].map((e => ({
                    label: e[0],
                    value: e[1]
                })))
            }, {
                type: "checkbox",
                property: [this, "flatShading"]
            }, {
                type: "input",
                label: "Mesh count",
                getValue: () => {
                    var e, t, n;
                    return null !== (n = null === (t = null === (e = this.userData) || void 0 === e ? void 0 : e.appliedMeshes) || void 0 === t ? void 0 : t.size) && void 0 !== n ? n : 0
                },
                setValue: e => {},
                disabled: !0
            }, {
                type: "button",
                label: `Download ${this.typeSlug}`,
                value: () => {
                    vt(new Blob([JSON.stringify(this.toJSON(), null, 2)], {
                        type: "application/json"
                    }), `standard-material.${this.typeSlug}`)
                }
            }]), this._uiConfig || (this._uiConfig = {
                type: "folder",
                label: "Physical Material",
                expanded: !0,
                children: this._uiConfigChildren,
                uuid: "MSM2_" + this.uuid,
                limitedUi: !0
            }), this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map((e => {
                var t;
                return null === (t = e.getUiConfig) || void 0 === t ? void 0 : t.call(e, this)
            }))].filter((e => e)), this._uiConfig
        }
        onBeforeCompile(e, t) {
            const n = [
                    ["vec3 totalDiffuse = ", "afterModulation"],
                    ["#include <aomap_fragment>", "beforeModulation"],
                    ["#include <lights_physical_fragment>", "beforeAccumulation"],
                    ["#include <clipping_planes_fragment>", "mainStart"]
                ],
                r = [
                    ["#include <uv_vertex>", "mainStart"]
                ];
            for (const t of r) e.vertexShader = e.vertexShader.replace(t[0], "#glMarker " + t[1] + "\n" + t[0]);
            for (const t of n) e.fragmentShader = e.fragmentShader.replace(t[0], "#glMarker " + t[1] + "\n" + t[0]);
            Vt.ApplyMaterialExtensions(this, e, this.materialExtensions, t), e.fragmentShader = e.fragmentShader.replaceAll("#glMarker", "// "), e.vertexShader = e.vertexShader.replaceAll("#glMarker", "// "), e.defines.INVERSE_ALPHAMAP = this.userData.inverseAlphaMap ? 1 : 0, super.onBeforeCompile(e, t)
        }
        customProgramCacheKey() {
            return super.customProgramCacheKey() + Vt.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap
        }
        onBeforeRender(e, t, n, r, i) {
            var s;
            super.onBeforeRender(e, t, n, r, i), Vt.MaterialBeforeRender(this, i, e);
            const o = this.userData.inverseAlphaMap ? 1 : 0;
            o !== this.defines.INVERSE_ALPHAMAP && (this.defines.INVERSE_ALPHAMAP = o, this.needsUpdate = !0), this.map && (null === (s = this.extraUniformsToUpload) || void 0 === s ? void 0 : s.uvTransform) && i.userData.cloneRotI > 0 && this.extraUniformsToUpload.uvTransform.value.setUvTransform(this.map.offset.x * this.map.repeat.x * i.userData.cloneRotI / (i.userData.rotationCount || 1), this.map.offset.y * this.map.repeat.y * i.userData.cloneRotI / (i.userData.rotationCount || 1), this.map.repeat.x, this.map.repeat.y, this.map.rotation, this.map.center.x, this.map.center.y)
        }
        copyProps(e, t = !1) {
            var n, r;
            if (!t && !["MeshStandardMaterial", Kt.TYPE, "MeshPhysicalMaterial"].includes(e.type)) return console.warn("Material type is not supported:", e.type), this;
            const i = {};
            y(e, i, Array.from(Object.keys(Wt)));
            const s = i.userData;
            delete i.userData;
            for (const e of Object.keys(i)) void 0 === i[e] && delete i[e];
            return this.setValues(i), s && qt(this.userData, s), null === (r = (n = this.userData).setDirty) || void 0 === r || r.call(n), this
        }
        toJSON(e) {
            const t = this.userData;
            this.userData = {};
            const n = super.toJSON(e);
            this.userData = t, n.userData = {}, qt(n.userData, t), n.userData.uuid = this.userData.uuid, n.type = Kt.TYPE;
            for (const e of Object.keys(n)) void 0 === n[e] && delete n[e];
            return n
        }
        fromJSON(e, t, n = !1) {
            return Array.isArray(e.normalScale) && (e.normalScale = (new i.FM8).fromArray(e.normalScale)), Array.isArray(e.clearcoatNormalScale) && (e.clearcoatNormalScale = (new i.FM8).fromArray(e.clearcoatNormalScale)), this.copyProps(e, n)
        }
        clone() {
            return super.clone()
        }
    }
    Kt.TypeSlug = "pmat", Kt.TYPE = "MeshStandardMaterial2";
    const Xt = ["appliedMeshes", "imageLoadAwaiter", "inverseModelMatrix", "uvTransform", "uuid"];

    function qt(e, t) {
        if (t)
            for (const n of Object.keys(t)) Xt.includes(n) || n.startsWith("__") || "function" != typeof e[n] && "function" != typeof t[n] && (e[n] = t[n]);
        return e
    }
    const Yt = {
        materialType: Kt.TYPE,
        name: "standard",
        color: "#ffffff"
    };
    class Zt extends r {
        constructor() {
            super(), this._templates = [Yt], this._materials = [], this._materialExtensions = [], this.processModel = this.processModel.bind(this), this.processMaterial = this.processMaterial.bind(this)
        }
        findOrCreate(e, t) {
            let n = this.findMaterial(e);
            return n || (n = this.generateFromTemplate(e, t)), n
        }
        generateFromTemplate(e, t) {
            const n = this.findTemplate(e);
            if (n) return this._generateFromTemplate(n, null != t ? t : {})
        }
        generateFromTemplateType(e, t) {
            const n = this._templates.find((t => t.materialType === e));
            if (n) return this._generateFromTemplate(n, null != t ? t : {})
        }
        findTemplate(e) {
            return this._templates.find((t => t.name === e))
        }
        registerMaterial(e) {
            if (this._materials.includes(e)) return;
            const t = this.findMaterial(e.uuid);
            t ? console.warn("Material UUID already exists", e, t) : this._materials.push(e)
        }
        registerMaterialObject(e) {
            const t = e.materialObject ? e : Object.assign(e, {
                assetType: "material",
                materialObject: e
            });
            return this.registerMaterial(t), t
        }
        unregisterMaterial(e) {
            this._materials = this._materials.filter((t => t.uuid !== e.uuid))
        }
        registerMaterialTemplate(e) {
            e.templateUUID || (e.templateUUID = Be());
            const t = this._templates.find((t => t.templateUUID === e.templateUUID));
            t ? console.warn("MaterialTemplate already exists", e, t) : this._templates.push(e)
        }
        unregisterMaterialTemplate(e) {
            this._templates = this._templates.filter((t => t.templateUUID !== e.templateUUID))
        }
        dispose() {}
        findMaterial(e) {
            return e ? this._materials.find((t => t.uuid === e)) : void 0
        }
        findMaterialsByName(e) {
            return this._materials.filter((t => t.name === e))
        }
        getMaterialsOfType(e) {
            return e ? this._materials.filter((t => t.typeSlug === e)) : []
        }
        getAllMaterials() {
            return [...this._materials]
        }
        processModel(e, t) {
            return g(e, "modelObject", this._processModel(e.modelObject, t)), e
        }
        _processMaterial(e, t) {
            var n, r, i;
            if (!e) return;
            if (null === (n = e.materialObject) || void 0 === n ? void 0 : n.isMaterial) return e;
            let s = e.mmMaterial;
            if (!s) {
                const n = (null === (r = e.userData) || void 0 === r ? void 0 : r.uuid) || e.uuid;
                s = this.findMaterial(n), s ? s.copyProps(e) : s = this.generateFromTemplate(null !== (i = t.materialTemplate) && void 0 !== i ? i : "standard", !1 !== t.useSourceMaterial && e.isMaterial ? e : {}), e.mmMaterial = s
            }
            return s
        }
        processMaterial(e, t) {
            return !1 !== t.register && this.registerMaterial(e), e.materialObject || (e = this._processMaterial(e, { ...t,
                register: !1
            })), e
        }
        registerMaterialExtension(e) {
            this._materialExtensions.includes(e) || this._materialExtensions.push(e)
        }
        unregisterMaterialExtension(e) {
            const t = this._materialExtensions.indexOf(e);
            t >= 0 && this._materialExtensions.splice(t, 1)
        }
        exportMaterial(e, t, n = !0, r = !1) {
            const i = Me(e, !1),
                s = JSON.stringify(i, null, n ? 0 : 2),
                o = (t || e.name || "physical_material") + "." + e.typeSlug,
                a = new File([s], o, {
                    type: "application/json"
                });
            return r && xt(a), a
        }
    }
    class Jt extends Zt {
        _generateFromTemplate(e, t) {
            var n, r, s, o, a;
            let l;
            const c = { ...e
            };
            c.customMaterialExtensions = [...null !== (n = c.customMaterialExtensions) && void 0 !== n ? n : [], ...this._materialExtensions];
            let u = {};
            switch (e.materialType) {
                case "MeshStandardMaterial2":
                case "standard":
                    t && y(t, c, Array.from(Object.keys(Wt))), u = c.userData, delete c.userData, l = new Kt({
                        customMaterialExtensions: c.customMaterialExtensions
                    }).fromJSON(c, void 0, !0), u && (qt(l.userData, u), u.uuid && (l.uuid = u.uuid), c.userData = u, u = {}), l.userData.uuid = l.uuid, null === (s = (r = l.userData).setDirty) || void 0 === s || s.call(r);
                    break;
                case "basic":
                    l = new i.vBJ(c);
                    break;
                case "shadow":
                    l = new i.Tn7(c);
                    break;
                default:
                    u = null, t && t.userData && (u = t.userData, delete t.userData), l = (null === (o = e.generator) || void 0 === o ? void 0 : o.call(e, c, t)) || void 0, t && u && (t.userData = u), u && l && (qt(l.userData, u), (null == u ? void 0 : u.uuid) && (l.uuid = u.uuid), u = null), l && (l.userData.uuid = l.uuid)
            }
            if (l) {
                t.runtimeMaterial && (l.userData.__runtimeMaterial = !0);
                const n = l;
                return l.clone = () => {
                    n.userData.cloneId || (n.userData.cloneId = "0", n.userData.cloneCount = 0), n.userData.cloneCount += 1;
                    const t = this.generateFromTemplate(e.name);
                    return t && (t.copyProps(n), t.userData.cloneId = t.userData.cloneId + "_" + n.userData.cloneCount, t.userData.cloneCount = 0, t.name = t.name + "_" + t.userData.cloneId), null == t ? void 0 : t.materialObject
                }, t && (this.findMaterial(null == t ? void 0 : t.uuid) && this.unregisterMaterial(t), this.findMaterial(null === (a = null == t ? void 0 : t.materialObject) || void 0 === a ? void 0 : a.uuid) && this.unregisterMaterial(t.materialObject)), this.registerMaterialObject(n)
            }
        }
        _processModel(e, t) {
            var n;
            let r = e.material;
            if (r) {
                let i = !0;
                Array.isArray(r) || (r = [r], i = !1);
                const s = [];
                for (const e of r) {
                    const n = this._processMaterial(e, t);
                    s.push(null == n ? void 0 : n.materialObject)
                }
                const o = null !== (n = e.userData.setMaterial) && void 0 !== n ? n : t => {
                    e.material = t
                };
                e.material = null, o(i ? s : s[0])
            }
            if (!1 !== t.recursive)
                for (let n = 0; n < e.children.length; n++) e.children[n] = this._processModel(e.children[n], t);
            return e
        }
    }
    class $t {
        constructor(e, t, n, r) {
            this.cls = e, this.ext = t, this.root = n, this.onCtor = r
        }
        ctor(e) {
            const t = this.cls && new this.cls(e.loadingManager);
            return "function" == typeof this.onCtor ? this.onCtor(t, e) : t
        }
    }

    function Qt(e) {
        var t;
        if (!e || "" === e || e.match(/__MACOSX\/.*\._/)) return "";
        const n = null !== (t = (e = e.replace(/\?.*$/, "")).split(/[\\/]/).pop()) && void 0 !== t ? t : "",
            r = n.lastIndexOf(".");
        return "" === n || r < 1 ? "" : n.slice(r + 1)
    }

    function en(e) {
        return e.substring(e.lastIndexOf("/") + 1)
    }
    class tn extends i.hH6 {
        load(e, t, n, r) {
            return super.load(e, (e => {
                try {
                    if ("string" != typeof e) throw new Error("Invalid JSON");
                    null == t || t(JSON.parse(e))
                } catch (e) {
                    null == r || r(e)
                }
            }), n, r)
        }
    }
    class nn extends i.yxD {
        constructor(e) {
            super(e), this.type = i.cLu
        }
        parse(e) {
            const t = function(e, t) {
                    switch (e) {
                        case 1:
                            console.error("THREE.RGBELoader Read Error: " + (t || ""));
                            break;
                        case 2:
                            console.error("THREE.RGBELoader Write Error: " + (t || ""));
                            break;
                        case 3:
                            console.error("THREE.RGBELoader Bad File Format: " + (t || ""));
                            break;
                        default:
                        case 4:
                            console.error("THREE.RGBELoader: Error: " + (t || ""))
                    }
                    return -1
                },
                n = function(e, t, n) {
                    t = t || 1024;
                    let r = e.pos,
                        i = -1,
                        s = 0,
                        o = "",
                        a = String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                    for (; 0 > (i = a.indexOf("\n")) && s < t && r < e.byteLength;) o += a, s += a.length, r += 128, a += String.fromCharCode.apply(null, new Uint16Array(e.subarray(r, r + 128)));
                    return -1 < i && (!1 !== n && (e.pos += s + i + 1), o + a.slice(0, i))
                },
                r = function(e, t, n, r) {
                    const i = e[t + 3],
                        s = Math.pow(2, i - 128) / 255;
                    n[r + 0] = e[t + 0] * s, n[r + 1] = e[t + 1] * s, n[r + 2] = e[t + 2] * s, n[r + 3] = 1
                },
                s = function(e, t, n, r) {
                    const s = e[t + 3],
                        o = Math.pow(2, s - 128) / 255;
                    n[r + 0] = i.A5E.toHalfFloat(Math.min(e[t + 0] * o, 65504)), n[r + 1] = i.A5E.toHalfFloat(Math.min(e[t + 1] * o, 65504)), n[r + 2] = i.A5E.toHalfFloat(Math.min(e[t + 2] * o, 65504)), n[r + 3] = i.A5E.toHalfFloat(1)
                },
                o = new Uint8Array(e);
            o.pos = 0;
            const a = function(e) {
                const r = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                    i = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                    s = /^\s*FORMAT=(\S+)\s*$/,
                    o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                    a = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                let l, c;
                if (e.pos >= e.byteLength || !(l = n(e))) return t(1, "no header found");
                if (!(c = l.match(/^#\?(\S+)/))) return t(3, "bad initial token");
                for (a.valid |= 1, a.programtype = c[1], a.string += l + "\n"; l = n(e), !1 !== l;)
                    if (a.string += l + "\n", "#" !== l.charAt(0)) {
                        if ((c = l.match(r)) && (a.gamma = parseFloat(c[1])), (c = l.match(i)) && (a.exposure = parseFloat(c[1])), (c = l.match(s)) && (a.valid |= 2, a.format = c[1]), (c = l.match(o)) && (a.valid |= 4, a.height = parseInt(c[1], 10), a.width = parseInt(c[2], 10)), 2 & a.valid && 4 & a.valid) break
                    } else a.comments += l + "\n";
                return 2 & a.valid ? 4 & a.valid ? a : t(3, "missing image size specifier") : t(3, "missing format specifier")
            }(o);
            if (-1 !== a) {
                const e = a.width,
                    n = a.height,
                    l = function(e, n, r) {
                        const i = n;
                        if (i < 8 || i > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
                        if (i !== (e[2] << 8 | e[3])) return t(3, "wrong scanline width");
                        const s = new Uint8Array(4 * n * r);
                        if (!s.length) return t(4, "unable to allocate buffer space");
                        let o = 0,
                            a = 0;
                        const l = 4 * i,
                            c = new Uint8Array(4),
                            u = new Uint8Array(l);
                        let p = r;
                        for (; p > 0 && a < e.byteLength;) {
                            if (a + 4 > e.byteLength) return t(1);
                            if (c[0] = e[a++], c[1] = e[a++], c[2] = e[a++], c[3] = e[a++], 2 != c[0] || 2 != c[1] || (c[2] << 8 | c[3]) != i) return t(3, "bad rgbe scanline format");
                            let n, r = 0;
                            for (; r < l && a < e.byteLength;) {
                                n = e[a++];
                                const i = n > 128;
                                if (i && (n -= 128), 0 === n || r + n > l) return t(3, "bad scanline data");
                                if (i) {
                                    const t = e[a++];
                                    for (let e = 0; e < n; e++) u[r++] = t
                                } else u.set(e.subarray(a, a + n), r), r += n, a += n
                            }
                            const h = i;
                            for (let e = 0; e < h; e++) {
                                let t = 0;
                                s[o] = u[e + t], t += i, s[o + 1] = u[e + t], t += i, s[o + 2] = u[e + t], t += i, s[o + 3] = u[e + t], o += 4
                            }
                            p--
                        }
                        return s
                    }(o.subarray(o.pos), e, n);
                if (-1 !== l) {
                    let t, o, c;
                    switch (this.type) {
                        case i.VzW:
                            c = l.length / 4;
                            const e = new Float32Array(4 * c);
                            for (let t = 0; t < c; t++) r(l, 4 * t, e, 4 * t);
                            t = e, o = i.VzW;
                            break;
                        case i.cLu:
                            c = l.length / 4;
                            const n = new Uint16Array(4 * c);
                            for (let e = 0; e < c; e++) s(l, 4 * e, n, 4 * e);
                            t = n, o = i.cLu;
                            break;
                        default:
                            console.error("THREE.RGBELoader: unsupported type: ", this.type)
                    }
                    return {
                        width: e,
                        height: n,
                        data: t,
                        header: a.string,
                        gamma: a.gamma,
                        exposure: a.exposure,
                        type: o
                    }
                }
            }
            return null
        }
        setDataType(e) {
            return this.type = e, this
        }
        load(e, t, n, r) {
            return super.load(e, (function(e, n) {
                switch (e.type) {
                    case i.VzW:
                    case i.cLu:
                        e.encoding = i.rnI, e.minFilter = i.wem, e.magFilter = i.wem, e.generateMipmaps = !1, e.flipY = !0
                }
                t && t(e, n)
            }), n, r)
        }
    }

    function rn(e) {
        Us.Importers.push(new $t(class extends nn {
            constructor(t) {
                super(t), this.setDataType(Bs(e))
            }
        }, ["hdr"], !1))
    }
    class sn extends i.aNw {
        constructor(e) {
            super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
                return new pn(e)
            })), this.register((function(e) {
                return new vn(e)
            })), this.register((function(e) {
                return new bn(e)
            })), this.register((function(e) {
                return new dn(e)
            })), this.register((function(e) {
                return new fn(e)
            })), this.register((function(e) {
                return new _n(e)
            })), this.register((function(e) {
                return new mn(e)
            })), this.register((function(e) {
                return new un(e)
            })), this.register((function(e) {
                return new gn(e)
            })), this.register((function(e) {
                return new hn(e)
            })), this.register((function(e) {
                return new ln(e)
            })), this.register((function(e) {
                return new xn(e)
            }))
        }
        load(e, t, n, r) {
            const s = this;
            let o;
            o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : i.Zp0.extractUrlBase(e), this.manager.itemStart(e);
            const a = function(t) {
                    r ? r(t) : console.error(t), s.manager.itemError(e), s.manager.itemEnd(e)
                },
                l = new i.hH6(this.manager);
            l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, (function(n) {
                try {
                    s.parse(n, o, (function(n) {
                        t(n), s.manager.itemEnd(e)
                    }), a)
                } catch (e) {
                    a(e)
                }
            }), n, a)
        }
        setDRACOLoader(e) {
            return this.dracoLoader = e, this
        }
        setDDSLoader() {
            throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
        }
        setKTX2Loader(e) {
            return this.ktx2Loader = e, this
        }
        setMeshoptDecoder(e) {
            return this.meshoptDecoder = e, this
        }
        register(e) {
            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
        }
        unregister(e) {
            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
        }
        parse(e, t, n, r) {
            let s;
            const o = {},
                a = {};
            if ("string" == typeof e) s = e;
            else if (i.Zp0.decodeText(new Uint8Array(e, 0, 4)) === yn) {
                try {
                    o[an.KHR_BINARY_GLTF] = new wn(e)
                } catch (e) {
                    return void(r && r(e))
                }
                s = o[an.KHR_BINARY_GLTF].content
            } else s = i.Zp0.decodeText(new Uint8Array(e));
            const l = JSON.parse(s);
            if (void 0 === l.asset || l.asset.version[0] < 2) return void(r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
            const c = new Hn(l, {
                path: t || this.resourcePath || "",
                crossOrigin: this.crossOrigin,
                requestHeader: this.requestHeader,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader,
                meshoptDecoder: this.meshoptDecoder
            });
            c.fileLoader.setRequestHeader(this.requestHeader);
            for (let e = 0; e < this.pluginCallbacks.length; e++) {
                const t = this.pluginCallbacks[e](c);
                a[t.name] = t, o[t.name] = !0
            }
            if (l.extensionsUsed)
                for (let e = 0; e < l.extensionsUsed.length; ++e) {
                    const t = l.extensionsUsed[e],
                        n = l.extensionsRequired || [];
                    switch (t) {
                        case an.KHR_MATERIALS_UNLIT:
                            o[t] = new cn;
                            break;
                        case an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            o[t] = new En;
                            break;
                        case an.KHR_DRACO_MESH_COMPRESSION:
                            o[t] = new Sn(l, this.dracoLoader);
                            break;
                        case an.KHR_TEXTURE_TRANSFORM:
                            o[t] = new Mn;
                            break;
                        case an.KHR_MESH_QUANTIZATION:
                            o[t] = new An;
                            break;
                        default:
                            n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                    }
                }
            c.setExtensions(o), c.setPlugins(a), c.parse(n, r)
        }
        parseAsync(e, t) {
            const n = this;
            return new Promise((function(r, i) {
                n.parse(e, t, r, i)
            }))
        }
    }

    function on() {
        let e = {};
        return {
            get: function(t) {
                return e[t]
            },
            add: function(t, n) {
                e[t] = n
            },
            remove: function(t) {
                delete e[t]
            },
            removeAll: function() {
                e = {}
            }
        }
    }
    const an = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
    };
    class ln {
        constructor(e) {
            this.parser = e, this.name = an.KHR_LIGHTS_PUNCTUAL, this.cache = {
                refs: {},
                uses: {}
            }
        }
        _markDefs() {
            const e = this.parser,
                t = this.parser.json.nodes || [];
            for (let n = 0, r = t.length; n < r; n++) {
                const r = t[n];
                r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && e._addNodeRef(this.cache, r.extensions[this.name].light)
            }
        }
        _loadLight(e) {
            const t = this.parser,
                n = "light:" + e;
            let r = t.cache.get(n);
            if (r) return r;
            const s = t.json,
                o = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
            let a;
            const l = new i.Ilk(16777215);
            void 0 !== o.color && l.fromArray(o.color);
            const c = void 0 !== o.range ? o.range : 0;
            switch (o.type) {
                case "directional":
                    a = new i.Ox3(l), a.target.position.set(0, 0, -1), a.add(a.target);
                    break;
                case "point":
                    a = new i.cek(l), a.distance = c;
                    break;
                case "spot":
                    a = new i.PMe(l), a.distance = c, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
            }
            return a.position.set(0, 0, 0), a.decay = 2, void 0 !== o.intensity && (a.intensity = o.intensity), a.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(a), t.cache.add(n, r), r
        }
        createNodeAttachment(e) {
            const t = this,
                n = this.parser,
                r = n.json.nodes[e],
                i = (r.extensions && r.extensions[this.name] || {}).light;
            return void 0 === i ? null : this._loadLight(i).then((function(e) {
                return n._getNodeRef(t.cache, i, e)
            }))
        }
    }
    class cn {
        constructor() {
            this.name = an.KHR_MATERIALS_UNLIT
        }
        getMaterialType() {
            return i.vBJ
        }
        extendParams(e, t, n) {
            const r = [];
            e.color = new i.Ilk(1, 1, 1), e.opacity = 1;
            const s = t.pbrMetallicRoughness;
            if (s) {
                if (Array.isArray(s.baseColorFactor)) {
                    const t = s.baseColorFactor;
                    e.color.fromArray(t), e.opacity = t[3]
                }
                void 0 !== s.baseColorTexture && r.push(n.assignTexture(e, "map", s.baseColorTexture, i.knz))
            }
            return Promise.all(r)
        }
    }
    class un {
        constructor(e) {
            this.parser = e, this.name = an.KHR_MATERIALS_EMISSIVE_STRENGTH
        }
        extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const r = n.extensions[this.name].emissiveStrength;
            return void 0 !== r && (t.emissiveIntensity = r), Promise.resolve()
        }
    }
    class pn {
        constructor(e) {
            this.parser = e, this.name = an.KHR_MATERIALS_CLEARCOAT
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? i.EJi : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const s = [],
                o = r.extensions[this.name];
            if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && s.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && s.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (s.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
                const e = o.clearcoatNormalTexture.scale;
                t.clearcoatNormalScale = new i.FM8(e, e)
            }
            return Promise.all(s)
        }
    }
    class hn {
        constructor(e) {
            this.parser = e, this.name = an.KHR_MATERIALS_IRIDESCENCE
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? i.EJi : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const i = [],
                s = r.extensions[this.name];
            return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor), void 0 !== s.iridescenceTexture && i.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)), void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum), void 0 !== s.iridescenceThicknessTexture && i.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)), Promise.all(i)
        }
    }
    class dn {
        constructor(e) {
            this.parser = e, this.name = an.KHR_MATERIALS_SHEEN
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? i.EJi : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const s = [];
            t.sheenColor = new i.Ilk(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
            const o = r.extensions[this.name];
            return void 0 !== o.sheenColorFactor && t.sheenColor.fromArray(o.sheenColorFactor), void 0 !== o.sheenRoughnessFactor && (t.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && s.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, i.knz)), void 0 !== o.sheenRoughnessTexture && s.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), r.extras && void 0 !== r.extras.sheenFactor && (t.sheen = r.extras.sheenFactor, delete r.extras.sheenFactor), Promise.all(s)
        }
    }
    class fn {
        constructor(e) {
            this.parser = e, this.name = an.KHR_MATERIALS_TRANSMISSION
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? i.EJi : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const i = [],
                s = r.extensions[this.name];
            return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(i)
        }
    }
    class _n {
        constructor(e) {
            this.parser = e, this.name = an.KHR_MATERIALS_VOLUME
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? i.EJi : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const s = [],
                o = r.extensions[this.name];
            t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && s.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 0;
            const a = o.attenuationColor || [1, 1, 1];
            return t.attenuationColor = new i.Ilk(a[0], a[1], a[2]), Promise.all(s)
        }
    }
    class mn {
        constructor(e) {
            this.parser = e, this.name = an.KHR_MATERIALS_IOR
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? i.EJi : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const r = n.extensions[this.name];
            return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
        }
    }
    class gn {
        constructor(e) {
            this.parser = e, this.name = an.KHR_MATERIALS_SPECULAR
        }
        getMaterialType(e) {
            const t = this.parser.json.materials[e];
            return t.extensions && t.extensions[this.name] ? i.EJi : null
        }
        extendMaterialParams(e, t) {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const s = [],
                o = r.extensions[this.name];
            t.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && s.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
            const a = o.specularColorFactor || [1, 1, 1];
            return t.specularColor = new i.Ilk(a[0], a[1], a[2]), void 0 !== o.specularColorTexture && s.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, i.knz)), Promise.all(s)
        }
    }
    class vn {
        constructor(e) {
            this.parser = e, this.name = an.KHR_TEXTURE_BASISU
        }
        loadTexture(e) {
            const t = this.parser,
                n = t.json,
                r = n.textures[e];
            if (!r.extensions || !r.extensions[this.name]) return null;
            const i = r.extensions[this.name],
                s = t.options.ktx2Loader;
            if (!s) {
                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                return null
            }
            return t.loadTextureImage(e, i.source, s)
        }
    }
    class bn {
        constructor(e) {
            this.parser = e, this.name = an.EXT_TEXTURE_WEBP, this.isSupported = null
        }
        loadTexture(e) {
            const t = this.name,
                n = this.parser,
                r = n.json,
                i = r.textures[e];
            if (!i.extensions || !i.extensions[t]) return null;
            const s = i.extensions[t],
                o = r.images[s.source];
            let a = n.textureLoader;
            if (o.uri) {
                const e = n.options.manager.getHandler(o.uri);
                null !== e && (a = e)
            }
            return this.detectSupport().then((function(i) {
                if (i) return n.loadTextureImage(e, s.source, a);
                if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                return n.loadTexture(e)
            }))
        }
        detectSupport() {
            return this.isSupported || (this.isSupported = new Promise((function(e) {
                const t = new Image;
                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                    e(1 === t.height)
                }
            }))), this.isSupported
        }
    }
    class xn {
        constructor(e) {
            this.name = an.EXT_MESHOPT_COMPRESSION, this.parser = e
        }
        loadBufferView(e) {
            const t = this.parser.json,
                n = t.bufferViews[e];
            if (n.extensions && n.extensions[this.name]) {
                const e = n.extensions[this.name],
                    r = this.parser.getDependency("buffer", e.buffer),
                    i = this.parser.options.meshoptDecoder;
                if (!i || !i.supported) {
                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                    return null
                }
                return Promise.all([r, i.ready]).then((function(t) {
                    const n = e.byteOffset || 0,
                        r = e.byteLength || 0,
                        s = e.count,
                        o = e.byteStride,
                        a = new ArrayBuffer(s * o),
                        l = new Uint8Array(t[0], n, r);
                    return i.decodeGltfBuffer(new Uint8Array(a), s, o, l, e.mode, e.filter), a
                }))
            }
            return null
        }
    }
    const yn = "glTF";
    class wn {
        constructor(e) {
            this.name = an.KHR_BINARY_GLTF, this.content = null, this.body = null;
            const t = new DataView(e, 0, 12);
            if (this.header = {
                    magic: i.Zp0.decodeText(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                }, this.header.magic !== yn) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
            if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const n = this.header.length - 12,
                r = new DataView(e, 12);
            let s = 0;
            for (; s < n;) {
                const t = r.getUint32(s, !0);
                s += 4;
                const n = r.getUint32(s, !0);
                if (s += 4, 1313821514 === n) {
                    const n = new Uint8Array(e, 12 + s, t);
                    this.content = i.Zp0.decodeText(n)
                } else if (5130562 === n) {
                    const n = 12 + s;
                    this.body = e.slice(n, n + t)
                }
                s += t
            }
            if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
        }
    }
    class Sn {
        constructor(e, t) {
            if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
            this.name = an.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
        }
        decodePrimitive(e, t) {
            const n = this.json,
                r = this.dracoLoader,
                i = e.extensions[this.name].bufferView,
                s = e.extensions[this.name].attributes,
                o = {},
                a = {},
                l = {};
            for (const e in s) {
                const t = In[e] || e.toLowerCase();
                o[t] = s[e]
            }
            for (const t in e.attributes) {
                const r = In[t] || t.toLowerCase();
                if (void 0 !== s[t]) {
                    const i = n.accessors[e.attributes[t]],
                        s = Pn[i.componentType];
                    l[r] = s, a[r] = !0 === i.normalized
                }
            }
            return t.getDependency("bufferView", i).then((function(e) {
                return new Promise((function(t) {
                    r.decodeDracoFile(e, (function(e) {
                        for (const t in e.attributes) {
                            const n = e.attributes[t],
                                r = a[t];
                            void 0 !== r && (n.normalized = r)
                        }
                        t(e)
                    }), o, l)
                }))
            }))
        }
    }
    class Mn {
        constructor() {
            this.name = an.KHR_TEXTURE_TRANSFORM
        }
        extendTexture(e, t) {
            return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
        }
    }
    class Tn extends i.Wid {
        constructor(e) {
            super(), this.isGLTFSpecularGlossinessMaterial = !0;
            const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                a = {
                    specular: {
                        value: (new i.Ilk).setHex(16777215)
                    },
                    glossiness: {
                        value: 1
                    },
                    specularMap: {
                        value: null
                    },
                    glossinessMap: {
                        value: null
                    }
                };
            this._extraUniforms = a, this.onBeforeCompile = function(e) {
                for (const t in a) e.uniforms[t] = a[t];
                e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o)
            }, Object.defineProperties(this, {
                specular: {
                    get: function() {
                        return a.specular.value
                    },
                    set: function(e) {
                        a.specular.value = e
                    }
                },
                specularMap: {
                    get: function() {
                        return a.specularMap.value
                    },
                    set: function(e) {
                        a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                    }
                },
                glossiness: {
                    get: function() {
                        return a.glossiness.value
                    },
                    set: function(e) {
                        a.glossiness.value = e
                    }
                },
                glossinessMap: {
                    get: function() {
                        return a.glossinessMap.value
                    },
                    set: function(e) {
                        a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                    }
                }
            }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
        }
        copy(e) {
            return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
        }
    }
    class En {
        constructor() {
            this.name = an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"]
        }
        getMaterialType() {
            return Tn
        }
        extendParams(e, t, n) {
            const r = t.extensions[this.name];
            e.color = new i.Ilk(1, 1, 1), e.opacity = 1;
            const s = [];
            if (Array.isArray(r.diffuseFactor)) {
                const t = r.diffuseFactor;
                e.color.fromArray(t), e.opacity = t[3]
            }
            if (void 0 !== r.diffuseTexture && s.push(n.assignTexture(e, "map", r.diffuseTexture, i.knz)), e.emissive = new i.Ilk(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new i.Ilk(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) {
                const t = r.specularGlossinessTexture;
                s.push(n.assignTexture(e, "glossinessMap", t)), s.push(n.assignTexture(e, "specularMap", t, i.knz))
            }
            return Promise.all(s)
        }
        createMaterial(e) {
            const t = new Tn(e);
            return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = i.IOt, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t
        }
    }
    class An {
        constructor() {
            this.name = an.KHR_MESH_QUANTIZATION
        }
    }
    class Cn extends i._C8 {
        constructor(e, t, n, r) {
            super(e, t, n, r)
        }
        copySampleValue_(e) {
            const t = this.resultBuffer,
                n = this.sampleValues,
                r = this.valueSize,
                i = e * r * 3 + r;
            for (let e = 0; e !== r; e++) t[e] = n[i + e];
            return t
        }
        interpolate_(e, t, n, r) {
            const i = this.resultBuffer,
                s = this.sampleValues,
                o = this.valueSize,
                a = 2 * o,
                l = 3 * o,
                c = r - t,
                u = (n - t) / c,
                p = u * u,
                h = p * u,
                d = e * l,
                f = d - l,
                _ = -2 * h + 3 * p,
                m = h - p,
                g = 1 - _,
                v = m - p + u;
            for (let e = 0; e !== o; e++) {
                const t = s[f + e + o],
                    n = s[f + e + a] * c,
                    r = s[d + e + o],
                    l = s[d + e] * c;
                i[e] = g * t + v * n + _ * r + m * l
            }
            return i
        }
    }
    const Rn = new i._fP;
    class kn extends Cn {
        interpolate_(e, t, n, r) {
            const i = super.interpolate_(e, t, n, r);
            return Rn.fromArray(i).normalize().toArray(i), i
        }
    }
    const Pn = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        Dn = {
            9728: i.TyD,
            9729: i.wem,
            9984: i.YLQ,
            9985: i.qyh,
            9986: i.aH4,
            9987: i.D1R
        },
        On = {
            33071: i.uWy,
            33648: i.OoA,
            10497: i.rpg
        },
        Ln = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        },
        In = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        },
        Fn = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        },
        Nn = {
            CUBICSPLINE: void 0,
            LINEAR: i.NMF,
            STEP: i.Syv
        };

    function Un(e, t, n) {
        for (const r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r])
    }

    function Bn(e, t) {
        void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
    }

    function jn(e, t) {
        if (e.updateMorphTargets(), void 0 !== t.weights)
            for (let n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];
        if (t.extras && Array.isArray(t.extras.targetNames)) {
            const n = t.extras.targetNames;
            if (e.morphTargetInfluences.length === n.length) {
                e.morphTargetDictionary = {};
                for (let t = 0, r = n.length; t < r; t++) e.morphTargetDictionary[n[t]] = t
            } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
        }
    }

    function zn(e) {
        const t = e.extensions && e.extensions[an.KHR_DRACO_MESH_COMPRESSION];
        let n;
        return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + Vn(t.attributes) : e.indices + ":" + Vn(e.attributes) + ":" + e.mode, n
    }

    function Vn(e) {
        let t = "";
        const n = Object.keys(e).sort();
        for (let r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";
        return t
    }

    function Gn(e) {
        switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
        }
    }
    class Hn {
        constructor(e = {}, t = {}) {
            this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new on, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                refs: {},
                uses: {}
            }, this.cameraCache = {
                refs: {},
                uses: {}
            }, this.lightCache = {
                refs: {},
                uses: {}
            }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
            const n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                r = navigator.userAgent.indexOf("Firefox") > -1,
                s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
            "undefined" == typeof createImageBitmap || n || r && s < 98 ? this.textureLoader = new i.dpR(this.options.manager) : this.textureLoader = new i.QRU(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new i.hH6(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
        }
        setExtensions(e) {
            this.extensions = e
        }
        setPlugins(e) {
            this.plugins = e
        }
        parse(e, t) {
            const n = this,
                r = this.json,
                i = this.extensions;
            this.cache.removeAll(), this._invokeAll((function(e) {
                return e._markDefs && e._markDefs()
            })), Promise.all(this._invokeAll((function(e) {
                return e.beforeRoot && e.beforeRoot()
            }))).then((function() {
                return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
            })).then((function(t) {
                const s = {
                    scene: t[0][r.scene || 0],
                    scenes: t[0],
                    animations: t[1],
                    cameras: t[2],
                    asset: r.asset,
                    parser: n,
                    userData: {}
                };
                Un(i, s, r), Bn(s, r), Promise.all(n._invokeAll((function(e) {
                    return e.afterRoot && e.afterRoot(s)
                }))).then((function() {
                    e(s)
                }))
            })).catch(t)
        }
        _markDefs() {
            const e = this.json.nodes || [],
                t = this.json.skins || [],
                n = this.json.meshes || [];
            for (let n = 0, r = t.length; n < r; n++) {
                const r = t[n].joints;
                for (let t = 0, n = r.length; t < n; t++) e[r[t]].isBone = !0
            }
            for (let t = 0, r = e.length; t < r; t++) {
                const r = e[t];
                void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh), void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)), void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera)
            }
        }
        _addNodeRef(e, t) {
            void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
        }
        _getNodeRef(e, t, n) {
            if (e.refs[t] <= 1) return n;
            const r = n.clone(),
                i = (e, t) => {
                    const n = this.associations.get(e);
                    null != n && this.associations.set(t, n);
                    for (const [n, r] of e.children.entries()) i(r, t.children[n])
                };
            return i(n, r), r.name += "_instance_" + e.uses[t]++, r
        }
        _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for (let n = 0; n < t.length; n++) {
                const r = e(t[n]);
                if (r) return r
            }
            return null
        }
        _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const n = [];
            for (let r = 0; r < t.length; r++) {
                const i = e(t[r]);
                i && n.push(i)
            }
            return n
        }
        getDependency(e, t) {
            const n = e + ":" + t;
            let r = this.cache.get(n);
            if (!r) {
                switch (e) {
                    case "scene":
                        r = this.loadScene(t);
                        break;
                    case "node":
                        r = this.loadNode(t);
                        break;
                    case "mesh":
                        r = this._invokeOne((function(e) {
                            return e.loadMesh && e.loadMesh(t)
                        }));
                        break;
                    case "accessor":
                        r = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        r = this._invokeOne((function(e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        }));
                        break;
                    case "buffer":
                        r = this.loadBuffer(t);
                        break;
                    case "material":
                        r = this._invokeOne((function(e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        }));
                        break;
                    case "texture":
                        r = this._invokeOne((function(e) {
                            return e.loadTexture && e.loadTexture(t)
                        }));
                        break;
                    case "skin":
                        r = this.loadSkin(t);
                        break;
                    case "animation":
                        r = this._invokeOne((function(e) {
                            return e.loadAnimation && e.loadAnimation(t)
                        }));
                        break;
                    case "camera":
                        r = this.loadCamera(t);
                        break;
                    default:
                        throw new Error("Unknown type: " + e)
                }
                this.cache.add(n, r)
            }
            return r
        }
        getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
                const n = this,
                    r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                t = Promise.all(r.map((function(t, r) {
                    return n.getDependency(e, r)
                }))), this.cache.add(e, t)
            }
            return t
        }
        loadBuffer(e) {
            const t = this.json.buffers[e],
                n = this.fileLoader;
            if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
            if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[an.KHR_BINARY_GLTF].body);
            const r = this.options;
            return new Promise((function(e, s) {
                n.load(i.Zp0.resolveURL(t.uri, r.path), e, void 0, (function() {
                    s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                }))
            }))
        }
        loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then((function(e) {
                const n = t.byteLength || 0,
                    r = t.byteOffset || 0;
                return e.slice(r, r + n)
            }))
        }
        loadAccessor(e) {
            const t = this,
                n = this.json,
                r = this.json.accessors[e];
            if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null);
            const s = [];
            return void 0 !== r.bufferView ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), void 0 !== r.sparse && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then((function(e) {
                const s = e[0],
                    o = Ln[r.type],
                    a = Pn[r.componentType],
                    l = a.BYTES_PER_ELEMENT,
                    c = l * o,
                    u = r.byteOffset || 0,
                    p = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                    h = !0 === r.normalized;
                let d, f;
                if (p && p !== c) {
                    const e = Math.floor(u / p),
                        n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
                    let c = t.cache.get(n);
                    c || (d = new a(s, e * p, r.count * p / l), c = new i.vpT(d, p / l), t.cache.add(n, c)), f = new i.kB5(c, o, u % p / l, h)
                } else d = null === s ? new a(r.count * o) : new a(s, u, r.count * o), f = new i.TlE(d, o, h);
                if (void 0 !== r.sparse) {
                    const t = Ln.SCALAR,
                        n = Pn[r.sparse.indices.componentType],
                        l = r.sparse.indices.byteOffset || 0,
                        c = r.sparse.values.byteOffset || 0,
                        u = new n(e[1], l, r.sparse.count * t),
                        p = new a(e[2], c, r.sparse.count * o);
                    null !== s && (f = new i.TlE(f.array.slice(), f.itemSize, f.normalized));
                    for (let e = 0, t = u.length; e < t; e++) {
                        const t = u[e];
                        if (f.setX(t, p[e * o]), o >= 2 && f.setY(t, p[e * o + 1]), o >= 3 && f.setZ(t, p[e * o + 2]), o >= 4 && f.setW(t, p[e * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                    }
                }
                return f
            }))
        }
        loadTexture(e) {
            const t = this.json,
                n = this.options,
                r = t.textures[e].source,
                i = t.images[r];
            let s = this.textureLoader;
            if (i.uri) {
                const e = n.manager.getHandler(i.uri);
                null !== e && (s = e)
            }
            return this.loadTextureImage(e, r, s)
        }
        loadTextureImage(e, t, n) {
            const r = this,
                s = this.json,
                o = s.textures[e],
                a = s.images[t],
                l = (a.uri || a.bufferView) + ":" + o.sampler;
            if (this.textureCache[l]) return this.textureCache[l];
            const c = this.loadImageSource(t, n).then((function(t) {
                t.flipY = !1, o.name && (t.name = o.name);
                const n = (s.samplers || {})[o.sampler] || {};
                return t.magFilter = Dn[n.magFilter] || i.wem, t.minFilter = Dn[n.minFilter] || i.D1R, t.wrapS = On[n.wrapS] || i.rpg, t.wrapT = On[n.wrapT] || i.rpg, r.associations.set(t, {
                    textures: e
                }), t
            })).catch((function() {
                return null
            }));
            return this.textureCache[l] = c, c
        }
        loadImageSource(e, t) {
            const n = this.json,
                r = this.options;
            if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone()));
            const s = n.images[e],
                o = self.URL || self.webkitURL;
            let a = s.uri || "",
                l = !1;
            if (void 0 !== s.bufferView) a = this.getDependency("bufferView", s.bufferView).then((function(e) {
                l = !0;
                const t = new Blob([e], {
                    type: s.mimeType
                });
                return a = o.createObjectURL(t), a
            }));
            else if (void 0 === s.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
            const c = Promise.resolve(a).then((function(e) {
                return new Promise((function(n, s) {
                    let o = n;
                    !0 === t.isImageBitmapLoader && (o = function(e) {
                        const t = new i.xEZ(e);
                        t.needsUpdate = !0, n(t)
                    }), t.load(i.Zp0.resolveURL(e, r.path), o, void 0, s)
                }))
            })).then((function(e) {
                var t;
                return !0 === l && o.revokeObjectURL(a), e.userData.mimeType = s.mimeType || ((t = s.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e
            })).catch((function(e) {
                throw console.error("THREE.GLTFLoader: Couldn't load texture", a), e
            }));
            return this.sourceCache[e] = c, c
        }
        assignTexture(e, t, n, r) {
            const i = this;
            return this.getDependency("texture", n.index).then((function(s) {
                if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), i.extensions[an.KHR_TEXTURE_TRANSFORM]) {
                    const e = void 0 !== n.extensions ? n.extensions[an.KHR_TEXTURE_TRANSFORM] : void 0;
                    if (e) {
                        const t = i.associations.get(s);
                        s = i.extensions[an.KHR_TEXTURE_TRANSFORM].extendTexture(s, e), i.associations.set(s, t)
                    }
                }
                return void 0 !== r && (s.encoding = r), e[t] = s, s
            }))
        }
        assignFinalMaterial(e) {
            const t = e.geometry;
            let n = e.material;
            const r = void 0 === t.attributes.tangent,
                s = void 0 !== t.attributes.color,
                o = void 0 === t.attributes.normal;
            if (e.isPoints) {
                const e = "PointsMaterial:" + n.uuid;
                let t = this.cache.get(e);
                t || (t = new i.UY4, i.F5T.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
            } else if (e.isLine) {
                const e = "LineBasicMaterial:" + n.uuid;
                let t = this.cache.get(e);
                t || (t = new i.nls, i.F5T.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t
            }
            if (r || s || o) {
                let e = "ClonedMaterial:" + n.uuid + ":";
                n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), r && (e += "derivative-tangents:"), s && (e += "vertex-colors:"), o && (e += "flat-shading:");
                let t = this.cache.get(e);
                t || (t = n.clone(), s && (t.vertexColors = !0), o && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
            }
            n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n
        }
        getMaterialType() {
            return i.Wid
        }
        loadMaterial(e) {
            const t = this,
                n = this.json,
                r = this.extensions,
                s = n.materials[e];
            let o;
            const a = {},
                l = s.extensions || {},
                c = [];
            if (l[an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                const e = r[an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                o = e.getMaterialType(), c.push(e.extendParams(a, s, t))
            } else if (l[an.KHR_MATERIALS_UNLIT]) {
                const e = r[an.KHR_MATERIALS_UNLIT];
                o = e.getMaterialType(), c.push(e.extendParams(a, s, t))
            } else {
                const n = s.pbrMetallicRoughness || {};
                if (a.color = new i.Ilk(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
                    const e = n.baseColorFactor;
                    a.color.fromArray(e), a.opacity = e[3]
                }
                void 0 !== n.baseColorTexture && c.push(t.assignTexture(a, "map", n.baseColorTexture, i.knz)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (c.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), o = this._invokeOne((function(t) {
                    return t.getMaterialType && t.getMaterialType(e)
                })), c.push(Promise.all(this._invokeAll((function(t) {
                    return t.extendMaterialParams && t.extendMaterialParams(e, a)
                }))))
            }!0 === s.doubleSided && (a.side = i.ehD);
            const u = s.alphaMode || "OPAQUE";
            if ("BLEND" === u ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, "MASK" === u && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && o !== i.vBJ && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new i.FM8(1, 1), void 0 !== s.normalTexture.scale)) {
                const e = s.normalTexture.scale;
                a.normalScale.set(e, e)
            }
            return void 0 !== s.occlusionTexture && o !== i.vBJ && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && o !== i.vBJ && (a.emissive = (new i.Ilk).fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && o !== i.vBJ && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, i.knz)), Promise.all(c).then((function() {
                let n;
                return n = o === Tn ? r[an.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new o(a), s.name && (n.name = s.name), Bn(n, s), t.associations.set(n, {
                    materials: e
                }), s.extensions && Un(r, n, s), n
            }))
        }
        createUniqueName(e) {
            const t = i.iUV.sanitizeNodeName(e || "");
            let n = t;
            for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;
            return this.nodeNamesUsed[n] = !0, n
        }
        loadGeometries(e) {
            const t = this,
                n = this.extensions,
                r = this.primitiveCache;

            function s(e) {
                return n[an.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                    return Kn(n, e, t)
                }))
            }
            const o = [];
            for (let n = 0, a = e.length; n < a; n++) {
                const a = e[n],
                    l = zn(a),
                    c = r[l];
                if (c) o.push(c.promise);
                else {
                    let e;
                    e = a.extensions && a.extensions[an.KHR_DRACO_MESH_COMPRESSION] ? s(a) : Kn(new i.u9r, a, t), r[l] = {
                        primitive: a,
                        promise: e
                    }, o.push(e)
                }
            }
            return Promise.all(o)
        }
        loadMesh(e) {
            const t = this,
                n = this.json,
                r = this.extensions,
                s = n.meshes[e],
                o = s.primitives,
                a = [];
            for (let e = 0, t = o.length; e < t; e++) {
                const t = void 0 === o[e].material ? (void 0 === (l = this.cache).DefaultMaterial && (l.DefaultMaterial = new i.Wid({
                    color: 16777215,
                    emissive: 0,
                    metalness: 1,
                    roughness: 1,
                    transparent: !1,
                    depthTest: !0,
                    side: i.Wl3
                })), l.DefaultMaterial) : this.getDependency("material", o[e].material);
                a.push(t)
            }
            var l;
            return a.push(t.loadGeometries(o)), Promise.all(a).then((function(n) {
                const a = n.slice(0, n.length - 1),
                    l = n[n.length - 1],
                    c = [];
                for (let n = 0, u = l.length; n < u; n++) {
                    const u = l[n],
                        p = o[n];
                    let h;
                    const d = a[n];
                    if (4 === p.mode || 5 === p.mode || 6 === p.mode || void 0 === p.mode) h = !0 === s.isSkinnedMesh ? new i.TUv(u, d) : new i.Kj0(u, d), !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), 5 === p.mode ? h.geometry = Xn(h.geometry, i.UlW) : 6 === p.mode && (h.geometry = Xn(h.geometry, i.z$h));
                    else if (1 === p.mode) h = new i.ejS(u, d);
                    else if (3 === p.mode) h = new i.x12(u, d);
                    else if (2 === p.mode) h = new i.blk(u, d);
                    else {
                        if (0 !== p.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode);
                        h = new i.woe(u, d)
                    }
                    Object.keys(h.geometry.morphAttributes).length > 0 && jn(h, s), h.name = t.createUniqueName(s.name || "mesh_" + e), Bn(h, s), p.extensions && Un(r, h, p), t.assignFinalMaterial(h), c.push(h)
                }
                s.extensions && c.forEach((e => Un(r, e, s)));
                for (let n = 0, r = c.length; n < r; n++) t.associations.set(c[n], {
                    meshes: e,
                    primitives: n
                });
                if (1 === c.length) return c[0];
                const u = new i.ZAu;
                t.associations.set(u, {
                    meshes: e
                });
                for (let e = 0, t = c.length; e < t; e++) u.add(c[e]);
                return u
            }))
        }
        loadCamera(e) {
            let t;
            const n = this.json.cameras[e],
                r = n[n.type];
            if (r) return "perspective" === n.type ? t = new i.cPb(i.M8C.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new i.iKG(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Bn(t, n), Promise.resolve(t);
            console.warn("THREE.GLTFLoader: Missing camera parameters.")
        }
        loadSkin(e) {
            const t = this.json.skins[e],
                n = {
                    joints: t.joints
                };
            return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
                return n.inverseBindMatrices = e, n
            }))
        }
        loadAnimation(e) {
            const t = this.json.animations[e],
                n = [],
                r = [],
                s = [],
                o = [],
                a = [];
            for (let e = 0, i = t.channels.length; e < i; e++) {
                const i = t.channels[e],
                    l = t.samplers[i.sampler],
                    c = i.target,
                    u = void 0 !== c.node ? c.node : c.id,
                    p = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
                    h = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
                n.push(this.getDependency("node", u)), r.push(this.getDependency("accessor", p)), s.push(this.getDependency("accessor", h)), o.push(l), a.push(c)
            }
            return Promise.all([Promise.all(n), Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(a)]).then((function(n) {
                const r = n[0],
                    s = n[1],
                    o = n[2],
                    a = n[3],
                    l = n[4],
                    c = [];
                for (let e = 0, t = r.length; e < t; e++) {
                    const t = r[e],
                        n = s[e],
                        u = o[e],
                        p = a[e],
                        h = l[e];
                    if (void 0 === t) continue;
                    let d;
                    switch (t.updateMatrix(), Fn[h.path]) {
                        case Fn.weights:
                            d = i.dUE;
                            break;
                        case Fn.rotation:
                            d = i.iLg;
                            break;
                        case Fn.position:
                        case Fn.scale:
                        default:
                            d = i.yC1
                    }
                    const f = t.name ? t.name : t.uuid,
                        _ = void 0 !== p.interpolation ? Nn[p.interpolation] : i.NMF,
                        m = [];
                    Fn[h.path] === Fn.weights ? t.traverse((function(e) {
                        e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid)
                    })) : m.push(f);
                    let g = u.array;
                    if (u.normalized) {
                        const e = Gn(g.constructor),
                            t = new Float32Array(g.length);
                        for (let n = 0, r = g.length; n < r; n++) t[n] = g[n] * e;
                        g = t
                    }
                    for (let e = 0, t = m.length; e < t; e++) {
                        const t = new d(m[e] + "." + Fn[h.path], n.array, g, _);
                        "CUBICSPLINE" === p.interpolation && (t.createInterpolant = function(e) {
                            return new(this instanceof i.iLg ? kn : Cn)(this.times, this.values, this.getValueSize() / 3, e)
                        }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(t)
                    }
                }
                const u = t.name ? t.name : "animation_" + e;
                return new i.m7l(u, void 0, c)
            }))
        }
        createNodeMesh(e) {
            const t = this.json,
                n = this,
                r = t.nodes[e];
            return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function(e) {
                const t = n._getNodeRef(n.meshCache, r.mesh, e);
                return void 0 !== r.weights && t.traverse((function(e) {
                    if (e.isMesh)
                        for (let t = 0, n = r.weights.length; t < n; t++) e.morphTargetInfluences[t] = r.weights[t]
                })), t
            }))
        }
        loadNode(e) {
            const t = this.json,
                n = this.extensions,
                r = this,
                s = t.nodes[e],
                o = s.name ? r.createUniqueName(s.name) : "";
            return function() {
                const t = [],
                    n = r._invokeOne((function(t) {
                        return t.createNodeMesh && t.createNodeMesh(e)
                    }));
                return n && t.push(n), void 0 !== s.camera && t.push(r.getDependency("camera", s.camera).then((function(e) {
                    return r._getNodeRef(r.cameraCache, s.camera, e)
                }))), r._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                })).forEach((function(e) {
                    t.push(e)
                })), Promise.all(t)
            }().then((function(t) {
                let a;
                if (a = !0 === s.isBone ? new i.N$j : t.length > 1 ? new i.ZAu : 1 === t.length ? t[0] : new i.Tme, a !== t[0])
                    for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
                if (s.name && (a.userData.name = s.name, a.name = o), Bn(a, s), s.extensions && Un(n, a, s), void 0 !== s.matrix) {
                    const e = new i.yGw;
                    e.fromArray(s.matrix), a.applyMatrix4(e)
                } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);
                return r.associations.has(a) || r.associations.set(a, {}), r.associations.get(a).nodes = e, a
            }))
        }
        loadScene(e) {
            const t = this.json,
                n = this.extensions,
                r = this.json.scenes[e],
                s = this,
                o = new i.ZAu;
            r.name && (o.name = s.createUniqueName(r.name)), Bn(o, r), r.extensions && Un(n, o, r);
            const a = r.nodes || [],
                l = [];
            for (let e = 0, n = a.length; e < n; e++) l.push(Wn(a[e], o, t, s));
            return Promise.all(l).then((function() {
                return s.associations = (e => {
                    const t = new Map;
                    for (const [e, n] of s.associations)(e instanceof i.F5T || e instanceof i.xEZ) && t.set(e, n);
                    return e.traverse((e => {
                        const n = s.associations.get(e);
                        null != n && t.set(e, n)
                    })), t
                })(o), o
            }))
        }
    }

    function Wn(e, t, n, r) {
        const s = n.nodes[e];
        return r.getDependency("node", e).then((function(e) {
            if (void 0 === s.skin) return e;
            let t;
            return r.getDependency("skin", s.skin).then((function(e) {
                t = e;
                const n = [];
                for (let e = 0, i = t.joints.length; e < i; e++) n.push(r.getDependency("node", t.joints[e]));
                return Promise.all(n)
            })).then((function(n) {
                return e.traverse((function(e) {
                    if (!e.isMesh) return;
                    const r = [],
                        s = [];
                    for (let e = 0, o = n.length; e < o; e++) {
                        const o = n[e];
                        if (o) {
                            r.push(o);
                            const n = new i.yGw;
                            void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e), s.push(n)
                        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                    }
                    e.bind(new i.OdW(r, s), e.matrixWorld)
                })), e
            }))
        })).then((function(e) {
            t.add(e);
            const i = [];
            if (s.children) {
                const t = s.children;
                for (let s = 0, o = t.length; s < o; s++) {
                    const o = t[s];
                    i.push(Wn(o, e, n, r))
                }
            }
            return Promise.all(i)
        }))
    }

    function Kn(e, t, n) {
        const r = t.attributes,
            s = [];

        function o(t, r) {
            return n.getDependency("accessor", t).then((function(t) {
                e.setAttribute(r, t)
            }))
        }
        for (const t in r) {
            const n = In[t] || t.toLowerCase();
            n in e.attributes || s.push(o(r[t], n))
        }
        if (void 0 !== t.indices && !e.index) {
            const r = n.getDependency("accessor", t.indices).then((function(t) {
                e.setIndex(t)
            }));
            s.push(r)
        }
        return Bn(e, t),
            function(e, t, n) {
                const r = t.attributes,
                    s = new i.ZzF;
                if (void 0 === r.POSITION) return; {
                    const e = n.json.accessors[r.POSITION],
                        t = e.min,
                        o = e.max;
                    if (void 0 === t || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (s.set(new i.Pa4(t[0], t[1], t[2]), new i.Pa4(o[0], o[1], o[2])), e.normalized) {
                        const t = Gn(Pn[e.componentType]);
                        s.min.multiplyScalar(t), s.max.multiplyScalar(t)
                    }
                }
                const o = t.targets;
                if (void 0 !== o) {
                    const e = new i.Pa4,
                        t = new i.Pa4;
                    for (let r = 0, i = o.length; r < i; r++) {
                        const i = o[r];
                        if (void 0 !== i.POSITION) {
                            const r = n.json.accessors[i.POSITION],
                                s = r.min,
                                o = r.max;
                            if (void 0 !== s && void 0 !== o) {
                                if (t.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), r.normalized) {
                                    const e = Gn(Pn[r.componentType]);
                                    t.multiplyScalar(e)
                                }
                                e.max(t)
                            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    s.expandByVector(e)
                }
                e.boundingBox = s;
                const a = new i.aLr;
                s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, e.boundingSphere = a
            }(e, t, n), Promise.all(s).then((function() {
                return void 0 !== t.targets ? function(e, t, n) {
                    let r = !1,
                        i = !1,
                        s = !1;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        if (void 0 !== n.POSITION && (r = !0), void 0 !== n.NORMAL && (i = !0), void 0 !== n.COLOR_0 && (s = !0), r && i && s) break
                    }
                    if (!r && !i && !s) return Promise.resolve(e);
                    const o = [],
                        a = [],
                        l = [];
                    for (let c = 0, u = t.length; c < u; c++) {
                        const u = t[c];
                        if (r) {
                            const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
                            o.push(t)
                        }
                        if (i) {
                            const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
                            a.push(t)
                        }
                        if (s) {
                            const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
                            l.push(t)
                        }
                    }
                    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then((function(t) {
                        const n = t[0],
                            o = t[1],
                            a = t[2];
                        return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = o), s && (e.morphAttributes.color = a), e.morphTargetsRelative = !0, e
                    }))
                }(e, t.targets, n) : e
            }))
    }

    function Xn(e, t) {
        let n = e.getIndex();
        if (null === n) {
            const t = [],
                r = e.getAttribute("position");
            if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
            for (let e = 0; e < r.count; e++) t.push(e);
            e.setIndex(t), n = e.getIndex()
        }
        const r = n.count - 2,
            s = [];
        if (t === i.z$h)
            for (let e = 1; e <= r; e++) s.push(n.getX(0)), s.push(n.getX(e)), s.push(n.getX(e + 1));
        else
            for (let e = 0; e < r; e++) e % 2 == 0 ? (s.push(n.getX(e)), s.push(n.getX(e + 1)), s.push(n.getX(e + 2))) : (s.push(n.getX(e + 2)), s.push(n.getX(e + 1)), s.push(n.getX(e)));
        s.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const o = e.clone();
        return o.setIndex(s), o
    }
    class qn extends sn {
        constructor(e) {
            super(e), this.isGLTFLoader2 = !0
        }
        async loadAsync(e, t) {
            const n = await super.loadAsync(e, t),
                r = n ? n.scene || n.scenes && n.scenes.length > 0 && n.scenes[0] : void 0;
            return r && n.animations.length > 0 && (r.animations = n.animations), r.traverse((e => {
                e.userData.gltfUUID && (e.uuid = e.userData.gltfUUID, delete e.userData.gltfUUID)
            })), r
        }
        register(e) {
            return super.register(e)
        }
    }
    class Yn extends i.hH6 {
        constructor(e) {
            super(e), this.type = i.cLu
        }
        async loadAsync(e, t) {
            const n = await this.parseAsync(e, t, !1),
                r = new i.IEO(n.data, n.width, n.height, i.wk1, this.type);
            return r.needsUpdate = !0, r.flipY = !0, r.encoding = i.rnI, r.minFilter = i.wem, r.magFilter = i.wem, r.source.data.complete = !0, r
        }
        async parseAsync(e, t, n = !1) {
            if (!e.startsWith("data:")) {
                this.responseType = "blob";
                const n = await super.loadAsync(e, t);
                e = (e = await bt(n)).replace("application/octet-stream", "image/png")
            }
            const r = await At(e);
            let s = Uint8Array;
            return this.type === i.cLu ? s = Uint16Array : this.type === i.VzW && (s = Uint32Array), {
                data: function(e, t = 3, n = Uint16Array, r = !1) {
                    let s;
                    const o = e.byteLength >> 2,
                        a = new n(o * t);
                    for (let n = 0; n < o; n++) s = Math.pow(2, e[4 * n + 3] - 136), r ? (a[n * t] = Math.min(e[4 * n] * s, 65504), a[n * t + 1] = Math.min(e[4 * n + 1] * s, 65504), a[n * t + 2] = Math.min(e[4 * n + 2] * s, 65504)) : (a[n * t] = i.A5E.toHalfFloat(Math.min(e[4 * n] * s, 65504)), a[n * t + 1] = i.A5E.toHalfFloat(Math.min(e[4 * n + 1] * s, 65504)), a[n * t + 2] = i.A5E.toHalfFloat(Math.min(e[4 * n + 2] * s, 65504))), 4 === t && (a[n * t + 3] = i.A5E.toHalfFloat(1));
                    return a
                }(r.data, 4, s, n),
                width: r.width,
                height: r.height
            }
        }
        setDataType(e) {
            return this.type = e, this
        }
    }
    class Zn extends i.Gql {
        constructor(e) {
            super(e), this._imageLoader = new i.S3k(e)
        }
        parseTextures2(e, t, n) {
            var r;
            for (const s of e) {
                const e = null === (r = null == s ? void 0 : s.userData) || void 0 === r ? void 0 : r.rootPath;
                if (e && (!s.image || !t[s.image])) {
                    const r = new i.Hw6(this._imageLoader.load(e, n));
                    if (!r) continue;
                    s.image && (r.uuid = s.image), t[r.uuid] = r, s.image = r.uuid
                }
            }
            return super.parseTextures(e, t)
        }
        parseMaterials2(e, t, n) {
            const r = {};
            return e.forEach((e => {
                if (!e) return;
                const i = { ...e
                    },
                    s = Object.keys(i);
                for (const e of s)
                    if ("map" === e || e.endsWith("Map")) {
                        const n = i[e];
                        "string" == typeof n && (t[n] ? i[e] = t[n] : (console.warn(`Texture ${n} not found`), delete i[e]))
                    }
                const o = n.generateFromTemplateType(i.type, i);
                o && (r[e.uuid] = o)
            })), r
        }
    }
    const Jn = "WEBGI_viewer";

    function $n(e) {
        Us.Importers.push(new $t(qn, ["gltf", "glb", "data:model/gltf"], !0, ((t, n) => {
            if (!t) return t;
            const r = t,
                i = new Zn(n.loadingManager);
            return r.register(rr(i)), r.register(nr(i)), r.register(ir(i)), r.register((e => new cr(e))), r.register((e => new ur(e))), r.register((e => new pr(e))), r.register((t => {
                var s, o, a, l, c, u, p, h, d;
                const f = Be() + ".drc",
                    _ = Be() + ".ktx2",
                    m = null === (a = null === (o = null === (s = t.json) || void 0 === s ? void 0 : s.extensionsRequired) || void 0 === o ? void 0 : o.includes) || void 0 === a ? void 0 : a.call(o, "KHR_draco_mesh_compression");
                if (m) {
                    const e = n.registerFile(f);
                    e && r.setDRACOLoader(e)
                }(null === (u = null === (c = null === (l = t.json) || void 0 === l ? void 0 : l.extensionsUsed) || void 0 === c ? void 0 : c.includes) || void 0 === u ? void 0 : u.call(c, "EXT_meshopt_compression")) && (window.MeshoptDecoder ? (r.setMeshoptDecoder(window.MeshoptDecoder), t.options.meshoptDecoder = window.MeshoptDecoder) : console.error("Add GLTFMeshOptPlugin to viewer to enable EXT_meshopt_compression decode"));
                const g = null === (d = null === (h = null === (p = t.json) || void 0 === p ? void 0 : p.extensionsUsed) || void 0 === h ? void 0 : h.includes) || void 0 === d ? void 0 : d.call(h, "KHR_texture_basisu");
                if (g) {
                    const e = n.registerFile(_);
                    e && (r.setKTX2Loader(e), t.options.ktx2Loader = e)
                }
                return {
                    name: "GLTF2_HELPER_PLUGIN",
                    afterRoot: async r => (m && n.unregisterFile(f), g && n.unregisterFile(_), sr(t, e, i))
                }
            })), r
        })))
    }
    const Qn = "WEBGI_light_extras",
        er = "WEBGI_object3d_extras",
        tr = "WEBGI_material_extras",
        nr = e => e => ({
            name: "__" + er,
            afterRoot: async e => {
                (e.scenes || (e.scene ? [e.scene] : [])).forEach((e => {
                    e.traverse((e => {
                        var t, n;
                        if (!e.isObject3D) return;
                        const r = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === n ? void 0 : n[er];
                        if (!r) return void(e.isLight && !e.isAmbientLight && (e.castShadow = !0));
                        const i = void 0 !== r.castShadow || void 0 !== r.receiveShadow;
                        void 0 !== r.castShadow && (e.castShadow = r.castShadow), void 0 !== r.receiveShadow && (e.receiveShadow = r.receiveShadow), void 0 !== r.visible && (e.visible = r.visible), void 0 !== r.frustumCulled && (e.frustumCulled = r.frustumCulled), void 0 !== r.renderOrder && (e.renderOrder = r.renderOrder), void 0 !== r.layers && (e.layers.mask = r.layers), i && (e.userData.__keepShadowDef = !0), delete e.userData.gltfExtensions[er]
                    }))
                }))
            }
        }),
        rr = e => e => ({
            name: "__" + tr,
            afterRoot: async e => {
                (e.scenes || (e.scene ? [e.scene] : [])).forEach((e => {
                    e.traverse((e => {
                        var t, n;
                        const r = null == e ? void 0 : e.material;
                        if (!(null == r ? void 0 : r.isMaterial)) return;
                        const i = null === (n = null === (t = r.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === n ? void 0 : n[tr];
                        i && (void 0 !== i.emissiveIntensity && (r.emissiveIntensity = i.emissiveIntensity), void 0 !== i.fog && (r.fog = i.fog), void 0 !== i.flatShading && (r.flatShading = i.flatShading), void 0 !== i.blending && (r.blending = i.blending), void 0 !== i.shadowSide && (r.shadowSide = i.shadowSide), void 0 !== i.depthTest && (r.depthTest = i.depthTest), void 0 !== i.depthWrite && (r.depthWrite = i.depthWrite), void 0 !== i.colorWrite && (r.colorWrite = i.colorWrite), void 0 !== i.wireframe && (r.wireframe = i.wireframe), void 0 !== i.wireframeLinewidth && (r.wireframeLinewidth = i.wireframeLinewidth), void 0 !== i.wireframeLinecap && (r.wireframeLinecap = i.wireframeLinecap), void 0 !== i.wireframeLinejoin && (r.wireframeLinejoin = i.wireframeLinejoin), void 0 !== i.rotation && (r.rotation = i.rotation), void 0 !== i.dithering && (r.dithering = i.dithering), void 0 !== i.alphaToCoverage && (r.alphaToCoverage = i.alphaToCoverage), void 0 !== i.premultipliedAlpha && (r.premultipliedAlpha = i.premultipliedAlpha), void 0 !== i.toneMapped && (r.toneMapped = i.toneMapped), void 0 !== i.reflectivity && (r.reflectivity = i.reflectivity), delete r.userData.gltfExtensions[tr])
                    }))
                }))
            }
        }),
        ir = e => t => ({
            name: "__" + Qn,
            afterRoot: async t => {
                (t.scenes || (t.scene ? [t.scene] : [])).forEach((t => {
                    t.traverse((t => {
                        var n, r;
                        if (!t.isLight) return;
                        const i = null === (r = null === (n = t.userData) || void 0 === n ? void 0 : n.gltfExtensions) || void 0 === r ? void 0 : r[Qn];
                        i && (!t.shadow && i.shadow && console.error("Light has no shadow, cannot import", t, i), i.shadow && t.shadow && (void 0 !== i.shadow.bias && (t.shadow.bias = i.shadow.bias), void 0 !== i.shadow.normalBias && (t.shadow.normalBias = i.shadow.normalBias), void 0 !== i.shadow.radius && (t.shadow.radius = i.shadow.radius), void 0 !== i.shadow.mapSize && t.shadow.mapSize.fromArray(i.shadow.mapSize), void 0 !== i.shadow.camera && (t.shadow.camera = e.parseObject(i.shadow.camera))), delete t.userData.gltfExtensions[Qn])
                    }))
                }))
            }
        });
    async function sr(e, t, n, r) {
        var i;
        if (!r) {
            const n = e.json.scenes || [];
            if (1 !== n.length) {
                for (const r of n) await sr(e, t, r);
                return
            }
            r = n[0]
        }
        const s = null === (i = r.extensions) || void 0 === i ? void 0 : i[Jn];
        if (!s) return;
        const o = [];
        Object.values(s.resources).forEach((e => {
            Object.values(e).forEach((e => {
                e.url && ("Uint16Array" === e.url.type && e.url.data && o.push(e.url), "Uint8Array" === e.url.type && e.url.data && o.push(e.url))
            }))
        }));
        for (const t of o) {
            const n = t.data.image,
                r = e.json.images[n],
                i = await e.getDependency("bufferView", r.bufferView);
            if (r.mimeType.startsWith("image/") && "Uint16Array" === t.type && "rgbe" === t.encoding) {
                const e = new Blob([i], {
                        type: r.mimeType
                    }),
                    n = "data:image/png;base64," + btoa(await e.text());
                t.data = (await (new Yn).parseAsync(n, void 0, !0)).data, delete t.encoding
            } else t.data = i
        }
        await t.getPlugin(Vs).importViewerConfig(s, n)
    }
    const or = "WEBGI_materials_bumpmap",
        ar = "WEBGI_materials_alphamap",
        lr = "WEBGI_materials_lightmap";
    class cr {
        constructor(e) {
            this.parser = e, this.name = or
        }
        async extendMaterialParams(e, t) {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const i = [],
                s = r.extensions[this.name];
            return void 0 !== s.bumpScale && (t.bumpScale = s.bumpScale), void 0 !== s.bumpTexture && i.push(n.assignTexture(t, "bumpMap", s.bumpTexture)), Promise.all(i)
        }
    }
    class ur {
        constructor(e) {
            this.parser = e, this.name = lr
        }
        async extendMaterialParams(e, t) {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const i = [],
                s = r.extensions[this.name];
            return void 0 !== s.lightMapIntensity && (t.lightMapIntensity = s.lightMapIntensity), void 0 !== s.lightMapTexture && i.push(n.assignTexture(t, "lightMap", s.lightMapTexture)), Promise.all(i)
        }
    }
    class pr {
        constructor(e) {
            this.parser = e, this.name = ar
        }
        async extendMaterialParams(e, t) {
            const n = this.parser,
                r = n.json.materials[e];
            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
            const i = [],
                s = r.extensions[this.name];
            return void 0 !== s.alphaTexture && i.push(n.assignTexture(t, "alphaMap", s.alphaTexture)), Promise.all(i)
        }
    }
    var hr = __webpackgi_require__(23);

    function dr() {
        Us.Importers.push(new $t(hr.Q, ["drc"], !0))
    }
    var fr = {},
        _r = Uint8Array,
        mr = Uint16Array,
        gr = Uint32Array,
        vr = new _r([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
        br = new _r([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
        xr = new _r([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
        yr = function(e, t) {
            for (var n = new mr(31), r = 0; r < 31; ++r) n[r] = t += 1 << e[r - 1];
            var i = new gr(n[30]);
            for (r = 1; r < 30; ++r)
                for (var s = n[r]; s < n[r + 1]; ++s) i[s] = s - n[r] << 5 | r;
            return [n, i]
        },
        wr = yr(vr, 2),
        Sr = wr[0],
        Mr = wr[1];
    Sr[28] = 258, Mr[258] = 28;
    for (var Tr = yr(br, 0), Er = Tr[0], Ar = Tr[1], Cr = new mr(32768), Rr = 0; Rr < 32768; ++Rr) {
        var kr = (43690 & Rr) >>> 1 | (21845 & Rr) << 1;
        kr = (61680 & (kr = (52428 & kr) >>> 2 | (13107 & kr) << 2)) >>> 4 | (3855 & kr) << 4, Cr[Rr] = ((65280 & kr) >>> 8 | (255 & kr) << 8) >>> 1
    }
    var Pr = function(e, t, n) {
            for (var r = e.length, i = 0, s = new mr(t); i < r; ++i) ++s[e[i] - 1];
            var o, a = new mr(t);
            for (i = 0; i < t; ++i) a[i] = a[i - 1] + s[i - 1] << 1;
            if (n) {
                o = new mr(1 << t);
                var l = 15 - t;
                for (i = 0; i < r; ++i)
                    if (e[i])
                        for (var c = i << 4 | e[i], u = t - e[i], p = a[e[i] - 1]++ << u, h = p | (1 << u) - 1; p <= h; ++p) o[Cr[p] >>> l] = c
            } else
                for (o = new mr(r), i = 0; i < r; ++i) e[i] && (o[i] = Cr[a[e[i] - 1]++] >>> 15 - e[i]);
            return o
        },
        Dr = new _r(288);
    for (Rr = 0; Rr < 144; ++Rr) Dr[Rr] = 8;
    for (Rr = 144; Rr < 256; ++Rr) Dr[Rr] = 9;
    for (Rr = 256; Rr < 280; ++Rr) Dr[Rr] = 7;
    for (Rr = 280; Rr < 288; ++Rr) Dr[Rr] = 8;
    var Or = new _r(32);
    for (Rr = 0; Rr < 32; ++Rr) Or[Rr] = 5;
    var Lr = Pr(Dr, 9, 0),
        Ir = Pr(Dr, 9, 1),
        Fr = Pr(Or, 5, 0),
        Nr = Pr(Or, 5, 1),
        Ur = function(e) {
            for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);
            return t
        },
        Br = function(e, t, n) {
            var r = t / 8 | 0;
            return (e[r] | e[r + 1] << 8) >> (7 & t) & n
        },
        jr = function(e, t) {
            var n = t / 8 | 0;
            return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t)
        },
        zr = function(e) {
            return (e / 8 | 0) + (7 & e && 1)
        },
        Vr = function(e, t, n) {
            (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length);
            var r = new(e instanceof mr ? mr : e instanceof gr ? gr : _r)(n - t);
            return r.set(e.subarray(t, n)), r
        },
        Gr = function(e, t, n) {
            var r = e.length;
            if (!r || n && !n.l && r < 5) return t || new _r(0);
            var i = !t || n,
                s = !n || n.i;
            n || (n = {}), t || (t = new _r(3 * r));
            var o = function(e) {
                    var n = t.length;
                    if (e > n) {
                        var r = new _r(Math.max(2 * n, e));
                        r.set(t), t = r
                    }
                },
                a = n.f || 0,
                l = n.p || 0,
                c = n.b || 0,
                u = n.l,
                p = n.d,
                h = n.m,
                d = n.n,
                f = 8 * r;
            do {
                if (!u) {
                    n.f = a = Br(e, l, 1);
                    var _ = Br(e, l + 1, 3);
                    if (l += 3, !_) {
                        var m = e[(A = zr(l) + 4) - 4] | e[A - 3] << 8,
                            g = A + m;
                        if (g > r) {
                            if (s) throw "unexpected EOF";
                            break
                        }
                        i && o(c + m), t.set(e.subarray(A, g), c), n.b = c += m, n.p = l = 8 * g;
                        continue
                    }
                    if (1 == _) u = Ir, p = Nr, h = 9, d = 5;
                    else {
                        if (2 != _) throw "invalid block type";
                        var v = Br(e, l, 31) + 257,
                            b = Br(e, l + 10, 15) + 4,
                            x = v + Br(e, l + 5, 31) + 1;
                        l += 14;
                        for (var y = new _r(x), w = new _r(19), S = 0; S < b; ++S) w[xr[S]] = Br(e, l + 3 * S, 7);
                        l += 3 * b;
                        var M = Ur(w),
                            T = (1 << M) - 1,
                            E = Pr(w, M, 1);
                        for (S = 0; S < x;) {
                            var A, C = E[Br(e, l, T)];
                            if (l += 15 & C, (A = C >>> 4) < 16) y[S++] = A;
                            else {
                                var R = 0,
                                    k = 0;
                                for (16 == A ? (k = 3 + Br(e, l, 3), l += 2, R = y[S - 1]) : 17 == A ? (k = 3 + Br(e, l, 7), l += 3) : 18 == A && (k = 11 + Br(e, l, 127), l += 7); k--;) y[S++] = R
                            }
                        }
                        var P = y.subarray(0, v),
                            D = y.subarray(v);
                        h = Ur(P), d = Ur(D), u = Pr(P, h, 1), p = Pr(D, d, 1)
                    }
                    if (l > f) {
                        if (s) throw "unexpected EOF";
                        break
                    }
                }
                i && o(c + 131072);
                for (var O = (1 << h) - 1, L = (1 << d) - 1, I = l;; I = l) {
                    var F = (R = u[jr(e, l) & O]) >>> 4;
                    if ((l += 15 & R) > f) {
                        if (s) throw "unexpected EOF";
                        break
                    }
                    if (!R) throw "invalid length/literal";
                    if (F < 256) t[c++] = F;
                    else {
                        if (256 == F) {
                            I = l, u = null;
                            break
                        }
                        var N = F - 254;
                        if (F > 264) {
                            var U = vr[S = F - 257];
                            N = Br(e, l, (1 << U) - 1) + Sr[S], l += U
                        }
                        var B = p[jr(e, l) & L],
                            j = B >>> 4;
                        if (!B) throw "invalid distance";
                        if (l += 15 & B, D = Er[j], j > 3 && (U = br[j], D += jr(e, l) & (1 << U) - 1, l += U), l > f) {
                            if (s) throw "unexpected EOF";
                            break
                        }
                        i && o(c + 131072);
                        for (var z = c + N; c < z; c += 4) t[c] = t[c - D], t[c + 1] = t[c + 1 - D], t[c + 2] = t[c + 2 - D], t[c + 3] = t[c + 3 - D];
                        c = z
                    }
                }
                n.l = u, n.p = I, n.b = c, u && (a = 1, n.m = h, n.d = p, n.n = d)
            } while (!a);
            return c == t.length ? t : Vr(t, 0, c)
        },
        Hr = function(e, t, n) {
            n <<= 7 & t;
            var r = t / 8 | 0;
            e[r] |= n, e[r + 1] |= n >>> 8
        },
        Wr = function(e, t, n) {
            n <<= 7 & t;
            var r = t / 8 | 0;
            e[r] |= n, e[r + 1] |= n >>> 8, e[r + 2] |= n >>> 16
        },
        Kr = function(e, t) {
            for (var n = [], r = 0; r < e.length; ++r) e[r] && n.push({
                s: r,
                f: e[r]
            });
            var i = n.length,
                s = n.slice();
            if (!i) return [Qr, 0];
            if (1 == i) {
                var o = new _r(n[0].s + 1);
                return o[n[0].s] = 1, [o, 1]
            }
            n.sort((function(e, t) {
                return e.f - t.f
            })), n.push({
                s: -1,
                f: 25001
            });
            var a = n[0],
                l = n[1],
                c = 0,
                u = 1,
                p = 2;
            for (n[0] = {
                    s: -1,
                    f: a.f + l.f,
                    l: a,
                    r: l
                }; u != i - 1;) a = n[n[c].f < n[p].f ? c++ : p++], l = n[c != u && n[c].f < n[p].f ? c++ : p++], n[u++] = {
                s: -1,
                f: a.f + l.f,
                l: a,
                r: l
            };
            var h = s[0].s;
            for (r = 1; r < i; ++r) s[r].s > h && (h = s[r].s);
            var d = new mr(h + 1),
                f = Xr(n[u - 1], d, 0);
            if (f > t) {
                r = 0;
                var _ = 0,
                    m = f - t,
                    g = 1 << m;
                for (s.sort((function(e, t) {
                        return d[t.s] - d[e.s] || e.f - t.f
                    })); r < i; ++r) {
                    var v = s[r].s;
                    if (!(d[v] > t)) break;
                    _ += g - (1 << f - d[v]), d[v] = t
                }
                for (_ >>>= m; _ > 0;) {
                    var b = s[r].s;
                    d[b] < t ? _ -= 1 << t - d[b]++ - 1 : ++r
                }
                for (; r >= 0 && _; --r) {
                    var x = s[r].s;
                    d[x] == t && (--d[x], ++_)
                }
                f = t
            }
            return [new _r(d), f]
        },
        Xr = function(e, t, n) {
            return -1 == e.s ? Math.max(Xr(e.l, t, n + 1), Xr(e.r, t, n + 1)) : t[e.s] = n
        },
        qr = function(e) {
            for (var t = e.length; t && !e[--t];);
            for (var n = new mr(++t), r = 0, i = e[0], s = 1, o = function(e) {
                    n[r++] = e
                }, a = 1; a <= t; ++a)
                if (e[a] == i && a != t) ++s;
                else {
                    if (!i && s > 2) {
                        for (; s > 138; s -= 138) o(32754);
                        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0)
                    } else if (s > 3) {
                        for (o(i), --s; s > 6; s -= 6) o(8304);
                        s > 2 && (o(s - 3 << 5 | 8208), s = 0)
                    }
                    for (; s--;) o(i);
                    s = 1, i = e[a]
                }
            return [n.subarray(0, r), t]
        },
        Yr = function(e, t) {
            for (var n = 0, r = 0; r < t.length; ++r) n += e[r] * t[r];
            return n
        },
        Zr = function(e, t, n) {
            var r = n.length,
                i = zr(t + 2);
            e[i] = 255 & r, e[i + 1] = r >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];
            for (var s = 0; s < r; ++s) e[i + s + 4] = n[s];
            return 8 * (i + 4 + r)
        },
        Jr = function(e, t, n, r, i, s, o, a, l, c, u) {
            Hr(t, u++, n), ++i[256];
            for (var p = Kr(i, 15), h = p[0], d = p[1], f = Kr(s, 15), _ = f[0], m = f[1], g = qr(h), v = g[0], b = g[1], x = qr(_), y = x[0], w = x[1], S = new mr(19), M = 0; M < v.length; ++M) S[31 & v[M]]++;
            for (M = 0; M < y.length; ++M) S[31 & y[M]]++;
            for (var T = Kr(S, 7), E = T[0], A = T[1], C = 19; C > 4 && !E[xr[C - 1]]; --C);
            var R, k, P, D, O = c + 5 << 3,
                L = Yr(i, Dr) + Yr(s, Or) + o,
                I = Yr(i, h) + Yr(s, _) + o + 14 + 3 * C + Yr(S, E) + (2 * S[16] + 3 * S[17] + 7 * S[18]);
            if (O <= L && O <= I) return Zr(t, u, e.subarray(l, l + c));
            if (Hr(t, u, 1 + (I < L)), u += 2, I < L) {
                R = Pr(h, d, 0), k = h, P = Pr(_, m, 0), D = _;
                var F = Pr(E, A, 0);
                for (Hr(t, u, b - 257), Hr(t, u + 5, w - 1), Hr(t, u + 10, C - 4), u += 14, M = 0; M < C; ++M) Hr(t, u + 3 * M, E[xr[M]]);
                u += 3 * C;
                for (var N = [v, y], U = 0; U < 2; ++U) {
                    var B = N[U];
                    for (M = 0; M < B.length; ++M) {
                        var j = 31 & B[M];
                        Hr(t, u, F[j]), u += E[j], j > 15 && (Hr(t, u, B[M] >>> 5 & 127), u += B[M] >>> 12)
                    }
                }
            } else R = Lr, k = Dr, P = Fr, D = Or;
            for (M = 0; M < a; ++M)
                if (r[M] > 255) {
                    j = r[M] >>> 18 & 31, Wr(t, u, R[j + 257]), u += k[j + 257], j > 7 && (Hr(t, u, r[M] >>> 23 & 31), u += vr[j]);
                    var z = 31 & r[M];
                    Wr(t, u, P[z]), u += D[z], z > 3 && (Wr(t, u, r[M] >>> 5 & 8191), u += br[z])
                } else Wr(t, u, R[r[M]]), u += k[r[M]];
            return Wr(t, u, R[256]), u + k[256]
        },
        $r = new gr([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
        Qr = new _r(0),
        ei = function(e, t, n, r, i, s) {
            var o = e.length,
                a = new _r(r + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
                l = a.subarray(r, a.length - i),
                c = 0;
            if (!t || o < 8)
                for (var u = 0; u <= o; u += 65535) {
                    var p = u + 65535;
                    p < o ? c = Zr(l, c, e.subarray(u, p)) : (l[u] = s, c = Zr(l, c, e.subarray(u, o)))
                } else {
                    for (var h = $r[t - 1], d = h >>> 13, f = 8191 & h, _ = (1 << n) - 1, m = new mr(32768), g = new mr(_ + 1), v = Math.ceil(n / 3), b = 2 * v, x = function(t) {
                            return (e[t] ^ e[t + 1] << v ^ e[t + 2] << b) & _
                        }, y = new gr(25e3), w = new mr(288), S = new mr(32), M = 0, T = 0, E = (u = 0, 0), A = 0, C = 0; u < o; ++u) {
                        var R = x(u),
                            k = 32767 & u,
                            P = g[R];
                        if (m[k] = P, g[R] = k, A <= u) {
                            var D = o - u;
                            if ((M > 7e3 || E > 24576) && D > 423) {
                                c = Jr(e, l, 0, y, w, S, T, E, C, u - C, c), E = M = T = 0, C = u;
                                for (var O = 0; O < 286; ++O) w[O] = 0;
                                for (O = 0; O < 30; ++O) S[O] = 0
                            }
                            var L = 2,
                                I = 0,
                                F = f,
                                N = k - P & 32767;
                            if (D > 2 && R == x(u - N))
                                for (var U = Math.min(d, D) - 1, B = Math.min(32767, u), j = Math.min(258, D); N <= B && --F && k != P;) {
                                    if (e[u + L] == e[u + L - N]) {
                                        for (var z = 0; z < j && e[u + z] == e[u + z - N]; ++z);
                                        if (z > L) {
                                            if (L = z, I = N, z > U) break;
                                            var V = Math.min(N, z - 2),
                                                G = 0;
                                            for (O = 0; O < V; ++O) {
                                                var H = u - N + O + 32768 & 32767,
                                                    W = H - m[H] + 32768 & 32767;
                                                W > G && (G = W, P = H)
                                            }
                                        }
                                    }
                                    N += (k = P) - (P = m[k]) + 32768 & 32767
                                }
                            if (I) {
                                y[E++] = 268435456 | Mr[L] << 18 | Ar[I];
                                var K = 31 & Mr[L],
                                    X = 31 & Ar[I];
                                T += vr[K] + br[X], ++w[257 + K], ++S[X], A = u + L, ++M
                            } else y[E++] = e[u], ++w[e[u]]
                        }
                    }
                    c = Jr(e, l, s, y, w, S, T, E, C, u - C, c), !s && 7 & c && (c = Zr(l, c + 1, Qr))
                }
            return Vr(a, 0, r + zr(c) + i)
        },
        ti = function() {
            for (var e = new Int32Array(256), t = 0; t < 256; ++t) {
                for (var n = t, r = 9; --r;) n = (1 & n && -306674912) ^ n >>> 1;
                e[t] = n
            }
            return e
        }(),
        ni = function() {
            var e = -1;
            return {
                p: function(t) {
                    for (var n = e, r = 0; r < t.length; ++r) n = ti[255 & n ^ t[r]] ^ n >>> 8;
                    e = n
                },
                d: function() {
                    return ~e
                }
            }
        },
        ri = function() {
            var e = 1,
                t = 0;
            return {
                p: function(n) {
                    for (var r = e, i = t, s = n.length, o = 0; o != s;) {
                        for (var a = Math.min(o + 2655, s); o < a; ++o) i += r += n[o];
                        r = (65535 & r) + 15 * (r >> 16), i = (65535 & i) + 15 * (i >> 16)
                    }
                    e = r, t = i
                },
                d: function() {
                    return (255 & (e %= 65521)) << 24 | e >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8
                }
            }
        },
        ii = function(e, t, n, r, i) {
            return ei(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, n, r, !i)
        },
        si = function(e, t) {
            var n = {};
            for (var r in e) n[r] = e[r];
            for (var r in t) n[r] = t[r];
            return n
        },
        oi = function(e, t, n) {
            for (var r = e(), i = e.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < r.length; ++o) {
                var a = r[o],
                    l = s[o];
                if ("function" == typeof a) {
                    t += ";" + l + "=";
                    var c = a.toString();
                    if (a.prototype)
                        if (-1 != c.indexOf("[native code]")) {
                            var u = c.indexOf(" ", 8) + 1;
                            t += c.slice(u, c.indexOf("(", u))
                        } else
                            for (var p in t += c, a.prototype) t += ";" + l + ".prototype." + p + "=" + a.prototype[p].toString();
                    else t += c
                } else n[l] = a
            }
            return [t, n]
        },
        ai = [],
        li = function(e, t, n, r) {
            var i;
            if (!ai[n]) {
                for (var s = "", o = {}, a = e.length - 1, l = 0; l < a; ++l) s = (i = oi(e[l], s, o))[0], o = i[1];
                ai[n] = oi(e[a], s, o)
            }
            var c = si({}, ai[n][1]);
            return function(e, t, n, r, i) {
                var s = new Worker(fr[t] || (fr[t] = URL.createObjectURL(new Blob([e], {
                    type: "text/javascript"
                }))));
                return s.onerror = function(e) {
                    return i(e.error, null)
                }, s.onmessage = function(e) {
                    return i(null, e.data)
                }, s.postMessage(n, r), s
            }(ai[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", n, c, function(e) {
                var t = [];
                for (var n in e)(e[n] instanceof _r || e[n] instanceof mr || e[n] instanceof gr) && t.push((e[n] = new e[n].constructor(e[n])).buffer);
                return t
            }(c), r)
        },
        ci = function() {
            return [_r, mr, gr, vr, br, xr, Sr, Er, Ir, Nr, Cr, Pr, Ur, Br, jr, zr, Vr, Gr, Ui, _i, mi]
        },
        ui = function() {
            return [_r, mr, gr, vr, br, xr, Mr, Ar, Lr, Dr, Fr, Or, Cr, $r, Qr, Pr, Hr, Wr, Kr, Xr, qr, Yr, Zr, Jr, zr, Vr, ei, ii, Li, _i]
        },
        pi = function() {
            return [Mi, Ai, Si, ni, ti]
        },
        hi = function() {
            return [Ti, Ei]
        },
        di = function() {
            return [Ci, Si, ri]
        },
        fi = function() {
            return [Ri]
        },
        _i = function(e) {
            return postMessage(e, [e.buffer])
        },
        mi = function(e) {
            return e && e.size && new _r(e.size)
        },
        gi = function(e, t, n, r, i, s) {
            var o = li(n, r, i, (function(e, t) {
                o.terminate(), s(e, t)
            }));
            return o.postMessage([e, t], t.consume ? [e.buffer] : []),
                function() {
                    o.terminate()
                }
        },
        vi = function(e) {
            return e.ondata = function(e, t) {
                    return postMessage([e, t], [e.buffer])
                },
                function(t) {
                    return e.push(t.data[0], t.data[1])
                }
        },
        bi = function(e, t, n, r, i) {
            var s, o = li(e, r, i, (function(e, n) {
                e ? (o.terminate(), t.ondata.call(t, e)) : (n[1] && o.terminate(), t.ondata.call(t, e, n[0], n[1]))
            }));
            o.postMessage(n), t.push = function(e, n) {
                if (s) throw "stream finished";
                if (!t.ondata) throw "no stream handler";
                o.postMessage([e, s = n], [e.buffer])
            }, t.terminate = function() {
                o.terminate()
            }
        },
        xi = function(e, t) {
            return e[t] | e[t + 1] << 8
        },
        yi = function(e, t) {
            return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0
        },
        wi = function(e, t) {
            return yi(e, t) + 4294967296 * yi(e, t + 4)
        },
        Si = function(e, t, n) {
            for (; n; ++t) e[t] = n, n >>>= 8
        },
        Mi = function(e, t) {
            var n = t.filename;
            if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && Si(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), n) {
                e[3] = 8;
                for (var r = 0; r <= n.length; ++r) e[r + 10] = n.charCodeAt(r)
            }
        },
        Ti = function(e) {
            if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data";
            var t = e[3],
                n = 10;
            4 & t && (n += e[10] | 2 + (e[11] << 8));
            for (var r = (t >> 3 & 1) + (t >> 4 & 1); r > 0; r -= !e[n++]);
            return n + (2 & t)
        },
        Ei = function(e) {
            var t = e.length;
            return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0
        },
        Ai = function(e) {
            return 10 + (e.filename && e.filename.length + 1 || 0)
        },
        Ci = function(e, t) {
            var n = t.level,
                r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
            e[0] = 120, e[1] = r << 6 | (r ? 32 - 2 * r : 1)
        },
        Ri = function(e) {
            if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
            if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported"
        };

    function ki(e, t) {
        return t || "function" != typeof e || (t = e, e = {}), this.ondata = t, e
    }
    var Pi = function() {
            function e(e, t) {
                t || "function" != typeof e || (t = e, e = {}), this.ondata = t, this.o = e || {}
            }
            return e.prototype.p = function(e, t) {
                this.ondata(ii(e, this.o, 0, 0, !t), t)
            }, e.prototype.push = function(e, t) {
                if (this.d) throw "stream finished";
                if (!this.ondata) throw "no stream handler";
                this.d = t, this.p(e, t || !1)
            }, e
        }(),
        Di = function() {
            return function(e, t) {
                bi([ui, function() {
                    return [vi, Pi]
                }], this, ki.call(this, e, t), (function(e) {
                    var t = new Pi(e.data);
                    onmessage = vi(t)
                }), 6)
            }
        }();

    function Oi(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return gi(e, t, [ui], (function(e) {
            return _i(Li(e.data[0], e.data[1]))
        }), 0, n)
    }

    function Li(e, t) {
        return ii(e, t || {}, 0, 0)
    }
    var Ii = function() {
            function e(e) {
                this.s = {}, this.p = new _r(0), this.ondata = e
            }
            return e.prototype.e = function(e) {
                if (this.d) throw "stream finished";
                if (!this.ondata) throw "no stream handler";
                var t = this.p.length,
                    n = new _r(t + e.length);
                n.set(this.p), n.set(e, t), this.p = n
            }, e.prototype.c = function(e) {
                this.d = this.s.i = e || !1;
                var t = this.s.b,
                    n = Gr(this.p, this.o, this.s);
                this.ondata(Vr(n, t, this.s.b), this.d), this.o = Vr(n, this.s.b - 32768), this.s.b = this.o.length, this.p = Vr(this.p, this.s.p / 8 | 0), this.s.p &= 7
            }, e.prototype.push = function(e, t) {
                this.e(e), this.c(t)
            }, e
        }(),
        Fi = function() {
            return function(e) {
                this.ondata = e, bi([ci, function() {
                    return [vi, Ii]
                }], this, 0, (function() {
                    var e = new Ii;
                    onmessage = vi(e)
                }), 7)
            }
        }();

    function Ni(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return gi(e, t, [ci], (function(e) {
            return _i(Ui(e.data[0], mi(e.data[1])))
        }), 1, n)
    }

    function Ui(e, t) {
        return Gr(e, t)
    }
    var Bi = function() {
            function e(e, t) {
                this.c = ni(), this.l = 0, this.v = 1, Pi.call(this, e, t)
            }
            return e.prototype.push = function(e, t) {
                Pi.prototype.push.call(this, e, t)
            }, e.prototype.p = function(e, t) {
                this.c.p(e), this.l += e.length;
                var n = ii(e, this.o, this.v && Ai(this.o), t && 8, !t);
                this.v && (Mi(n, this.o), this.v = 0), t && (Si(n, n.length - 8, this.c.d()), Si(n, n.length - 4, this.l)), this.ondata(n, t)
            }, e
        }(),
        ji = function() {
            return function(e, t) {
                bi([ui, pi, function() {
                    return [vi, Pi, Bi]
                }], this, ki.call(this, e, t), (function(e) {
                    var t = new Bi(e.data);
                    onmessage = vi(t)
                }), 8)
            }
        }();

    function zi(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return gi(e, t, [ui, pi, function() {
            return [Vi]
        }], (function(e) {
            return _i(Vi(e.data[0], e.data[1]))
        }), 2, n)
    }

    function Vi(e, t) {
        t || (t = {});
        var n = ni(),
            r = e.length;
        n.p(e);
        var i = ii(e, t, Ai(t), 8),
            s = i.length;
        return Mi(i, t), Si(i, s - 8, n.d()), Si(i, s - 4, r), i
    }
    var Gi = function() {
            function e(e) {
                this.v = 1, Ii.call(this, e)
            }
            return e.prototype.push = function(e, t) {
                if (Ii.prototype.e.call(this, e), this.v) {
                    var n = this.p.length > 3 ? Ti(this.p) : 4;
                    if (n >= this.p.length && !t) return;
                    this.p = this.p.subarray(n), this.v = 0
                }
                if (t) {
                    if (this.p.length < 8) throw "invalid gzip stream";
                    this.p = this.p.subarray(0, -8)
                }
                Ii.prototype.c.call(this, t)
            }, e
        }(),
        Hi = function() {
            return function(e) {
                this.ondata = e, bi([ci, hi, function() {
                    return [vi, Ii, Gi]
                }], this, 0, (function() {
                    var e = new Gi;
                    onmessage = vi(e)
                }), 9)
            }
        }();

    function Wi(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return gi(e, t, [ci, hi, function() {
            return [Ki]
        }], (function(e) {
            return _i(Ki(e.data[0]))
        }), 3, n)
    }

    function Ki(e, t) {
        return Gr(e.subarray(Ti(e), -8), t || new _r(Ei(e)))
    }
    var Xi = function() {
            function e(e, t) {
                this.c = ri(), this.v = 1, Pi.call(this, e, t)
            }
            return e.prototype.push = function(e, t) {
                Pi.prototype.push.call(this, e, t)
            }, e.prototype.p = function(e, t) {
                this.c.p(e);
                var n = ii(e, this.o, this.v && 2, t && 4, !t);
                this.v && (Ci(n, this.o), this.v = 0), t && Si(n, n.length - 4, this.c.d()), this.ondata(n, t)
            }, e
        }(),
        qi = function() {
            return function(e, t) {
                bi([ui, di, function() {
                    return [vi, Pi, Xi]
                }], this, ki.call(this, e, t), (function(e) {
                    var t = new Xi(e.data);
                    onmessage = vi(t)
                }), 10)
            }
        }();

    function Yi(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return gi(e, t, [ui, di, function() {
            return [Zi]
        }], (function(e) {
            return _i(Zi(e.data[0], e.data[1]))
        }), 4, n)
    }

    function Zi(e, t) {
        t || (t = {});
        var n = ri();
        n.p(e);
        var r = ii(e, t, 2, 4);
        return Ci(r, t), Si(r, r.length - 4, n.d()), r
    }
    var Ji = function() {
            function e(e) {
                this.v = 1, Ii.call(this, e)
            }
            return e.prototype.push = function(e, t) {
                if (Ii.prototype.e.call(this, e), this.v) {
                    if (this.p.length < 2 && !t) return;
                    this.p = this.p.subarray(2), this.v = 0
                }
                if (t) {
                    if (this.p.length < 4) throw "invalid zlib stream";
                    this.p = this.p.subarray(0, -4)
                }
                Ii.prototype.c.call(this, t)
            }, e
        }(),
        $i = function() {
            return function(e) {
                this.ondata = e, bi([ci, fi, function() {
                    return [vi, Ii, Ji]
                }], this, 0, (function() {
                    var e = new Ji;
                    onmessage = vi(e)
                }), 11)
            }
        }();

    function Qi(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return gi(e, t, [ci, fi, function() {
            return [es]
        }], (function(e) {
            return _i(es(e.data[0], mi(e.data[1])))
        }), 5, n)
    }

    function es(e, t) {
        return Gr((Ri(e), e.subarray(2, -4)), t)
    }
    var ts = function() {
            function e(e) {
                this.G = Gi, this.I = Ii, this.Z = Ji, this.ondata = e
            }
            return e.prototype.push = function(e, t) {
                if (!this.ondata) throw "no stream handler";
                if (this.s) this.s.push(e, t);
                else {
                    if (this.p && this.p.length) {
                        var n = new _r(this.p.length + e.length);
                        n.set(this.p), n.set(e, this.p.length)
                    } else this.p = e;
                    if (this.p.length > 2) {
                        var r = this,
                            i = function() {
                                r.ondata.apply(r, arguments)
                            };
                        this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i), this.s.push(this.p, t), this.p = null
                    }
                }
            }, e
        }(),
        ns = function() {
            function e(e) {
                this.G = Hi, this.I = Fi, this.Z = $i, this.ondata = e
            }
            return e.prototype.push = function(e, t) {
                ts.prototype.push.call(this, e, t)
            }, e
        }();

    function rs(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Wi(e, t, n) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Ni(e, t, n) : Qi(e, t, n)
    }

    function is(e, t) {
        return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Ki(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? Ui(e, t) : es(e, t)
    }
    var ss = function(e, t, n, r) {
            for (var i in e) {
                var s = e[i],
                    o = t + i;
                s instanceof _r ? n[o] = [s, r] : Array.isArray(s) ? n[o] = [s[0], si(r, s[1])] : ss(s, o + "/", n, r)
            }
        },
        os = "undefined" != typeof TextEncoder && new TextEncoder,
        as = "undefined" != typeof TextDecoder && new TextDecoder,
        ls = 0;
    try {
        as.decode(Qr, {
            stream: !0
        }), ls = 1
    } catch (Eu) {}
    var cs = function(e) {
            for (var t = "", n = 0;;) {
                var r = e[n++],
                    i = (r > 127) + (r > 223) + (r > 239);
                if (n + i > e.length) return [t, Vr(e, n - 1)];
                i ? 3 == i ? (r = ((15 & r) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536, t += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & e[n++]) : String.fromCharCode((15 & r) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) : t += String.fromCharCode(r)
            }
        },
        us = function() {
            function e(e) {
                this.ondata = e, ls ? this.t = new TextDecoder : this.p = Qr
            }
            return e.prototype.push = function(e, t) {
                if (!this.ondata) throw "no callback";
                if (t = !!t, this.t) {
                    if (this.ondata(this.t.decode(e, {
                            stream: !0
                        }), t), t) {
                        if (this.t.decode().length) throw "invalid utf-8 data";
                        this.t = null
                    }
                } else {
                    if (!this.p) throw "stream finished";
                    var n = new _r(this.p.length + e.length);
                    n.set(this.p), n.set(e, this.p.length);
                    var r = cs(n),
                        i = r[0],
                        s = r[1];
                    if (t) {
                        if (s.length) throw "invalid utf-8 data";
                        this.p = null
                    } else this.p = s;
                    this.ondata(i, t)
                }
            }, e
        }(),
        ps = function() {
            function e(e) {
                this.ondata = e
            }
            return e.prototype.push = function(e, t) {
                if (!this.ondata) throw "no callback";
                if (this.d) throw "stream finished";
                this.ondata(hs(e), this.d = t || !1)
            }, e
        }();

    function hs(e, t) {
        if (t) {
            for (var n = new _r(e.length), r = 0; r < e.length; ++r) n[r] = e.charCodeAt(r);
            return n
        }
        if (os) return os.encode(e);
        var i = e.length,
            s = new _r(e.length + (e.length >> 1)),
            o = 0,
            a = function(e) {
                s[o++] = e
            };
        for (r = 0; r < i; ++r) {
            if (o + 5 > s.length) {
                var l = new _r(o + 8 + (i - r << 1));
                l.set(s), s = l
            }
            var c = e.charCodeAt(r);
            c < 128 || t ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++r)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c))
        }
        return Vr(s, 0, o)
    }

    function ds(e, t) {
        if (t) {
            for (var n = "", r = 0; r < e.length; r += 16384) n += String.fromCharCode.apply(null, e.subarray(r, r + 16384));
            return n
        }
        if (as) return as.decode(e);
        var i = cs(e),
            s = i[0];
        if (i[1].length) throw "invalid utf-8 data";
        return s
    }
    var fs = function(e) {
            return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0
        },
        _s = function(e, t) {
            return t + 30 + xi(e, t + 26) + xi(e, t + 28)
        },
        ms = function(e, t, n) {
            var r = xi(e, t + 28),
                i = ds(e.subarray(t + 46, t + 46 + r), !(2048 & xi(e, t + 8))),
                s = t + 46 + r,
                o = yi(e, t + 20),
                a = n && 4294967295 == o ? gs(e, s) : [o, yi(e, t + 24), yi(e, t + 42)],
                l = a[0],
                c = a[1],
                u = a[2];
            return [xi(e, t + 10), l, c, i, s + xi(e, t + 30) + xi(e, t + 32), u]
        },
        gs = function(e, t) {
            for (; 1 != xi(e, t); t += 4 + xi(e, t + 2));
            return [wi(e, t + 12), wi(e, t + 4), wi(e, t + 20)]
        },
        vs = function(e) {
            var t = 0;
            if (e)
                for (var n in e) {
                    var r = e[n].length;
                    if (r > 65535) throw "extra field too long";
                    t += r + 4
                }
            return t
        },
        bs = function(e, t, n, r, i, s, o, a) {
            var l = r.length,
                c = n.extra,
                u = a && a.length,
                p = vs(c);
            Si(e, t, null != o ? 33639248 : 67324752), t += 4, null != o && (e[t++] = 20, e[t++] = n.os), e[t] = 20, t += 2, e[t++] = n.flag << 1 | (null == s && 8), e[t++] = i && 8, e[t++] = 255 & n.compression, e[t++] = n.compression >> 8;
            var h = new Date(null == n.mtime ? Date.now() : n.mtime),
                d = h.getFullYear() - 1980;
            if (d < 0 || d > 119) throw "date not in range 1980-2099";
            if (Si(e, t, d << 25 | h.getMonth() + 1 << 21 | h.getDate() << 16 | h.getHours() << 11 | h.getMinutes() << 5 | h.getSeconds() >>> 1), t += 4, null != s && (Si(e, t, n.crc), Si(e, t + 4, s), Si(e, t + 8, n.size)), Si(e, t + 12, l), Si(e, t + 14, p), t += 16, null != o && (Si(e, t, u), Si(e, t + 6, n.attrs), Si(e, t + 10, o), t += 14), e.set(r, t), t += l, p)
                for (var f in c) {
                    var _ = c[f],
                        m = _.length;
                    Si(e, t, +f), Si(e, t + 2, m), e.set(_, t + 4), t += 4 + m
                }
            return u && (e.set(a, t), t += u), t
        },
        xs = function(e, t, n, r, i) {
            Si(e, t, 101010256), Si(e, t + 8, n), Si(e, t + 10, n), Si(e, t + 12, r), Si(e, t + 16, i)
        },
        ys = function() {
            function e(e) {
                this.filename = e, this.c = ni(), this.size = 0, this.compression = 0
            }
            return e.prototype.process = function(e, t) {
                this.ondata(null, e, t)
            }, e.prototype.push = function(e, t) {
                if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
                this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1)
            }, e
        }(),
        ws = function() {
            function e(e, t) {
                var n = this;
                t || (t = {}), ys.call(this, e), this.d = new Pi(t, (function(e, t) {
                    n.ondata(null, e, t)
                })), this.compression = 8, this.flag = fs(t.level)
            }
            return e.prototype.process = function(e, t) {
                try {
                    this.d.push(e, t)
                } catch (e) {
                    this.ondata(e, null, t)
                }
            }, e.prototype.push = function(e, t) {
                ys.prototype.push.call(this, e, t)
            }, e
        }(),
        Ss = function() {
            function e(e, t) {
                var n = this;
                t || (t = {}), ys.call(this, e), this.d = new Di(t, (function(e, t, r) {
                    n.ondata(e, t, r)
                })), this.compression = 8, this.flag = fs(t.level), this.terminate = this.d.terminate
            }
            return e.prototype.process = function(e, t) {
                this.d.push(e, t)
            }, e.prototype.push = function(e, t) {
                ys.prototype.push.call(this, e, t)
            }, e
        }(),
        Ms = function() {
            function e(e) {
                this.ondata = e, this.u = [], this.d = 1
            }
            return e.prototype.add = function(e) {
                var t = this;
                if (2 & this.d) throw "stream finished";
                var n = hs(e.filename),
                    r = n.length,
                    i = e.comment,
                    s = i && hs(i),
                    o = r != e.filename.length || s && i.length != s.length,
                    a = r + vs(e.extra) + 30;
                if (r > 65535) throw "filename too long";
                var l = new _r(a);
                bs(l, 0, e, n, o);
                var c = [l],
                    u = function() {
                        for (var e = 0, n = c; e < n.length; e++) {
                            var r = n[e];
                            t.ondata(null, r, !1)
                        }
                        c = []
                    },
                    p = this.d;
                this.d = 0;
                var h = this.u.length,
                    d = si(e, {
                        f: n,
                        u: o,
                        o: s,
                        t: function() {
                            e.terminate && e.terminate()
                        },
                        r: function() {
                            if (u(), p) {
                                var e = t.u[h + 1];
                                e ? e.r() : t.d = 1
                            }
                            p = 1
                        }
                    }),
                    f = 0;
                e.ondata = function(n, r, i) {
                    if (n) t.ondata(n, r, i), t.terminate();
                    else if (f += r.length, c.push(r), i) {
                        var s = new _r(16);
                        Si(s, 0, 134695760), Si(s, 4, e.crc), Si(s, 8, f), Si(s, 12, e.size), c.push(s), d.c = f, d.b = a + f + 16, d.crc = e.crc, d.size = e.size, p && d.r(), p = 1
                    } else p && u()
                }, this.u.push(d)
            }, e.prototype.end = function() {
                var e = this;
                if (2 & this.d) {
                    if (1 & this.d) throw "stream finishing";
                    throw "stream finished"
                }
                this.d ? this.e() : this.u.push({
                    r: function() {
                        1 & e.d && (e.u.splice(-1, 1), e.e())
                    },
                    t: function() {}
                }), this.d = 3
            }, e.prototype.e = function() {
                for (var e = 0, t = 0, n = 0, r = 0, i = this.u; r < i.length; r++) n += 46 + (l = i[r]).f.length + vs(l.extra) + (l.o ? l.o.length : 0);
                for (var s = new _r(n + 22), o = 0, a = this.u; o < a.length; o++) {
                    var l = a[o];
                    bs(s, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + vs(l.extra) + (l.o ? l.o.length : 0), t += l.b
                }
                xs(s, e, this.u.length, n, t), this.ondata(null, s, !0), this.d = 2
            }, e.prototype.terminate = function() {
                for (var e = 0, t = this.u; e < t.length; e++) t[e].t();
                this.d = 2
            }, e
        }();

    function Ts(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        var r = {};
        ss(e, "", r, t);
        var i = Object.keys(r),
            s = i.length,
            o = 0,
            a = 0,
            l = s,
            c = new Array(s),
            u = [],
            p = function() {
                for (var e = 0; e < u.length; ++e) u[e]()
            },
            h = function() {
                var e = new _r(a + 22),
                    t = o,
                    r = a - o;
                a = 0;
                for (var i = 0; i < l; ++i) {
                    var s = c[i];
                    try {
                        var u = s.c.length;
                        bs(e, a, s, s.f, s.u, u);
                        var p = 30 + s.f.length + vs(s.extra),
                            h = a + p;
                        e.set(s.c, h), bs(e, o, s, s.f, s.u, u, a, s.m), o += 16 + p + (s.m ? s.m.length : 0), a = h + u
                    } catch (e) {
                        return n(e, null)
                    }
                }
                xs(e, o, c.length, r, t), n(null, e)
            };
        s || h();
        for (var d = function(e) {
                var t = i[e],
                    l = r[t],
                    d = l[0],
                    f = l[1],
                    _ = ni(),
                    m = d.length;
                _.p(d);
                var g = hs(t),
                    v = g.length,
                    b = f.comment,
                    x = b && hs(b),
                    y = x && x.length,
                    w = vs(f.extra),
                    S = 0 == f.level ? 0 : 8,
                    M = function(r, i) {
                        if (r) p(), n(r, null);
                        else {
                            var l = i.length;
                            c[e] = si(f, {
                                size: m,
                                crc: _.d(),
                                c: i,
                                f: g,
                                m: x,
                                u: v != t.length || x && b.length != y,
                                compression: S
                            }), o += 30 + v + w + l, a += 76 + 2 * (v + w) + (y || 0) + l, --s || h()
                        }
                    };
                if (v > 65535 && M("filename too long", null), S)
                    if (m < 16e4) try {
                        M(null, Li(d, f))
                    } catch (e) {
                        M(e, null)
                    } else u.push(Oi(d, f, M));
                    else M(null, d)
            }, f = 0; f < l; ++f) d(f);
        return p
    }

    function Es(e, t) {
        t || (t = {});
        var n = {},
            r = [];
        ss(e, "", n, t);
        var i = 0,
            s = 0;
        for (var o in n) {
            var a = n[o],
                l = a[0],
                c = a[1],
                u = 0 == c.level ? 0 : 8,
                p = (S = hs(o)).length,
                h = c.comment,
                d = h && hs(h),
                f = d && d.length,
                _ = vs(c.extra);
            if (p > 65535) throw "filename too long";
            var m = u ? Li(l, c) : l,
                g = m.length,
                v = ni();
            v.p(l), r.push(si(c, {
                size: l.length,
                crc: v.d(),
                c: m,
                f: S,
                m: d,
                u: p != o.length || d && h.length != f,
                o: i,
                compression: u
            })), i += 30 + p + _ + g, s += 76 + 2 * (p + _) + (f || 0) + g
        }
        for (var b = new _r(s + 22), x = i, y = s - i, w = 0; w < r.length; ++w) {
            var S = r[w];
            bs(b, S.o, S, S.f, S.u, S.c.length);
            var M = 30 + S.f.length + vs(S.extra);
            b.set(S.c, S.o + M), bs(b, i, S, S.f, S.u, S.c.length, S.o, S.m), i += 16 + M + (S.m ? S.m.length : 0)
        }
        return xs(b, i, r.length, y, x), b
    }
    var As = function() {
            function e() {}
            return e.prototype.push = function(e, t) {
                this.ondata(null, e, t)
            }, e.compression = 0, e
        }(),
        Cs = function() {
            function e() {
                var e = this;
                this.i = new Ii((function(t, n) {
                    e.ondata(null, t, n)
                }))
            }
            return e.prototype.push = function(e, t) {
                try {
                    this.i.push(e, t)
                } catch (n) {
                    this.ondata(n, e, t)
                }
            }, e.compression = 8, e
        }(),
        Rs = function() {
            function e(e, t) {
                var n = this;
                t < 32e4 ? this.i = new Ii((function(e, t) {
                    n.ondata(null, e, t)
                })) : (this.i = new Fi((function(e, t, r) {
                    n.ondata(e, t, r)
                })), this.terminate = this.i.terminate)
            }
            return e.prototype.push = function(e, t) {
                this.i.terminate && (e = Vr(e, 0)), this.i.push(e, t)
            }, e.compression = 8, e
        }(),
        ks = function() {
            function e(e) {
                this.onfile = e, this.k = [], this.o = {
                    0: As
                }, this.p = Qr
            }
            return e.prototype.push = function(e, t) {
                var n = this;
                if (!this.onfile) throw "no callback";
                if (!this.p) throw "stream finished";
                if (this.c > 0) {
                    var r = Math.min(this.c, e.length),
                        i = e.subarray(0, r);
                    if (this.c -= r, this.d ? this.d.push(i, !this.c) : this.k[0].push(i), (e = e.subarray(r)).length) return this.push(e, t)
                } else {
                    var s = 0,
                        o = 0,
                        a = void 0,
                        l = void 0;
                    this.p.length ? e.length ? ((l = new _r(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;
                    for (var c = l.length, u = this.c, p = u && this.d, h = function() {
                            var e, t = yi(l, o);
                            if (67324752 == t) {
                                s = 1, a = o, d.d = null, d.c = 0;
                                var r = xi(l, o + 6),
                                    i = xi(l, o + 8),
                                    p = 2048 & r,
                                    h = 8 & r,
                                    f = xi(l, o + 26),
                                    _ = xi(l, o + 28);
                                if (c > o + 30 + f + _) {
                                    var m = [];
                                    d.k.unshift(m), s = 2;
                                    var g, v = yi(l, o + 18),
                                        b = yi(l, o + 22),
                                        x = ds(l.subarray(o + 30, o += 30 + f), !p);
                                    4294967295 == v ? (e = h ? [-2] : gs(l, o), v = e[0], b = e[1]) : h && (v = -1), o += _, d.c = v;
                                    var y = {
                                        name: x,
                                        compression: i,
                                        start: function() {
                                            if (!y.ondata) throw "no callback";
                                            if (v) {
                                                var e = n.o[i];
                                                if (!e) throw "unknown compression type " + i;
                                                (g = v < 0 ? new e(x) : new e(x, v, b)).ondata = function(e, t, n) {
                                                    y.ondata(e, t, n)
                                                };
                                                for (var t = 0, r = m; t < r.length; t++) {
                                                    var s = r[t];
                                                    g.push(s, !1)
                                                }
                                                n.k[0] == m && n.c ? n.d = g : g.push(Qr, !0)
                                            } else y.ondata(null, Qr, !0)
                                        },
                                        terminate: function() {
                                            g && g.terminate && g.terminate()
                                        }
                                    };
                                    v >= 0 && (y.size = v, y.originalSize = b), d.onfile(y)
                                }
                                return "break"
                            }
                            if (u) {
                                if (134695760 == t) return a = o += 12 + (-2 == u && 8), s = 3, d.c = 0, "break";
                                if (33639248 == t) return a = o -= 4, s = 3, d.c = 0, "break"
                            }
                        }, d = this; o < c - 4 && "break" !== h(); ++o);
                    if (this.p = Qr, u < 0) {
                        var f = s ? l.subarray(0, a - 12 - (-2 == u && 8) - (134695760 == yi(l, a - 16) && 4)) : l.subarray(0, o);
                        p ? p.push(f, !!s) : this.k[+(2 == s)].push(f)
                    }
                    if (2 & s) return this.push(l.subarray(o), t);
                    this.p = l.subarray(o)
                }
                if (t) {
                    if (this.c) throw "invalid zip file";
                    this.p = null
                }
            }, e.prototype.register = function(e) {
                this.o[e.compression] = e
            }, e
        }();

    function Ps(e, t) {
        if ("function" != typeof t) throw "no callback";
        for (var n = [], r = function() {
                for (var e = 0; e < n.length; ++e) n[e]()
            }, i = {}, s = e.length - 22; 101010256 != yi(e, s); --s)
            if (!s || e.length - s > 65558) return void t("invalid zip file", null);
        var o = xi(e, s + 8);
        o || t(null, {});
        var a = o,
            l = yi(e, s + 16),
            c = 4294967295 == l;
        if (c) {
            if (s = yi(e, s - 12), 101075792 != yi(e, s)) return void t("invalid zip file", null);
            a = o = yi(e, s + 32), l = yi(e, s + 48)
        }
        for (var u = function(s) {
                var a = ms(e, l, c),
                    u = a[0],
                    p = a[1],
                    h = a[2],
                    d = a[3],
                    f = a[4],
                    _ = a[5],
                    m = _s(e, _);
                l = f;
                var g = function(e, n) {
                    e ? (r(), t(e, null)) : (i[d] = n, --o || t(null, i))
                };
                if (u)
                    if (8 == u) {
                        var v = e.subarray(m, m + p);
                        if (p < 32e4) try {
                            g(null, Ui(v, new _r(h)))
                        } catch (e) {
                            g(e, null)
                        } else n.push(Ni(v, {
                            size: h
                        }, g))
                    } else g("unknown compression type " + u, null);
                else g(null, Vr(e, m, m + p))
            }, p = 0; p < a; ++p) u();
        return r
    }

    function Ds(e) {
        for (var t = {}, n = e.length - 22; 101010256 != yi(e, n); --n)
            if (!n || e.length - n > 65558) throw "invalid zip file";
        var r = xi(e, n + 8);
        if (!r) return {};
        var i = yi(e, n + 16),
            s = 4294967295 == i;
        if (s) {
            if (n = yi(e, n - 12), 101075792 != yi(e, n)) throw "invalid zip file";
            r = yi(e, n + 32), i = yi(e, n + 48)
        }
        for (var o = 0; o < r; ++o) {
            var a = ms(e, i, s),
                l = a[0],
                c = a[1],
                u = a[2],
                p = a[3],
                h = a[4],
                d = a[5],
                f = _s(e, d);
            if (i = h, l) {
                if (8 != l) throw "unknown compression type " + l;
                t[p] = Ui(e.subarray(f, f + c), new _r(u))
            } else t[p] = Vr(e, f, f + c)
        }
        return t
    }
    class Os extends i.hH6 {
        load(e, t, n, r) {
            return this.setResponseType("arraybuffer"), super.load(e, (e => {
                const n = Ds(new Uint8Array(e)),
                    r = new Map(Object.entries(n).map((([e, t]) => [e, new File([t], e)])));
                null == t || t(r)
            }), n, r)
        }
    }

    function Ls() {
        Us.Importers.push(new $t(Os, ["zip"], !0))
    }
    class Is extends i.Ox3 {
        constructor(e, t) {
            super(), this.assetType = "light", this.isDirectionalLight2 = !0, this.color = new i.Ilk(e), this.intensity = t || 1, this.userData.setDirty = () => {
                var e, t;
                this.dispatchEvent({
                    type: "objectUpdate"
                }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0)
            }, this.target.position.set(0, 0, -1), this.add(this.target)
        }
        get lightObject() {
            return this
        }
        get modelObject() {
            return this
        }
        copy(e, t) {
            const n = this.target,
                r = e.userData;
            return e.userData = {}, super.copy(e, t), pt(this.userData, r), n.position.copy(this.target.position), n.updateMatrixWorld(), this.target = n, this
        }
        get uiConfig() {
            return this._uiConfig ? this._uiConfig : this._uiConfig = {
                type: "folder",
                label: "Directional Light",
                children: [{
                    type: "checkbox",
                    label: "Enabled",
                    property: [this, "visible"]
                }, {
                    type: "color",
                    label: "Color",
                    property: [this, "color"]
                }, {
                    type: "slider",
                    label: "Intensity",
                    bounds: [0, 20],
                    property: [this, "intensity"]
                }, {
                    type: "vec3",
                    label: "Rotation",
                    property: [this, "rotation"]
                }, {
                    type: "vec3",
                    label: "Position",
                    property: [this, "position"]
                }, {
                    type: "checkbox",
                    label: "Shadow Enabled",
                    property: [this, "castShadow"]
                }, {
                    type: "vec2",
                    label: "Shadow Map Size",
                    property: [null == this ? void 0 : this.shadow, "mapSize"],
                    onChange: () => {
                        var e, t;
                        null === (e = this.shadow.map) || void 0 === e || e.dispose(), null === (t = this.shadow.mapPass) || void 0 === t || t.dispose(), this.shadow.map = null, this.shadow.mapPass = null
                    }
                }, {
                    type: "slider",
                    bounds: [-.001, .001],
                    stepSize: 2e-5,
                    label: "Shadow Bias",
                    property: [null == this ? void 0 : this.shadow, "bias"],
                    onChange: this.userData.setDirty
                }, {
                    type: "slider",
                    bounds: [-.1, .1],
                    stepSize: .005,
                    label: "Shadow Normal Bias",
                    property: [null == this ? void 0 : this.shadow, "normalBias"],
                    onChange: this.userData.setDirty
                }, {
                    type: "slider",
                    bounds: [0, 5],
                    label: "Shadow radius",
                    property: [null == this ? void 0 : this.shadow, "radius"],
                    onChange: this.userData.setDirty
                }, {
                    type: "slider",
                    bounds: [.1, 50],
                    label: "Shadow frustum",
                    getValue: () => 2 * this.shadow.camera.right,
                    setValue: e => {
                        this.shadow.camera.left = -e / 2, this.shadow.camera.right = e / 2, this.shadow.camera.top = e / 2, this.shadow.camera.bottom = -e / 2
                    },
                    onChange: this.userData.setDirty
                }]
            }
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.type = "DirectionalLight2", t.target = this.target.position.toArray(), Object.assign(t, Me(this, !0, e))
        }
        fromJSON(e, t) {
            if ("DirectionalLight2" !== e.type) return null;
            const n = e.target,
                r = e.object;
            return e.target && (this.target.position.fromArray(e.target), this.target.updateMatrixWorld(), delete e.target), e.object && delete e.object, Te(e, this, !0, t), n && (e.target = n), r && (void 0 !== r.color && this.color.set(r.color), void 0 !== r.intensity && (this.intensity = r.intensity), e.object = r), this
        }
    }
    class Fs extends i.PMe {
        constructor(e, t, n, r, i, s) {
            super(e, t, n, r, i, s), this.assetType = "light", this.userData.setDirty = () => {
                var e, t;
                this.dispatchEvent({
                    type: "objectUpdate"
                }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0)
            }, this.target.position.set(0, 0, -1), this.add(this.target)
        }
        get lightObject() {
            return this
        }
        get modelObject() {
            return this
        }
        copy(e, t) {
            const n = this.target,
                r = e.userData;
            return e.userData = {}, super.copy(e, t), pt(this.userData, r), n.position.copy(this.target.position), n.updateMatrixWorld(), this.target = n, this
        }
        get uiConfig() {
            return this._uiConfig ? this._uiConfig : this._uiConfig = {
                type: "folder",
                label: "Spot Light",
                children: [{
                    type: "checkbox",
                    label: "Enabled",
                    property: [this, "visible"]
                }, {
                    type: "color",
                    label: "Color",
                    property: [this, "color"]
                }, {
                    type: "slider",
                    label: "Intensity",
                    bounds: [0, 30],
                    property: [this, "intensity"]
                }, {
                    type: "slider",
                    bounds: [0, 2],
                    property: [this, "angle"]
                }, {
                    type: "slider",
                    bounds: [0, .9999],
                    property: [this, "penumbra"]
                }, {
                    type: "vec3",
                    label: "Rotation",
                    property: [this, "rotation"]
                }, {
                    type: "vec3",
                    label: "Position",
                    property: [this, "position"]
                }, {
                    type: "checkbox",
                    label: "Shadow Enabled",
                    property: [this, "castShadow"]
                }, {
                    type: "vec2",
                    label: "Shadow Map Size",
                    property: [null == this ? void 0 : this.shadow, "mapSize"],
                    onChange: () => {
                        var e, t;
                        null === (e = this.shadow.map) || void 0 === e || e.dispose(), null === (t = this.shadow.mapPass) || void 0 === t || t.dispose(), this.shadow.map = null, this.shadow.mapPass = null
                    }
                }, {
                    type: "slider",
                    bounds: [-.001, .001],
                    stepSize: 2e-5,
                    label: "Shadow Bias",
                    property: [null == this ? void 0 : this.shadow, "bias"],
                    onChange: this.userData.setDirty
                }, {
                    type: "slider",
                    bounds: [0, 5],
                    label: "Shadow radius",
                    property: [null == this ? void 0 : this.shadow, "radius"],
                    onChange: this.userData.setDirty
                }]
            }
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.type = "SpotLight2", t.target = this.target.position.toArray(), Object.assign(t, Me(this, !0, e))
        }
        fromJSON(e, t) {
            return "SpotLight2" !== e.type ? null : (e.target && (this.target.position.fromArray(e.target), this.target.updateMatrixWorld()), e.object ? (void 0 !== e.object.color && this.color.set(e.object.color), void 0 !== e.object.intensity && (this.intensity = e.object.intensity), void 0 !== e.object.distance && (this.distance = e.object.distance), void 0 !== e.object.angle && (this.angle = e.object.angle), void 0 !== e.object.decay && (this.decay = e.object.decay), void 0 !== e.object.penumbra && (this.penumbra = e.object.penumbra), Te(e, this, !0, t), this) : this)
        }
    }
    class Ns extends i.Mig {
        constructor(e, t) {
            super(e, t), this.assetType = "light", this.userData.setDirty = () => {
                var e, t;
                this.dispatchEvent({
                    type: "objectUpdate"
                }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0)
            }
        }
        get lightObject() {
            return this
        }
        get modelObject() {
            return this
        }
        copy(e, t) {
            const n = e.userData;
            return e.userData = {}, super.copy(e, t), pt(this.userData, n), this
        }
        get uiConfig() {
            return this._uiConfig ? this._uiConfig : this._uiConfig = {
                type: "folder",
                label: "Ambient Light",
                children: [{
                    type: "checkbox",
                    label: "Enabled",
                    property: [this, "visible"]
                }, {
                    type: "color",
                    label: "Color",
                    property: [this, "color"]
                }, {
                    type: "slider",
                    label: "Intensity",
                    bounds: [0, 20],
                    property: [this, "intensity"]
                }]
            }
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.type = "AmbientLight2", Object.assign(t, Me(this, !0, e))
        }
        fromJSON(e, t) {
            return "AmbientLight2" !== e.type ? null : e.object ? (void 0 !== e.object.color && this.color.set(e.object.color), void 0 !== e.object.intensity && (this.intensity = e.object.intensity), Te(e, this, !0, t), this) : this
        }
    }
    class Us extends r {
        constructor(e, t = !1) {
            super(), this._processors = new rt, this._logger = console.log, this._loaderCache = [], this._fileDatabase = new Map, this._cachedAssets = [], t || (this._logger = () => {}), this._viewer = e, this._onLoad = this._onLoad.bind(this), this._onProgress = this._onProgress.bind(this), this._onError = this._onError.bind(this), this._onStart = this._onStart.bind(this), this._urlModifier = this._urlModifier.bind(this), this._loadingManager = new i.lLk(this._onLoad, this._onProgress, this._onError), this._loadingManager.onStart = this._onStart, this._loadingManager.setURLModifier(this._urlModifier), Ls(), rn(e.renderer.rendererObject), $n(e), dr()
        }
        get processors() {
            return this._processors
        }
        get loadingManager() {
            return this._loadingManager
        }
        _onLoad() {
            this.dispatchEvent({
                type: "onLoad"
            })
        }
        _onProgress(e, t, n) {
            this.dispatchEvent({
                type: "onProgress",
                url: e,
                loaded: t,
                total: n
            })
        }
        _onError(e) {
            this.dispatchEvent({
                type: "onError",
                url: e
            })
        }
        _onStart(e, t, n) {
            this.dispatchEvent({
                type: "onStart",
                url: e,
                loaded: t,
                total: n
            })
        }
        _urlModifier(e) {
            var t;
            let n = decodeURI(e);
            const r = null === (t = this._rootContext) || void 0 === t ? void 0 : t.rootUrl;
            n.includes("://") || !r || n.startsWith(r) || (n = r + n), n = n.replace("./", ""), n = n.replace(/^(\/\/)/, "/"), n = n.replace(/\?.*$/, "");
            const i = this._fileDatabase.get(n);
            return i ? i.ext ? (i.objectUrl || (i.objectUrl = URL.createObjectURL(i) + "#" + n), i.objectUrl) : (console.error("Unable to determine file extension", i), e) : e
        }
        _createLoader(e) {
            const t = this._getImporter(e),
                n = null == t ? void 0 : t.ctor(this);
            return n && (null == t || t.ext.forEach((e => {
                const t = new RegExp(e.startsWith("data:") ? "^" + e + "\\/" : "\\." + e + "$", "i");
                this._loadingManager.addHandler(t, n)
            }))), n && (this._loaderCache.push({
                loader: n,
                files: []
            }), this.dispatchEvent({
                type: "loaderCreate",
                loader: n
            })), n
        }
        async importFiles(e, t, n = {}) {
            const r = new Map;
            let {
                allowedExtensions: i
            } = n;
            if (i && i.length < 1 && (i = void 0), 0 === e.size) return r;
            this.dispatchEvent({
                type: "importFiles",
                files: Object.keys(e),
                state: "start"
            });
            const s = [],
                o = [];
            if (e.forEach(((e, t) => {
                    var n;
                    this.registerFile(t, e);
                    const r = e.ext;
                    r && (null === (n = null == i ? void 0 : i.includes(r.toLowerCase())) || void 0 === n || n) && (this._isRootFileExtension(r) ? s.push(t) : o.push(t))
                })), s.length > 0)
                for (const e of s) {
                    const t = await this._importFile(e, void 0, n);
                    r.set(e, t)
                } else
                    for (const e of o) {
                        const t = await this._importFile(e, void 0, n);
                        r.set(e, t)
                    }
            return this.dispatchEvent({
                type: "importFiles",
                files: Object.keys(e),
                state: "end"
            }), e.forEach(((e, t) => {
                this.unregisterFile(t)
            })), r
        }
        registerFile(e, t) {
            var n, r, i;
            e = e.replace(/\?.*$/, "");
            const s = null !== (n = null == t ? void 0 : t.ext) && void 0 !== n ? n : null === (i = Qt(null !== (r = null == t ? void 0 : t.name) && void 0 !== r ? r : e)) || void 0 === i ? void 0 : i.toLowerCase();
            t && (t.ext || (t.ext = s), this._fileDatabase.set(e, t));
            let o = this._getLoader(e);
            if (o || (o = this._createLoader(null != t ? t : {
                    name: e,
                    ext: s
                })), o)
                for (const t of this._loaderCache)
                    if (t.loader === o) {
                        t.files.push(e);
                        break
                    }
            return o
        }
        unregisterFile(e) {
            e = e.replace(/\?.*$/, "");
            const t = this._fileDatabase.get(e);
            (null == t ? void 0 : t.objectUrl) && (URL.revokeObjectURL(t.objectUrl), t.objectUrl = void 0), t && this._fileDatabase.delete(e)
        }
        _isRootFileExtension(e) {
            return null != Us.Importers.find((t => t.root && t.ext.includes(e.toLowerCase())))
        }
        resolveURL(e) {
            return this._loadingManager.resolveURL(e)
        }
        async _importFile(e, t, n = {}) {
            var r, s;
            if (null === (r = t) || void 0 === r ? void 0 : r.__imported) return t.__imported;
            let o;
            this.dispatchEvent({
                type: "importFile",
                path: e,
                state: "downloading"
            });
            try {
                this.registerFile(e, t), n.rootPath = e;
                const r = this.resolveURL(e),
                    a = e.replace(/\?.*$/, ""),
                    l = null !== (s = n.fileHandler) && void 0 !== s ? s : await this._loadingManager.getHandler(a) || (t ? await this._loadingManager.getHandler(t.name || t.ext || "") : void 0);
                if (!l) throw new Error("AssetImporter: Unable to find loader for " + e);
                this._rootContext = {
                    path: e,
                    url: r,
                    rootUrl: i.Zp0.extractUrlBase(e),
                    baseUrl: i.Zp0.extractUrlBase(r)
                }, o = await l.loadAsync(e + (n.queryString ? (e.includes("?") ? "&" : "?") + n.queryString : "")), this._rootContext = void 0, this.dispatchEvent({
                    type: "importFile",
                    path: e,
                    state: "adding"
                }), o && (o = !1 !== n.processImported ? await this.processImported(o, n) : [o]), t ? this._logger("AssetImporter: loaded", e) : this._logger("AssetImporter: downloaded", e), t && this.unregisterFile(e)
            } catch (n) {
                return console.error("AssetImporter: Unable to import file", e, t), console.error(n), this.dispatchEvent({
                    type: "importFile",
                    path: e,
                    state: "error",
                    error: n
                }), []
            }
            return this.dispatchEvent({
                type: "importFile",
                path: e,
                state: "done"
            }), t && (t.__imported = o), o
        }
        _getImporter(e, t = !1) {
            return Us.Importers.find((n => {
                if (t && !n.root) return !1;
                const r = n.ext.find((t => {
                    var n, r, i;
                    return e.ext && t === e.ext.toLowerCase() || (null === (r = null === (n = e.name) || void 0 === n ? void 0 : n.toLowerCase()) || void 0 === r ? void 0 : r.endsWith("." + t.toLowerCase())) || (null == t ? void 0 : t.startsWith("data:")) && (null === (i = e.name) || void 0 === i ? void 0 : i.startsWith(t))
                }));
                return !!r && (e.ext = r, !0)
            }))
        }
        _getLoader(e) {
            var t;
            return null !== (t = this._loadingManager.getHandler(e)) && void 0 !== t ? t : void 0
        }
        async importAsset(e, t = {}) {
            var n;
            if (!e) return [];
            if (!this._cachedAssets.includes(e)) {
                if (1 === Object.entries(e).length && e.path) {
                    const t = this._cachedAssets.find((t => t.path === e.path));
                    t && Object.assign(e, t)
                }
                const t = this._cachedAssets.findIndex((t => t.path === e.path));
                t >= 0 && this._cachedAssets.splice(t, 1), this._cachedAssets.push(e)
            }
            return (null == e ? void 0 : e.preImported) || (e.preImported = this._importFile(t.pathOverride || e.path, "function" == typeof(null === (n = e.file) || void 0 === n ? void 0 : n.arrayBuffer) ? e.file : void 0, t)), await e.preImported
        }
        async importSingle(e, t = {}) {
            var n;
            return null === (n = await this.importAsset(e, t)) || void 0 === n ? void 0 : n[0]
        }
        async importSinglePath(e, t) {
            var n;
            return null === (n = await this.importPath(e, t)) || void 0 === n ? void 0 : n[0]
        }
        async importPath(e, t = {}) {
            const n = t.pathOverride;
            void 0 !== n && delete t.pathOverride;
            const r = JSON.stringify(t);
            void 0 !== n && (t.pathOverride = n);
            let i;
            return i = this._cachedAssets.find((t => t.path === e && t._options === r)) || {
                path: e
            }, i._options = r, await this.importAsset(i, t)
        }
        async processImportedSingle(e, t = {}) {
            return (await this.processImported(e, t))[0]
        }
        async processImported(e, t = {}) {
            var n, r, s;
            if (Array.isArray(e)) {
                const n = [];
                for (const r of e) n.push(...await this.processImported(r, t));
                return n
            }
            if (null === (n = null == e ? void 0 : e.userData) || void 0 === n ? void 0 : n.rootSceneModelRoot) return t.rootSceneImported = !0, e.animations && e.children[0] && (e.children[0].animations || (e.children[0].animations = []), e.children[0].animations.push(...e.animations)), this.processImported([...e.children], t);
            if ((null === (r = null == e ? void 0 : e.userData) || void 0 === r ? void 0 : r.iModel) && (e = e.userData.iModel), e.assetImporterProcessed && !t.forceImporterReprocess) return [e];
            if (!e.assetType) {
                if (e.isBufferGeometry && (e = new i.Kj0(e, new i.Wid)), e.isObject3D) {
                    e = e.isLight ? js(e) : new it(e, t);
                    const n = [];
                    e.modelObject.traverse((t => {
                        t !== e.modelObject && n.push([t, js(t)])
                    }));
                    for (const e of n) {
                        const t = e[0].parent;
                        t && (t.remove(e[0]), t.add(e[1]))
                    }!t.rootPath || e.modelObject.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (e.modelObject.userData.rootPath = t.rootPath)
                }
                e.isTexture && (e.assetType = "texture", void 0 !== t.generageMipmaps && (e.generateMipmaps = t.generageMipmaps), e.generateMipmaps || e.isRenderTargetTexture || (e.minFilter = e.minFilter === i.D1R ? i.wem : e.minFilter, e.magFilter = e.magFilter === i.D1R ? i.wem : e.magFilter), !t.rootPath || e.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (e.userData.rootPath = t.rootPath)), e.isMaterial && (e.assetType = "material", !t.rootPath || e.userData.rootPath || t.rootPath.startsWith("blob:") || t.rootPath.startsWith("/") || (e.userData.rootPath = t.rootPath))
            }
            if (null != e.assetType) return (e = await this._processors.process(e.assetType, e, {})).assetImporterProcessed = !0, [e];
            if (e instanceof Map) return [...(await this.importFiles(e, void 0, t)).values()].flat();
            if (e.type) {
                const t = this._viewer.getPluginByType(e.type);
                if (t) {
                    let n = e._importedResources || {};
                    return e.resources && (n = await (null === (s = this._viewer.getManager()) || void 0 === s ? void 0 : s.importConfigResources(e.resources)), delete e.resources, e._importedResources = n), "function" == typeof t.fromJSON && (await Promise.resolve(t.fromJSON(e, n)), e.assetImporterProcessed = !1), []
                }
            } else if (e.plugins) return await this._viewer.getManager().importViewerConfig(e), e.assetImporterProcessed = !1, [];
            return console.warn("unknown asset type: ", e), [e]
        }
        dispose() {
            var e;
            null === (e = this._processors) || void 0 === e || e.dispose()
        }
    }

    function Bs(e) {
        if (!e) return i.ywz;
        const t = e.extensions.has("EXT_color_buffer_half_float") || e.capabilities.isWebGL2 && e.extensions.has("EXT_color_buffer_float"),
            n = e.capabilities.isWebGL2 || e.extensions.has("OES_texture_float") || e.extensions.has("WEBGL_color_buffer_float");
        return t ? i.cLu : n ? i.VzW : i.ywz
    }

    function js(e) {
        var t, n, r;
        if (!e.isLight) return e;
        if ("light" === e.assetType) return e;
        if (e.uiConfig) return console.warn("ui config already exists, not supported", e), e;
        let i;
        if (e.children.length, e.isDirectionalLight && (i = new Is), e.isAmbientLight && (i = new Ns), e.isSpotLight && (i = new Fs), i) {
            null === (n = (t = i.lightObject).copy) || void 0 === n || n.call(t, e);
            const s = e.parent;
            "model" === (null === (r = s) || void 0 === r ? void 0 : r.assetType) && (s.remove(e), e.dispose(), s.add(i.lightObject)), lt(i.lightObject, s)
        }
        return i
    }
    Us.Importers = [new $t(tn, ["json"], !1), new $t(i.hH6, ["txt"], !1), new $t(Yn, ["rgbe.png", "hdr.png", "hdrpng"], !1), new $t(i.dpR, ["webp", "png", "jpeg", "jpg", "svg", "data:image"], !1)];
    class zs extends i.u7G {
        constructor(e) {
            super(e)
        }
        async loadAsync(e, t) {
            var n;
            const r = new i.hH6(this.manager);
            r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
            const s = await r.loadAsync(e, t);
            try {
                const e = JSON.parse(s);
                if (e.images && this.importer) {
                    const t = {};
                    for (const r of e.images) {
                        if (!r.url || !r.uuid) continue;
                        const e = null === (n = await this.importer.importPath(r.url, {
                                processImported: !1
                            })) || void 0 === n ? void 0 : n[0],
                            s = null == e ? void 0 : e.source;
                        if (!e || !s) continue;
                        const o = new i.Hw6(s.data);
                        o.uuid = r.uuid, t[o.uuid] = o, e.dispose()
                    }
                    return this.parse(e, t)
                }
                return this.parse(e)
            } catch (t) {
                throw console.error(t), this.manager.itemError(e), t
            }
        }
        parse(e, t) {
            var n, r;
            let s;
            const o = {
                p: new Promise((e => {
                    s = e
                }))
            };
            if (e.images || e.textures) {
                const n = new Zn(this.manager);
                let r = {};
                const i = e => {
                        s(), o.p = void 0, Object.values(r).forEach((e => {
                            var t;
                            e.isTexture && (null === (t = e.image) || void 0 === t ? void 0 : t.complete) && (e.needsUpdate = !0)
                        }))
                    },
                    a = t || n.parseImages(e.images, i);
                r = n.parseTextures2(e.textures, a, i), this.setTextures(r)
            }
            this.materials || console.warn("A Material Manager is not set to import three materials, trying standard materials");
            const a = { ...e
            };
            if (Object.entries(a).forEach((([e, t]) => {
                    t && "string" == typeof t && this.textures[t] && (a[e] = this.textures[t])
                })), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? a.vertexColors = e.vertexColors > 0 : a.vertexColors = e.vertexColors), void 0 !== e.normalScale) {
                let t = e.normalScale;
                !1 === Array.isArray(t) && (t = [t, t]), a.normalScale = (new i.FM8).fromArray(t)
            }
            let l = e.type;
            "MeshPhysicalMaterial" !== l && "MeshStandardMaterial" !== l || (l = Kt.TYPE);
            const c = null !== (r = null === (n = this.materials) || void 0 === n ? void 0 : n.generateFromTemplateType(l, a)) && void 0 !== r ? r : super.parse(e);
            return this.setTextures({}), c.userData.imageLoadAwaiter = o, c
        }
    }
    class Vs extends r {
        constructor(e, t, {
            simpleCache: n = !1,
            storage: r
        } = {}) {
            if (super(), this._sceneUpdated = this._sceneUpdated.bind(this), this.addAsset = this.addAsset.bind(this), this.addProcessedAssets = this.addProcessedAssets.bind(this), this.addImported = this.addImported.bind(this), (n || r) && (i.CtF.enabled = !0, r instanceof Cache)) {
                const e = { ...i.CtF
                };
                i.CtF.get = (t, n, i) => n ? t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") ? Promise.resolve(void 0) : r.match(t).then((e => {
                    if (e) switch (n) {
                        case "arraybuffer":
                            return e.arrayBuffer();
                        case "blob":
                            return e.blob();
                        case "document":
                            return e.text().then((e => (new DOMParser).parseFromString(e, null != i ? i : "text/html")));
                        case "json":
                            return e.json();
                        default:
                            if (void 0 === i) return e.text(); {
                                const t = /charset="?([^;"\s]*)"?/i.exec(i),
                                    n = t && t[1] ? t[1].toLowerCase() : void 0,
                                    r = new TextDecoder(n);
                                return e.arrayBuffer().then((e => r.decode(e)))
                            }
                    }
                })) : e.get(t), i.CtF.add = (t, n, i) => {
                    i || e.add(t, n), t.startsWith("data:") || t.startsWith("blob") || t.startsWith("chrome-extension") || r.put(t, new Response(n, {
                        status: 200
                    }))
                }, i.CtF.remove = (t, n) => {
                    n || e.remove(t), r.delete(t)
                }
            }
            this._importer = e, this._materials = t
        }
        async addAsset(e, t = {}) {
            if (!this._importer || !this._viewer) return [];
            const n = await this._importer.importAsset(e, t);
            return n ? (this.addProcessedAssets(n, t), n) : (console.warn("Unable to import", e, n), [])
        }
        async addFromPath(e, t = {}) {
            if (!this._importer || !this._viewer) return [];
            const n = await this._importer.importPath(e, t);
            return n ? (this.addProcessedAssets(n, t), n) : (console.warn("Unable to import", e, n), [])
        }
        addProcessedAssets(e, t) {
            return e.map((e => {
                var n;
                return null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.addSceneObject(e, t)
            }))
        }
        async addAssetSingle(e, t = {}) {
            var n;
            return e ? null === (n = await ("string" == typeof e ? this.addFromPath : this.addAsset)(e, t)) || void 0 === n ? void 0 : n[0] : void 0
        }
        async addImported(e, t = {}) {
            var n;
            return null === (n = this._importer) || void 0 === n ? void 0 : n.processImported(e, t).then((e => (this.addProcessedAssets(e, t), e)))
        }
        async addImportedSingle(e, t = {}) {
            return this.addImported(e, t).then((e => null == e ? void 0 : e[0]))
        }
        _sceneUpdated(e) {
            var t;
            if ("addSceneObject" === e.type) {
                const n = e.object;
                switch (n.assetType) {
                    case "material":
                        null === (t = this._materials) || void 0 === t || t.processMaterial(n, {})
                }
            } else console.error("Unexpected")
        }
        async onAdded(e) {
            this._viewer = e, this._materials || (this._materials = new Jt, this._viewer.scene.addEventListener("addSceneObject", this._sceneUpdated)), this._importer || (this._importer = new Us(e, !!e.getPluginByType("debug")), this._importer.processors.add("model", {
                forAssetType: "model",
                process: (e, t) => (at(e, (e => {
                    var t;
                    return null === (t = this._materials) || void 0 === t ? void 0 : t.processModel(e, {
                        recursive: !1
                    })
                })), e)
            }), this._importer.processors.add("model", {
                forAssetType: "model",
                process: this._materials.processModel
            }), this._importer.processors.add("material", {
                forAssetType: "material",
                process: (e, t) => {
                    var n;
                    return (null === (n = this.materials) || void 0 === n ? void 0 : n.findMaterial(e.uuid)) && (console.warn("imported material uuid already exists, creating new uuid"), e.uuid = $(), e.userData.uuid && (e.userData.uuid = e.uuid)), this._materials.processMaterial(e, t)
                }
            })), Us.Importers.push(new $t(zs, [Kt.TypeSlug], !1, (e => (e && (e.materials = this._materials), e && (e.importer = this._importer), e))));
            const t = this.importViewerConfig.bind(this);
            Us.Importers.push(new $t(class extends tn {
                async loadAsync(e, n) {
                    return t(await super.loadAsync(e, n))
                }
            }, [Vs.ViewerTypeSlug], !0))
        }
        async onDispose(e) {}
        async onRemove(e) {
            var t, n;
            e === this._viewer && (null === (t = this._importer) || void 0 === t || t.dispose(), this._importer = void 0, this._viewer.scene.removeEventListener("addSceneObject", this._sceneUpdated), null === (n = this._materials) || void 0 === n || n.dispose(), this._materials = void 0)
        }
        get importer() {
            return this._importer
        }
        get exporter() {
            var e, t;
            return null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("AssetExporterPlugin")) || void 0 === t ? void 0 : t.exporter
        }
        get materials() {
            return this._materials
        }
        exportViewerConfig() {
            if (!this._viewer) return {};
            const e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                },
                t = this._viewer.toJSON(e);
            return t.resources = e, t
        }
        exportPluginPresets(e) {
            var t;
            const n = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {}
            };
            return {
                plugins: null === (t = this._viewer) || void 0 === t ? void 0 : t.serializePlugins(n, e),
                resources: n
            }
        }
        exportPluginPreset(e) {
            if (!e.toJSON) return;
            const t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {}
                },
                n = e.toJSON(t);
            return n.resources = t, n
        }
        async importPluginPreset(e, t) {
            var n;
            const r = e.type;
            if (!(t = t || (null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType(r)))) return void console.warn(`No plugin found for type ${r} to import preset`);
            if (!t.fromJSON) return void console.warn(`Plugin ${r} does not support importing presets`);
            const i = e.resources || {};
            return e.resources && delete e.resources, await t.fromJSON(e, i), i && (e.resources = i), t
        }
        async importViewerConfig(e, t) {
            var n;
            if (!this._viewer || !this._importer) return void console.warn("No viewer or importer");
            const r = await this.importConfigResources(e.resources || {}, t);
            this._viewer.fromJSON(e, r);
            for (const e of Object.values(r.materials)) e.__useCount ? delete e.__useCount : null === (n = this._materials) || void 0 === n || n.unregisterMaterial(e);
            for (const e of Object.values(r.textures)) e.__useCount && delete e.__useCount
        }
        async importConfigResources(e, t) {
            var n, r, s;
            if (!this._importer) throw "Importer not initialized yet.";
            const o = {};
            t = null != t ? t : new Zn(this._importer.loadingManager), o.animations = t.parseAnimations(e.animations), o.shapes = t.parseShapes(e.shapes), o.geometries = t.parseGeometries(e.geometries, o.shapes), o.images = await t.parseImagesAsync(Object.values(e.images));
            for (const t of Object.values(e.textures)) {
                const e = null === (n = null == t ? void 0 : t.userData) || void 0 === n ? void 0 : n.rootPath;
                if (e && (!t.image || !o.images[t.image])) {
                    const n = null === (r = await this._importer.importPath(e, {
                            processImported: !1
                        })) || void 0 === r ? void 0 : r[0],
                        s = null == n ? void 0 : n.source;
                    if (!n || !s) continue;
                    const a = new i.Hw6(s.data);
                    t.image && (a.uuid = t.image), o.images[a.uuid] = a, t.image = a.uuid, n.dispose()
                }
            }
            o.textures = t.parseTextures2(Object.values(e.textures), o.images, (() => {
                Object.values(o.textures).forEach((e => {
                    var t;
                    e.isTexture && (null === (t = e.image) || void 0 === t ? void 0 : t.complete) && (e.needsUpdate = !0)
                }))
            }));
            for (const e of Object.entries(o.textures)) e[1] = null === (s = await this._importer.processImported(e[1], {})) || void 0 === s ? void 0 : s[0], e[1] ? o.textures[e[0]] = e[1] : delete o.textures[e[0]];
            const a = Object.values(e.materials);
            for (const e of a) Object.entries(e).forEach((([t, n]) => {
                n && n.resource && n.uuid && "textures" === n.resource && (e[t] = n.uuid)
            }));
            return o.materials = t.parseMaterials2(a, o.textures, this._materials), e.object && (o.object = t.parseObject(e.object, o.geometries, o.materials, o.textures, o.animations), e.skeletons && (o.skeletons = t.parseSkeletons(e.skeletons, o.object), t.bindSkeletons(o.object, o.skeletons))), o
        }
    }
    Vs.PluginType = "AssetManager", Vs.ViewerTypeSlug = "vjson";
    class Gs extends r {
        constructor() {
            super(...arguments), this._dirty = !1
        }
        get dirty() {
            return this._dirty
        }
        set dirty(e) {
            this._dirty = e
        }
        async onAdded(e) {
            this._viewer = e
        }
        async onDispose(e) {}
        async onRemove(e) {
            this._viewer !== e && console.error("Wrong viewer"), this._viewer = void 0
        }
        toJSON(e) {
            const t = Me(this, !0, e);
            return t.type = this.constructor.PluginType, this.dispatchEvent({
                type: "serialize",
                data: t
            }), t
        }
        fromJSON(e, t) {
            return e.type !== this.constructor.PluginType ? null : (Te(e, this, !0, t), this.dispatchEvent({
                type: "deserialize",
                data: e
            }), this)
        }
    }

    function Hs(e, t, n) {
        return { ...t,
            get dirty() {
                return t.dirty || !1
            },
            set dirty(e) {
                g(t, "dirty", e, !0)
            },
            update() {
                var e, r, i;
                this.passObject.enabled && (null === (r = (e = this.passObject).updateShaderProperties) || void 0 === r || r.call(e, x(n)), null === (i = t.update) || void 0 === i || i.call(this))
            },
            onRegister(n) {
                var r, i, s;
                this.passObject.materialExtension && (null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.materials) || void 0 === i || i.registerMaterialExtension(this.passObject.materialExtension)), null === (s = t.onRegister) || void 0 === s || s.call(this, n)
            },
            onUnregister(n) {
                var r, i, s;
                this.passObject.materialExtension && (null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.materials) || void 0 === i || i.unregisterMaterialExtension(this.passObject.materialExtension)), null === (s = t.onUnregister) || void 0 === s || s.call(this, n)
            },
            dispose() {
                var e, n, r;
                null === (n = (e = this.passObject).dispose) || void 0 === n || n.call(e), null === (r = t.dispose) || void 0 === r || r.call(this)
            }
        }
    }
    class Ws extends Gs {
        constructor() {
            super(), this._enabledTemp = !0
        }
        _update(e) {
            var t;
            return (null === (t = this._pass) || void 0 === t ? void 0 : t.enabled) && this.enabled || !1
        }
        get enabled() {
            var e, t;
            return (null === (t = null === (e = this._pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || this._enabledTemp
        }
        set enabled(e) {
            var t;
            (null === (t = this._pass) || void 0 === t ? void 0 : t.passObject) && (this._pass.passObject.enabled = e), this._enabledTemp = e
        }
        async onAdded(e) {
            await super.onAdded(e);
            const t = {
                enabled: !0,
                passId: this.passId,
                passObject: this.passCtor(e),
                after: this._afterFilters,
                before: this._beforeFilters,
                required: this._requiredFilters,
                set dirty(t) {
                    t && e.setDirty()
                },
                get dirty() {
                    return !1
                },
                dispose() {
                    var e, t;
                    null === (t = null === (e = this.passObject) || void 0 === e ? void 0 : e.dispose) || void 0 === t || t.call(e)
                },
                update: () => this._update(e)
            };
            this._pass = t, void 0 !== t.passObject.onDirty && t.passObject.onDirty.push((() => t.dirty = !0)), e.renderer.registerPass(this._pass), this.enabled = this._enabledTemp
        }
        async onRemove(e) {
            var t, n;
            this._pass && e.renderer.unregisterPass(this._pass), null === (n = null === (t = this._pass) || void 0 === t ? void 0 : t.dispose) || void 0 === n || n.call(t), this._pass = void 0, await super.onRemove(e)
        }
        get pass() {
            return this._pass
        }
        toJSON(e) {
            var t, n;
            const r = super.toJSON(e);
            if (!r.type) return r;
            const i = this.pass;
            return i && (r.pass = Me(null !== (n = null === (t = i) || void 0 === t ? void 0 : t.passObject) && void 0 !== n ? n : i, !1, e)), r
        }
        fromJSON(e, t) {
            var n, r;
            if (!super.fromJSON(e, t)) return null;
            if (e.pass) {
                const i = this.pass;
                i && Te(e.pass, null !== (r = null === (n = i) || void 0 === n ? void 0 : n.passObject) && void 0 !== r ? r : i, !1, t)
            }
            return this
        }
    }! function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        s > 3 && o && Object.defineProperty(t, n, o)
    }([xe()], Ws.prototype, "enabled", null);
    const Ks = new Set,
        Xs = new Set;
    class qs extends Nt {
        constructor(e, t, n, r) {
            super(void 0, void 0, t, null != n ? n : new ve(1, 1, 1), null != r ? r : 1), this.target = e
        }
        render(e, t, n, r, i) {
            const s = e.getRenderTarget(),
                o = e.getActiveCubeFace(),
                a = e.getActiveMipmapLevel();
            this.scene.traverse((({
                material: e
            }) => {
                e && ((e.transparent && e.userData.renderToDepth || !e.transparent && 0 === e.transmission && !1 === e.userData.renderToDepth) && (Ks.add(e), e.transparent = !e.transparent), Math.abs(e.transmission || 0) > 0 && e.userData.renderToDepth && (Xs.add([e, e.transmission]), e.transmission = 0))
            })), K(e, {
                shadowMapRender: !1,
                backgroundRender: !1,
                opaqueRender: !0,
                transparentRender: !1,
                transmissionRender: !1,
                mainRenderPass: !1
            }, (() => super.render(e, t, this.target, r, i))), Ks.forEach((e => e.transparent = !e.transparent)), Ks.clear(), Xs.forEach((([e, t]) => e.transmission = t)), Xs.clear(), e.setRenderTarget(s, o, a)
        }
    }
    class Ys extends Ws {
        constructor(e = !0) {
            super(), this.renderFlagsBuffer = e, this.passId = "gbuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._gbufferTextures = []
        }
        passCtor(e) {
            var t, n;
            const r = (null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer.isWebGL2) && this.renderFlagsBuffer,
                s = e.renderer.createTarget({
                    depthBuffer: !0,
                    type: i.ywz,
                    textureCount: r ? 2 : 1
                });
            Array.isArray(s.texture) ? (s.texture[0].name = "gbufferDepthNormal", s.texture[1].name = "gbufferFlags", this._gbufferTextures = s.texture) : (s.texture.name = "gbufferDepthNormal", this._gbufferTextures.push(s.texture)), this._gbufferTarget = s;
            const o = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("debug");
            return o && (o.addTexture("gbuffer depth normal", (() => this.getDepthNormal()), [40, 510, 200, 100]), this._gbufferTextures.length > 1 && o.addTexture("gbuffer flags", (() => this.getFlagsTexture()), [40, 310, 200, 100])), new qs(s, new Bt(r))
        }
        _update(e) {
            if (!super._update(e)) return !1;
            const t = this.pass.passObject;
            return t.scene = e.scene.modelObject, e.scene.activeCamera.updateShaderProperties(t.overrideMaterial), t.camera = e.scene.activeCamera.cameraObject, !0
        }
        getDepthNormal() {
            return this._gbufferTextures.length > 0 ? this._gbufferTextures[0] : void 0
        }
        getFlagsTexture() {
            return this._gbufferTextures.length > 1 ? this._gbufferTextures[1] : void 0
        }
        async onDispose(e) {}
        async onRemove(e) {
            return this._gbufferTarget && (e.renderer.disposeTarget(this._gbufferTarget), this._gbufferTarget = void 0), super.onRemove(e)
        }
        getTarget() {
            return this._gbufferTarget
        }
        getUnpackSnippet() {
            return jt
        }
        updateShaderProperties(e) {
            var t, n;
            if (e.uniforms.tNormalDepth ? e.uniforms.tNormalDepth.value = null !== (t = this.getDepthNormal()) && void 0 !== t ? t : void 0 : console.warn("BaseRenderer: no uniform: tNormalDepth"), e.uniforms.tGBufferFlags) {
                e.uniforms.tGBufferFlags.value = null !== (n = this.getFlagsTexture()) && void 0 !== n ? n : void 0;
                const t = e.uniforms.tGBufferFlags.value ? 1 : 0;
                t !== e.defines.GBUFFER_HAS_FLAGS && (e.defines.GBUFFER_HAS_FLAGS = t, e.needsUpdate = !0)
            }
            return this
        }
    }
    Ys.PluginType = "GBuffer";
    class Zs extends Nt {
        constructor(e, t = !0) {
            super(), this._viewer = e, this._doTransmissionFix = t, this.clear = !0, this.clearColor = new ve(0, 0, 0), this.clearAlpha = 0, this.clearDepth = !1, this._blendPass = new Ut({}, "c = vec4(a.rgb * (1. - b.a) + b.rgb * b.a, 1.);")
        }
        get transparentTarget() {
            return this._transparentTarget || (this._transparentTarget = this._viewer.renderer.getTempTarget({
                sizeMultiplier: 1,
                isAntialiased: !1,
                encoding: i.rnI,
                type: i.cLu,
                format: i.wk1,
                minFilter: i.wem,
                magFilter: i.wem,
                depthBuffer: !1
            })), this._transparentTarget
        }
        _releaseTransparentTarget() {
            this._transparentTarget && this._viewer.renderer.releaseTempTarget(this._transparentTarget), this._transparentTarget = void 0
        }
        render(e, t, n, r, i) {
            var s;
            let o = !1;
            if (e.userData.mainRenderPass = !0, !this._doTransmissionFix) return super.render(e, t, n, r, i), this.needsSwap = o, void(e.userData.mainRenderPass = void 0);
            const a = e.userData;
            a || console.error("threejs is not patched?");
            const l = this._viewer.useGBufferDepth;
            let c;
            if (l) {
                const t = null === (s = this._viewer.getPlugin(Ys)) || void 0 === s ? void 0 : s.getTarget();
                if (t) {
                    const n = e.properties.get(t);
                    c = n.__webglDepthRenderbuffer || n.__webglDepthbuffer
                } else console.warn("No Gbuffer present for depth prepass.")
            }
            let u = () => {
                super.render(e, void 0, n, r, i, c)
            };
            if (this._viewer.useRgbm) {
                if (this._viewer.useRgbm) {
                    if (o = !1, !e.info.autoReset) throw "renderer.info.autoReset must be true"; {
                        const t = e.autoClearDepth;
                        e.autoClearDepth = !l, K(e, {
                            shadowMapRender: !0,
                            backgroundRender: !0,
                            opaqueRender: !0,
                            transparentRender: !1,
                            transmissionRender: !1
                        }, u), e.autoClearDepth = t
                    }
                    if (!l) {
                        const t = e.properties.get(n);
                        c = t.__webglDepthRenderbuffer || t.__webglDepthbuffer
                    }
                    u = () => {
                        super.render(e, void 0, this.transparentTarget, r, i, c)
                    }; {
                        const t = this.clear,
                            n = e.autoClearDepth;
                        e.autoClearDepth = !1, this.clear = !0, K(e, {
                            shadowMapRender: !1,
                            backgroundRender: !1,
                            opaqueRender: !1,
                            transparentRender: !0,
                            transmissionRender: !1
                        }, u), this.clear = t, e.autoClearDepth = n
                    }
                    e.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, n, r, i), o = !0); {
                        const r = this.clear;
                        this.clear = !1, a.transmissionRenderTarget = o ? t : n, K(e, {
                            shadowMapRender: !1,
                            backgroundRender: !1,
                            opaqueRender: !1,
                            transparentRender: !1,
                            transmissionRender: !0
                        }, u), a.transmissionRenderTarget = void 0, this.clear = r
                    }
                    e.info.render.calls > 0 && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture, this._blendPass.render(e, t, n, r, i), o = !0)
                }
            } else {
                {
                    const t = this.clear,
                        n = e.autoClearDepth;
                    e.autoClearDepth = !l, this.clear = !0, K(e, {
                        shadowMapRender: !0,
                        backgroundRender: !0,
                        opaqueRender: !0,
                        transparentRender: !0,
                        transmissionRender: !1
                    }, u), this.clear = t, e.autoClearDepth = n
                } {
                    this._viewer.renderer.blit(n.texture, t, {
                        clear: !0
                    });
                    const r = this.clear;
                    this.clear = !1, a.transmissionRenderTarget = t, K(e, {
                        shadowMapRender: !1,
                        backgroundRender: !1,
                        opaqueRender: !1,
                        transparentRender: !1,
                        transmissionRender: !0
                    }, u), a.transmissionRenderTarget = void 0, this.clear = r
                }
                o = !1
            }
            this._releaseTransparentTarget(), this.needsSwap = o, e.userData.mainRenderPass = void 0
        }
    }

    function Js(e, t) {
        return e.multiplyScalar(e.w * t), e.w = 1, e
    }

    function $s(e, t) {
        return Js(e, t), new ve(e.x, e.y, e.z)
    }

    function Qs(e, t) {
        const n = Math.max(e.x, Math.max(e.y, e.z));
        let r = Math.max(Math.min(n / t, 1), 0);
        return r = Math.ceil(255 * r) / 255, e.divideScalar(r * t), e.w = r, e
    }

    function eo(e, t) {
        return Qs(new i.Ltg(e.r, e.g, e.b, 1), t)
    }
    var to = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };

    function no(e) {
        return Object.getPrototypeOf(e).constructor.PluginType
    }
    i.Vj0.background.fragmentShader = i.Vj0.background.fragmentShader.replace("uniform sampler2D t2D;", "uniform sampler2D t2D;\nuniform float intensity;"), i.Vj0.background.fragmentShader = i.Vj0.background.fragmentShader.replace("texture2D( t2D, vUv )", "texture2D( t2D, vUv )*intensity");
    class ro extends r {
        constructor({
            isAntialiased: e = !1,
            useRgbm: n = !0,
            useGBufferDepth: r = !1,
            ...o
        }) {
            var a, l;
            super(), this.console = console, this._state = t.None, this.plugins = {}, this._needsResize = !1, this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver((e => this.resize())) : void 0, this._lastSize = new i.FM8, this._onContextRestore = e => {
                this.enabled = !0, this._canvas.width = this._lastSize.width, this._canvas.height = this._lastSize.height, this.resize(), this.scene.setDirty({
                    sceneUpdate: !0,
                    frameFade: !1
                })
            }, this._onContextLost = e => {
                this._lastSize.set(this._canvas.width, this._canvas.height), this._canvas.width = 2, this._canvas.height = 2, this.resize(), this.enabled = !1
            }, this.resize = () => {
                this._needsResize = !0, this.setDirty()
            }, this._needsReset = !0, this.enabled = !0, this.renderEnabled = !0, this._isRenderingFrame = !1, this.maxFramePerLoop = 1, this._rawBackground = null, this.backgroundIntensity = 1, this._sceneEnvironmentChanged = async () => {
                this._rawBackground === io && await this.scene.setBackground(this.scene.getEnvironment())
            }, this._useRgbm = n, this._useGBufferDepth = r, this._canvas = o.canvas || mt();
            let c = o.container;
            if (c && !o.canvas && c.appendChild(this._canvas), c || (c = null !== (a = this._canvas.parentElement) && void 0 !== a ? a : void 0), !c) throw new Error("No container.");
            this._container = c, this._animationLoop = this._animationLoop.bind(this), this.setDirty = this.setDirty.bind(this), window.webGiViewers || (window.webGiViewers = []), window.webGiViewers.push(this), async function() {
                try {
                    const e = window.location.href;
                    if (e.startsWith("http://localhost:8062") || e.startsWith("https://localhost:8062")) return !0;
                    const t = "https://europe-west1-pixotronics-320918.cloudfunctions.net/viewer-hit-test";
                    await fetch(t + "/?u=" + encodeURIComponent(e), {
                        mode: "no-cors",
                        method: "POST",
                        credentials: "omit",
                        cache: "no-store",
                        keepalive: !1,
                        referrer: "about:client",
                        referrerPolicy: "unsafe-url"
                    })
                } catch (e) {
                    return !1
                }
            }(), async function() {
                var e;
                const t = window.location.href,
                    n = "https://dev-sandbox.pixotronics.com/webgi/";
                if (!t.startsWith(n)) return !0;
                if (null !== kt("noUpdate")) return !0;
                const r = null === (e = t.match(/\/webgi\/([0-9.a-zA-Z]+)/)) || void 0 === e ? void 0 : e[1],
                    i = (await (await fetch(n + "version.txt")).text()).split("\n")[0];
                if (r && r !== i) {
                    if (confirm(`New version ${i} is available, do you want to open?`)) {
                        const e = window.location.href.replace(r, i);
                        return window.location.href = e, !1
                    }
                    window.location.href.includes("noUpdate") || (window.location.href += (window.location.href.includes("?") ? "&" : "?") + "noUpdate")
                }
            }();
            const u = new nt(void 0, void 0, this._canvas);
            this.addEventListener("postFrame", (() => {
                var e, t;
                const n = h.scene.activeCamera;
                if (n && n.interactionsEnabled) {
                    if (0 === (null === (e = this.getPluginByType("Progressive")) || void 0 === e ? void 0 : e.postFrameConvergedRecordingDelta())) return;
                    null === (t = n.controls) || void 0 === t || t.update()
                }
            })), this.scene = new _t(u), this.scene.addEventListener("environmentChanged", this._sceneEnvironmentChanged), this._renderer = new Y({
                canvas: this._canvas,
                animationLoop: this._animationLoop,
                targetOptions: {
                    isAntialiased: false,
                    encoding: n ? 3005 : i.rnI,
                    type: n ? i.ywz : i.cLu,
                    depthBuffer: !r
                }
            }), this._isAntialiased = false;
            let p = !0;
            this._renderer.rendererObject.userData || (p = !1, this._renderer.rendererObject.userData = {}), this._renderer.rendererObject.userData.renderTransmissionPass = !p;
            const h = this;
            this.renderFilter = {
                passId: "render",
                passObject: new Zs(this, p),
                update() {
                    const e = this.passObject;
                    e.scene = h.scene.modelObject, e.camera = h.scene.activeCamera.cameraObject
                }
            }, [this.renderFilter, {
                passId: "screen",
                after: ["render"],
                required: ["render"],
                passObject: new Ft({ ...s,
                    fragmentShader: "\n                       varying vec2 vUv;\n                       " + (null !== (l = o.screenFragmentShader) && void 0 !== l ? l : M `
                        void main() {

                            vec4 texel = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));
                            gl_FragColor = LinearTosRGB(texel);// Gamma Correction

                        }
                    `),
                    uniforms: {
                        tDiffuse: {
                            value: null
                        }
                    }
                }, "tDiffuse")
            }].forEach((e => this._renderer.registerPass(e))), this._renderer.pipeline = ["render", "screen"], this.scene.addEventListener("sceneMaterialUpdate", (e => this.setDirty(this.scene, e))), this.scene.addEventListener("sceneUpdate", (e => {
                this.setDirty(this.scene, e), !1 !== e.geometryChanged && this.renderer.resetShadows()
            })), this.scene.addEventListener("update", (e => this.setDirty(this.scene, e))), this._renderer.addEventListener("update", (e => this.setDirty(this._renderer, e))), this.resizeObserver && this.resizeObserver.observe(this._canvas), window && window.addEventListener("resize", this.resize), this._canvas.addEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.addEventListener("webglcontextlost", this._onContextLost, !1), this.renderer.addEventListener("resize", (() => {
                this.scene.activeCamera.refreshAspect()
            })), this.setBackground("#ffffff"), this.console.log("WebGi Viewer instance initialized, version: ", ro.VERSION)
        }
        get useRgbm() {
            return this._useRgbm
        }
        get useGBufferDepth() {
            return this._useGBufferDepth
        }
        get isAntialiased() {
            return this._isAntialiased
        }
        setDirty(e, t) {
            this._needsReset = !0, e = null != e ? e : this, this.dispatchEvent({ ...null != t ? t : {},
                type: "update",
                source: e
            })
        }
        get renderer() {
            return this._renderer
        }
        dispose() {
            var e;
            this._canvas.removeEventListener("webglcontextrestored", this._onContextRestore, !1), this._canvas.removeEventListener("webglcontextlost", this._onContextLost, !1), null === (e = window.webGiViewers) || void 0 === e || e.splice(window.webGiViewers.indexOf(this), 1), this.resizeObserver ? this.resizeObserver.unobserve(this._canvas) : window.removeEventListener("resize", this.resize), this.dispatchEvent({
                type: "dispose"
            })
        }
        _animationLoop({
            time: e,
            deltaTime: t,
            xrFrame: n
        }) {
            var r, i;
            if (this.enabled && this.renderEnabled)
                if (this._isRenderingFrame) this.console.warn("animation loop: frame skip");
                else {
                    this._isRenderingFrame = !0;
                    for (let s = 0; s < this.maxFramePerLoop; s++) {
                        if (this._needsReset && (this._renderer.reset(), this._needsReset = !1), this._needsResize) {
                            const e = [this._canvas.clientWidth, this._canvas.clientHeight];
                            if (n) {
                                const t = null === (i = null === (r = this._renderer.rendererObject.xr.getCamera()) || void 0 === r ? void 0 : r.cameras[0]) || void 0 === i ? void 0 : i.viewport;
                                t ? (0 === t.x && 0 === t.y || this.console.warn("x and y must be 0?"), e[0] = t.width, e[1] = t.height, this.console.log("resize for xr", e)) : this._needsResize = !1
                            }
                            this._needsResize && (this._renderer.setSize(...e), this._needsResize = !1)
                        }
                        this.dispatchEvent({
                            type: "preFrame",
                            target: this,
                            time: e,
                            deltaTime: t,
                            xrFrame: n
                        });
                        const s = Object.values(this.plugins).filter((e => e.dirty));
                        s.length > 0 && this.setDirty(s), this._needsReset && (this._renderer.reset(), this._needsReset = !1), this._renderer.updateDirty();
                        const o = this._renderer.dirty;
                        if (o) {
                            this.dispatchEvent({
                                type: "preRender",
                                target: this
                            });
                            try {
                                this._renderer.render()
                            } catch (e) {
                                this.console.error(e), this.enabled = !1
                            }
                            this.dispatchEvent({
                                type: "postRender",
                                target: this
                            })
                        }
                        if (this.dispatchEvent({
                                type: "postFrame",
                                target: this
                            }), !o) break
                    }
                    this._isRenderingFrame = !1
                }
        }
        get state() {
            return this._state
        }
        get container() {
            return this._container
        }
        get canvas() {
            return this._canvas
        }
        getPlugin(e) {
            return this.plugins[e.PluginType]
        }
        getPluginByType(e) {
            return this.plugins[e]
        }
        async addPlugin(e, ...t) {
            var n;
            let r;
            r = e.prototype ? new e(...t) : e;
            const i = no(r);
            return i ? (null === (n = r.dependencies) || void 0 === n || n.forEach((e => {
                this.getPlugin(e) || (this.console.log("Adding plugin dependency", e.name, "for", i), this.addPlugin(e))
            })), this.plugins[i] && this.console.error(`Plugin of type ${i} already exists`, this.plugins[i], r), this.plugins[i] = r, await r.onAdded(this), this.dispatchEvent({
                type: "addPlugin",
                target: this,
                plugin: r
            }), this.setDirty(r), r) : (this.console.error("PluginType is not defined for", r), r)
        }
        async removePlugin(e, t = !0) {
            const n = no(e);
            this.plugins[n] && (await e.onRemove(this), delete this.plugins[n], t && await e.onDispose(this), this.setDirty(e))
        }
        createCamera(e) {
            var t;
            const n = null !== (t = e.userData.iCamera) && void 0 !== t ? t : new nt(e, {
                controlsMode: "",
                controlsEnabled: !1
            }, this.container);
            return n.autoLookAtTarget = !1, n
        }
        _backgroundIntensityChanged() {
            var e, t, n, r;
            const s = null !== (r = null === (n = null === (t = null === (e = this._renderer) || void 0 === e ? void 0 : e.rendererObject) || void 0 === t ? void 0 : t.background.getPlaneMesh()) || void 0 === n ? void 0 : n.material.uniforms) && void 0 !== r ? r : i.Vj0.background.uniforms;
            s.intensity || (s.intensity = {
                value: 1
            }), s.intensity.value = this.backgroundIntensity, this.setDirty()
        }
        async setBackgroundColor(e) {
            const t = (new ve).set(e).convertSRGBToLinear();
            return this.setBackground(t)
        }
        async setBackground(e) {
            if (this._rawBackground = e, null != e && ("string" == typeof e || "number" == typeof e || e.isVector4 || e.isColor)) {
                if (e === io) return this._sceneEnvironmentChanged();
                const t = e.isVector4 ? W(e) : H(e.isColor ? e : new ve(e));
                return t.assetType = "texture", this.scene.setBackground(t)
            }
            return !e && this.useRgbm && this.console.error("Transparent background not supported with HDR RGBM rendering mode"), this.scene.setBackground(e)
        }
        getBackground(e = !1) {
            var t, n, r;
            if (e) return this._rawBackground;
            let i = null !== (t = this._rawBackground) && void 0 !== t ? t : this.scene.getBackground();
            return i ? ((null === (n = i) || void 0 === n ? void 0 : n.isVector4) && (i = $s(i, 7).getHexString()), (null === (r = i) || void 0 === r ? void 0 : r.isColor) ? i.getHexString() : this._rawBackground === io ? this.scene.getEnvironment() : i) : null
        }
        getManager() {
            return this.getPluginByType("AssetManager")
        }
        resetCamera({
            rootObject: e,
            centerOffset: t = new i.Pa4(1, 1, 1),
            targetOffset: n = new i.Pa4(0, 0, 0),
            ...r
        } = {}) {
            if (this.scene.activeCamera) {
                this.scene.matrixWorldNeedsUpdate = !0, this.scene.updateMatrixWorld(!0);
                const r = e ? (new P).expandByObject(e, !0, !0) : this.scene.getBounds(!0),
                    s = r.getCenter(new i.Pa4),
                    o = .5 * r.getSize(new i.Pa4).length();
                s.add(n.clone().multiplyScalar(o)), this.scene.activeCamera.position = new i.Pa4(s.x + t.x * o, s.y + t.y * o, s.z + t.z * o), this.scene.activeCamera.target = s, this.setDirty()
            }
        }
        async createObject3D(e) {
            var t;
            return null === (t = this.getManager()) || void 0 === t ? void 0 : t.addImportedSingle(e || new i.Tme, {
                autoScale: !1,
                pseudoCenter: !1
            })
        }
        createPhysicalMaterial(e) {
            var t, n, r, i, s;
            if (null === (t = e) || void 0 === t ? void 0 : t.isMaterial) {
                const t = null === (r = null === (n = this.getManager()) || void 0 === n ? void 0 : n.materials) || void 0 === r ? void 0 : r.findMaterial(e.uuid);
                if (t) return t
            }
            return null === (s = null === (i = this.getManager()) || void 0 === i ? void 0 : i.materials) || void 0 === s ? void 0 : s.generateFromTemplate("standard", e)
        }
        serializePlugins(e, t) {
            return Object.entries(this.plugins).map((n => {
                var r, i;
                if (!t || t.includes(n[1].constructor.PluginType)) return null === (i = (r = n[1]).toJSON) || void 0 === i ? void 0 : i.call(r, e)
            })).filter((e => !!e))
        }
        deserializePlugins(e, t) {
            return e.forEach((e => {
                var n;
                if (!e.type) return void this.console.warn("Invalid plugin to import ", e);
                const r = this.getPluginByType(e.type);
                r && (null === (n = r.fromJSON) || void 0 === n || n.call(r, e, t))
            })), this
        }
        toJSON(e, t) {
            return Object.assign({
                version: ro.VERSION,
                plugins: this.serializePlugins(e, t)
            }, Me(this, !0, e))
        }
        async fromJSON(e, t) {
            return Te(e, this, !0, t), Array.isArray(e.plugins) && this.deserializePlugins(e.plugins, t), await this.setBackground(this._rawBackground), this
        }
    }
    ro.VERSION = "0.4.5", to([xe()], ro.prototype, "scene", void 0), to([xe("background")], ro.prototype, "_rawBackground", void 0), to([xe(), C(ro.prototype._backgroundIntensityChanged)], ro.prototype, "backgroundIntensity", void 0);
    const io = "envMapBackground";
    class so extends Ft {
        constructor(e) {
            super({
                vertexShader: s.vertexShader,
                fragmentShader: M `
                uniform vec4 weight;
                uniform vec4 weight2;
                varying vec2 vUv;
                void main() {
                    vec4 texel = clamp(weight * tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ) + weight2 * tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), vec4(0), vec4(8));
                    gl_FragColor = texel;
                    #include <encodings_fragment>
                }
            `,
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    tDiffuse2: {
                        value: e
                    },
                    weight: {
                        value: new i.Ltg(1, 1, 1, 1)
                    },
                    weight2: {
                        value: new i.Ltg(1, 1, 1, 1)
                    }
                }
            }, "tDiffuse", "tDiffuse2"), this.clear = !1, this.needsSwap = !0
        }
        set weights2(e) {
            this.uniforms.weight2.value.copy(e)
        }
        get weights2() {
            return this.uniforms.weight2.value
        }
        set weights1(e) {
            this.uniforms.weight.value.copy(e)
        }
        get weights1() {
            return this.uniforms.weight.value
        }
        set blendTexture(e) {
            this.uniforms.tDiffuse2.value = e
        }
    }
    class oo extends Gs {
        constructor() {
            super(), this._pipeline = []
        }
        get passes() {
            if (!this._passes) throw "Plugin not yet added to the viewer";
            return this._passes
        }
        get pipeline() {
            return this._pipeline
        }
        set pipeline(e) {
            this._pipeline = e
        }
        async onAdded(e) {
            await super.onAdded(e);
            const t = this.createPasses(e);
            this._passes = Object.fromEntries(t.map((t => (t.passId || (console.warn("no id found for pass", t), t.passId = Be()), e.renderer.registerPass(t, !0), [t.passId, t]))))
        }
        async onRemove(e) {
            var t;
            if (this._passes) {
                for (const n of [...Object.values(this._passes)]) {
                    const r = n;
                    e.renderer.unregisterPass(r), null === (t = null == r ? void 0 : r.dispose) || void 0 === t || t.call(r)
                }
                this._passes = void 0
            }
            await super.onRemove(e)
        }
        toJSON(e) {
            var t, n;
            const r = super.toJSON(e);
            if (!r.type) return r;
            const i = Object.entries(this.passes);
            r.passes = {};
            for (const [s, o] of i) r.passes[s] = Me(null !== (n = null === (t = o) || void 0 === t ? void 0 : t.passObject) && void 0 !== n ? n : o, !1, e);
            return r
        }
        fromJSON(e, t) {
            var n, r;
            if (!super.fromJSON(e, t)) return null;
            if (e.passes) {
                const i = Object.entries(this.passes);
                for (const [s, o] of i) Te(e.passes[s], null !== (r = null === (n = o) || void 0 === n ? void 0 : n.passObject) && void 0 !== r ? r : o, !1, t)
            }
            return this
        }
    }
    var ao = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    const lo = [{
        x: 0,
        y: 0
    }, {
        x: -.5,
        y: 0
    }, {
        x: -.375,
        y: -.25
    }, {
        x: -.1875,
        y: -.125
    }, {
        x: -.125,
        y: -.375
    }, {
        x: .0625,
        y: -.0625
    }, {
        x: .125,
        y: -.3125
    }, {
        x: .375,
        y: -.4375
    }, {
        x: .3125,
        y: -.1875
    }, {
        x: .25,
        y: .0625
    }, {
        x: .4375,
        y: .25
    }, {
        x: .1875,
        y: .3125
    }, {
        x: 0,
        y: .4375
    }, {
        x: -.0625,
        y: .1875
    }, {
        x: -.25,
        y: .375
    }, {
        x: -.4375,
        y: .5
    }, {
        x: -.3125,
        y: .125
    }];
    class co extends oo {
        constructor(e = 2 * lo.length) {
            super(), this.enabled = !0, this.jitter = !0, this._hasSetOffset = !1, this.trackedJitterCameras = new Set, this._addSceneObject = e => {
                const t = e.object;
                (t.modelObject || t.lightObject) && (t.modelObject || t.lightObject).traverse((e => {
                    var t;
                    (null === (t = null == e ? void 0 : e.shadow) || void 0 === t ? void 0 : t.camera) && e.shadow.mapSize && this.trackedJitterCameras.add([e.shadow.camera, e.shadow.mapSize])
                }))
            }, this._jitterCamera = e => {
                var t;
                const n = e.target;
                if (this.jitter && n.renderer.frameCount > 2) {
                    const e = (e, t) => {
                            const r = { ...lo[n.renderer.frameCount % lo.length]
                            };
                            e.setViewOffset(t.width, t.height, r.x, r.y, t.width, t.height)
                        },
                        r = n.scene.activeCamera.cameraObject;
                    e(r, {
                        width: n.canvas.clientWidth * n.renderer.displayCanvasScaling,
                        height: n.canvas.clientHeight * n.renderer.displayCanvasScaling
                    }), this.trackedJitterCameras.forEach((t => e(...t))), this._hasSetOffset = !0, null === (t = this._viewer) || void 0 === t || t.renderer.resetShadows()
                }
            }, this._resetCameraJitter = e => {
                const t = e.target;
                this._hasSetOffset && (t.scene.activeCamera.cameraObject.clearViewOffset(), this._hasSetOffset = !1)
            }, this.uiConfig = $e("Progressive", this), this.maxFrameCount = e
        }
        async onAdded(e) {
            return this._lastFrame = e.renderer.composerTarget.clone(!0), await super.onAdded(e)
        }
        async onRemove(e) {
            e.removeEventListener("preRender", this._jitterCamera), e.removeEventListener("postRender", this._resetCameraJitter), e.scene.removeEventListener("addSceneObject", this._addSceneObject), this._lastFrame && e.renderer.disposeTarget(this._lastFrame), this._lastFrame = void 0, await super.onRemove(e)
        }
        get lastFrame() {
            return this._lastFrame
        }
        createPasses(e) {
            e.addEventListener("preRender", this._jitterCamera), e.addEventListener("postRender", this._resetCameraJitter), e.scene.addEventListener("addSceneObject", this._addSceneObject);
            const t = this;
            return [Hs(e, {
                passId: "progressive",
                get dirty() {
                    var e;
                    return t.jitter && ((null === (e = t._viewer) || void 0 === e ? void 0 : e.renderer.frameCount) || 0) < t.maxFrameCount
                },
                after: ["render"],
                before: ["tonemap", "screen"],
                required: ["render"],
                passObject: new class extends so {
                    render(n, r, i, s, o) {
                        if (e.renderer.frameCount < 1) return this.needsSwap = !1, void((null == i ? void 0 : i.texture) && e.renderer.blit(i.texture, t.lastFrame, {}));
                        this.needsSwap = !0, super.render(n, r, i, s, o), e.renderer.blit(r.texture, t.lastFrame, {})
                    }
                },
                update() {
                    if (!t.lastFrame) return void console.error("lastFrame render target undefined");
                    let n = 1 / (Math.max(e.renderer.frameCount, 0) + 1);
                    this.passObject.weights1.set(n, n, n, n), n = 1 - n, this.passObject.weights2.set(n, n, n, n), this.passObject.blendTexture = t.lastFrame.texture, this.passObject.material.uniformsNeedUpdate = !0
                }
            })]
        }
        isConverged(e = !1) {
            var t;
            return ((null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer.frameCount) || 0) >= this.maxFrameCount - 1 + (e ? 1 : 0)
        }
        updateShaderProperties(e) {
            var t, n;
            return e.uniforms.tLastFrame && (e.uniforms.tLastFrame.value = null !== (n = null === (t = this.lastFrame) || void 0 === t ? void 0 : t.texture) && void 0 !== n ? n : void 0), this
        }
        postFrameConvergedRecordingDelta(e = "CanvasRecorder") {
            const t = this._viewer.getPluginByType(e);
            return t && t.isRecording() && t.convergeMode ? this.isConverged(!0) ? 1 / t.videoFrameRate : 0 : -1
        }
    }
    co.PluginType = "Progressive", ao([xe(), qe("Frame count")], co.prototype, "maxFrameCount", void 0), ao([xe(), Ve("Jitter")], co.prototype, "jitter", void 0);
    var uo = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    const po = i.dZ3;
    let ho = class extends Ft {
        constructor(e = !1) {
            super({
                vertexShader: s.vertexShader,
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    tNormalDepth: {
                        value: null
                    },
                    tGBufferFlags: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    }
                },
                defines: {
                    TONEMAP_BACKGROUND: 0,
                    TRANSPARENT_BACKGROUND: 0,
                    GBUFFER_HAS_FLAGS: 0
                },
                fragmentShader: `\n${e?jt:""}\n#define USE_DEPTH_TONEMAP ${e?"1":"0"}\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));gl_FragColor=opacity*texel;\n#if USE_DEPTH_TONEMAP > 0\nbool doTonemap=getGBufferFlags(vUv).x>0.5;\n#if TONEMAP_BACKGROUND < 1 || TRANSPARENT_BACKGROUND > 0\nif(getDepth(vUv)>0.999)doTonemap=false;\n#endif\nif(doTonemap){\n#endif\n#include <tonemapping_fragment>\n#if USE_DEPTH_TONEMAP > 0\n}else{\n#if TRANSPARENT_BACKGROUND > 0\ngl_FragColor.a=0.;\n#endif\n}\n#endif\n#include <encodings_fragment>\n}\n                `
            }, "tDiffuse"), this.uiConfig = void 0, this.toneMapping = i.LY2, this.tonemapBackground = !0, this.clipBackground = !1, this.exposure = 1
        }
        render(e, t, n, r, s) {
            const {
                toneMapping: o,
                toneMappingExposure: a,
                outputEncoding: l
            } = e;
            let c = this.tonemapBackground ? "1" : "0";
            this.material.defines.TONEMAP_BACKGROUND !== c && (this.material.defines.TONEMAP_BACKGROUND = c, this.material.needsUpdate = !0), c = this.clipBackground ? "1" : "0", this.material.defines.TRANSPARENT_BACKGROUND !== c && (this.material.defines.TRANSPARENT_BACKGROUND = c, this.material.needsUpdate = !0), e.toneMapping = this.toneMapping, e.toneMappingExposure = this.exposure, e.outputEncoding = i.knz, this.material.toneMapped = !0, this.material.needsUpdate = !0, super.render(e, t, n, r, s), e.toneMapping = o, e.toneMappingExposure = a, e.outputEncoding = l, this.needsSwap = !0
        }
    };
    uo([Ke("Mode", [
        ["Linear", i.EoG],
        ["Reinhard", i.CdI],
        ["Cineon", i.YGz],
        ["ACESFilmic", i.LY2],
        ["Uncharted2", po]
    ].map((e => ({
        label: e[0],
        value: e[1]
    }))), {
        limitedUi: !0
    }), xe()], ho.prototype, "toneMapping", void 0), uo([Ve("Tonemap Background", {
        limitedUi: !0
    }), xe()], ho.prototype, "tonemapBackground", void 0), uo([Ve("Clip Background"), xe()], ho.prototype, "clipBackground", void 0), uo([He("Exposure", [0, 2 * Math.PI], .01, {
        limitedUi: !0
    }), xe()], ho.prototype, "exposure", void 0), ho = uo([Qe("Tonemapping")], ho), i.WdD.tonemapping_pars_fragment = i.WdD.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", "\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( 1.0 ) ) );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return Uncharted2ToneMapping( color ); }\n\n");
    class fo extends Ws {
        constructor(e = !1, t = !0) {
            super(), this.depthTonemap = e, this.renderToScreen = t, this.passId = "tonemap", this.dependencies = [Ys], this._beforeFilters = [], this._afterFilters = ["render"], this._requiredFilters = ["render"], this._setDirty = this._setDirty.bind(this)
        }
        async onAdded(e) {
            return this.renderToScreen && g(e.renderer.passes.find((e => "screen" === e.passId)), "enabled", !1, !0, !0), super.onAdded(e)
        }
        passCtor(e) {
            var t, n;
            const r = new ho(this.depthTonemap);
            return g(null === (n = null === (t = r.uiConfig) || void 0 === t ? void 0 : t.children) || void 0 === n ? void 0 : n.find((e => {
                var t;
                return "Enabled" === (null === (t = e) || void 0 === t ? void 0 : t.label)
            })), "hidden", !0, !0), r
        }
        _update(e) {
            var t;
            return !!super._update(e) && (this._pass.passObject.updateShaderProperties(null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Ys)), !0)
        }
        get exposure() {
            var e, t;
            return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.exposure) && void 0 !== t ? t : 1
        }
        set exposure(e) {
            var t;
            const n = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
            n && (n.exposure = e, this._setDirty())
        }
        get toneMapping() {
            var e, t;
            return null !== (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.toneMapping) && void 0 !== t ? t : i.EoG
        }
        set toneMapping(e) {
            var t;
            const n = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
            n && (n.toneMapping = e, this._setDirty())
        }
        _setDirty() {
            this.pass && (this.pass.dirty = !0)
        }
        get uiConfig() {
            var e, t, n, r, i;
            const s = null !== (n = null === (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== n ? n : {};
            return null === (i = null === (r = s.children) || void 0 === r ? void 0 : r.map((e => x(e)))) || void 0 === i || i.flat(2).forEach((e => e && (e.onChange = this._setDirty))), s
        }
    }
    fo.PluginType = "Tonemap";
    var _o = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}",
        mo = "#ifndef BASIC_CAMERA_HELPERS\n#define BASIC_CAMERA_HELPERS\nuniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;uniform mat4 projection;\n#ifndef THREE_PACKING_INCLUDED\n#define THREE_PACKING_INCLUDED\n#include <packing>\n#endif\nfloat linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}float depthToViewZ(const in float depth){return(depth>0.999)?-cameraNearFar.y*1000.:-mix(cameraNearFar.x,cameraNearFar.y,depth);}float viewZToDepth(const in float viewZ){return linstep(-cameraNearFar.x,-cameraNearFar.y,viewZ);}vec4 viewToScreen3(const in vec3 pos){vec4 projected=projection*vec4(pos,1.);projected.z=pos.z;projected.w=1./projected.w;projected.xyz*=projected.w;projected.xy=0.5+0.5*projected.xy;return projected;}vec3 screenToView(const in vec2 uv,const in float viewZ){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewZ/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewZ/projection[1][1];return vec3(xe,ye,viewZ);}\n#endif\n",
        go = "#ifndef BASIC_HELPERS\n#define BASIC_HELPERS\nfloat saturate2(float v,float mx){return max(0.,min(mx,v));}vec3 saturate2(vec3 v){return max(vec3(0.),min(vec3(1.),v));}\n#endif\n",
        vo = "#ifndef BASIC_RANDOM_HELPERS\n#define BASIC_RANDOM_HELPERS\nuniform float frameCount;float random(float n){return fract(sin(n)*43758.5453123);}float random2(vec2 n,float x){n+=x;return fract(sin(dot(n.xy,vec2(12.9898,78.233)))*43758.5453);}float random3(vec3 v){v=fract(v*443.8975);v+=dot(v,v.yzx+19.19);return fract((v.x+v.y)*v.z);}float interleavedGradientNoise(const in vec2 fragCoord,const in float seed){vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(fragCoord.xy+seed*vec2(2.083,4.867),magic.xy)));}vec3 hash3(vec2 p){vec3 q=vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9)));return fract(sin(q)*43758.5453);}\n#endif\n",
        bo = "#define PI 3.141592653589793\nmat3 GetTangentBasis(vec3 TangentZ){vec3 up=vec3(0.,0.,1.);vec3 TangentX=normalize(cross(dot(TangentZ,up)<0.8?up:vec3(1.,0.,0.),TangentZ));vec3 TangentY=cross(TangentZ,TangentX);return mat3(TangentX,TangentY,TangentZ);}vec4 CosineSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=sqrt(E.y);float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=CosTheta*(1./PI);return vec4(H,PDF);}vec4 UniformSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=E.y;float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=1./(2.*PI);return vec4(H,PDF);}vec2 UniformSampleDiskConcentric(vec2 E){vec2 p=2.*E-1.;float Radius;float Phi;if(abs(p.x)>abs(p.y)){Radius=p.x;Phi=(PI/4.)*(p.y/p.x);}else{Radius=p.y;Phi=(PI/2.)-(PI/4.)*(p.x/p.y);}return vec2(Radius*cos(Phi),Radius*sin(Phi));}vec2 UniformSampleDiskConcentricApprox(vec2 E){vec2 sf=E*sqrt(2.)-sqrt(0.5);vec2 sq=sf*sf;float root=sqrt(2.*max(sq.x,sq.y)-min(sq.x,sq.y));if(sq.x>sq.y){sf.x=sf.x>0.?root:-root;}else{sf.y=sf.y>0.?root:-root;}return sf;}",
        xo = "#ifndef SSRT_PARS_SNIP\n#define SSRT_PARS_SNIP\n#define pow2(a) a*a\nfloat getDepth2(const in vec2 uv,const in float lod){float viewDepth=getDepth(uv);return depthToViewZ(viewDepth);}\n#define LOD_DEPTH 1.0\n#define LOD_COLOR 5.0\nvoid _traceRay(in vec4 ray_origin,in vec4 ray_dir,in float tolerance,inout vec3 state,in int loopMax,in float iStepCount){vec4 sample_uv;float d,hit;float dLod=0.;\n#pragma unroll_loop_start\nfor(int i=0;i<8;i++){if(UNROLLED_LOOP_INDEX<loopMax){sample_uv=ray_origin+ray_dir*state.y;d=getDepth2(sample_uv.xy,dLod);d=sample_uv.z/sample_uv.w-d;if(abs(d+tolerance)<tolerance){hit=clamp(state.x/(state.x-d),0.,1.)-1.;hit=(state.y+hit*iStepCount);state.z=min(state.z,hit);}state.x=d;state.y+=1.*iStepCount;}}\n#pragma unroll_loop_end\n}vec3 traceRay(in vec3 ray_origin_view,in vec3 ray_dir_view,in float tolerance,inout vec3 state,in int _STEP_COUNT){vec4 sample_uv;vec4 ray_origin=viewToScreen3(ray_origin_view);vec3 ray_end_view=ray_origin_view+ray_dir_view;vec4 ray_dir=viewToScreen3(ray_end_view);vec2 clamp_end=clamp(ray_dir.xy,vec2(0.),vec2(1.));vec2 correction=abs(ray_dir.xy-clamp_end);correction=(step(0.01,correction)*correction/(abs(clamp_end-ray_origin.xy)+0.01))+1.;correction.x=1./min(max(correction.y,correction.x),10.);ray_dir=ray_dir-ray_origin;ray_dir.xyw*=correction.x;float iStepCount=1./float(_STEP_COUNT);tolerance*=0.125;_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT,iStepCount);if(_STEP_COUNT>8&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-8,iStepCount);if(_STEP_COUNT>15&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);if(_STEP_COUNT>23&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);sample_uv=ray_origin+ray_dir*state.z;sample_uv.z/=sample_uv.w;state.z=state.z<0.999?state.z:9999999.;return sample_uv.xyz;}\n#endif\n",
        yo = "uniform float objectRadius;uniform float radius;uniform float tolerance;uniform bool autoRadius;\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius\nuniform float sceneBoundingRadius;\n#endif\nvec3 ComputeReflectionL(vec3 N,vec2 E,vec3 V,float rough){float rough4=rough*rough*rough*rough;float phi=2.*PI*E.x;float cos_theta=pow(max(E.y,0.000001),rough4/(2.-rough4));float sin_theta=sqrt(max(0.,1.-cos_theta*cos_theta));vec3 half_vec=vec3(sin_theta*cos(phi),sin_theta*sin(phi),cos_theta);vec3 tangentX=normalize(cross(abs(N.z)<0.999?vec3(0.,0.,1.):vec3(1.,0.,0.),N));vec3 tangentY=cross(N,tangentX);half_vec=half_vec.x*tangentX+half_vec.y*tangentY+half_vec.z*N;vec3 ray_dir=(2.*dot(V,half_vec))*half_vec-V;return ray_dir;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=interleavedGradientNoise(gl_FragCoord.xy,frameCount*117.);rand_e.y=fract(rand_e.x*38.65435);rand_e.y=mix(rand_e.y,1.,0.7);return rand_e;}vec4 calculateSSR(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor,in float roughness){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeReflectionL(normal,E,-normalize(viewPos),roughness);L=normalize(L);float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?mix((cameraDist+objectRadius*sceneBoundingRadius)+viewPos.z,-viewPos.z-max(0.,cameraDist-objectRadius*sceneBoundingRadius),L.z*0.5+0.5):objectRadius*sceneBoundingRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount+seed);rayLen=max(rayLen,0.001);int steps=SSR_STEP_COUNT/(frameCount<float(SSR_LOW_QUALITY_FRAMES)?2:1);vec3 state=vec3(0.,(r+0.5)/float(steps),2.);viewPos+=normal*max(-0.0001*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,steps);if(state.z<0.99){vec3 hitColor=(tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy))).rgb;float ssrWeight=1.;return vec4(hitColor*ssrWeight,1.);}return vec4(0.);}",
        wo = "#ifndef SIMPLE_CAMERA_HELPERS\n#define SIMPLE_CAMERA_HELPERS\n#ifndef USE_TRANSMISSION\nuniform mat4 projectionMatrix;\n#endif\nvec3 viewToScreen(const in vec3 pos){vec4 projected=projectionMatrix*vec4(pos,1.);return vec3(0.5+0.5*projected.xy/projected.w,projected.w);}\n#endif\n",
        So = function(e, t, n, r) {
            var i, s = arguments.length,
                o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
            else
                for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
            return s > 3 && o && Object.defineProperty(t, n, o), o
        };
    let Mo = class extends Ft {
        constructor(e, t, n, r = !0) {
            super({
                vertexShader: _o,
                fragmentShader: `\n\nvarying vec2 vUv;\n\n${go}\n${mo}\n${vo}\n${bo}\n${n}\n\n${xo}\n\n${yo}\n\nuniform sampler2D tLastThis;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 lastAO=tLastThisTexelToLinear(texture2D(tLastThis,vUv));float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>=0.999){discard;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec3 viewPos=screenToView(screenPos.xy,screenPos.z);viewPos.z=viewZ/viewPos.z;vec4 ao=vec4(0.);ao+=calculateSSR(8.,screenPos,normal,1.,0.1);ao.rgb=min(vec3(3.),ao.rgb);ao.rgb=max(vec3(0.),ao.rgb);if(frameCount<1.){gl_FragColor=ao;return;}if(ao.a<0.01){gl_FragColor.rgb=lastAO.rgb;gl_FragColor.a=(((lastAO.a)*frameCount)/(frameCount+1.));}else{gl_FragColor=((ao+(lastAO)*frameCount)/(frameCount+1.));}\n#include <encodings_fragment>\n}\n\n\n            `,
                uniforms: {
                    tLastThis: {
                        value: null
                    },
                    tDiffuse: {
                        value: null
                    },
                    tNormalDepth: {
                        value: null
                    },
                    tLastFrame: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    },
                    intensity: {
                        value: 0
                    },
                    boost: {
                        value: new i.Pa4(0, 0, 0)
                    },
                    objectRadius: {
                        value: 0
                    },
                    autoRadius: {
                        value: !1
                    },
                    power: {
                        value: 0
                    },
                    maskFrontFactor: {
                        value: -.1
                    },
                    tolerance: {
                        value: 0
                    },
                    frameCount: {
                        value: 0
                    },
                    projection: {
                        value: new i.yGw
                    },
                    cameraPositionWorld: {
                        value: new i.Pa4
                    },
                    cameraNearFar: {
                        value: new i.FM8(.1, 1e3)
                    },
                    sceneBoundingRadius: {
                        value: 0
                    }
                },
                defines: {
                    PERSPECTIVE_CAMERA: 1,
                    SSR_STEP_COUNT: 16,
                    SSR_LOW_QUALITY_FRAMES: 2,
                    SSR_MASK_FRONT_RAYS: !0,
                    SSR_INLINE: r ? "1" : "0",
                    SSR_NON_PHYSICAL: "0"
                }
            }, "tDiffuse", "tLastThis", "tLastFrame"), this.uiConfig = void 0, this.materialExtension = {
                shaderExtender: (e, t, n) => {
                    if (!e.defines.SSR_ENABLED) return;
                    const r = "#glMarker beforeModulation";
                    e.fragmentShader = e.fragmentShader.replace(r, `\n\n            \n            #if defined(SSR_ENABLED) && SSR_ENABLED > 0\nvec3 screenPos=viewToScreen(geometry.position);vec4 ssrColor=vec4(0,0,0,0);float alphaModifier=1.-clamp(material.roughness*.3,0.,1.);alphaModifier*=ssrIntensity;\n#if defined(SSR_MASK_FRONT_RAYS) && SSR_MASK_FRONT_RAYS > 0\nalphaModifier*=clamp(-4.*dot(geometry.viewDir,normal)+(4.+ssrMaskFrontFactor),0.,1.);\n#endif\n#ifdef USE_TRANSMISSION\nalphaModifier*=1.-transmission;\n#endif\nfloat vignette=1.;if(true){float fadeStrength=0.1;float dist=min(min(1.-screenPos.x,1.-screenPos.y),min(screenPos.x,screenPos.y));float fade=dist*dist/(fadeStrength+0.001);fade=clamp(fade,0.,1.);fade=pow(fade,0.3);vignette=fade;}alphaModifier*=vignette;vec3 specularColor=EnvironmentBRDF(geometry.normal,geometry.viewDir,material.specularColor.rgb,material.specularF90,material.roughness);if(length(specularColor.rgb)*alphaModifier>0.01&&roughnessFactor<0.9){\n#if defined(SSR_INLINE) && SSR_INLINE > 0\nssrColor=calculateSSR(8.,vec3(screenPos.xy,geometry.position.z),geometry.normal,1.,material.roughness);\n#else\nssrColor=tSSRMapTexelToLinear(texture2D(tSSRMap,screenPos.xy));\n#endif \n}ssrColor.rgb*=ssrBoost;ssrColor.a*=alphaModifier;ssrColor.a=min(ssrColor.a,1.);\n#if defined(SSR_NON_PHYSICAL) && SSR_NON_PHYSICAL > 0\ndiffuseColor.a=max(ssrColor.a,diffuseColor.a*diffuseColor.a);reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(diffuseColor.rgb*ssrColor.rgb),1.);reflectedLight.indirectDiffuse=vec3(0.);reflectedLight.directDiffuse=vec3(0.);reflectedLight.directSpecular=vec3(0.);\n#else\nreflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(specularColor.rgb*ssrColor.rgb),ssrColor.a);\n#endif\n#endif\n\n            \n            // reflectedLight.directDiffuse = vec3(0.);\n            // reflectedLight.indirectDiffuse = vec3(0.);\n            // reflectedLight.directSpecular = vec3(0.);\n            // reflectedLight.indirectSpecular = vec3(0.);\n            \n            \n${r}`)
                },
                onObjectRender: (e, t, n) => {
                    var r, i, s, o;
                    let a = this.enabled && !1 !== n.userData.screenSpaceRendering && !(null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r.ssreflDisabled) ? 1 : 0;
                    t.materialObject.defines.SSR_ENABLED !== a && (t.materialObject.defines.SSR_ENABLED = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_STEP_COUNT, t.materialObject.defines.SSR_STEP_COUNT !== a && (t.materialObject.defines.SSR_STEP_COUNT = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_LOW_QUALITY_FRAMES, t.materialObject.defines.SSR_LOW_QUALITY_FRAMES !== a && (t.materialObject.defines.SSR_LOW_QUALITY_FRAMES = a, t.materialObject.needsUpdate = !0), a = this.material.defines.PERSPECTIVE_CAMERA, t.materialObject.defines.PERSPECTIVE_CAMERA !== a && (t.materialObject.defines.PERSPECTIVE_CAMERA = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_INLINE, t.materialObject.defines.SSR_INLINE !== a && (t.materialObject.defines.SSR_INLINE = a, t.materialObject.needsUpdate = !0), a = this.material.defines.SSR_MASK_FRONT_RAYS ? 1 : 0, t.materialObject.defines.SSR_MASK_FRONT_RAYS !== a && (t.materialObject.defines.SSR_MASK_FRONT_RAYS = a, t.materialObject.needsUpdate = !0), a = (null === (i = t.materialObject.userData) || void 0 === i ? void 0 : i.ssreflNonPhysical) ? "1" : "0", t.materialObject.defines.SSR_NON_PHYSICAL !== a && (t.materialObject.defines.SSR_NON_PHYSICAL = a, t.materialObject.needsUpdate = !0), a = null !== (o = null === (s = this._target) || void 0 === s ? void 0 : s.texture) && void 0 !== o ? o : null, this.materialExtension.extraUniforms.tSSRMap.value !== a && (this.materialExtension.extraUniforms.tSSRMap.value = a, t.materialObject.needsUpdate = !0)
                },
                parsFragmentSnippet: e => {
                    var t;
                    return "\nuniform float ssrPower;\nuniform float ssrIntensity;\nuniform float ssrMaskFrontFactor;\nuniform vec3 ssrBoost;\nuniform sampler2D tSSRMap;\nuniform sampler2D tLastFrame;\n" + U("tSSRMap", null === (t = this._target) || void 0 === t ? void 0 : t.texture, e.capabilities.isWebGL2) + U("tLastFrame", this.materialExtension.extraUniforms.tLastFrame.value, e.capabilities.isWebGL2) + (this._inline ? `\n#if 1\n// #if SSR_INLINE\n    ${go}\n    \n    #define THREE_PACKING_INCLUDED\n    ${mo}\n    \n    ${vo}\n    ${bo}\n    ${jt}\n    \n    ${xo}\n    \n    ${yo}\n// #endif // SSR_INLINE\n#endif\n` : "") + `\n\n${wo}\n\n        `
                },
                extraUniforms: {
                    tSSRMap: {
                        value: null
                    },
                    ssrPower: this.material.uniforms.power,
                    ssrIntensity: this.material.uniforms.intensity,
                    ssrMaskFrontFactor: this.material.uniforms.maskFrontFactor,
                    ssrBoost: this.material.uniforms.boost,
                    tNormalDepth: this.material.uniforms.tNormalDepth,
                    tLastFrame: this.material.uniforms.tLastFrame,
                    objectRadius: this.material.uniforms.objectRadius,
                    autoRadius: this.material.uniforms.autoRadius,
                    tolerance: this.material.uniforms.tolerance,
                    frameCount: this.material.uniforms.frameCount,
                    projection: this.material.uniforms.projection,
                    cameraPositionWorld: this.material.uniforms.cameraPositionWorld,
                    cameraNearFar: this.material.uniforms.cameraNearFar,
                    sceneBoundingRadius: this.material.uniforms.sceneBoundingRadius
                },
                computeCacheKey: e => {
                    var t, n;
                    return this.enabled ? "1" : "0" + (null === (n = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === n ? void 0 : n.encoding)
                },
                isCompatible: e => {
                    var t;
                    return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssreflDisabled) && e.isMeshStandardMaterial2
                }
            }, this.intensity = 1, this.boost = new i.Pa4(1, 1, 1), this.objectRadius = 1, this.autoRadius = !0, this.power = 1.1, this.tolerance = .5, this.stepCount = 16, this.lowQualityFrames = 0, this.maskFrontRays = !0, this.maskFrontFactor = -.2, this._renderer = e, this._target = t, this.needsSwap = !1, this._inline = r
        }
        render(e, t, n, r, i) {
            if (this._inline) this.needsSwap = !1;
            else {
                if (!this._target) throw "Target must be set when inline = false";
                this._renderer.blit(this._target.texture, t, {}), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, n, r, i), this.needsSwap = !1
            }
        }
    };
    So([He("Intensity", [0, 4]), xe(), V()], Mo.prototype, "intensity", void 0), So([We("Boost"), xe(), V()], Mo.prototype, "boost", void 0), So([He("Object Radius", [.01, 2]), xe(), V()], Mo.prototype, "objectRadius", void 0), So([Ve("Auto radius"), xe(), V()], Mo.prototype, "autoRadius", void 0), So([He("Power", [0, 3]), xe(), V()], Mo.prototype, "power", void 0), So([He("Tolerance", [.1, 5]), xe(), V()], Mo.prototype, "tolerance", void 0), So([He("Step count", [1, 32], 1), xe(), G("SSR_STEP_COUNT")], Mo.prototype, "stepCount", void 0), So([He("Low Quality Frames", [0, 4], 1), xe(), G("SSR_LOW_QUALITY_FRAMES")], Mo.prototype, "lowQualityFrames", void 0), So([Ve("Ignore front rays"), xe(), G("SSR_MASK_FRONT_RAYS")], Mo.prototype, "maskFrontRays", void 0), So([He("Mask front rays factor", [-1, 1], .01, (e => ({
        hidden: () => !e.maskFrontRays
    }))), xe(), V()], Mo.prototype, "maskFrontFactor", void 0), Mo = So([Qe("Screen Space Reflections")], Mo);
    class To extends oo {
        constructor() {
            super(), this.dependencies = [Vs, Ys, co], this.inlineSSR = !0, this.setDirty = this.setDirty.bind(this)
        }
        get ssrTarget() {
            return this._ssrTarget
        }
        get enabled() {
            var e, t;
            return (null === (t = null === (e = this.passes.ssr) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1
        }
        set enabled(e) {
            var t;
            (null === (t = this.passes.ssr) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssr.passObject.enabled = e)
        }
        async onAdded(e) {
            var t, n;
            e.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSRPlugin"), await super.onAdded(e), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t, "postFrame", !0)
        }
        createPasses(e) {
            var t, n;
            return this._ssrTarget = this.inlineSSR ? void 0 : e.renderer.createTarget({
                sizeMultiplier: 1
            }), [Hs(e, {
                passId: "ssr",
                after: ["gbuffer"],
                before: ["render"],
                required: ["render", "gbuffer", "progressive"],
                passObject: new Mo(e.renderer, this._ssrTarget, null !== (n = null === (t = e.getPlugin(Ys)) || void 0 === t ? void 0 : t.getUnpackSnippet()) && void 0 !== n ? n : "", this.inlineSSR)
            }, (() => [e.getPlugin(Ys), e.getPlugin(co), e.scene.activeCamera, e.renderer, e.scene]))]
        }
        async onRemove(e) {
            return this._ssrTarget && e.renderer.disposeTarget(this._ssrTarget), super.onRemove(e)
        }
        setDirty() {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setDirty()
        }
        get uiConfig() {
            var e, t, n, r, i;
            const s = null !== (n = null === (t = null === (e = this.passes.ssr) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== n ? n : {};
            return null === (i = null === (r = s.children) || void 0 === r ? void 0 : r.map((e => x(e)))) || void 0 === i || i.flat(2).forEach((e => e && (e.onChange = this.setDirty))), s
        }
    }
    To.PluginType = "SSReflection";
    var Eo = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class Ao extends Ft {
        constructor(e, t, n = "rgba") {
            super({
                vertexShader: s.vertexShader,
                fragmentShader: t + "uniform vec2 tDiffuseSize;uniform vec2 bilDirection;varying vec2 vUv;uniform bool smoothEnabled;uniform float edgeSharpness;vec4 bilaterialAO(){vec4 color=clamp((texture2D(tDiffuse,vUv.xy)).B_SRC_ACCESSOR,0.,5.);if(!smoothEnabled)return color;float depth;vec3 normal;getDepthNormal(vUv.xy,depth,normal);float gaussianWeights[4];gaussianWeights[0]=0.153170;gaussianWeights[1]=0.144893;gaussianWeights[2]=0.122649;gaussianWeights[3]=0.092902;float Z=gaussianWeights[0]+0.03;vec4 final_colour=Z*color;vec2 nuv;vec4 cc;float dp;vec3 nor;vec2 direction=bilDirection/tDiffuseSize.xy;\n#pragma unroll_loop_start\nfor(int i=0;i<6;i++){direction*=-1.;nuv=vUv+2.*direction*float(UNROLLED_LOOP_INDEX/2+1);getDepthNormal(nuv,dp,nor);if(dp<0.999){float normalCloseness=dot(normal,nor);normalCloseness*=normalCloseness;float normalError=(1.-normalCloseness)*8.;float normalWeight=max((1.-normalError*edgeSharpness),0.00);float depthWeight=max(0.,1.-edgeSharpness*4000.*abs(depth-dp));float kernelWeight=gaussianWeights[UNROLLED_LOOP_INDEX/2]+0.03;float bilateralWeight=kernelWeight*depthWeight*normalWeight;Z+=bilateralWeight;cc=clamp((texture2D(tDiffuse,nuv)).B_SRC_ACCESSOR,0.,5.);final_colour+=bilateralWeight*cc;}}\n#pragma unroll_loop_end\nfinal_colour/=Z;return final_colour;}void main(){vec4 ao=clamp(bilaterialAO(),vec4(0.),vec4(1.));gl_FragColor=ao;}",
                uniforms: {
                    bilDirection: {
                        value: new i.FM8(1, 0)
                    },
                    tNormalDepth: {
                        value: null
                    },
                    tDiffuse: {
                        value: e.texture
                    },
                    tDiffuseSize: {
                        value: new i.FM8
                    }
                },
                defines: {
                    B_SRC_ACCESSOR: n
                }
            }, "tDiffuse", "tDiffuse2"), this.smoothEnabled = !0, this.edgeSharpness = .1, this._target = e, this.clear = !1, this.needsSwap = !1
        }
        render(e, t, n, r, i) {
            var s, o, a, l;
            this.enabled && (this.uniforms.bilDirection.value.set(1, 0), this.uniforms.tDiffuse.value = this._target.texture, this.uniforms.tDiffuseSize.value.set((null === (s = this.uniforms.tDiffuse.value) || void 0 === s ? void 0 : s.image.width) || 0, (null === (o = this.uniforms.tDiffuse.value) || void 0 === o ? void 0 : o.image.height) || 0), super.render(e, t, this._target, r, i), this.uniforms.bilDirection.value.set(0, 1), this.uniforms.tDiffuse.value = t.texture, this.uniforms.tDiffuseSize.value.set((null === (a = this.uniforms.tDiffuse.value) || void 0 === a ? void 0 : a.image.width) || 0, (null === (l = this.uniforms.tDiffuse.value) || void 0 === l ? void 0 : l.image.height) || 0), super.render(e, this._target, t, r, i))
        }
    }
    Eo([xe(), V()], Ao.prototype, "smoothEnabled", void 0), Eo([xe(), V()], Ao.prototype, "edgeSharpness", void 0);
    var Co = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class Ro extends Ft {
        constructor(e, t, n) {
            super({
                defines: {
                    LINEAR_DEPTH: 1,
                    NUM_SAMPLES: 11,
                    NUM_SPIRAL_TURNS: 3,
                    DEPTH_NORMAL_TEXTURE: 1,
                    DEPTH_PACKING_MODE: 2,
                    PERSPECTIVE_CAMERA: 1
                },
                uniforms: {
                    tLastThis: {
                        value: null
                    },
                    tNormalDepth: {
                        value: null
                    },
                    screenSize: {
                        value: new i.FM8(512, 512)
                    },
                    saoData: {
                        value: new i.Ltg
                    },
                    frameCount: {
                        value: 0
                    },
                    cameraNearFar: {
                        value: new i.FM8(.1, 1e3)
                    },
                    projection: {
                        value: new i.yGw
                    },
                    saoBiasEpsilon: {
                        value: new i.Pa4(1, 1, 1)
                    }
                },
                vertexShader: _o,
                fragmentShader: `\n\n${vo}\n\n${n}\n\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cameraNearFar;uniform mat4 projection;uniform sampler2D tLastThis;uniform vec4 saoData;uniform vec3 saoBiasEpsilon;uniform vec2 screenSize;const float INV_NUM_SAMPLES=1./float(NUM_SAMPLES);float getViewZFromNDCZ(const in float depth){\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 packFloatToRGB(const in float x){const vec3 code=vec3(1.,255.,65025.);vec3 pack=vec3(code*x);pack.gb=fract(pack.gb);pack.rg-=pack.gb*(1./256.);return pack;}vec3 getViewPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return vec3(xe,ye,viewDepth);}float decodeDepth(const in vec2 uv){vec4 uncodedDepth;\n#if DEPTH_PACKING_MODE == 2\nuncodedDepth=texture2D(tNormalDepth,uv);\n#else\nuncodedDepth=texture2D(tDepth,uv);\n#endif\n#if DEPTH_PACKING_MODE == 0\nreturn uncodedDepth.x;\n#elif DEPTH_PACKING_MODE == 1\n#if LINEAR_DEPTH == 1\nreturn pow2(unpackRGBAToDepth(uncodedDepth));\n#else\nreturn unpackRGBAToDepth(uncodedDepth);\n#endif\n#else\nreturn pow2(unpack16(uncodedDepth.xy));\n#endif\n}vec3 getPositionFromOffset(const in vec2 uv,const in vec2 offset,const in float screenSpaceRadius){vec2 uvOffset=uv+floor(screenSpaceRadius*offset)/screenSize;float d=decodeDepth(uvOffset);\n#if LINEAR_DEPTH == 0\nfloat centerViewZ=getViewZFromNDCZ(d);return getViewPositionFromViewZ(uvOffset,centerViewZ);\n#else\nd=mix(-cameraNearFar.x,-cameraNearFar.y,d);return getViewPositionFromViewZ(uvOffset,d);\n#endif\n}float getOcclusion(const in vec2 uv,const in int id,const in float randomAngle,const in float occlusionSphereRadius,const in vec3 centerPosition,const in vec3 centerNormal){float screenSpaceRadius=(float(id)+mod(randomAngle,1.)+0.5)*INV_NUM_SAMPLES;float angle=screenSpaceRadius*(float(NUM_SPIRAL_TURNS)*6.28)+randomAngle;screenSpaceRadius=(screenSpaceRadius*occlusionSphereRadius);vec2 offset=vec2(cos(angle),sin(angle));vec3 samplePosition=getPositionFromOffset(uv,offset,screenSpaceRadius);vec3 direction=samplePosition-centerPosition;float d2=dot(direction,direction);float ao=max((dot(centerNormal,direction)+centerPosition.z*saoBiasEpsilon.x)/(saoBiasEpsilon.z*d2+saoBiasEpsilon.y),0.);return ao;}void main(){float centerDepth;vec3 centerNormal;getDepthNormal(vUv,centerDepth,centerNormal);\n#if LINEAR_DEPTH == 0\nfloat centerViewZ=getViewZFromNDCZ(centerDepth);\n#else\nfloat centerViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,centerDepth);\n#endif\nvec3 centerPosition=getViewPositionFromViewZ(vUv,centerViewZ);float occlusionSphereScreenRadius=200.*saoData.z/(-centerPosition.z);float randomAngle=6.2*random3(vec3(vUv,frameCount*0.1));float sum=0.;sum+=getOcclusion(vUv,0,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#if NUM_SAMPLES > 1\nsum+=getOcclusion(vUv,1,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 2\nsum+=getOcclusion(vUv,2,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 3\nsum+=getOcclusion(vUv,3,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 4\nsum+=getOcclusion(vUv,4,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 5\nsum+=getOcclusion(vUv,5,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 6\nsum+=getOcclusion(vUv,6,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 7\nsum+=getOcclusion(vUv,7,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 8\nsum+=getOcclusion(vUv,8,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 9\nsum+=getOcclusion(vUv,9,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\n#if NUM_SAMPLES > 10\nsum+=getOcclusion(vUv,10,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);\n#endif\nfloat aoValue=sum*saoData.y*INV_NUM_SAMPLES;aoValue=clamp(1.-max(aoValue,0.),0.,1.);gl_FragColor.gba=packFloatToRGB(centerDepth);gl_FragColor.r=(vec4(aoValue)).r;}\n\n            `
            }, "tDiffuse"), this.parameters = {
                intensity: .25,
                occlusionWorldRadius: 1,
                bias: .001,
                falloff: 1,
                edgeSharpness: .3,
                blurEnabled: !0
            }, this._smoothEnabled = !0, this.materialExtension = {
                shaderExtender: (e, t, n) => {
                    e.defines.SSAO_ENABLED && (e.fragmentShader = e.fragmentShader.replace("#include <aomap_fragment>", "#ifndef USE_TRANSMISSION\n#if defined(SSAO_ENABLED) && SSAO_ENABLED > 0\nfloat ambientOcclusion=tSSAOMapTexelToLinear(texture2D(tSSAOMap,viewToScreen(vViewPosition.xyz).xy)).r;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\n#endif\n#endif\n"))
                },
                onObjectRender: (e, t, n) => {
                    var r, i;
                    this.materialExtension.extraUniforms.tSSAOMap.value = null === (r = this._target) || void 0 === r ? void 0 : r.texture;
                    const s = t.materialObject,
                        o = !s.transparent && s.transmission < .001;
                    let a = this.enabled && o && !1 !== n.userData.screenSpaceRendering && !(null === (i = t.materialObject.userData) || void 0 === i ? void 0 : i.ssaoDisabled) ? 1 : 0;
                    s.defines.SSAO_ENABLED !== a && (s.defines.SSAO_ENABLED = a, s.needsUpdate = !0), a = this._target.texture, this.materialExtension.extraUniforms.tSSAOMap.value !== a && (this.materialExtension.extraUniforms.tSSAOMap.value = a, s.needsUpdate = !0)
                },
                parsFragmentSnippet: e => {
                    var t;
                    return M `
             uniform sampler2D tSSAOMap;
             ${U("tSSAOMap",null===(t=this._target)||void 0===t?void 0:t.texture,e.capabilities.isWebGL2)}
            ${wo}
        `
                },
                extraUniforms: {
                    tSSAOMap: {
                        value: null
                    }
                },
                computeCacheKey: e => {
                    var t, n;
                    return this.enabled ? "1" : "0" + (null === (n = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === n ? void 0 : n.encoding)
                },
                isCompatible: e => {
                    var t;
                    return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssaoDisabled) && e.isMeshStandardMaterial2
                }
            }, this._renderer = e, this._target = t, this.needsSwap = !1, this.clear = !0, this.bilateralPass = new Ao(this._target, n, "rrrr")
        }
        get smoothEnabled() {
            return this._smoothEnabled
        }
        set smoothEnabled(e) {
            this._smoothEnabled = e, this.bilateralPass.enabled = e, this.bilateralPass.uniforms.smoothEnabled.value = e
        }
        render(e, t, n, r, i) {
            this.enabled && (this._updateParameters(), this._renderer.blit(this._target.texture, t, {}), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, n, r, i), this._smoothEnabled && this.bilateralPass.render(e, t, n, r, i))
        }
        _updateParameters() {
            const e = this.material.uniforms.saoData.value;
            e.y = this.parameters.intensity, e.z = this.parameters.occlusionWorldRadius;
            const t = this.material.uniforms.saoBiasEpsilon.value;
            t.x = this.parameters.bias, t.y = .001, t.z = this.parameters.falloff
        }
    }
    Co([xe()], Ro.prototype, "bilateralPass", void 0), Co([xe()], Ro.prototype, "parameters", void 0);
    class ko extends oo {
        constructor() {
            super(), this.dependencies = [Vs, Ys], this.setDirty = this.setDirty.bind(this)
        }
        get aoTarget() {
            return this._aoTarget
        }
        async onAdded(e) {
            return e.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSAOPlugin"), super.onAdded(e)
        }
        createPasses(e) {
            var t, n;
            return this._aoTarget = e.renderer.createTarget({
                sizeMultiplier: 1
            }), [Hs(e, {
                passId: "ssao",
                after: ["gbuffer"],
                before: ["render"],
                required: ["render", "gbuffer"],
                passObject: new Ro(e.renderer, this._aoTarget, null !== (n = null === (t = e.getPlugin(Ys)) || void 0 === t ? void 0 : t.getUnpackSnippet()) && void 0 !== n ? n : ""),
                update() {
                    this.passObject.bilateralPass.updateShaderProperties([e.getPlugin(Ys)])
                }
            }, (() => [e.getPlugin(Ys), e.scene.activeCamera, e.renderer]))]
        }
        async onRemove(e) {
            return e.renderer.disposeTarget(this._aoTarget), super.onRemove(e)
        }
        setDirty() {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setDirty()
        }
        get enabled() {
            var e, t;
            return (null === (t = null === (e = this.passes.ssao) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1
        }
        set enabled(e) {
            var t;
            (null === (t = this.passes.ssao) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssao.passObject.enabled = e)
        }
        get uiConfig() {
            var e;
            if (this._uiConfig) return this._uiConfig;
            const t = this,
                n = t.passes.ssao.passObject;
            return this._uiConfig = {
                type: "folder",
                label: "SS Ambient Occlusion",
                children: [{
                    type: "checkbox",
                    label: "Enabled",
                    property: [n, "enabled"],
                    onChange: t.setDirty
                }, {
                    type: "slider",
                    label: "Intensity",
                    bounds: [0, 4],
                    property: [n.parameters, "intensity"],
                    onChange: t.setDirty
                }, {
                    type: "slider",
                    label: "Radius",
                    bounds: [.1, 8],
                    property: [n.parameters, "occlusionWorldRadius"],
                    onChange: t.setDirty
                }, {
                    type: "slider",
                    label: "Bias",
                    bounds: [1e-5, .01],
                    property: [n.parameters, "bias"],
                    onChange: t.setDirty
                }, {
                    type: "slider",
                    label: "Falloff",
                    bounds: [.01, 3],
                    property: [n.parameters, "falloff"],
                    onChange: t.setDirty
                }, {
                    type: "slider",
                    label: "Num samples",
                    stepSize: 1,
                    bounds: [1, 11],
                    property: [null === (e = n.material) || void 0 === e ? void 0 : e.defines, "NUM_SAMPLES"],
                    onChange: [() => n.material.needsUpdate = !0, t.setDirty]
                }, {
                    type: "checkbox",
                    property: [n.bilateralPass, "smoothEnabled"],
                    onChange: t.setDirty
                }, {
                    type: "vec4",
                    property: [n.bilateralPass, "edgeSharpness"],
                    onChange: t.setDirty
                }]
            }
        }
    }
    ko.PluginType = "SSAO";
    class Po {
        constructor(e) {
            this._normalsCache = {}, this._renderer = e, this._scene = new i.xsS, this._mesh = new i.Kj0, this._mesh.frustumCulled = !1, this._scene.add(this._mesh), this._mesh.position.set(0, 0, 0), this._mesh.material = new Do
        }
        dispose() {
            this._mesh.material.dispose()
        }
        captureNormalMap(e, t, n = 512) {
            if (!e) throw "No geometry";
            if (e.userData._normalsCaptureMap) return !1;
            const r = null == t ? void 0 : t.split(";").find((e => this._normalsCache[e]));
            if (r) {
                const i = this._normalsCache[r];
                return null == t || t.split(";").forEach((e => e !== r && (this._normalsCache[e] = i))), i.width !== n && console.warn("last cacheKey normalMapRes mismatch, check model", n), e.userData._normalsCaptureMap = i, !1
            }
            const s = this._renderer.createTargetCustom({
                width: n,
                height: n
            }, {
                minFilter: i.TyD,
                magFilter: i.TyD,
                generateMipmaps: !1,
                type: i.cLu
            }, i.oAp);
            if (!s) throw "Unable to create render target";
            null == t || t.split(";").forEach((e => this._normalsCache[e] = s)), s.addEventListener("dispose", (() => delete this._normalsCache[t]));
            const o = new i._am(1e-4, 100, s);
            this._scene.add(o);
            const a = e.userData._normalsCaptureOffsets;
            return void 0 !== a.center && this._mesh.material.uniforms.offsetCenter.value.copy(a.center), void 0 !== a.offsetMatrixInv && this._mesh.material.uniforms.offsetMatrixInv.value.copy(a.offsetMatrixInv), void 0 !== a.radius && (this._mesh.material.uniforms.radius.value = a.radius), this._mesh.geometry = e, o.update(this._renderer.rendererObject, this._scene), this._scene.remove(o), this._mesh.geometry = void 0, e.userData._normalsCaptureMap = s, !0
        }
    }
    class Do extends i.jyz {
        constructor() {
            super({
                vertexShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform mat4 offsetMatrixInv;uniform vec3 offsetCenter;void main(){vNormal=normalize((offsetMatrixInv*vec4(normal,0.)).xyz);vecPosition=(modelMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.)).xyz;gl_Position=projectionMatrix*modelViewMatrix*offsetMatrixInv*vec4(position-offsetCenter,1.);}",
                fragmentShader: "varying vec3 vNormal;varying vec3 vecPosition;uniform float radius;void main(){vec3 color=normalize(vNormal);color=color*0.5+0.5;gl_FragColor=vec4(color.x,color.y,color.z,length(vecPosition)/radius);}",
                side: i.ehD,
                clipping: !1,
                uniforms: {
                    radius: {
                        value: 1
                    },
                    offsetMatrixInv: {
                        value: (new i.yGw).identity()
                    },
                    offsetCenter: {
                        value: new i.Pa4
                    }
                }
            })
        }
    }

    function Oo(e) {
        const t = new i.Pa4(0, 0, 0),
            n = new i.Pa4(0, 0, 0),
            r = new i.Pa4(0, 0, 0),
            s = new i.Pa4(0, 0, 0),
            o = e.getAttribute("position"),
            a = e.index;
        if (a)
            for (let i = Math.max(0, e.drawRange.start), l = Math.min(a.count, e.drawRange.start + e.drawRange.count) - 1; i < l / 3; i += 3) {
                const e = a.getX(i),
                    l = a.getX(i + 1),
                    c = a.getX(i + 2);
                n.set(o.getX(e), o.getY(e), o.getZ(e)), r.set(o.getX(l), o.getY(l), o.getZ(l)), s.set(o.getX(c), o.getY(c), o.getZ(c)), r.sub(n), s.sub(n), s.cross(r), s.normalize(), t.add(s)
            } else {
                const e = o.array;
                for (let i = 0; i < e.length / 3; i += 9) n.set(e[i], e[i + 1], e[i + 2]), r.set(e[i + 3], e[i + 4], e[i + 5]), s.set(e[i + 6], e[i + 7], e[i + 8]), r.sub(n), s.sub(n), s.cross(r), s.normalize(), t.add(s)
            }
        t.normalize();
        let l = !1,
            c = 0;
        for (; !l;) {
            const e = c / 3,
                i = a ? a.getX(e) : e,
                s = a ? a.getX(e + 1) : e + 1;
            n.set(o.getX(i), o.getY(i), o.getZ(i)), r.set(o.getX(s), o.getY(s), o.getZ(s)), n.sub(r), n.normalize();
            const u = t.dot(n);
            Math.abs(u - 1) > .001 && n.length() > .5 && (l = !0), c += 3
        }
        r.crossVectors(n, t), r.normalize(), n.crossVectors(t, r), n.normalize();
        const u = new i.yGw;
        u.elements[0] = n.x, u.elements[1] = n.y, u.elements[2] = n.z, u.elements[3] = 0, u.elements[4] = t.x, u.elements[5] = t.y, u.elements[6] = t.z, u.elements[7] = 0, u.elements[8] = r.x, u.elements[9] = r.y, u.elements[10] = r.z, u.elements[11] = 0, u.elements[12] = 0, u.elements[13] = 0, u.elements[14] = 0, u.elements[15] = 1, e.computeBoundingSphere();
        const p = e.boundingSphere.radius,
            h = (new i.yGw).makeScale(p, p, p);
        return u.multiply(h), u
    }
    const Lo = { ...Gt,
        color: new ve(1, 1, 1),
        envMapIntensity: 1,
        envMapRotation: 0,
        dispersion: .012,
        squashFactor: .98,
        geometryFactor: .5,
        gammaFactor: 1,
        absorptionFactor: 1,
        reflectivity: .5,
        refractiveIndex: 2.4,
        boostFactors: new i.Pa4(.892, .892, .98595025),
        envMap: null,
        wireframe: !1,
        wireframeLinewidth: 0,
        skinning: !1,
        transmission: 0,
        morphTargets: !1,
        morphNormals: !1,
        rayBounces: 1,
        diamondOrientedEnvMap: 0
    };
    var Io = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class Fo extends i.jyz {
        constructor(e) {
            super({
                side: i.ehD,
                defines: {
                    DIA_ORIENT_ENVMAP: 0,
                    RAY_BOUNCES: 5,
                    ENV_MAP_TYPE: 0,
                    PI: 3.1428
                },
                vertexShader: "#ifndef USE_ENVMAP\n#define USE_ENVMAP \n#endif\nvarying vec3 vWorldPosition;varying vec3 vWorldNormal;void main(){vWorldNormal=(modelMatrix*vec4(normal,0.)).xyz;\n#include <begin_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\nvWorldPosition=worldPosition.xyz;}",
                fragmentShader: "varying vec3 vWorldNormal;varying vec3 vWorldPosition;uniform samplerCube tCubeMapNormals;\n#if ENV_MAP_TYPE == 0\nuniform samplerCube envMap;\n#elif ENV_MAP_TYPE == 1\nuniform sampler2D envMap;\n#endif\nuniform float envMapIntensity;uniform mat4 modelMatrix;uniform mat4 inverseModelMatrix;uniform mat4 offsetMatrixInv;uniform mat4 offsetMatrix;uniform float transmission;uniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform float refractiveIndex;uniform float radius;uniform float rIndexDelta;uniform float squashFactor;uniform float geometryFactor;uniform vec3 color;uniform vec3 colorCorrection;uniform vec3 boostFactors;uniform vec3 centerOffset;uniform float gammaFactor;uniform float absorptionFactor;uniform float envMapRotation;uniform float reflectivity;vec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float roughness){float dotNV=abs(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec2 cartesianToPolar(vec3 n){vec2 uv;uv.x=atan(n.z,n.x)/(PI*2.)+0.5;uv.y=asin(n.y)/PI+0.5;return uv;}vec4 sampleEnvMap(vec3 direction){\n#if !defined(USE_ENVMAP)\nreturn vec4(direction,1);\n#else\nfloat cs=cos(envMapRotation);float sn=sin(envMapRotation);float temp=cs*direction.x+sn*direction.z;direction.z=-sn*direction.x+cs*direction.z;direction.x=temp;direction.x*=-1.;direction.z*=-1.;\n#if ENV_MAP_TYPE == 0\nreturn(textureCube(envMap,direction));\n#elif ENV_MAP_TYPE == 1\nreturn(texture2D(envMap,cartesianToPolar(direction)));\n#endif\nreturn vec4(1,0,1,1);\n#endif\n}vec4 SampleSpecularReflection(vec3 direction){return envMapIntensity*(sampleEnvMap(direction));}uniform mat4 projectionMatrix;vec4 SampleSpecularContribution(vec3 direction){direction=normalize(direction);direction.x*=-1.;direction.z*=-1.;return envMapIntensity*(sampleEnvMap(direction));}vec4 SampleSpecularContributionRef(vec3 origin,int i){vec4 ndcPos=projectionMatrix*viewMatrix*vec4(origin,1.);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.;refractionCoords/=2.;return transmissionSamplerMapTexelToLinear(texture2D(transmissionSamplerMap,refractionCoords));}vec3 intersectSphere(vec3 origin,vec3 direction){origin-=centerOffset;direction.y/=squashFactor;float A=dot(direction,direction);float B=2.*dot(origin,direction);float C=dot(origin,origin)-radius*radius;float disc=B*B-4.*A*C;if(disc>0.){disc=sqrt(disc);float t1=(-B+disc)*geometryFactor/A;float t2=(-B-disc)*geometryFactor/A;float t=(t1>t2)?t1:t2;direction.y*=squashFactor;return vec3(origin+centerOffset+direction*t);}return vec3(0.);}vec3 linePlaneIntersect(in vec3 pointOnLine,in vec3 lineDirection,in vec3 pointOnPlane,in vec3 planeNormal){return lineDirection*(dot(planeNormal,pointOnPlane-pointOnLine)/dot(planeNormal,lineDirection))+pointOnLine;}vec4 getNormalDistance(vec3 d){return textureCube(tCubeMapNormals,d);}vec3 getSurfaceNormal(vec4 surfaceInfos){vec3 surfaceNormal=surfaceInfos.rgb;surfaceNormal=surfaceNormal*2.-1.;return-normalize(surfaceNormal);}vec3 intersect(vec3 rayOrigin,vec3 rayDirection){vec3 sphereHitPoint=intersectSphere(rayOrigin,rayDirection);vec3 direction1=normalize(sphereHitPoint-centerOffset);vec4 normalDistanceData1=getNormalDistance(direction1);float distance1=normalDistanceData1.a*radius;vec3 pointOnPlane1=centerOffset+direction1*distance1;vec3 planeNormal1=getSurfaceNormal(normalDistanceData1);vec3 hitPoint1=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane1,planeNormal1);vec3 direction2=normalize(hitPoint1-centerOffset);vec4 normalDistanceData2=getNormalDistance(direction2);float distance2=normalDistanceData2.a*radius;vec3 pointOnPlane2=centerOffset+direction2*distance2;vec3 hitPoint=hitPoint1;vec3 planeNormal2=getSurfaceNormal(normalDistanceData2);hitPoint=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane2,planeNormal2);return hitPoint;}vec3 debugBounces(int count){vec3 color=vec3(1.,1.,1.);if(count==1)color=vec3(0.,1.,0.);else if(count==2)color=vec3(0.,0.,1.);else if(count==3)color=vec3(1.,1.,0.);else if(count==4)color=vec3(0.,1.,1.);else color=vec3(0.,1.,0.);if(count==0)color=vec3(1.,0.,0.);return color;}vec3 traceRay(vec3 origin,vec3 direction,vec3 normal){vec3 outColor=vec3(0.);const float n1=1.;const float epsilon=1e-4;float f0=(2.4-n1)/(2.4+n1);f0*=f0;vec3 attenuationFactor=vec3(1.);vec3 newDirection=refract(direction,normal,n1/refractiveIndex);vec3 reflectedDirection=reflect(direction,normal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(reflectedDirection,normal,vec3(f0),0.);vec3 brdfRefracted=BRDF_Specular_GGX_Environment(newDirection,-normal,vec3(f0),0.);attenuationFactor*=(vec3(1.)-brdfRefracted);outColor+=SampleSpecularReflection(reflectedDirection).rgb*brdfReflected*reflectivity*2.;int count=0;newDirection=(offsetMatrixInv*inverseModelMatrix*vec4(newDirection,0.)).xyz;newDirection=normalize(newDirection);origin=(offsetMatrixInv*inverseModelMatrix*vec4(origin,1.)).xyz;vec3 origin2=origin;origin2=(modelMatrix*offsetMatrix*vec4(origin2,1.)).xyz;for(int i=0;i<RAY_BOUNCES;i++){vec3 intersectedPos=intersect(origin,newDirection);vec3 dist=intersectedPos-origin;vec3 d=normalize(intersectedPos-centerOffset);vec3 mappedNormal=getNormalDistance(d).rgb;mappedNormal=2.*mappedNormal-1.;mappedNormal=-normalize(mappedNormal);float r=length(dist)/radius*absorptionFactor;attenuationFactor*=exp(-r*(1.-color));origin=intersectedPos;origin2=(modelMatrix*offsetMatrix*vec4(intersectedPos,1.)).xyz;vec3 oldDir=newDirection;newDirection=refract(newDirection,mappedNormal,refractiveIndex/n1);if(dot(newDirection,newDirection)<epsilon){newDirection=reflect(oldDir,mappedNormal);if(i==RAY_BOUNCES-1){vec3 brdfReflected=BRDF_Specular_GGX_Environment(-oldDir,mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(oldDir,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);outColor+=((transmission>0.&&cosT<transmission)?SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb:SampleSpecularContribution(DIA_ORIENT_ENVMAP<1?d1:newDirection).rgb)*attenuationFactor*colorCorrection*boostFactors*(vec3(1.)-brdfReflected);}}else{vec3 brdfRefracted=vec3(1.)-BRDF_Specular_GGX_Environment(newDirection,-mappedNormal,vec3(f0),0.);vec3 d1=(modelMatrix*offsetMatrix*vec4(newDirection,0.)).xyz;d1=normalize(d1);float cosT=1.-dot(direction,d1);if(transmission>0.&&cosT<transmission){outColor+=SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}else{vec3 dir0=newDirection;vec3 dir1=refract(oldDir,mappedNormal,(refractiveIndex+rIndexDelta)/n1);vec3 dir2=refract(oldDir,mappedNormal,(refractiveIndex-rIndexDelta)/n1);\n#if DIA_ORIENT_ENVMAP < 1\ndir0=d1;dir1=(modelMatrix*offsetMatrix*vec4(dir1,0.)).xyz;dir2=(modelMatrix*offsetMatrix*vec4(dir2,0.)).xyz;\n#endif\noutColor+=vec3(SampleSpecularContribution(dir1).r,SampleSpecularContribution(dir0).g,SampleSpecularContribution(dir2).b)*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}newDirection=reflect(oldDir,mappedNormal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(newDirection,mappedNormal,vec3(f0),0.);attenuationFactor*=brdfReflected*boostFactors;count++;}}return outColor;}void main(){vec3 normalizedNormal=normalize(vWorldNormal);vec3 viewVector=normalize(vWorldPosition-cameraPosition);vec3 color=traceRay(vWorldPosition,viewVector,normalizedNormal);gl_FragColor=vec4(color.rgb,1.);\n#include <encodings_fragment>\n}",
                uniforms: {
                    envMap: {
                        value: e.envMap || null
                    },
                    envMapRotation: {
                        value: 0
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new i.FM8
                    },
                    normalOffset: {
                        value: 0
                    },
                    distanceOffset: {
                        value: 0
                    },
                    colorCorrection: {
                        value: new i.Pa4(1, 1, 1)
                    }
                }
            }), this.typeSlug = Fo.TypeSlug, this.assetType = "material", this._envMap = null, this.isDiamondMaterial = !0, this.color = new ve(1, 1, 1), this.envMapIntensity = 1, this.dispersion = .012, this.absorptionFactor = 1, this.refractiveIndex = 2.4, this.squashFactor = .98, this.geometryFactor = .5, this.gammaFactor = 1, this.boostFactors = new i.Pa4(.892, .892, .98595025), this.transmission = 0, this.reflectivity = .5, this.rayBounces = 5, this.diamondOrientedEnvMap = 0, this.normalsCaptureMap = null, this.extraUniformsToUpload = {
                inverseModelMatrix: {
                    value: (new i.yGw).identity()
                },
                radius: {
                    value: 1
                },
                centerOffset: {
                    value: new i.Pa4(0, 0, 0)
                },
                offsetMatrix: {
                    value: (new i.yGw).identity()
                },
                offsetMatrixInv: {
                    value: (new i.yGw).identity()
                }
            }, this.userData.setDirty = () => {
                var e, t;
                this.needsUpdate = !0, this.dispatchEvent({
                    type: "materialUpdate"
                }), null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0)
            }, this.userData.separateEnvMapIntensity = !0, this.setValues(e)
        }
        get mmMaterial() {
            return this
        }
        get materialObject() {
            return this
        }
        onBeforeRender(e, t, n, r, i) {
            var s, o;
            super.onBeforeRender(e, t, n, r, i), this.uniforms.envMapRotation.value = (null === (s = this.envMap) || void 0 === s ? void 0 : s.rotation) || 0, this.extraUniformsToUpload.inverseModelMatrix.value.copy(i.matrixWorld).invert();
            const a = r.userData._normalsCaptureOffsets;
            a && (this.extraUniformsToUpload.centerOffset.value.copy(a.centerOffset), this.extraUniformsToUpload.offsetMatrix.value.copy(a.offsetMatrix), this.extraUniformsToUpload.offsetMatrixInv.value.copy(a.offsetMatrixInv), this.extraUniformsToUpload.radius.value = a.radius);
            const l = null === (o = r.userData._normalsCaptureMap) || void 0 === o ? void 0 : o.texture;
            this.normalsCaptureMap !== l && (this.normalsCaptureMap = l)
        }
        set envMap(e) {
            var t;
            this._envMap = e, this.uniforms.envMap.value = this._envMap, (null === (t = this._envMap) || void 0 === t ? void 0 : t.isCubeTexture) ? (this.defines.ENV_MAP_TYPE = 0, this.needsUpdate = !0) : (this.defines.ENV_MAP_TYPE = 1, this.needsUpdate = !0)
        }
        get envMap() {
            return this._envMap
        }
        clone() {
            return super.clone()
        }
        toJSON(e) {
            const t = {};
            return t.name = this.name, t.uuid = this.uuid, t.color = this.color.getHex(), t.envMapIntensity = this.envMapIntensity, t.dispersion = this.dispersion, t.squashFactor = this.squashFactor, t.geometryFactor = this.geometryFactor, t.gammaFactor = this.gammaFactor, t.absorptionFactor = this.absorptionFactor, t.reflectivity = this.reflectivity, t.refractiveIndex = this.refractiveIndex, t.rayBounces = this.rayBounces, t.diamondOrientedEnvMap = this.diamondOrientedEnvMap, t.boostFactors = {
                x: this.boostFactors.x,
                y: this.boostFactors.y,
                z: this.boostFactors.z,
                isVector3: !0
            }, t.transmission = this.transmission, t.isDiamondMaterialParameters = !0, t.type = Fo.TYPE, t.userData = {}, qt(t.userData, this.userData), t.userData.uuid = this.userData.uuid, t
        }
        get uiConfig() {
            const e = this;
            return this._uiConfigChildren || (this._uiConfigChildren = [{
                type: "input",
                property: [this, "name"]
            }, {
                type: "checkbox",
                property: [this, "wireframe"]
            }, ...Je(this), {
                type: "input",
                label: "Mesh count",
                get value() {
                    var t, n, r;
                    return null !== (r = null === (n = null === (t = e.userData) || void 0 === t ? void 0 : t.appliedMeshes) || void 0 === n ? void 0 : n.size) && void 0 !== r ? r : 0
                },
                set value(e) {},
                disabled: !0
            }, {
                type: "input",
                label: "uuid",
                get value() {
                    return e.uuid
                },
                set value(e) {},
                disabled: !0
            }, {
                type: "checkbox",
                label: "Render to Depth",
                hidden: () => 0 === this.transmission,
                get value() {
                    return !0 === e.userData.renderToDepth
                },
                set value(t) {
                    e.userData.renderToDepth = t || void 0
                }
            }, {
                type: "button",
                label: "Download .dmat",
                value: () => {
                    vt(new Blob([JSON.stringify(e.toJSON(), null, 2)], {
                        type: "application/json"
                    }), "diamond-material.dmat")
                }
            }]), this._uiConfig || (this._uiConfig = {
                type: "folder",
                label: "Diamond Material",
                expanded: !0,
                children: this._uiConfigChildren,
                limitedUi: !0
            }), this._uiConfig
        }
        copyProps(e) {
            var t, n;
            if (!e.isDiamondMaterialParameters && !e.isDiamondMaterial && !e.isDiamond) return console.warn("Material type is not supported", e), this;
            const r = {};
            y(e, r, Array.from(Object.keys(Lo)));
            const i = r.userData;
            return delete r.userData, this.setValues(r), qt(this.userData, i), null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t), this
        }
        fromJSON(e, t) {
            return this.copyProps(e)
        }
    }
    Fo.TypeSlug = "dmat", Fo.TYPE = "DiamondMaterial", Io([Ye("Color", {
        limitedUi: !0
    }), V()], Fo.prototype, "color", void 0), Io([He("Env Intensity", [0, 5], .01, {
        limitedUi: !0
    }), V()], Fo.prototype, "envMapIntensity", void 0), Io([He("Dispersion", [0, .1], 1e-4, {
        limitedUi: !0
    }), V({
        propKey: "rIndexDelta"
    })], Fo.prototype, "dispersion", void 0), Io([He("Absorption", [0, 15], .01, {
        limitedUi: !0
    }), V()], Fo.prototype, "absorptionFactor", void 0), Io([He("Refractive Index", [0, 4], .01, {
        limitedUi: !0
    }), V()], Fo.prototype, "refractiveIndex", void 0), Io([V()], Fo.prototype, "squashFactor", void 0), Io([V()], Fo.prototype, "geometryFactor", void 0), Io([V()], Fo.prototype, "gammaFactor", void 0), Io([We("RGB Boost", void 0, void 0, {
        limitedUi: !0
    }), V()], Fo.prototype, "boostFactors", void 0), Io([He("Transmission", [0, 1], .01, {
        limitedUi: !0
    }), V()], Fo.prototype, "transmission", void 0), Io([He("Reflectivity", [0, 2], .01, {
        limitedUi: !0
    }), V()], Fo.prototype, "reflectivity", void 0), Io([G("RAY_BOUNCES", void 0, !0), He("Ray Bounces", [1, 16], 1)], Fo.prototype, "rayBounces", void 0), Io([G("DIA_ORIENT_ENVMAP", void 0, !0), He("Diamond Oriented Lighting", [0, 1], 1)], Fo.prototype, "diamondOrientedEnvMap", void 0), Io([V({
        propKey: "tCubeMapNormals"
    })], Fo.prototype, "normalsCaptureMap", void 0);
    class No extends r {
        constructor(e, t, n, r) {
            super(), this._scene = e, this._camera = null != n ? n : this._scene.activeCamera, this.domElement = t, this._time = this.time, this._mouseDownTime = 0, this._mouseUpTime = 1, this.selectionCondition = null != r ? r : e => !1 !== e.userData.userSelectable && !1 !== e.userData.bboxVisible && null != e.material && "ShadowMaterial" !== e.material.type, this.raycaster = new i.iMs, this.mouse = new i.FM8, this._selected = [], this._hovering = [], this.cursorStyles = {
                default: "grab",
                down: "grabbing"
            }, this._activeCameraChange = this._activeCameraChange.bind(this), this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.domElement.style.touchAction = "none", this.domElement.style.cursor = this.cursorStyles.default, this.domElement.addEventListener("pointermove", (e => this.onPointerMove(e))), this.domElement.addEventListener("pointerleave", (e => this.onPointerLeave(e))), this.domElement.addEventListener("pointerout", (e => this.onPointerLeave(e))), this.domElement.addEventListener("pointercancel", (e => this.onPointerCancel(e))), this.domElement.addEventListener("pointerenter", (e => this.onPointerEnter(e))), this.domElement.addEventListener("pointerdown", (e => this.onPointerDown(e))), this.domElement.addEventListener("pointerup", (e => this.onPointerUp(e)))
        }
        get scene() {
            return this._scene
        }
        set scene(e) {
            var t;
            null === (t = this._scene) || void 0 === t || t.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene = e, this._scene.addEventListener("activeCameraChange", this._activeCameraChange)
        }
        _activeCameraChange() {
            this.camera = this._scene.activeCamera
        }
        get camera() {
            return this._camera
        }
        set camera(e) {
            this._camera = e
        }
        get selectedObject() {
            return this._selected.length > 0 ? this._selected[0] : null
        }
        set selectedObject(e) {
            1 === this._selected.length && this._selected[0] === e || (this._selected = e ? Array.isArray(e) ? [...e] : [e] : [], this.refreshOutlinePass(), this.dispatchEvent({
                type: "selectedObjectChanged",
                object: this.selectedObject
            }))
        }
        get hoverObject() {
            return this._hovering.length > 0 ? this._hovering[0] : null
        }
        set hoverObject(e) {
            this._hovering = e ? Array.isArray(e) ? [...e] : [e] : [], this.refreshOutlinePass(), this.dispatchEvent({
                type: "hoverObjectChanged",
                object: this.hoverObject
            })
        }
        get time() {
            return this._time = Ct(), this._time
        }
        get isMouseDown() {
            return this.mouseDownDeltaTime < 0
        }
        get mouseDownDeltaTime() {
            return this._mouseUpTime - this._mouseDownTime
        }
        onPointerMove(e) {
            !1 !== e.isPrimary && this.updateMouseFromEvent(e)
        }
        onPointerLeave(e) {
            !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this.hoverObject = null)
        }
        onPointerEnter(e) {}
        onPointerCancel(e) {}
        updateMouseFromEvent(e) {
            const t = this.domElement.getBoundingClientRect();
            this.mouse.x = (e.clientX - t.x) / t.width * 2 - 1, this.mouse.y = -(e.clientY - t.y) / t.height * 2 + 1
        }
        onPointerDown(e) {
            !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.down, this._mouseDownTime = this.time)
        }
        onPointerUp(e) {
            !1 !== e.isPrimary && (this.domElement.style.cursor = this.cursorStyles.default, this._mouseUpTime = this.time, this.mouseDownDeltaTime < 200 && this.onPointerClick(e))
        }
        onPointerClick(e) {
            if (!1 === e.isPrimary) return;
            this.updateMouseFromEvent(e);
            const t = this.checkIntersection();
            t && this.dispatchEvent({
                type: "hitObject",
                time: this._mouseUpTime,
                intersects: t
            }), this.selectedObject = (null == t ? void 0 : t.selectedObject) || null
        }
        addPasses() {}
        checkIntersection() {
            var e;
            const t = null === (e = this._camera) || void 0 === e ? void 0 : e.cameraObject;
            if (!t) return null;
            this.raycaster.setFromCamera(this.mouse, t);
            const n = this.raycaster.intersectObject(this._scene.modelObject, !0),
                r = this.selectedObject;
            if (r) {
                const e = n.length - 1 - [...n].reverse().findIndex((e => {
                    let t = e.object;
                    for (; t;) {
                        if (e.object === r) return !0;
                        t = t.parent
                    }
                    return !1
                }));
                e >= 0 && n.splice(0, e + 1)
            }
            if (n.length > 0) {
                for (const e of n) {
                    let t = e.object;
                    for (; !(null == t || t.visible && this.selectionCondition(t));) t = t.parent;
                    if (t) return {
                        selectedObject: t,
                        intersect: e,
                        intersects: n,
                        mouse: this.mouse.toArray()
                    }
                }
                return null
            }
            return null
        }
        refreshOutlinePass() {
            var e;
            null !== (e = this.hoverObject) && void 0 !== e || this.selectedObject
        }
        isHovering() {
            return null != this.hoverObject
        }
        isSelected() {
            return null != this.selectedObject
        }
    }
    const Uo = new i.iMs,
        Bo = new i.Pa4,
        jo = new i.Pa4,
        zo = new i._fP,
        Vo = {
            X: new i.Pa4(1, 0, 0),
            Y: new i.Pa4(0, 1, 0),
            Z: new i.Pa4(0, 0, 1)
        },
        Go = {
            type: "change"
        },
        Ho = {
            type: "mouseDown"
        },
        Wo = {
            type: "mouseUp",
            mode: null
        },
        Ko = {
            type: "objectChange"
        };
    class Xo extends i.Tme {
        constructor(e, t) {
            super(), void 0 === t && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
            const n = new fa;
            this._gizmo = n, this.add(n);
            const r = new _a;
            this._plane = r, this.add(r);
            const s = this;

            function o(e, t) {
                let i = t;
                Object.defineProperty(s, e, {
                    get: function() {
                        return void 0 !== i ? i : t
                    },
                    set: function(t) {
                        i !== t && (i = t, r[e] = t, n[e] = t, s.dispatchEvent({
                            type: e + "-changed",
                            value: t
                        }), s.dispatchEvent(Go))
                    }
                }), s[e] = t, r[e] = t, n[e] = t
            }
            o("camera", e), o("object", void 0), o("enabled", !0), o("axis", null), o("mode", "translate"), o("translationSnap", null), o("rotationSnap", null), o("scaleSnap", null), o("space", "world"), o("size", 1), o("dragging", !1), o("showX", !0), o("showY", !0), o("showZ", !0);
            const a = new i.Pa4,
                l = new i.Pa4,
                c = new i._fP,
                u = new i._fP,
                p = new i.Pa4,
                h = new i._fP,
                d = new i.Pa4,
                f = new i.Pa4,
                _ = new i.Pa4,
                m = new i.Pa4;
            o("worldPosition", a), o("worldPositionStart", l), o("worldQuaternion", c), o("worldQuaternionStart", u), o("cameraPosition", p), o("cameraQuaternion", h), o("pointStart", d), o("pointEnd", f), o("rotationAxis", _), o("rotationAngle", 0), o("eye", m), this._offset = new i.Pa4, this._startNorm = new i.Pa4, this._endNorm = new i.Pa4, this._cameraScale = new i.Pa4, this._parentPosition = new i.Pa4, this._parentQuaternion = new i._fP, this._parentQuaternionInv = new i._fP, this._parentScale = new i.Pa4, this._worldScaleStart = new i.Pa4, this._worldQuaternionInv = new i._fP, this._worldScale = new i.Pa4, this._positionStart = new i.Pa4, this._quaternionStart = new i._fP, this._scaleStart = new i.Pa4, this._getPointer = qo.bind(this), this._onPointerDown = Zo.bind(this), this._onPointerHover = Yo.bind(this), this._onPointerMove = Jo.bind(this), this._onPointerUp = $o.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp)
        }
        updateMatrixWorld() {
            void 0 !== this.object && (this.object.updateMatrixWorld(), null === this.object.parent ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye) : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this)
        }
        pointerHover(e) {
            if (void 0 === this.object || !0 === this.dragging) return;
            Uo.setFromCamera(e, this.camera);
            const t = Qo(this._gizmo.picker[this.mode], Uo);
            this.axis = t ? t.object.name : null
        }
        pointerDown(e) {
            if (void 0 !== this.object && !0 !== this.dragging && 0 === e.button && null !== this.axis) {
                Uo.setFromCamera(e, this.camera);
                const t = Qo(this._plane, Uo, !0);
                t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, Ho.mode = this.mode, this.dispatchEvent(Ho)
            }
        }
        pointerMove(e) {
            const t = this.axis,
                n = this.mode,
                r = this.object;
            let i = this.space;
            if ("scale" === n ? i = "local" : "E" !== t && "XYZE" !== t && "XYZ" !== t || (i = "world"), void 0 === r || null === t || !1 === this.dragging || -1 !== e.button) return;
            Uo.setFromCamera(e, this.camera);
            const s = Qo(this._plane, Uo, !0);
            if (s) {
                if (this.pointEnd.copy(s.point).sub(this.worldPositionStart), "translate" === n) this._offset.copy(this.pointEnd).sub(this.pointStart), "local" === i && "XYZ" !== t && this._offset.applyQuaternion(this._worldQuaternionInv), -1 === t.indexOf("X") && (this._offset.x = 0), -1 === t.indexOf("Y") && (this._offset.y = 0), -1 === t.indexOf("Z") && (this._offset.z = 0), "local" === i && "XYZ" !== t ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r.position.copy(this._offset).add(this._positionStart), this.translationSnap && ("local" === i && (r.position.applyQuaternion(zo.copy(this._quaternionStart).invert()), -1 !== t.search("X") && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)), "world" === i && (r.parent && r.position.add(Bo.setFromMatrixPosition(r.parent.matrixWorld)), -1 !== t.search("X") && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(Bo.setFromMatrixPosition(r.parent.matrixWorld))));
                else if ("scale" === n) {
                    if (-1 !== t.search("XYZ")) {
                        let e = this.pointEnd.length() / this.pointStart.length();
                        this.pointEnd.dot(this.pointStart) < 0 && (e *= -1), jo.set(e, e, e)
                    } else Bo.copy(this.pointStart), jo.copy(this.pointEnd), Bo.applyQuaternion(this._worldQuaternionInv), jo.applyQuaternion(this._worldQuaternionInv), jo.divide(Bo), -1 === t.search("X") && (jo.x = 1), -1 === t.search("Y") && (jo.y = 1), -1 === t.search("Z") && (jo.z = 1);
                    r.scale.copy(this._scaleStart).multiply(jo), this.scaleSnap && (-1 !== t.search("X") && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Y") && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Z") && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap))
                } else if ("rotate" === n) {
                    this._offset.copy(this.pointEnd).sub(this.pointStart);
                    const e = 20 / this.worldPosition.distanceTo(Bo.setFromMatrixPosition(this.camera.matrixWorld));
                    "E" === t ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : "XYZE" === t ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Bo.copy(this.rotationAxis).cross(this.eye)) * e) : "X" !== t && "Y" !== t && "Z" !== t || (this.rotationAxis.copy(Vo[t]), Bo.copy(Vo[t]), "local" === i && Bo.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(Bo.cross(this.eye).normalize()) * e), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), "local" === i && "E" !== t && "XYZE" !== t ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(zo.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(zo.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize())
                }
                this.dispatchEvent(Go), this.dispatchEvent(Ko)
            }
        }
        pointerUp(e) {
            0 === e.button && (this.dragging && null !== this.axis && (Wo.mode = this.mode, this.dispatchEvent(Wo)), this.dragging = !1, this.axis = null)
        }
        dispose() {
            this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse((function(e) {
                e.geometry && e.geometry.dispose(), e.material && e.material.dispose()
            }))
        }
        attach(e) {
            return this.object = e, this.visible = !0, this
        }
        detach() {
            return this.object = void 0, this.visible = !1, this.axis = null, this
        }
        reset() {
            this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Go), this.dispatchEvent(Ko), this.pointStart.copy(this.pointEnd))
        }
        getRaycaster() {
            return Uo
        }
        getMode() {
            return this.mode
        }
        setMode(e) {
            this.mode = e
        }
        setTranslationSnap(e) {
            this.translationSnap = e
        }
        setRotationSnap(e) {
            this.rotationSnap = e
        }
        setScaleSnap(e) {
            this.scaleSnap = e
        }
        setSize(e) {
            this.size = e
        }
        setSpace(e) {
            this.space = e
        }
        update() {
            console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")
        }
    }

    function qo(e) {
        if (this.domElement.ownerDocument.pointerLockElement) return {
            x: 0,
            y: 0,
            button: e.button
        }; {
            const t = this.domElement.getBoundingClientRect();
            return {
                x: (e.clientX - t.left) / t.width * 2 - 1,
                y: -(e.clientY - t.top) / t.height * 2 + 1,
                button: e.button
            }
        }
    }

    function Yo(e) {
        if (this.enabled) switch (e.pointerType) {
            case "mouse":
            case "pen":
                this.pointerHover(this._getPointer(e))
        }
    }

    function Zo(e) {
        this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(e.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(e)), this.pointerDown(this._getPointer(e)))
    }

    function Jo(e) {
        this.enabled && this.pointerMove(this._getPointer(e))
    }

    function $o(e) {
        this.enabled && (this.domElement.releasePointerCapture(e.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(e)))
    }

    function Qo(e, t, n) {
        const r = t.intersectObject(e, !0);
        for (let e = 0; e < r.length; e++)
            if (r[e].object.visible || n) return r[e];
        return !1
    }
    const ea = new i.USm,
        ta = new i.Pa4(0, 1, 0),
        na = new i.Pa4(0, 0, 0),
        ra = new i.yGw,
        ia = new i._fP,
        sa = new i._fP,
        oa = new i.Pa4,
        aa = new i.yGw,
        la = new i.Pa4(1, 0, 0),
        ca = new i.Pa4(0, 1, 0),
        ua = new i.Pa4(0, 0, 1),
        pa = new i.Pa4,
        ha = new i.Pa4,
        da = new i.Pa4;
    class fa extends i.Tme {
        constructor() {
            super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
            const e = new i.vBJ({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                    toneMapped: !1,
                    transparent: !0
                }),
                t = new i.nls({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                    toneMapped: !1,
                    transparent: !0
                }),
                n = e.clone();
            n.opacity = .15;
            const r = t.clone();
            r.opacity = .5;
            const s = e.clone();
            s.color.setHex(16711680);
            const o = e.clone();
            o.color.setHex(65280);
            const a = e.clone();
            a.color.setHex(255);
            const l = e.clone();
            l.color.setHex(16711680), l.opacity = .5;
            const c = e.clone();
            c.color.setHex(65280), c.opacity = .5;
            const u = e.clone();
            u.color.setHex(255), u.opacity = .5;
            const p = e.clone();
            p.opacity = .25;
            const h = e.clone();
            h.color.setHex(16776960), h.opacity = .25, e.clone().color.setHex(16776960);
            const d = e.clone();
            d.color.setHex(7895160);
            const f = new i.fHI(0, .04, .1, 12);
            f.translate(0, .05, 0);
            const _ = new i.DvJ(.08, .08, .08);
            _.translate(0, .04, 0);
            const m = new i.u9r;
            m.setAttribute("position", new i.a$l([0, 0, 0, 1, 0, 0], 3));
            const g = new i.fHI(.0075, .0075, .5, 3);

            function v(e, t) {
                const n = new i.XvJ(e, .0075, 3, 64, t * Math.PI * 2);
                return n.rotateY(Math.PI / 2), n.rotateX(Math.PI / 2), n
            }
            g.translate(0, .25, 0);
            const b = {
                    X: [
                        [new i.Kj0(f, s), [.5, 0, 0],
                            [0, 0, -Math.PI / 2]
                        ],
                        [new i.Kj0(f, s), [-.5, 0, 0],
                            [0, 0, Math.PI / 2]
                        ],
                        [new i.Kj0(g, s), [0, 0, 0],
                            [0, 0, -Math.PI / 2]
                        ]
                    ],
                    Y: [
                        [new i.Kj0(f, o), [0, .5, 0]],
                        [new i.Kj0(f, o), [0, -.5, 0],
                            [Math.PI, 0, 0]
                        ],
                        [new i.Kj0(g, o)]
                    ],
                    Z: [
                        [new i.Kj0(f, a), [0, 0, .5],
                            [Math.PI / 2, 0, 0]
                        ],
                        [new i.Kj0(f, a), [0, 0, -.5],
                            [-Math.PI / 2, 0, 0]
                        ],
                        [new i.Kj0(g, a), null, [Math.PI / 2, 0, 0]]
                    ],
                    XYZ: [
                        [new i.Kj0(new i.pQR(.1, 0), p.clone()), [0, 0, 0]]
                    ],
                    XY: [
                        [new i.Kj0(new i.DvJ(.15, .15, .01), u.clone()), [.15, .15, 0]]
                    ],
                    YZ: [
                        [new i.Kj0(new i.DvJ(.15, .15, .01), l.clone()), [0, .15, .15],
                            [0, Math.PI / 2, 0]
                        ]
                    ],
                    XZ: [
                        [new i.Kj0(new i.DvJ(.15, .15, .01), c.clone()), [.15, 0, .15],
                            [-Math.PI / 2, 0, 0]
                        ]
                    ]
                },
                x = {
                    X: [
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [.3, 0, 0],
                            [0, 0, -Math.PI / 2]
                        ],
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [-.3, 0, 0],
                            [0, 0, Math.PI / 2]
                        ]
                    ],
                    Y: [
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, .3, 0]],
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, -.3, 0],
                            [0, 0, Math.PI]
                        ]
                    ],
                    Z: [
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, .3],
                            [Math.PI / 2, 0, 0]
                        ],
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, -.3],
                            [-Math.PI / 2, 0, 0]
                        ]
                    ],
                    XYZ: [
                        [new i.Kj0(new i.pQR(.2, 0), n)]
                    ],
                    XY: [
                        [new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, .15, 0]]
                    ],
                    YZ: [
                        [new i.Kj0(new i.DvJ(.2, .2, .01), n), [0, .15, .15],
                            [0, Math.PI / 2, 0]
                        ]
                    ],
                    XZ: [
                        [new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, 0, .15],
                            [-Math.PI / 2, 0, 0]
                        ]
                    ]
                },
                y = {
                    START: [
                        [new i.Kj0(new i.pQR(.01, 2), r), null, null, null, "helper"]
                    ],
                    END: [
                        [new i.Kj0(new i.pQR(.01, 2), r), null, null, null, "helper"]
                    ],
                    DELTA: [
                        [new i.x12(function() {
                            const e = new i.u9r;
                            return e.setAttribute("position", new i.a$l([0, 0, 0, 1, 1, 1], 3)), e
                        }(), r), null, null, null, "helper"]
                    ],
                    X: [
                        [new i.x12(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
                    ],
                    Y: [
                        [new i.x12(m, r.clone()), [0, -1e3, 0],
                            [0, 0, Math.PI / 2],
                            [1e6, 1, 1], "helper"
                        ]
                    ],
                    Z: [
                        [new i.x12(m, r.clone()), [0, 0, -1e3],
                            [0, -Math.PI / 2, 0],
                            [1e6, 1, 1], "helper"
                        ]
                    ]
                },
                w = {
                    XYZE: [
                        [new i.Kj0(v(.5, 1), d), null, [0, Math.PI / 2, 0]]
                    ],
                    X: [
                        [new i.Kj0(v(.5, .5), s)]
                    ],
                    Y: [
                        [new i.Kj0(v(.5, .5), o), null, [0, 0, -Math.PI / 2]]
                    ],
                    Z: [
                        [new i.Kj0(v(.5, .5), a), null, [0, Math.PI / 2, 0]]
                    ],
                    E: [
                        [new i.Kj0(v(.75, 1), h), null, [0, Math.PI / 2, 0]]
                    ]
                },
                S = {
                    AXIS: [
                        [new i.x12(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
                    ]
                },
                M = {
                    XYZE: [
                        [new i.Kj0(new i.xo$(.25, 10, 8), n)]
                    ],
                    X: [
                        [new i.Kj0(new i.XvJ(.5, .1, 4, 24), n), [0, 0, 0],
                            [0, -Math.PI / 2, -Math.PI / 2]
                        ]
                    ],
                    Y: [
                        [new i.Kj0(new i.XvJ(.5, .1, 4, 24), n), [0, 0, 0],
                            [Math.PI / 2, 0, 0]
                        ]
                    ],
                    Z: [
                        [new i.Kj0(new i.XvJ(.5, .1, 4, 24), n), [0, 0, 0],
                            [0, 0, -Math.PI / 2]
                        ]
                    ],
                    E: [
                        [new i.Kj0(new i.XvJ(.75, .1, 2, 24), n)]
                    ]
                },
                T = {
                    X: [
                        [new i.Kj0(_, s), [.5, 0, 0],
                            [0, 0, -Math.PI / 2]
                        ],
                        [new i.Kj0(g, s), [0, 0, 0],
                            [0, 0, -Math.PI / 2]
                        ],
                        [new i.Kj0(_, s), [-.5, 0, 0],
                            [0, 0, Math.PI / 2]
                        ]
                    ],
                    Y: [
                        [new i.Kj0(_, o), [0, .5, 0]],
                        [new i.Kj0(g, o)],
                        [new i.Kj0(_, o), [0, -.5, 0],
                            [0, 0, Math.PI]
                        ]
                    ],
                    Z: [
                        [new i.Kj0(_, a), [0, 0, .5],
                            [Math.PI / 2, 0, 0]
                        ],
                        [new i.Kj0(g, a), [0, 0, 0],
                            [Math.PI / 2, 0, 0]
                        ],
                        [new i.Kj0(_, a), [0, 0, -.5],
                            [-Math.PI / 2, 0, 0]
                        ]
                    ],
                    XY: [
                        [new i.Kj0(new i.DvJ(.15, .15, .01), u), [.15, .15, 0]]
                    ],
                    YZ: [
                        [new i.Kj0(new i.DvJ(.15, .15, .01), l), [0, .15, .15],
                            [0, Math.PI / 2, 0]
                        ]
                    ],
                    XZ: [
                        [new i.Kj0(new i.DvJ(.15, .15, .01), c), [.15, 0, .15],
                            [-Math.PI / 2, 0, 0]
                        ]
                    ],
                    XYZ: [
                        [new i.Kj0(new i.DvJ(.1, .1, .1), p.clone())]
                    ]
                },
                E = {
                    X: [
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [.3, 0, 0],
                            [0, 0, -Math.PI / 2]
                        ],
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [-.3, 0, 0],
                            [0, 0, Math.PI / 2]
                        ]
                    ],
                    Y: [
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, .3, 0]],
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, -.3, 0],
                            [0, 0, Math.PI]
                        ]
                    ],
                    Z: [
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, .3],
                            [Math.PI / 2, 0, 0]
                        ],
                        [new i.Kj0(new i.fHI(.2, 0, .6, 4), n), [0, 0, -.3],
                            [-Math.PI / 2, 0, 0]
                        ]
                    ],
                    XY: [
                        [new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, .15, 0]]
                    ],
                    YZ: [
                        [new i.Kj0(new i.DvJ(.2, .2, .01), n), [0, .15, .15],
                            [0, Math.PI / 2, 0]
                        ]
                    ],
                    XZ: [
                        [new i.Kj0(new i.DvJ(.2, .2, .01), n), [.15, 0, .15],
                            [-Math.PI / 2, 0, 0]
                        ]
                    ],
                    XYZ: [
                        [new i.Kj0(new i.DvJ(.2, .2, .2), n), [0, 0, 0]]
                    ]
                },
                A = {
                    X: [
                        [new i.x12(m, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
                    ],
                    Y: [
                        [new i.x12(m, r.clone()), [0, -1e3, 0],
                            [0, 0, Math.PI / 2],
                            [1e6, 1, 1], "helper"
                        ]
                    ],
                    Z: [
                        [new i.x12(m, r.clone()), [0, 0, -1e3],
                            [0, -Math.PI / 2, 0],
                            [1e6, 1, 1], "helper"
                        ]
                    ]
                };

            function C(e) {
                const t = new i.Tme;
                for (const n in e)
                    for (let r = e[n].length; r--;) {
                        const i = e[n][r][0].clone(),
                            s = e[n][r][1],
                            o = e[n][r][2],
                            a = e[n][r][3],
                            l = e[n][r][4];
                        i.name = n, i.tag = l, s && i.position.set(s[0], s[1], s[2]), o && i.rotation.set(o[0], o[1], o[2]), a && i.scale.set(a[0], a[1], a[2]), i.updateMatrix();
                        const c = i.geometry.clone();
                        c.applyMatrix4(i.matrix), i.geometry = c, i.renderOrder = 1 / 0, i.position.set(0, 0, 0), i.rotation.set(0, 0, 0), i.scale.set(1, 1, 1), t.add(i)
                    }
                return t
            }
            this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = C(b)), this.add(this.gizmo.rotate = C(w)), this.add(this.gizmo.scale = C(T)), this.add(this.picker.translate = C(x)), this.add(this.picker.rotate = C(M)), this.add(this.picker.scale = C(E)), this.add(this.helper.translate = C(y)), this.add(this.helper.rotate = C(S)), this.add(this.helper.scale = C(A)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1
        }
        updateMatrixWorld(e) {
            const t = "local" === ("scale" === this.mode ? "local" : this.space) ? this.worldQuaternion : sa;
            this.gizmo.translate.visible = "translate" === this.mode, this.gizmo.rotate.visible = "rotate" === this.mode, this.gizmo.scale.visible = "scale" === this.mode, this.helper.translate.visible = "translate" === this.mode, this.helper.rotate.visible = "rotate" === this.mode, this.helper.scale.visible = "scale" === this.mode;
            let n = [];
            n = n.concat(this.picker[this.mode].children), n = n.concat(this.gizmo[this.mode].children), n = n.concat(this.helper[this.mode].children);
            for (let e = 0; e < n.length; e++) {
                const r = n[e];
                let i;
                if (r.visible = !0, r.rotation.set(0, 0, 0), r.position.copy(this.worldPosition), i = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), r.scale.set(1, 1, 1).multiplyScalar(i * this.size / 4), "helper" !== r.tag) {
                    if (r.quaternion.copy(t), "translate" === this.mode || "scale" === this.mode) {
                        const e = .99,
                            n = .2;
                        "X" === r.name && Math.abs(ta.copy(la).applyQuaternion(t).dot(this.eye)) > e && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "Y" === r.name && Math.abs(ta.copy(ca).applyQuaternion(t).dot(this.eye)) > e && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "Z" === r.name && Math.abs(ta.copy(ua).applyQuaternion(t).dot(this.eye)) > e && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "XY" === r.name && Math.abs(ta.copy(ua).applyQuaternion(t).dot(this.eye)) < n && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "YZ" === r.name && Math.abs(ta.copy(la).applyQuaternion(t).dot(this.eye)) < n && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), "XZ" === r.name && Math.abs(ta.copy(ca).applyQuaternion(t).dot(this.eye)) < n && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1)
                    } else "rotate" === this.mode && (ia.copy(t), ta.copy(this.eye).applyQuaternion(zo.copy(t).invert()), -1 !== r.name.search("E") && r.quaternion.setFromRotationMatrix(ra.lookAt(this.eye, na, ca)), "X" === r.name && (zo.setFromAxisAngle(la, Math.atan2(-ta.y, ta.z)), zo.multiplyQuaternions(ia, zo), r.quaternion.copy(zo)), "Y" === r.name && (zo.setFromAxisAngle(ca, Math.atan2(ta.x, ta.z)), zo.multiplyQuaternions(ia, zo), r.quaternion.copy(zo)), "Z" === r.name && (zo.setFromAxisAngle(ua, Math.atan2(ta.y, ta.x)), zo.multiplyQuaternions(ia, zo), r.quaternion.copy(zo)));
                    r.visible = r.visible && (-1 === r.name.indexOf("X") || this.showX), r.visible = r.visible && (-1 === r.name.indexOf("Y") || this.showY), r.visible = r.visible && (-1 === r.name.indexOf("Z") || this.showZ), r.visible = r.visible && (-1 === r.name.indexOf("E") || this.showX && this.showY && this.showZ), r.material._color = r.material._color || r.material.color.clone(), r.material._opacity = r.material._opacity || r.material.opacity, r.material.color.copy(r.material._color), r.material.opacity = r.material._opacity, this.enabled && this.axis && (r.name === this.axis || this.axis.split("").some((function(e) {
                        return r.name === e
                    }))) && (r.material.color.setHex(16776960), r.material.opacity = 1)
                } else r.visible = !1, "AXIS" === r.name ? (r.position.copy(this.worldPositionStart), r.visible = !!this.axis, "X" === this.axis && (zo.setFromEuler(ea.set(0, 0, 0)), r.quaternion.copy(t).multiply(zo), Math.abs(ta.copy(la).applyQuaternion(t).dot(this.eye)) > .9 && (r.visible = !1)), "Y" === this.axis && (zo.setFromEuler(ea.set(0, 0, Math.PI / 2)), r.quaternion.copy(t).multiply(zo), Math.abs(ta.copy(ca).applyQuaternion(t).dot(this.eye)) > .9 && (r.visible = !1)), "Z" === this.axis && (zo.setFromEuler(ea.set(0, Math.PI / 2, 0)), r.quaternion.copy(t).multiply(zo), Math.abs(ta.copy(ua).applyQuaternion(t).dot(this.eye)) > .9 && (r.visible = !1)), "XYZE" === this.axis && (zo.setFromEuler(ea.set(0, Math.PI / 2, 0)), ta.copy(this.rotationAxis), r.quaternion.setFromRotationMatrix(ra.lookAt(na, ta, ca)), r.quaternion.multiply(zo), r.visible = this.dragging), "E" === this.axis && (r.visible = !1)) : "START" === r.name ? (r.position.copy(this.worldPositionStart), r.visible = this.dragging) : "END" === r.name ? (r.position.copy(this.worldPosition), r.visible = this.dragging) : "DELTA" === r.name ? (r.position.copy(this.worldPositionStart), r.quaternion.copy(this.worldQuaternionStart), Bo.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Bo.applyQuaternion(this.worldQuaternionStart.clone().invert()), r.scale.copy(Bo), r.visible = this.dragging) : (r.quaternion.copy(t), this.dragging ? r.position.copy(this.worldPositionStart) : r.position.copy(this.worldPosition), this.axis && (r.visible = -1 !== this.axis.search(r.name)))
            }
            super.updateMatrixWorld(e)
        }
    }
    class _a extends i.Kj0 {
        constructor() {
            super(new i._12(1e5, 1e5, 2, 2), new i.vBJ({
                visible: !1,
                wireframe: !0,
                side: i.ehD,
                transparent: !0,
                opacity: .1,
                toneMapped: !1
            })), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane"
        }
        updateMatrixWorld(e) {
            let t = this.space;
            switch (this.position.copy(this.worldPosition), "scale" === this.mode && (t = "local"), pa.copy(la).applyQuaternion("local" === t ? this.worldQuaternion : sa), ha.copy(ca).applyQuaternion("local" === t ? this.worldQuaternion : sa), da.copy(ua).applyQuaternion("local" === t ? this.worldQuaternion : sa), ta.copy(ha), this.mode) {
                case "translate":
                case "scale":
                    switch (this.axis) {
                        case "X":
                            ta.copy(this.eye).cross(pa), oa.copy(pa).cross(ta);
                            break;
                        case "Y":
                            ta.copy(this.eye).cross(ha), oa.copy(ha).cross(ta);
                            break;
                        case "Z":
                            ta.copy(this.eye).cross(da), oa.copy(da).cross(ta);
                            break;
                        case "XY":
                            oa.copy(da);
                            break;
                        case "YZ":
                            oa.copy(pa);
                            break;
                        case "XZ":
                            ta.copy(da), oa.copy(ha);
                            break;
                        case "XYZ":
                        case "E":
                            oa.set(0, 0, 0)
                    }
                    break;
                case "rotate":
                default:
                    oa.set(0, 0, 0)
            }
            0 === oa.length() ? this.quaternion.copy(this.cameraQuaternion) : (aa.lookAt(Bo.set(0, 0, 0), oa, ta), this.quaternion.setFromRotationMatrix(aa)), super.updateMatrixWorld(e)
        }
    }
    const ma = new i.ZzF,
        ga = new i.Pa4;
    class va extends i.L5s {
        constructor() {
            super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new i.a$l([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new i.a$l([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2))
        }
        applyMatrix4(e) {
            const t = this.attributes.instanceStart,
                n = this.attributes.instanceEnd;
            return void 0 !== t && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        }
        setPositions(e) {
            let t;
            e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
            const n = new i.$TI(t, 6, 1);
            return this.setAttribute("instanceStart", new i.kB5(n, 3, 0)), this.setAttribute("instanceEnd", new i.kB5(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this
        }
        setColors(e) {
            let t;
            e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
            const n = new i.$TI(t, 6, 1);
            return this.setAttribute("instanceColorStart", new i.kB5(n, 3, 0)), this.setAttribute("instanceColorEnd", new i.kB5(n, 3, 3)), this
        }
        fromWireframeGeometry(e) {
            return this.setPositions(e.attributes.position.array), this
        }
        fromEdgesGeometry(e) {
            return this.setPositions(e.attributes.position.array), this
        }
        fromMesh(e) {
            return this.fromWireframeGeometry(new i.Uk6(e.geometry)), this
        }
        fromLineSegments(e) {
            const t = e.geometry;
            return this.setPositions(t.attributes.position.array), this
        }
        computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new i.ZzF);
            const e = this.attributes.instanceStart,
                t = this.attributes.instanceEnd;
            void 0 !== e && void 0 !== t && (this.boundingBox.setFromBufferAttribute(e), ma.setFromBufferAttribute(t), this.boundingBox.union(ma))
        }
        computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new i.aLr), null === this.boundingBox && this.computeBoundingBox();
            const e = this.attributes.instanceStart,
                t = this.attributes.instanceEnd;
            if (void 0 !== e && void 0 !== t) {
                const n = this.boundingSphere.center;
                this.boundingBox.getCenter(n);
                let r = 0;
                for (let i = 0, s = e.count; i < s; i++) ga.fromBufferAttribute(e, i), r = Math.max(r, n.distanceToSquared(ga)), ga.fromBufferAttribute(t, i), r = Math.max(r, n.distanceToSquared(ga));
                this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
            }
        }
        toJSON() {}
        applyMatrix(e) {
            return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e)
        }
    }
    class ba extends va {
        constructor(e) {
            super(), this.isWireframeGeometry2 = !0, this.type = "WireframeGeometry2", this.fromWireframeGeometry(new i.Uk6(e))
        }
    }
    i.rBU.line = {
        worldUnits: {
            value: 1
        },
        linewidth: {
            value: 1
        },
        resolution: {
            value: new i.FM8(1, 1)
        },
        dashOffset: {
            value: 0
        },
        dashScale: {
            value: 1
        },
        dashSize: {
            value: 1
        },
        gapSize: {
            value: 1
        }
    }, i.Vj0.line = {
        uniforms: i.rDY.merge([i.rBU.common, i.rBU.fog, i.rBU.line]),
        vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( position.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\n\t\t\t\tworldPos.xyz += offset;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
        fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"
    };
    class xa extends i.jyz {
        constructor(e) {
            super({
                type: "LineMaterial",
                uniforms: i.rDY.clone(i.Vj0.line.uniforms),
                vertexShader: i.Vj0.line.vertexShader,
                fragmentShader: i.Vj0.line.fragmentShader,
                clipping: !0
            }), this.isLineMaterial = !0, Object.defineProperties(this, {
                color: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.diffuse.value
                    },
                    set: function(e) {
                        this.uniforms.diffuse.value = e
                    }
                },
                worldUnits: {
                    enumerable: !0,
                    get: function() {
                        return "WORLD_UNITS" in this.defines
                    },
                    set: function(e) {
                        !0 === e ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS
                    }
                },
                linewidth: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.linewidth.value
                    },
                    set: function(e) {
                        this.uniforms.linewidth.value = e
                    }
                },
                dashed: {
                    enumerable: !0,
                    get: function() {
                        return Boolean("USE_DASH" in this.defines)
                    },
                    set(e) {
                        Boolean(e) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), !0 === e ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH
                    }
                },
                dashScale: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.dashScale.value
                    },
                    set: function(e) {
                        this.uniforms.dashScale.value = e
                    }
                },
                dashSize: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.dashSize.value
                    },
                    set: function(e) {
                        this.uniforms.dashSize.value = e
                    }
                },
                dashOffset: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.dashOffset.value
                    },
                    set: function(e) {
                        this.uniforms.dashOffset.value = e
                    }
                },
                gapSize: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.gapSize.value
                    },
                    set: function(e) {
                        this.uniforms.gapSize.value = e
                    }
                },
                opacity: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.opacity.value
                    },
                    set: function(e) {
                        this.uniforms.opacity.value = e
                    }
                },
                resolution: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.resolution.value
                    },
                    set: function(e) {
                        this.uniforms.resolution.value.copy(e)
                    }
                },
                alphaToCoverage: {
                    enumerable: !0,
                    get: function() {
                        return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)
                    },
                    set: function(e) {
                        Boolean(e) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), !0 === e ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1)
                    }
                }
            }), this.setValues(e)
        }
    }
    const ya = new i.Pa4,
        wa = new i.Pa4;
    class Sa extends i.Kj0 {
        constructor(e = new va, t = new xa({
            color: 16777215 * Math.random()
        })) {
            super(e, t), this.isWireframe = !0, this.type = "Wireframe"
        }
        computeLineDistances() {
            const e = this.geometry,
                t = e.attributes.instanceStart,
                n = e.attributes.instanceEnd,
                r = new Float32Array(2 * t.count);
            for (let e = 0, i = 0, s = t.count; e < s; e++, i += 2) ya.fromBufferAttribute(t, e), wa.fromBufferAttribute(n, e), r[i] = 0 === i ? 0 : r[i - 1], r[i + 1] = r[i] + ya.distanceTo(wa);
            const s = new i.$TI(r, 2, 1);
            return e.setAttribute("instanceDistanceStart", new i.kB5(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new i.kB5(s, 1, 1)), this
        }
    }
    class Ma extends i.ZAu {
        constructor(e) {
            super(), this.assetType = "widget", this.modelObject = this, this._object = null, this.boundingScaleMultiplier = 1, this.position.set(0, 0, 0), this.visible = !1, this.renderOrder = 1, this.userData.bboxVisible = !1, this.userData.setDirty = e, this._updater = this._updater.bind(this)
        }
        _updater() {
            const e = this._object;
            if (e) {
                const t = (new P).expandByObject(e, !1);
                t.getCenter(this.position);
                const n = t.getBoundingSphere(new i.aLr).radius;
                this.scale.setScalar(n * this.boundingScaleMultiplier), this.setVisible(!0)
            } else this.setVisible(!1)
        }
        _initGeometry(e) {
            if (this._geometry) return;
            const t = new ba(e);
            this._geometry = t;
            const n = new xa({
                    color: "#ff2222",
                    transparent: !0,
                    opacity: .9,
                    linewidth: 5,
                    resolution: new i.FM8(1024, 1024),
                    dashed: !1,
                    toneMapped: !1
                }),
                r = new Sa(t, n);
            r.computeLineDistances(), r.scale.set(1, 1, 1), r.visible = !0, this.add(r)
        }
        setVisible(e) {
            var t, n;
            e !== this.visible && (this.visible = e, null === (n = (t = this.userData).setDirty) || void 0 === n || n.call(t))
        }
        attach(e) {
            return this.detach(), e ? (this._object = e, this._object.addEventListener("objectUpdate", this._updater), this._updater(), this) : this
        }
        detach() {
            var e;
            return this._object ? (null === (e = this._object) || void 0 === e || e.removeEventListener("objectUpdate", this._updater), this._object = null, this._updater(), this) : this
        }
        get object() {
            return this._object
        }
    }
    class Ta extends Ma {
        constructor(e) {
            super(e), this.boundingScaleMultiplier = 1 / 1.7, this._initGeometry(new i.nvb(2, 2, 2, 1, 1, 1))
        }
        _updater() {
            super._updater();
            const e = this.object;
            e && ((new P).expandByObject(e, !1).getSize(this.scale).multiplyScalar(this.boundingScaleMultiplier).clampScalar(.1, 100), this.setVisible(!0))
        }
    }
    class Ea extends Ws {
        constructor() {
            super(), this.passId = "frameFade", this._fadeTime = 0, this._fadeTimeState = 0, this._toSaveFrame = !1, this._beforeFilters = ["progressive", "taa"], this._afterFilters = ["render"], this._requiredFilters = ["render", "progressive"], this.dependencies = [co], this.fadeOnActiveCameraChange = !0, this.fadeOnMaterialUpdate = !0, this.fadeOnSceneUpdate = !0, this.pointerEnabled = !0, this._fadeCam = e => !1 !== e.frameFade && this.fadeOnActiveCameraChange && this.startTransition(1e3), this._fadeMat = e => {
                !1 !== e.frameFade && this.fadeOnMaterialUpdate && this.startTransition(200)
            }, this._fadeScene = e => {
                !1 !== e.frameFade && this.fadeOnSceneUpdate && this.startTransition(500)
            }, this._onPointerMove = e => {
                var t;
                const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas;
                if (!n) return void(this.pointerEnabled = !1);
                if (!e.buttons || e.target !== n) return void(this.pointerEnabled = !0);
                const r = n.getBoundingClientRect(),
                    i = (e.clientX - r.left) / r.width,
                    s = (e.clientY - r.top) / r.height;
                this.pointerEnabled = i < 0 || i > 1 || s < 0 || s > 1
            }, this._disabledBy = [], this.startTransition = this.startTransition.bind(this), this.stopTransition = this.stopTransition.bind(this), this._fadeCam = this._fadeCam.bind(this), this._fadeMat = this._fadeMat.bind(this)
        }
        startTransition(e) {
            this._viewer && this._pass && !this.isDisabled() && (this._target || (this._target = this._viewer.renderer.getTempTarget({
                sizeMultiplier: 1,
                minFilter: i.wem,
                magFilter: i.wem,
                encoding: this._viewer.renderer.composerTarget.texture.encoding
            })), this._fadeTimeState = Math.max(e, this._fadeTimeState), this._fadeTime = this._fadeTimeState, this._toSaveFrame = !0, this.setDirty())
        }
        stopTransition() {
            this._fadeTimeState = 0
        }
        async onAdded(e) {
            await super.onAdded(e), e.scene.addEventListener("activeCameraChange", this._fadeCam), e.scene.addEventListener("activeCameraUpdate", this.stopTransition), e.scene.addEventListener("sceneMaterialUpdate", this._fadeMat), e.scene.addEventListener("sceneUpdate", this._fadeScene), window.addEventListener("pointermove", this._onPointerMove)
        }
        async onRemove(e) {
            return e.scene.removeEventListener("activeCameraChange", this._fadeCam), e.scene.removeEventListener("activeCameraUpdate", this.stopTransition), e.scene.removeEventListener("sceneMaterialUpdate", this._fadeMat), e.scene.removeEventListener("sceneUpdate", this._fadeScene), window.removeEventListener("pointermove", this._onPointerMove), super.onRemove(e)
        }
        passCtor(e) {
            const t = this,
                n = e.getPlugin(co),
                r = new class extends so {
                    constructor() {
                        super(...arguments), this._lastTime = 0, this.uiConfig = $e("Frame Fade", this)
                    }
                    render(r, i, s, o, a) {
                        this.needsSwap = !1;
                        const l = t._target;
                        if (!l || !t.pointerEnabled || !this.enabled || !t.dirty || t._fadeTimeState < .001) return;
                        t._toSaveFrame && n.lastFrame && (e.renderer.blit(n.lastFrame.texture, l), this._lastTime = 0, t._toSaveFrame = !1), this.blendTexture = null == l ? void 0 : l.texture;
                        const c = t._fadeTimeState / t._fadeTime;
                        this.weights2.setScalar(c), this.weights2.w = 1, this.weights1.setScalar(1 - c), this.weights1.w = 1, super.render(r, i, s, o, a), this.needsSwap = !0;
                        const u = Ct();
                        this._lastTime < 10 && (this._lastTime = u - 10);
                        const p = u - this._lastTime;
                        this._lastTime = u, t._fadeTimeState -= p
                    }
                };
            return r.enabled = !0, r
        }
        setDirty() {
            var e;
            this.enabled && (null === (e = this._viewer) || void 0 === e || e.setDirty())
        }
        get dirty() {
            return this.enabled && this._fadeTimeState > 0
        }
        set dirty(e) {
            console.warn("FrameFadePlugin.dirty is readonly")
        }
        _update(e) {
            return !!super._update(e) && (this.isDisabled() && this.stopTransition(), this._fadeTimeState < .001 && (this._toSaveFrame = !1, this._target && this._viewer && (this._viewer.renderer.releaseTempTarget(this._target), this._target = void 0)), !0)
        }
        get uiConfig() {
            var e, t;
            return null === (t = null === (e = this.pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig
        }
        disable(e) {
            this._disabledBy.includes(e) || this._disabledBy.push(e)
        }
        enable(e) {
            const t = this._disabledBy.indexOf(e);
            t >= 0 && this._disabledBy.splice(t, 1)
        }
        isDisabled() {
            return !this.pointerEnabled || this._disabledBy.length > 0 || !this.enabled
        }
    }
    Ea.PluginType = "FrameFade";
    var Aa = i.M8C.degToRad;
    class Ca extends Gs {
        constructor(e = Ta, t = !1, n = !0) {
            super(), this.enabled = !0, this.autoFocus = !1, e && (this._widget = new e((() => {
                this.setDirty()
            }))), this._controls = t, this._pickUi = n
        }
        get picker() {
            return this._picker
        }
        setDirty() {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setDirty()
        }
        getSelectedObject() {
            var e;
            if (this.enabled) return (null === (e = this._picker) || void 0 === e ? void 0 : e.selectedObject) || void 0
        }
        setSelectedObject(e, t = !1) {
            if (this.enabled && this._picker) {
                const n = this.autoFocus;
                n && !t && (this.autoFocus = !1), this._picker.selectedObject = e || null, this.autoFocus = n
            }
        }
        async onAdded(e) {
            await super.onAdded(e), this._picker = new No(e.scene, e.canvas, void 0, (e => {
                var t, n;
                if (!e.material) return !1;
                let r = e,
                    i = !1;
                for (; r;) {
                    if (!r.visible) return !1;
                    if ("model" === (null !== (t = r.userData.iModel) && void 0 !== t ? t : r).assetType && (i = !0), "widget" === (null !== (n = r.userData.iModel) && void 0 !== n ? n : r).assetType) return !1;
                    if (!1 === r.userData.userSelectable) return !1;
                    if (!1 === r.userData.bboxVisible) return !1;
                    r = r.parent
                }
                return i
            })), this._widget && e.scene.addWidget(this._widget), this._transformControls = new Ra(e), this._transformControls.enabled = this._controls, this._picker.addEventListener("selectedObjectChanged", (t => {
                var n, r, s, o, a;
                this.dispatchEvent(t);
                const l = null === (n = this._picker) || void 0 === n ? void 0 : n.selectedObject;
                if (this._pickUi) {
                    const e = null === (r = l) || void 0 === r ? void 0 : r.uiConfig,
                        t = this.uiConfig;
                    t.children = e ? [e] : [], null === (s = t.uiRefresh) || void 0 === s || s.call(t)
                }
                const c = this._widget;
                c && (l ? c.attach(l) : c.detach());
                const u = this._transformControls;
                u && (null === (o = this._viewer) || void 0 === o ? void 0 : o.scene.activeCamera.controls) && (l && u.enabled ? u.attach(l) : u.detach()), this.autoFocus && l && (null === (a = this._viewer) || void 0 === a || a.resetCamera({
                    rootObject: l,
                    centerOffset: new i.Pa4(4, 4, 4)
                })), e.setDirty()
            })), this._picker.addEventListener("hoverObjectChanged", this.dispatchEvent), this._picker.addEventListener("hitObject", this.dispatchEvent), e.scene.addEventListener("addSceneObject", (e => {
                var t, n;
                const r = e.object,
                    i = this.getSelectedObject();
                if (i && "material" === (null == r ? void 0 : r.assetType) && "function" == typeof(null === (t = i.modelObject) || void 0 === t ? void 0 : t.userData.setMaterial) && confirm("Apply material to selected object?")) {
                    const e = i.material;
                    if (Array.isArray(e)) console.warn("Dropping on material array not yet fully supported."), i.modelObject.userData.setMaterial(r);
                    else {
                        let t = Array.from(null !== (n = null == e ? void 0 : e.userData.appliedMeshes) && void 0 !== n ? n : []);
                        (t.length > 1 ? !confirm("Apply to all objects using this material?") : t.length < 1) && (t = [i.modelObject]);
                        for (const e of t) e && e.userData.setMaterial(r)
                    }
                }
            }))
        }
        get uiConfig() {
            return this._pickUi ? this._uiConfig ? this._uiConfig : this._uiConfig = {
                type: "folder",
                label: "Picker",
                expanded: !0,
                children: [{}]
            } : {}
        }
        get transformControls() {
            return this._transformControls
        }
        get widget() {
            return this._widget
        }
    }
    Ca.PluginType = "Picking";
    class Ra extends Xo {
        constructor(e) {
            super(e.scene.activeCamera.cameraObject, e.canvas), this.modelObject = this, this.assetType = "widget", this._activeCameraChange = this._activeCameraChange.bind(this), this._scene = e.scene, this._scene.addEventListener("activeCameraChange", this._activeCameraChange), this.visible = !1, this.userData.bboxVisible = !1, this.addEventListener("objectChange", (() => {
                var e;
                null === (e = null == this ? void 0 : this.object) || void 0 === e || e.dispatchEvent({
                    type: "objectUpdate",
                    fadeFrame: !1
                })
            })), this.addEventListener("dragging-changed", (t => {
                const n = null == e ? void 0 : e.getPlugin(Ea);
                n && (n.enabled = !t.value), this._scene.activeCamera.interactionsEnabled = !t.value
            })), this._keyDownListener = this._keyDownListener.bind(this), window.addEventListener("keydown", this._keyDownListener), window.addEventListener("keyup", this._keyUpListener), this._scene.addWidget(this)
        }
        _keyDownListener(e) {
            if (this.enabled && this.object) {
                switch (e.keyCode) {
                    case 81:
                        this.setSpace("local" === this.space ? "world" : "local");
                        break;
                    case 16:
                        this.setTranslationSnap(100), this.setRotationSnap(Aa(15)), this.setScaleSnap(.25);
                        break;
                    case 87:
                        this.setMode("translate");
                        break;
                    case 69:
                        this.setMode("rotate");
                        break;
                    case 82:
                        this.setMode("scale");
                        break;
                    case 187:
                    case 107:
                        this.setSize(this.size + .1);
                        break;
                    case 189:
                    case 109:
                        this.setSize(Math.max(this.size - .1, .1));
                        break;
                    case 88:
                        this.showX = !this.showX;
                        break;
                    case 89:
                        this.showY = !this.showY;
                        break;
                    case 90:
                        this.showZ = !this.showZ;
                        break;
                    case 32:
                        this.enabled = !this.enabled;
                        break;
                    default:
                        return
                }
                this._scene.setDirty({
                    sceneUpdate: !0,
                    frameFade: !0
                })
            }
        }
        _keyUpListener(e) {
            if (this.enabled) {
                switch (e.keyCode) {
                    case 16:
                        this.setTranslationSnap(null), this.setRotationSnap(null), this.setScaleSnap(null)
                }
                this.object && e.keyCode
            }
        }
        _activeCameraChange() {
            this.camera = this._scene.activeCamera.cameraObject
        }
        dispose() {
            window.removeEventListener("keydown", this._keyDownListener), window.removeEventListener("keyup", this._keyUpListener), this._scene.removeEventListener("activeCameraChange", this._activeCameraChange), this._scene.modelObject.remove(this), super.dispose()
        }
    }
    var ka = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class Pa extends Gs {
        constructor() {
            super(), this.offsetCache = {}, this.enabled = !0, this.envMap = null, this.forceSceneEnvMap = !1, this.getEnvMap = () => {
                var e;
                return !this.forceSceneEnvMap && this.envMap ? this.envMap : (null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment()) || null
            }, this._modelProcessor = {
                forAssetType: "model",
                processAsync: async (e, t) => {
                    const n = [];
                    return e.modelObject.traverse((e => {
                        var t, r, i, s;
                        const o = null === (r = null === (t = e.userData) || void 0 === t ? void 0 : t.gltfExtensions) || void 0 === r ? void 0 : r[Pa.DIAMOND_GLTF_EXTENSION];
                        o && e.geometry && (this.prepareDiamondMesh(e, o), delete e.userData.gltfExtensions[Pa.DIAMOND_GLTF_EXTENSION]), e.material && !n.includes(e.material) && (null === (s = null === (i = e.material.userData) || void 0 === i ? void 0 : i.gltfExtensions) || void 0 === s ? void 0 : s[Pa.DIAMOND_GLTF_EXTENSION]) && (e.material.materialObject || console.warn("material not processed", e.material), n.push(e.material))
                    })), n.forEach((e => {
                        const t = e.userData.gltfExtensions[Pa.DIAMOND_GLTF_EXTENSION];
                        t && this._convertToDiamondMaterial(e, t)
                    })), e
                }
            }, this.uiConfig = {
                type: "folder",
                label: "Diamonds",
                children: [{
                    type: "toggle",
                    label: "Use Scene Environment",
                    property: [this, "forceSceneEnvironment"],
                    limitedUi: !0
                }, {
                    type: "image",
                    label: "Environment",
                    hidden: () => this.forceSceneEnvMap,
                    property: [this, "envMap"],
                    limitedUi: !0
                }, {
                    type: "slider",
                    bounds: [0, 2 * Math.PI],
                    hidden: () => this.forceSceneEnvMap,
                    label: "Env Rotation",
                    property: [this, "envMapRotation"],
                    limitedUi: !0
                }, {
                    type: "button",
                    label: "Make Diamond",
                    hidden: () => {
                        var e, t, n, r;
                        return (null === (r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material) || void 0 === r ? void 0 : r.typeSlug) !== Kt.TypeSlug
                    },
                    value: () => {
                        var e, t;
                        const n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject();
                        if (!(null == n ? void 0 : n.material)) return;
                        const r = prompt("Cache key?", "");
                        let i = parseInt(prompt("Cache size?", "512") || "512");
                        isFinite(i) || (i = 512), i < 64 && (i = 64), this.makeDiamond(n.material, {
                            cacheKey: r || void 0,
                            normalMapRes: i
                        }, {}), this.refreshUi()
                    },
                    limitedUi: !0
                }, {
                    type: "button",
                    label: "Make Standard",
                    hidden: () => {
                        var e, t, n, r;
                        return (null === (r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material) || void 0 === r ? void 0 : r.typeSlug) !== Fo.TypeSlug
                    },
                    value: () => {
                        var e, t, n, r, i, s;
                        const o = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject(),
                            a = null == o ? void 0 : o.material;
                        if (!a) return;
                        const l = a.userData._baseMaterial,
                            c = (null === (i = null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getManager()) || void 0 === r ? void 0 : r.materials) || void 0 === i ? void 0 : i.findMaterial(l)) || (null === (s = this._viewer) || void 0 === s ? void 0 : s.createPhysicalMaterial({
                                color: a.color
                            }));
                        if (c) {
                            const e = confirm("Convert all with this material?") ? Array.from(a.userData.appliedMeshes) : [o];
                            for (const t of e) null == t || t.modelObject.userData.setMaterial(c)
                        }
                        this.refreshUi()
                    },
                    limitedUi: !0
                }]
            }, this.refreshEnvMaps = this.refreshEnvMaps.bind(this), this.refreshUi = this.refreshUi.bind(this)
        }
        get envMapRotation() {
            var e, t;
            return null !== (t = null === (e = this.envMap) || void 0 === e ? void 0 : e.rotation) && void 0 !== t ? t : 0
        }
        set envMapRotation(e) {
            var t;
            const n = this.envMap;
            n && (n.rotation = e, null === (t = this._viewer) || void 0 === t || t.scene.setDirty())
        }
        refreshEnvMaps() {
            var e, t, n;
            if (!this._viewer) return;
            const r = this.getEnvMap(),
                i = (null === (t = null === (e = this._viewer.getPlugin(Vs)) || void 0 === e ? void 0 : e.materials) || void 0 === t ? void 0 : t.getMaterialsOfType(Fo.TypeSlug)) || [];
            for (const e of i) e && e.envMap !== r && (e.envMap = r, e.needsUpdate = !0);
            null === (n = this._viewer) || void 0 === n || n.scene.setDirty()
        }
        refreshUi() {
            var e, t, n;
            null === (e = this._viewer) || void 0 === e || e.setDirty(), null === (n = null === (t = this.uiConfig) || void 0 === t ? void 0 : t.uiRefresh) || void 0 === n || n.call(t, "postFrame", !0)
        }
        async onAdded(e) {
            var t, n, r, i, s, o;
            this._normalCapture = new Po(e.renderer), this.offsetCache = {}, e.scene.addEventListener("environmentChanged", this.refreshEnvMaps);
            const a = e.getPlugin(Vs);
            null === (t = null == a ? void 0 : a.importer) || void 0 === t || t.processors.add("model", this._modelProcessor), null === (n = e.getPlugin(Ca)) || void 0 === n || n.addEventListener("selectedObjectChanged", this.refreshUi);
            const l = this.getEnvMap,
                c = new $t(class extends tn {
                    async loadAsync(e, t) {
                        var n;
                        const r = await super.loadAsync(e, t);
                        return r.type === Fo.TYPE || r.isDiamondMaterialParameters ? (r.envMap = l(), null === (n = null == a ? void 0 : a.materials) || void 0 === n ? void 0 : n.generateFromTemplate("diamond", r)) : (console.error("Invalid material type for Diamond Material.", r), null)
                    }
                }, [Fo.TypeSlug], !1);
            return Us.Importers.push(c), null === (s = null === (i = null === (r = null == a ? void 0 : a.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Da), null === (o = null == a ? void 0 : a.materials) || void 0 === o || o.registerMaterialTemplate({
                name: "diamond",
                materialType: Fo.TYPE,
                isDiamondMaterialParameters: !0,
                generator: (e, t) => {
                    const n = new Fo(e);
                    return n.envMap = l(), t && t !== {} && n.copyProps(t), n
                }
            }), super.onAdded(e)
        }
        async onRemove(e) {
            var t, n, r, i;
            return null === (t = this._normalCapture) || void 0 === t || t.dispose(), this._normalCapture = void 0, this.offsetCache = {}, null === (r = null === (n = e.getPlugin(Vs)) || void 0 === n ? void 0 : n.importer) || void 0 === r || r.processors.remove("model", this._modelProcessor), null === (i = e.getPlugin(Ca)) || void 0 === i || i.removeEventListener("selectedObjectChanged", this.refreshUi), super.onRemove(e)
        }
        prepareDiamondMesh(e, {
            cacheKey: t,
            normalMapRes: n
        }) {
            var r, i, s;
            e.userData._diamondCacheKey = null != t ? t : e.userData._diamondCacheKey, e.userData._diamondNormalMapRes = null != n ? n : e.userData._diamondNormalMapRes, t = t && t.length > 0 ? t.includes(";" + e.geometry.uuid) ? t : t + ";" + e.geometry.uuid : e.geometry.uuid, this._computeOffsets(e.geometry, e.geometry.uuid);
            const o = null !== (i = null === (r = this._normalCapture) || void 0 === r ? void 0 : r.captureNormalMap(e.geometry, t, n)) && void 0 !== i ? i : [void 0, !1],
                a = null === (s = this._viewer) || void 0 === s ? void 0 : s.getPluginByType("debug");
            a && o && (a.counters.normalsCapture || (a.counters.normalsCapture = 0), a.counters.normalsCapture++, console.log("DEBUG: new normal map captured", a.counters.normalsCapture, t), a.addTexture("normal" + a.counters.normalsCapture, (() => {
                var t;
                return null === (t = e.geometry.userData._normalsCaptureMap) || void 0 === t ? void 0 : t.texture
            }), [40, 110 * a.counters.normalsCapture - 100, 200, 100], void 0, void 0, "postRender", !0))
        }
        makeDiamond(e, t, n) {
            var r, i;
            Array.from(null !== (r = null == e ? void 0 : e.userData.appliedMeshes) && void 0 !== r ? r : []).forEach((e => {
                (null == e ? void 0 : e.isMesh) && e.geometry && this.prepareDiamondMesh(e, t)
            })), this._convertToDiamondMaterial(e, n), null === (i = this._viewer) || void 0 === i || i.setDirty()
        }
        _convertToDiamondMaterial(e, t = {
            isDiamond: !0
        }) {
            var n, r, s, o, a, l, c;
            let u = { ...null != t ? t : {}
            };
            u.isDiamond || u.isDiamondMaterialParameters ? Array.isArray(u.boostFactors) && (u.boostFactors = (new i.Pa4).fromArray(u.boostFactors)) : u = {
                isDiamondMaterialParameters: !0
            }, u.color = null !== (s = null !== (n = u.color) && void 0 !== n ? n : null === (r = null == e ? void 0 : e.materialObject) || void 0 === r ? void 0 : r.color) && void 0 !== s ? s : new ve(1, 1, 1);
            const p = null === (l = null === (a = null === (o = this._viewer) || void 0 === o ? void 0 : o.getManager()) || void 0 === a ? void 0 : a.materials) || void 0 === l ? void 0 : l.generateFromTemplate("diamond", u);
            p && e && (p.userData._baseMaterial = e.uuid), Array.from(null !== (c = null == e ? void 0 : e.userData.appliedMeshes) && void 0 !== c ? c : []).forEach((e => {
                (e => {
                    var t;
                    return null !== (t = e.userData.setMaterial) && void 0 !== t ? t : t => {
                        e.material = t.materialObject
                    }
                })(e)(p), this.prepareDiamondMesh(e, t)
            }))
        }
        _computeOffsets(e, t, n = !1) {
            const r = t.split(";").find((e => this.offsetCache[e]));
            if (r && !n) {
                const n = this.offsetCache[r];
                return t.split(";").forEach((e => e !== r && (this.offsetCache[e] = n))), e.userData._normalsCaptureOffsets = n, n
            }
            e.computeBoundingBox();
            const s = e.boundingBox.getCenter(new i.Pa4),
                o = Oo(e),
                a = o.clone().invert(),
                l = {
                    center: s,
                    offsetMatrix: o,
                    offsetMatrixInv: a,
                    radius: 1,
                    centerOffset: (new i.Pa4).copy(s).applyMatrix4(a)
                };
            return t.split(";").forEach((e => this.offsetCache[e] = l)), e.userData._normalsCaptureOffsets = l, l
        }
    }
    Pa.PluginType = "Diamond", Pa.DIAMOND_GLTF_EXTENSION = "WEBGI_materials_diamond", ka([C(Pa.prototype.refreshEnvMaps), xe()], Pa.prototype, "envMap", void 0), ka([C(Pa.prototype.refreshEnvMaps), xe()], Pa.prototype, "forceSceneEnvMap", void 0);
    const Da = e => ({
        writeMaterial: (t, n) => {
            t.isDiamondMaterial && (n.extensions = n.extensions || {}, n.extensions[Pa.DIAMOND_GLTF_EXTENSION] = t.toJSON(), e.extensionsUsed[Pa.DIAMOND_GLTF_EXTENSION] = !0)
        },
        writeMesh: (t, n) => {
            var r, i;
            if (!(null == t ? void 0 : t.material.isDiamondMaterial)) return;
            n.extensions = n.extensions || {};
            const s = {};
            null === (i = null === (r = t.userData) || void 0 === r ? void 0 : r.gltfExtensions) || void 0 === i || delete i[Pa.DIAMOND_GLTF_EXTENSION], t.userData._diamondNormalMapRes && (s.normalMapRes = t.userData._diamondNormalMapRes), t.userData._diamondCacheKey && (s.cacheKey = t.userData._diamondCacheKey), n.extensions[Pa.DIAMOND_GLTF_EXTENSION] = s, e.extensionsUsed[Pa.DIAMOND_GLTF_EXTENSION] = !0
        }
    });
    var Oa = function() {
        return (Oa = Object.assign || function(e) {
            for (var t, n = 1, r = arguments.length; n < r; n++)
                for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e
        }).apply(this, arguments)
    };

    function La(e, t) {
        var n = {};
        for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
            var i = 0;
            for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
        }
        return n
    }
    Object.create, Object.create;
    var Ia = function(e, t, n) {
        return Math.min(Math.max(n, e), t)
    };

    function Fa(e, t) {
        return e * Math.sqrt(1 - t * t)
    }
    var Na = ["duration", "bounce"],
        Ua = ["stiffness", "damping", "mass"];

    function Ba(e, t) {
        return t.some((function(t) {
            return void 0 !== e[t]
        }))
    }

    function ja(e) {
        var t = e.from,
            n = void 0 === t ? 0 : t,
            r = e.to,
            i = void 0 === r ? 1 : r,
            s = e.restSpeed,
            o = void 0 === s ? 2 : s,
            a = e.restDelta,
            l = La(e, ["from", "to", "restSpeed", "restDelta"]),
            c = {
                done: !1,
                value: n
            },
            u = function(e) {
                var t = Oa({
                    velocity: 0,
                    stiffness: 100,
                    damping: 10,
                    mass: 1,
                    isResolvedFromDuration: !1
                }, e);
                if (!Ba(e, Ua) && Ba(e, Na)) {
                    var n = function(e) {
                        var t, n, r = e.duration,
                            i = void 0 === r ? 800 : r,
                            s = e.bounce,
                            o = void 0 === s ? .25 : s,
                            a = e.velocity,
                            l = void 0 === a ? 0 : a,
                            c = e.mass,
                            u = void 0 === c ? 1 : c,
                            p = 1 - o;
                        p = Ia(.05, 1, p), i = Ia(.01, 10, i / 1e3), p < 1 ? (t = function(e) {
                            var t = e * p,
                                n = t * i;
                            return .001 - (t - l) / Fa(e, p) * Math.exp(-n)
                        }, n = function(e) {
                            var n = e * p * i,
                                r = n * l + l,
                                s = Math.pow(p, 2) * Math.pow(e, 2) * i,
                                o = Math.exp(-n),
                                a = Fa(Math.pow(e, 2), p);
                            return (.001 - t(e) > 0 ? -1 : 1) * ((r - s) * o) / a
                        }) : (t = function(e) {
                            return Math.exp(-e * i) * ((e - l) * i + 1) - .001
                        }, n = function(e) {
                            return Math.exp(-e * i) * (i * i * (l - e))
                        });
                        var h = function(e, t, n) {
                            for (var r = n, i = 1; i < 12; i++) r -= e(r) / t(r);
                            return r
                        }(t, n, 5 / i);
                        if (i *= 1e3, isNaN(h)) return {
                            stiffness: 100,
                            damping: 10,
                            duration: i
                        };
                        var d = Math.pow(h, 2) * u;
                        return {
                            stiffness: d,
                            damping: 2 * p * Math.sqrt(u * d),
                            duration: i
                        }
                    }(e);
                    (t = Oa(Oa(Oa({}, t), n), {
                        velocity: 0,
                        mass: 1
                    })).isResolvedFromDuration = !0
                }
                return t
            }(l),
            p = u.stiffness,
            h = u.damping,
            d = u.mass,
            f = u.velocity,
            _ = u.duration,
            m = u.isResolvedFromDuration,
            g = za,
            v = za;

        function b() {
            var e = f ? -f / 1e3 : 0,
                t = i - n,
                r = h / (2 * Math.sqrt(p * d)),
                s = Math.sqrt(p / d) / 1e3;
            if (null != a || (a = Math.abs(i - n) <= 1 ? .01 : .4), r < 1) {
                var o = Fa(s, r);
                g = function(n) {
                    var a = Math.exp(-r * s * n);
                    return i - a * ((e + r * s * t) / o * Math.sin(o * n) + t * Math.cos(o * n))
                }, v = function(n) {
                    var i = Math.exp(-r * s * n);
                    return r * s * i * (Math.sin(o * n) * (e + r * s * t) / o + t * Math.cos(o * n)) - i * (Math.cos(o * n) * (e + r * s * t) - o * t * Math.sin(o * n))
                }
            } else if (1 === r) g = function(n) {
                return i - Math.exp(-s * n) * (t + (e + s * t) * n)
            };
            else {
                var l = s * Math.sqrt(r * r - 1);
                g = function(n) {
                    var o = Math.exp(-r * s * n),
                        a = Math.min(l * n, 300);
                    return i - o * ((e + r * s * t) * Math.sinh(a) + l * t * Math.cosh(a)) / l
                }
            }
        }
        return b(), {
            next: function(e) {
                var t = g(e);
                if (m) c.done = e >= _;
                else {
                    var n = 1e3 * v(e),
                        r = Math.abs(n) <= o,
                        s = Math.abs(i - t) <= a;
                    c.done = r && s
                }
                return c.value = c.done ? i : t, c
            },
            flipTarget: function() {
                var e;
                f = -f, n = (e = [i, n])[0], i = e[1], b()
            }
        }
    }
    ja.needsInterpolation = function(e, t) {
        return "string" == typeof e || "string" == typeof t
    };
    var za = function(e) {
            return 0
        },
        Va = function(e, t, n) {
            var r = t - e;
            return 0 === r ? 1 : (n - e) / r
        },
        Ga = function(e, t, n) {
            return -n * e + n * t + e
        },
        Ha = function(e, t) {
            return function(n) {
                return Math.max(Math.min(n, t), e)
            }
        },
        Wa = function(e) {
            return e % 1 ? Number(e.toFixed(5)) : e
        },
        Ka = /(-)?([\d]*\.?[\d])+/g,
        Xa = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi,
        qa = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;

    function Ya(e) {
        return "string" == typeof e
    }
    var Za = {
            test: function(e) {
                return "number" == typeof e
            },
            parse: parseFloat,
            transform: function(e) {
                return e
            }
        },
        Ja = Oa(Oa({}, Za), {
            transform: Ha(0, 1)
        }),
        $a = (Oa(Oa({}, Za), {
            default: 1
        }), function(e, t) {
            return function(n) {
                return Boolean(Ya(n) && qa.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t))
            }
        }),
        Qa = function(e, t, n) {
            return function(r) {
                var i;
                if (!Ya(r)) return r;
                var s = r.match(Ka),
                    o = s[0],
                    a = s[1],
                    l = s[2],
                    c = s[3];
                return (i = {})[e] = parseFloat(o), i[t] = parseFloat(a), i[n] = parseFloat(l), i.alpha = void 0 !== c ? parseFloat(c) : 1, i
            }
        },
        el = Ha(0, 255),
        tl = Oa(Oa({}, Za), {
            transform: function(e) {
                return Math.round(el(e))
            }
        }),
        nl = {
            test: $a("rgb", "red"),
            parse: Qa("red", "green", "blue"),
            transform: function(e) {
                var t = e.red,
                    n = e.green,
                    r = e.blue,
                    i = e.alpha,
                    s = void 0 === i ? 1 : i;
                return "rgba(" + tl.transform(t) + ", " + tl.transform(n) + ", " + tl.transform(r) + ", " + Wa(Ja.transform(s)) + ")"
            }
        },
        rl = {
            test: $a("#"),
            parse: function(e) {
                var t = "",
                    n = "",
                    r = "",
                    i = "";
                return e.length > 5 ? (t = e.substr(1, 2), n = e.substr(3, 2), r = e.substr(5, 2), i = e.substr(7, 2)) : (t = e.substr(1, 1), n = e.substr(2, 1), r = e.substr(3, 1), i = e.substr(4, 1), t += t, n += n, r += r, i += i), {
                    red: parseInt(t, 16),
                    green: parseInt(n, 16),
                    blue: parseInt(r, 16),
                    alpha: i ? parseInt(i, 16) / 255 : 1
                }
            },
            transform: nl.transform
        },
        il = function(e) {
            return {
                test: function(t) {
                    return Ya(t) && t.endsWith(e) && 1 === t.split(" ").length
                },
                parse: parseFloat,
                transform: function(t) {
                    return "" + t + e
                }
            }
        },
        sl = (il("deg"), il("%")),
        ol = (il("px"), il("vh"), il("vw"), Oa(Oa({}, sl), {
            parse: function(e) {
                return sl.parse(e) / 100
            },
            transform: function(e) {
                return sl.transform(100 * e)
            }
        }), {
            test: $a("hsl", "hue"),
            parse: Qa("hue", "saturation", "lightness"),
            transform: function(e) {
                var t = e.hue,
                    n = e.saturation,
                    r = e.lightness,
                    i = e.alpha,
                    s = void 0 === i ? 1 : i;
                return "hsla(" + Math.round(t) + ", " + sl.transform(Wa(n)) + ", " + sl.transform(Wa(r)) + ", " + Wa(Ja.transform(s)) + ")"
            }
        }),
        al = function(e, t, n) {
            var r = e * e,
                i = t * t;
            return Math.sqrt(Math.max(0, n * (i - r) + r))
        },
        ll = [rl, nl, ol],
        cl = function(e) {
            return ll.find((function(t) {
                return t.test(e)
            }))
        },
        ul = function(e) {
            return "'" + e + "' is not an animatable color. Use the equivalent color code instead."
        },
        pl = function(e, t) {
            var n = cl(e),
                r = cl(t);
            ul(e), ul(t), n.transform, r.transform;
            var i = n.parse(e),
                s = r.parse(t),
                o = Oa({}, i),
                a = n === ol ? Ga : al;
            return function(e) {
                for (var t in o) "alpha" !== t && (o[t] = a(i[t], s[t], e));
                return o.alpha = Ga(i.alpha, s.alpha, e), n.transform(o)
            }
        },
        hl = function(e) {
            return nl.test(e) || rl.test(e) || ol.test(e)
        },
        dl = function(e) {
            return nl.test(e) ? nl.parse(e) : ol.test(e) ? ol.parse(e) : rl.parse(e)
        },
        fl = function(e) {
            return Ya(e) ? e : e.hasOwnProperty("red") ? nl.transform(e) : ol.transform(e)
        },
        _l = "${c}",
        ml = "${n}";

    function gl(e) {
        var t = [],
            n = 0,
            r = e.match(Xa);
        r && (n = r.length, e = e.replace(Xa, _l), t.push.apply(t, r.map(dl)));
        var i = e.match(Ka);
        return i && (e = e.replace(Ka, ml), t.push.apply(t, i.map(Za.parse))), {
            values: t,
            numColors: n,
            tokenised: e
        }
    }

    function vl(e) {
        return gl(e).values
    }

    function bl(e) {
        var t = gl(e),
            n = t.values,
            r = t.numColors,
            i = t.tokenised,
            s = n.length;
        return function(e) {
            for (var t = i, n = 0; n < s; n++) t = t.replace(n < r ? _l : ml, n < r ? fl(e[n]) : Wa(e[n]));
            return t
        }
    }
    var xl = function(e) {
            return "number" == typeof e ? 0 : e
        },
        yl = {
            test: function(e) {
                var t, n, r, i;
                return isNaN(e) && Ya(e) && (null !== (n = null === (t = e.match(Ka)) || void 0 === t ? void 0 : t.length) && void 0 !== n ? n : 0) + (null !== (i = null === (r = e.match(Xa)) || void 0 === r ? void 0 : r.length) && void 0 !== i ? i : 0) > 0
            },
            parse: vl,
            createTransformer: bl,
            getAnimatableNone: function(e) {
                var t = vl(e);
                return bl(e)(t.map(xl))
            }
        },
        wl = function(e, t) {
            return function(n) {
                return t(e(n))
            }
        },
        Sl = function() {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return e.reduce(wl)
        };

    function Ml(e, t) {
        return function(e) {
            return "number" == typeof e
        }(e) ? function(n) {
            return Ga(e, t, n)
        } : hl(e) ? pl(e, t) : Cl(e, t)
    }
    var Tl = function(e, t) {
            var n = function(e, t) {
                    for (var n = 0, r = t.length, i = e.length; n < r; n++, i++) e[i] = t[n];
                    return e
                }([], e),
                r = n.length,
                i = e.map((function(e, n) {
                    return Ml(e, t[n])
                }));
            return function(e) {
                for (var t = 0; t < r; t++) n[t] = i[t](e);
                return n
            }
        },
        El = function(e, t) {
            var n = Oa(Oa({}, e), t),
                r = {};
            for (var i in n) void 0 !== e[i] && void 0 !== t[i] && (r[i] = Ml(e[i], t[i]));
            return function(e) {
                for (var t in r) n[t] = r[t](e);
                return n
            }
        };

    function Al(e) {
        for (var t = yl.parse(e), n = t.length, r = 0, i = 0, s = 0, o = 0; o < n; o++) r || "number" == typeof t[o] ? r++ : void 0 !== t[o].hue ? s++ : i++;
        return {
            parsed: t,
            numNumbers: r,
            numRGB: i,
            numHSL: s
        }
    }
    var Cl = function(e, t) {
            var n = yl.createTransformer(t),
                r = Al(e),
                i = Al(t);
            return r.numHSL === i.numHSL && r.numRGB === i.numRGB && (r.numNumbers, i.numNumbers), Sl(Tl(r.parsed, i.parsed), n)
        },
        Rl = function(e, t) {
            return function(n) {
                return Ga(e, t, n)
            }
        };

    function kl(e, t, n) {
        var r = void 0 === n ? {} : n,
            i = r.clamp,
            s = void 0 === i || i,
            o = r.ease,
            a = r.mixer,
            l = e.length;
        t.length, !o || !Array.isArray(o) || o.length, e[0] > e[l - 1] && (e = [].concat(e), t = [].concat(t), e.reverse(), t.reverse());
        var c = function(e, t, n) {
                for (var r = [], i = n || function(e) {
                        return "number" == typeof e ? Rl : "string" == typeof e ? hl(e) ? pl : Cl : Array.isArray(e) ? Tl : "object" == typeof e ? El : void 0
                    }(e[0]), s = e.length - 1, o = 0; o < s; o++) {
                    var a = i(e[o], e[o + 1]);
                    if (t) {
                        var l = Array.isArray(t) ? t[o] : t;
                        a = Sl(l, a)
                    }
                    r.push(a)
                }
                return r
            }(t, o, a),
            u = 2 === l ? function(e, t) {
                var n = e[0],
                    r = e[1],
                    i = t[0];
                return function(e) {
                    return i(Va(n, r, e))
                }
            }(e, c) : function(e, t) {
                var n = e.length,
                    r = n - 1;
                return function(i) {
                    var s = 0,
                        o = !1;
                    if (i <= e[0] ? o = !0 : i >= e[r] && (s = r - 1, o = !0), !o) {
                        for (var a = 1; a < n && !(e[a] > i || a === r); a++);
                        s = a - 1
                    }
                    var l = Va(e[s], e[s + 1], i);
                    return t[s](l)
                }
            }(e, c);
        return s ? function(t) {
            return u(Ia(e[0], e[l - 1], t))
        } : u
    }
    var Pl, Dl = function(e) {
            return function(t) {
                return 1 - e(1 - t)
            }
        },
        Ol = function(e) {
            return function(t) {
                return t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2
            }
        },
        Ll = function(e) {
            return function(t) {
                return t * t * ((e + 1) * t - e)
            }
        },
        Il = (2, function(e) {
            return Math.pow(e, 2)
        }),
        Fl = Dl(Il),
        Nl = Ol(Il),
        Ul = function(e) {
            return 1 - Math.sin(Math.acos(e))
        },
        Bl = Dl(Ul),
        jl = Ol(Bl),
        zl = Ll(1.525),
        Vl = Dl(zl),
        Gl = Ol(zl),
        Hl = (Pl = Ll(1.525), function(e) {
            return (e *= 2) < 1 ? .5 * Pl(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
        }),
        Wl = function(e) {
            if (1 === e || 0 === e) return e;
            var t = e * e;
            return e < .36363636363636365 ? 7.5625 * t : e < .7272727272727273 ? 9.075 * t - 9.9 * e + 3.4 : e < .9 ? 12.066481994459833 * t - 19.63545706371191 * e + 8.898060941828255 : 10.8 * e * e - 20.52 * e + 10.72
        },
        Kl = Dl(Wl);

    function Xl(e, t) {
        return e.map((function() {
            return t || Nl
        })).splice(0, e.length - 1)
    }

    function ql(e) {
        var t = e.from,
            n = void 0 === t ? 0 : t,
            r = e.to,
            i = void 0 === r ? 1 : r,
            s = e.ease,
            o = e.offset,
            a = e.duration,
            l = void 0 === a ? 300 : a,
            c = {
                done: !1,
                value: n
            },
            u = Array.isArray(i) ? i : [n, i],
            p = function(e, t) {
                return e.map((function(e) {
                    return e * t
                }))
            }(o && o.length === u.length ? o : function(e) {
                var t = e.length;
                return e.map((function(e, n) {
                    return 0 !== n ? n / (t - 1) : 0
                }))
            }(u), l);

        function h() {
            return kl(p, u, {
                ease: Array.isArray(s) ? s : Xl(u, s)
            })
        }
        var d = h();
        return {
            next: function(e) {
                return c.value = d(e), c.done = e >= l, c
            },
            flipTarget: function() {
                u.reverse(), d = h()
            }
        }
    }
    var Yl = {
            keyframes: ql,
            spring: ja,
            decay: function(e) {
                var t = e.velocity,
                    n = void 0 === t ? 0 : t,
                    r = e.from,
                    i = void 0 === r ? 0 : r,
                    s = e.power,
                    o = void 0 === s ? .8 : s,
                    a = e.timeConstant,
                    l = void 0 === a ? 350 : a,
                    c = e.restDelta,
                    u = void 0 === c ? .5 : c,
                    p = e.modifyTarget,
                    h = {
                        done: !1,
                        value: i
                    },
                    d = o * n,
                    f = i + d,
                    _ = void 0 === p ? f : p(f);
                return _ !== f && (d = _ - i), {
                    next: function(e) {
                        var t = -d * Math.exp(-e / l);
                        return h.done = !(t > u || t < -u), h.value = h.done ? _ : _ + t, h
                    },
                    flipTarget: function() {}
                }
            }
        },
        Zl = 1 / 60 * 1e3,
        Jl = "undefined" != typeof performance ? function() {
            return performance.now()
        } : function() {
            return Date.now()
        },
        $l = "undefined" != typeof window ? function(e) {
            return window.requestAnimationFrame(e)
        } : function(e) {
            return setTimeout((function() {
                return e(Jl())
            }), Zl)
        },
        Ql = !0,
        ec = !1,
        tc = !1,
        nc = {
            delta: 0,
            timestamp: 0
        },
        rc = ["read", "update", "preRender", "render", "postRender"],
        ic = rc.reduce((function(e, t) {
            return e[t] = function(e) {
                var t = [],
                    n = [],
                    r = 0,
                    i = !1,
                    s = new WeakSet,
                    o = {
                        schedule: function(e, o, a) {
                            void 0 === o && (o = !1), void 0 === a && (a = !1);
                            var l = a && i,
                                c = l ? t : n;
                            return o && s.add(e), -1 === c.indexOf(e) && (c.push(e), l && i && (r = t.length)), e
                        },
                        cancel: function(e) {
                            var t = n.indexOf(e); - 1 !== t && n.splice(t, 1), s.delete(e)
                        },
                        process: function(a) {
                            var l;
                            if (i = !0, t = (l = [n, t])[0], (n = l[1]).length = 0, r = t.length)
                                for (var c = 0; c < r; c++) {
                                    var u = t[c];
                                    u(a), s.has(u) && (o.schedule(u), e())
                                }
                            i = !1
                        }
                    };
                return o
            }((function() {
                return ec = !0
            })), e
        }), {}),
        sc = rc.reduce((function(e, t) {
            var n = ic[t];
            return e[t] = function(e, t, r) {
                return void 0 === t && (t = !1), void 0 === r && (r = !1), ec || cc(), n.schedule(e, t, r)
            }, e
        }), {}),
        oc = rc.reduce((function(e, t) {
            return e[t] = ic[t].cancel, e
        }), {}),
        ac = function(e) {
            return ic[e].process(nc)
        },
        lc = function(e) {
            ec = !1, nc.delta = Ql ? Zl : Math.max(Math.min(e - nc.timestamp, 40), 1), nc.timestamp = e, tc = !0, rc.forEach(ac), tc = !1, ec && (Ql = !1, $l(lc))
        },
        cc = function() {
            ec = !0, Ql = !0, tc || $l(lc)
        },
        uc = sc;

    function pc(e, t, n) {
        return void 0 === n && (n = 0), e - t - n
    }
    var hc = function(e) {
        var t = function(t) {
            var n = t.delta;
            return e(n)
        };
        return {
            start: function() {
                return uc.update(t, !0)
            },
            stop: function() {
                return oc.update(t)
            }
        }
    };

    function dc(e) {
        var t, n, r, i, s, o = e.from,
            a = e.autoplay,
            l = void 0 === a || a,
            c = e.driver,
            u = void 0 === c ? hc : c,
            p = e.elapsed,
            h = void 0 === p ? 0 : p,
            d = e.repeat,
            f = void 0 === d ? 0 : d,
            _ = e.repeatType,
            m = void 0 === _ ? "loop" : _,
            g = e.repeatDelay,
            v = void 0 === g ? 0 : g,
            b = e.onPlay,
            x = e.onStop,
            y = e.onComplete,
            w = e.onRepeat,
            S = e.onUpdate,
            M = La(e, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]),
            T = M.to,
            E = 0,
            A = M.duration,
            C = !1,
            R = !0,
            k = function(e) {
                if (Array.isArray(e.to)) return ql;
                if (Yl[e.type]) return Yl[e.type];
                var t = new Set(Object.keys(e));
                return t.has("ease") || t.has("duration") && !t.has("dampingRatio") ? ql : t.has("dampingRatio") || t.has("stiffness") || t.has("mass") || t.has("damping") || t.has("restSpeed") || t.has("restDelta") ? ja : ql
            }(M);
        (null === (n = (t = k).needsInterpolation) || void 0 === n ? void 0 : n.call(t, o, T)) && (s = kl([0, 100], [o, T], {
            clamp: !1
        }), o = 0, T = 100);
        var P = k(Oa(Oa({}, M), {
            from: o,
            to: T
        }));
        return l && (null == b || b(), (r = u((function(e) {
            if (R || (e = -e), h += e, !C) {
                var t = P.next(Math.max(0, h));
                i = t.value, s && (i = s(i)), C = R ? t.done : h <= 0
            }
            null == S || S(i), C && (0 === E && (null != A || (A = h)), E < f ? function(e, t, n, r) {
                return r ? e >= t + n : e <= -n
            }(h, A, v, R) && (E++, "reverse" === m ? h = function(e, t, n, r) {
                return void 0 === n && (n = 0), void 0 === r && (r = !0), r ? pc(t + -e, t, n) : t - (e - t) + n
            }(h, A, v, R = E % 2 == 0) : (h = pc(h, A, v), "mirror" === m && P.flipTarget()), C = !1, w && w()) : (r.stop(), y && y()))
        }))).start()), {
            stop: function() {
                null == x || x(), r.stop()
            }
        }
    }
    const fc = {
        linear: function(e) {
            return e
        },
        easeIn: Il,
        easeOut: Fl,
        easeInOut: Nl,
        circIn: Ul,
        circOut: Bl,
        circInOut: jl,
        backIn: zl,
        backOut: Vl,
        backInOut: Gl,
        anticipate: Hl,
        bounceOut: Wl,
        bounceIn: Kl,
        bounceInOut: function(e) {
            return e < .5 ? .5 * (1 - Wl(1 - 2 * e)) : .5 * Wl(2 * e - 1) + .5
        },
        easeInOutSine: function(e) {
            return -(Math.cos(Math.PI * e) - 1) / 2
        }
    };
    async function _c(e) {
        return new Promise((t => setTimeout(t, Math.max(0, e))))
    }

    function mc(e, t, n) {
        const r = e[t],
            i = () => {
                var t;
                "function" == typeof(null === (t = null == e ? void 0 : e.userData) || void 0 === t ? void 0 : t.setDirty) && e.userData.setDirty(), null == n || n()
            };
        return r.isVector3 || r.isVector2 || r.isVector4 ? e => {
            r.copy(e), i()
        } : n => {
            e[t] = n, i()
        }
    }

    function gc(e) {
        return "boolean" != typeof e
    }
    async function vc(e, t, n) {
        t in e || console.error("invalid key", t, e);
        const r = mc(e, t),
            i = e[t],
            s = e => {
                var t;
                r(e), null === (t = n.onUpdate) || void 0 === t || t.call(n, e)
            };
        if (gc(i)) return "function" == typeof n.to && (n = { ...n,
            to: n.to(i, e)
        }), bc({ ...n,
            from: i,
            onUpdate: s
        }); {
            const {
                duration: e
            } = n;
            return _c(null != e ? e : 0).then((() => s(n.to)))
        }
    }
    async function bc(e) {
        return new Promise(((t, n) => {
            dc({
                onComplete: () => {
                    var n;
                    null === (n = e.onComplete) || void 0 === n || n.call(e), t()
                },
                onStop: () => {
                    var n;
                    null === (n = e.onStop) || void 0 === n || n.call(e), t()
                },
                ...e
            })
        }))
    }
    var xc, yc = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let wc = xc = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.animations = [], this.loopAnimations = !0, this.loopRepetitions = 1 / 0, this.timeScale = 0, this.animateOnScroll = !1, this.animationSpeed = 1, this._scrollAnimationState = 0, this.scrollAnimationDamping = .1, this.dependencies = [Vs], this._lastFrameTime = 0, this._fadeDisabled = !1, this._objectAdded = e => {
                const t = e.object;
                "model" === t.assetType && t.modelObject && this._viewer && t.modelObject.traverse((e => {
                    const t = e.animations;
                    if (t.length < 1) return;
                    const n = Math.max(...t.map((e => e.duration)));
                    t.forEach((e => e.duration = n));
                    const r = new i.Xcj(this._viewer.scene.modelRoot.modelObject),
                        s = t.map((e => r.clipAction(e).setLoop(this.loopAnimations ? i.YKA : i.jAl, this.loopRepetitions)));
                    this.animations.push({
                        mixer: r,
                        clips: t,
                        actions: s,
                        duration: n
                    }), this.onPropertyChange()
                }))
            }, this._animationTime = 0, this._animationDuration = 0, this._animationState = "none", this.uiConfig = void 0, this._lastAnimId = "", this.timelineMarkers = [], this._postFrame = this._postFrame.bind(this), this._wheel = this._wheel.bind(this), this.playClips = this.playClips.bind(this), this.playClip = this.playClip.bind(this), this.playAnimation = this.playAnimation.bind(this), this.playPauseAnimation = this.playPauseAnimation.bind(this), this.pauseAnimation = this.pauseAnimation.bind(this), this.stopAnimation = this.stopAnimation.bind(this), this.resetAnimation = this.resetAnimation.bind(this), this.onPropertyChange = this.onPropertyChange.bind(this), this._loaderCreate = this._loaderCreate.bind(this)
        }
        get animationState() {
            return this._animationState
        }
        get animationTime() {
            return this._animationTime
        }
        get animationDuration() {
            return this._animationDuration
        }
        _wheel({
            deltaY: e
        }) {
            this.enabled && Math.abs(e) > .001 && (this._scrollAnimationState = -1 * Math.sign(e))
        }
        _postFrame() {
            var e, t;
            if (!this._viewer) return;
            const n = this._viewer,
                r = this.animateOnScroll;
            if (!this.enabled || this.animations.length < 1 || "playing" !== this._animationState && !r) return this._lastFrameTime = 0, void(this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(xc.PluginType), this._fadeDisabled = !1));
            const i = Ct() / 1e3;
            this._lastFrameTime < 1 && (this._lastFrameTime = i - 1 / 30);
            let s = i - this._lastFrameTime;
            if (s *= this.animationSpeed, this._lastFrameTime = i, r && (s *= this._scrollAnimationState), Math.abs(s) < 1e-4) return;
            const o = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();
            if (o && o > 0 && (s = o), 0 !== o && (this.animations.map((e => e.mixer.update(s))), this._animationTime += s, this._animationTime > this._animationDuration && (this._animationTime -= this._animationDuration), this._animationTime < 0 && (this._animationTime += this._animationDuration), this._scrollAnimationState < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, n.scene.activeCamera.cameraObject.userData.__animatingCamera && n.scene.activeCamera.setDirty(), n.renderer.resetShadows(), n.setDirty(), !this._fadeDisabled)) {
                const e = this._viewer.getPluginByType("FrameFade");
                e && (e.disable(xc.PluginType), this._fadeDisabled = !0)
            }
        }
        _loaderCreate({
            loader: e
        }) {
            e.isGLTFLoader2 && e.register((e => new Sc(e, this)))
        }
        async onAdded(e) {
            var t, n, r, i, s, o;
            null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), e.scene.addEventListener("addSceneObject", this._objectAdded), null === (o = null === (s = null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.exporter) || void 0 === i ? void 0 : i.getExporter("gltf", "glb")) || void 0 === s ? void 0 : s.extensions) || void 0 === o || o.push(Mc), e.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel);
            let a = -1;
            return Object.defineProperty(e.scene.modelRoot, "currentTimelineMarker", {
                get: () => a,
                set: t => e.scene.modelRoot.dispatchEvent({
                    type: "animationTimelineMarker",
                    marker: this.timelineMarkers[a = t]
                })
            }), e.scene.modelRoot.addEventListener("animationTimelineMarker", (({
                marker: e
            }) => {
                var t;
                if (!this._viewer) return;
                if (!e) return this._viewer.scene.activeCamera = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.defaultCamera, void this._viewer.setDirty();
                const n = e.camera;
                n && (n.userData.__animatingCamera = !0, this._viewer.scene.activeCamera = this._viewer.createCamera(n))
            })), super.onAdded(e)
        }
        async onRemove(e) {
            var t, n;
            return e.scene.removeEventListener("addSceneObject", this._objectAdded), null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), e.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), super.onRemove(e)
        }
        onPropertyChange() {
            "playing" === this._animationState && this.playAnimation(), this._animationDuration = Math.max(...this.animations.map((({
                duration: e
            }) => e)))
        }
        onStateChange() {
            var e, t;
            null === (t = null === (e = this.uiConfig) || void 0 === e ? void 0 : e.children) || void 0 === t || t.map((e => e && x(e))).flat(2).forEach((e => {
                var t;
                return null === (t = null == e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e)
            }))
        }
        playPauseAnimation() {
            "playing" === this._animationState ? this.pauseAnimation() : this.playAnimation()
        }
        async playClip(e, t = !1) {
            return this.playClips([e], t)
        }
        async playClips(e, t = !1) {
            const n = [];
            return this.animations.forEach((({
                actions: t
            }) => {
                t.forEach((t => {
                    e.includes(t.getClip().name) && n.push(t)
                }))
            })), this.playAnimation(n, t)
        }
        async playAnimation(e, t = !1) {
            var n, r, s;
            if (!this.enabled) return;
            "playing" === this._animationState && this.stopAnimation(!1), g(null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("Picking")) || void 0 === r ? void 0 : r.transformControls, "enabled", !1);
            let o = 0;
            e || (e = [], this.animations.forEach((({
                mixer: t,
                actions: n,
                clips: r
            }) => {
                e.push(...n)
            })));
            const a = Be();
            this._lastAnimId = a, "paused" !== this._animationState && this.resetAnimation();
            for (const t of e) this.timeScale > 0 && (t.timeScale = this.timeScale), t.setLoop(this.loopAnimations ? i.YKA : i.jAl, this.loopRepetitions), t.play(), o = Math.max(o, t.getClip().duration / t.timeScale);
            if (this._animationState = "playing", null === (s = this._viewer) || void 0 === s || s.setDirty(), o *= this.loopAnimations ? this.loopRepetitions : 1, o /= this.animationSpeed, !isFinite(o)) return;
            const l = 1e3 * o - this._animationTime / this.animationSpeed + .01;
            l > 0 && await _c(l), a === this._lastAnimId && this.stopAnimation(t)
        }
        pauseAnimation() {
            var e, t, n;
            this._animationState = "paused", g(null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.transformControls, "enabled", !0), null === (n = this._viewer) || void 0 === n || n.setDirty(), this._lastAnimId = ""
        }
        stopAnimation(e = !1) {
            var t, n;
            this._animationState = "stopped", g(null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), "enabled", !0), e ? this.resetAnimation() : null === (n = this._viewer) || void 0 === n || n.setDirty(), this._lastAnimId = ""
        }
        resetAnimation() {
            var e;
            "stopped" === this._animationState ? (this.animations.forEach((({
                mixer: e,
                actions: t,
                clips: n
            }) => {
                e.stopAllAction(), e.setTime(0)
            })), this._animationTime = 0, null === (e = this._viewer) || void 0 === e || e.setDirty()) : this.stopAnimation(!0)
        }
    };
    wc.PluginType = "GLTFAnimation", wc.AnimationMarkersExtension = "WEBGI_animation_markers", yc([Ge()], wc.prototype, "animationState", null), yc([Ge()], wc.prototype, "animationTime", null), yc([Ge()], wc.prototype, "animationDuration", null), yc([C(xc.prototype.onPropertyChange), Ve("Loop", {
        limitedUi: !0
    })], wc.prototype, "loopAnimations", void 0), yc([C(xc.prototype.onPropertyChange)], wc.prototype, "loopRepetitions", void 0), yc([C(xc.prototype.onPropertyChange)], wc.prototype, "timeScale", void 0), yc([Ve(), xe()], wc.prototype, "animateOnScroll", void 0), yc([He("Speed", [.1, 4], .1, {
        limitedUi: !0
    }), xe()], wc.prototype, "animationSpeed", void 0), yc([C(xc.prototype.onStateChange)], wc.prototype, "_animationState", void 0), yc([Xe("Play/Pause", (e => ({
        label: () => "playing" === e.animationState ? "Pause" : "Play",
        limitedUi: !0
    })))], wc.prototype, "playPauseAnimation", null), yc([Xe("Stop", {
        limitedUi: !0
    })], wc.prototype, "stopAnimation", null), yc([Xe("Reset", {
        limitedUi: !0
    })], wc.prototype, "resetAnimation", null), wc = xc = yc([Qe("GLTF Animations")], wc);
    class Sc {
        constructor(e, t) {
            this.parser = e, this.name = wc.AnimationMarkersExtension, this.plugin = t
        }
        async afterRoot(e) {
            var t;
            let n = [];
            for (const e of this.parser.json.scenes) {
                if (!e.extensions) continue;
                const t = e.extensions[this.name];
                for (const e of (null == t ? void 0 : t.markers) || []) {
                    const t = void 0 !== e.camera ? await this.parser.getDependency("camera", e.camera) : void 0;
                    if (void 0 === e.time) {
                        const t = 30;
                        e.time = e.frame / t, console.error("Update timeline markers plugin for correct times.")
                    }
                    n.push({
                        name: e.name,
                        frame: e.frame,
                        time: e.time,
                        camera: t
                    })
                }
            }
            if (n.length < 1) return;
            n = n.sort(((e, t) => e.frame - t.frame));
            const r = null !== (t = e.scene) && void 0 !== t ? t : e.scenes[0];
            if (!r) return;
            r.userData.__markers = n;
            const s = this.plugin.timelineMarkers,
                o = n.map((e => e.time));
            let a = s.length;
            const l = n.map((e => a++)),
                c = Math.max(...o) + .01;
            s.push(...n);
            const u = new i.dUE(".currentTimelineMarker", o, l, 2300),
                p = new i.m7l("animationTimelineMarker", c, [u]);
            p.__gltfExport = !1, e.animations.push(p)
        }
    }
    const Mc = e => ({
        afterParse(t) {
            const n = e.json.scenes[e.json.scene || 0];
            n.extensions = n.extensions || {};
            const r = {
                    markers: []
                },
                i = [];
            if ((Array.isArray(t) ? t : [t]).forEach((e => e.traverse((e => {
                    e.userData.__markers && i.push(...e.userData.__markers)
                })))), i.sort(((e, t) => e.frame - t.frame)), !(i.length < 1)) {
                for (const t of i) {
                    const n = t.camera;
                    if (n) {
                        const i = e.nodeMap.get(n);
                        if (void 0 === i) {
                            console.warn("Camera not found in gltf export", n, e.nodeMap);
                            continue
                        }
                        const s = e.json.nodes[i].camera;
                        t.camera = s, r.markers.push(t)
                    }
                }
                n.extensions[wc.AnimationMarkersExtension] = r, e.extensionsUsed[wc.AnimationMarkersExtension] = !0
            }
        }
    });
    var Tc, Ec = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let Ac = Tc = class extends Ft {
        constructor() {
            super({
                vertexShader: s.vertexShader,
                defines: {
                    PASS_STEP: 1
                },
                uniforms: {
                    tSource: {
                        value: null
                    },
                    tDiffuse: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    },
                    tDiffuseSize: {
                        value: new i.FM8
                    },
                    weight: {
                        value: 1
                    },
                    tNormalDepth: {
                        value: null
                    }
                },
                fragmentShader: jt + "\nuniform float intensity;uniform float opacity;uniform vec2 tDiffuseSize;varying vec2 vUv;uniform float weight;\n#if PASS_STEP == 0\nuniform vec4 prefilter;vec4 Prefilter(vec4 c){if(getDepth(vUv)>0.999){return vec4(0.);}float brightness=max(c.r,max(c.g,c.b));float soft=brightness+prefilter.x*(prefilter.y-1.);soft=clamp(soft,0.,prefilter.z);soft=soft*soft*prefilter.w;float contribution=max(soft,brightness-prefilter.x);contribution/=max(brightness,0.001);return vec4(c.rgb*contribution,c.a);}\n#endif\nvec4 Sample(vec2 uv){return tDiffuseTexelToLinear(texture2D(tDiffuse,uv));}vec4 SampleBox(vec2 uv,float delta){vec4 o=vec2(-delta,delta).xxyy/tDiffuseSize.xyxy;vec4 s=Sample(uv+o.xy)+Sample(uv+o.zy)+Sample(uv+o.xw)+Sample(uv+o.zw);return s*0.25;}void main(){\n#if PASS_STEP == 0 \ngl_FragColor=weight*Prefilter(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 1 \ngl_FragColor=weight*(SampleBox(vUv,1.));gl_FragColor.a=1.;\n#elif PASS_STEP == 2 \ngl_FragColor=(SampleBox(vUv,0.5));gl_FragColor.a=1.;\n#elif PASS_STEP == 3 \nvec4 texel=tSourceTexelToLinear(texture2D(tSource,vUv));vec4 bloom=intensity*SampleBox(vUv,0.5).rgba;float brightness=max(bloom.r,max(bloom.g,bloom.b));texel.rgb+=bloom.rgb;texel.a=min(1.,texel.a+brightness);gl_FragColor=texel;\n#elif PASS_STEP == 4 \nvec4 texel=vec4(0.);texel.rgb+=intensity*SampleBox(vUv,0.5).rgb;texel.a=1.;gl_FragColor=texel;\n#endif\n#include <encodings_fragment>\n}"
            }, "tDiffuse", "tSource"), this.uiConfig = void 0, this.prefilter = new i.Ltg(2, .5, 0, 0), this.threshold = 2, this.softThreshold = .5, this.intensity = .5, this.bloomIterations = 4, this.radius = .6, this.power = 1, this.bloomDebug = !1, this._weights = [], this._updateWeights = this._updateWeights.bind(this), this._thresholdsUpdated = this._thresholdsUpdated.bind(this), this._updateWeights(), this._thresholdsUpdated(), this.clear = !0, this.userData = {
                setDirty: () => {
                    this.setDirty()
                }
            }
        }
        _thresholdsUpdated() {
            this.prefilter.x = this.threshold, this.prefilter.y = this.softThreshold, this.prefilter.z = 2 * this.prefilter.x * this.prefilter.y, this.prefilter.w = .125 / (this.uniforms.prefilter.value.z + 1e-5)
        }
        render(e, t, n, r, s) {
            const o = e.baseRenderer;
            this.material.defines.PASS_STEP = 0, this.clear = !0;
            const a = n;
            let l = .5,
                c = a.width * l,
                u = a.height * l;
            const p = [];
            let h = o.getTempTarget({
                sizeMultiplier: .5,
                type: i.cLu
            });
            p.push(h);
            let d = a;
            this.material.needsUpdate = !0, this.material.uniforms.weight.value = this._weights[0], super.render(e, h, d, r, s), d = h;
            let f = 1;
            for (; f < this.bloomIterations && (c /= 2, u /= 2, l /= 2, !(u < 2 || c < 2)); f++) {
                h = o.getTempTarget({
                    sizeMultiplier: l,
                    type: i.cLu
                }), p.push(h), this.material.defines.PASS_STEP = 1;
                let t = this._weights[f];
                t = 0 !== this._weights[f - 1] ? this._weights[f] / this._weights[f - 1] : this._weights[f], this.material.uniforms.weight.value = t, this.material.needsUpdate = !0, super.render(e, h, d, r, s), d = h
            }
            this.clear = !1;
            const _ = e.autoClear;
            for (e.autoClear = !1, f -= 2; f >= 0; f--) h = p[f], p[f] = void 0, this.material.defines.PASS_STEP = 2, this.material.transparent = !0, this.material.blending = i.WMw, this.material.needsUpdate = !0, e.autoClear = !1, super.render(e, h, d, r, s), this.material.blending = i.jFi, o.releaseTempTarget(d), d = h;
            this.clear = !0, e.autoClear = _, e.autoClear = !0, this.bloomDebug ? (this.material.defines.PASS_STEP = 4, this.material.needsUpdate = !0, super.render(e, t, d, r, s)) : (this.uniforms.tSource.value = a.texture, this.material.defines.PASS_STEP = 3, this.material.needsUpdate = !0, super.render(e, t, d, r, s), this.uniforms.tSource.value = null), o.releaseTempTarget(d)
        }
        _updateWeights() {
            if (!this._weights) return;
            const e = Math.max(Math.min(this.radius, 1), 0),
                t = 1 / (this.bloomIterations - 1);
            for (let n = 0; n < this.bloomIterations; n++) {
                let r = n * t + .1,
                    i = 1.2 - r;
                r = Math.pow(r, this.power), i = Math.pow(i, this.power), this._weights[n] = i * (1 - e) + r * e
            }
            this.setDirty()
        }
    };
    Ec([V()], Ac.prototype, "prefilter", void 0), Ec([He("Threshold", [0, 2]), C(Tc.prototype._thresholdsUpdated), xe()], Ac.prototype, "threshold", void 0), Ec([He("Soft Threshold", [0, 1]), C(Tc.prototype._thresholdsUpdated), xe()], Ac.prototype, "softThreshold", void 0), Ec([He("Intensity", [0, 3]), xe(), V()], Ac.prototype, "intensity", void 0), Ec([He("Iterations", [0, 7], 1), C(Tc.prototype._updateWeights), xe()], Ac.prototype, "bloomIterations", void 0), Ec([He("Radius", [0, 1], .01), C(Tc.prototype._updateWeights), xe()], Ac.prototype, "radius", void 0), Ec([He("Power", [.2, 10], .01), C(Tc.prototype._updateWeights), xe()], Ac.prototype, "power", void 0), Ec([Ve("Debug")], Ac.prototype, "bloomDebug", void 0), Ac = Tc = Ec([Qe("Bloom")], Ac);
    class Cc extends Ws {
        constructor() {
            super(...arguments), this.passId = "bloom", this._beforeFilters = ["tonemap", "screen"], this._afterFilters = ["render", "progressive"], this._requiredFilters = ["render"]
        }
        passCtor(e) {
            return new Ac
        }
        _update(e) {
            var t, n;
            return null === (t = e.getPlugin(Ys)) || void 0 === t || t.updateShaderProperties(null === (n = this.pass) || void 0 === n ? void 0 : n.passObject.material), super._update(e)
        }
        get uiConfig() {
            var e;
            return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig
        }
        get params() {
            var e;
            return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject
        }
    }
    Cc.PluginType = "Bloom";
    var Rc = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let kc = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.dependencies = [Vs], this._defines = {
                ANISOTROPY_DEBUG: !1
            }, this._uniforms = {
                anisotropyFactor: {
                    value: 1
                },
                anisotropyNoise: {
                    value: 1
                },
                anisotropyDirection: {
                    value: 1
                },
                anisotropyDirectionMap: {
                    value: null
                },
                frameCount: {
                    value: 0
                }
            }, this.materialExtension = {
                shaderExtender: (e, t, n) => {
                    var r;
                    if (!this.enabled || !t.materialObject.userData._isAnisotropic) return;
                    const s = null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r._anisotropyDirectionMap,
                        o = M `
                #include <bsdfs>
                //#if ANISOTROPY_ENABLED
                ${vo}
                ${"uniform float anisotropyFactor;uniform float anisotropyNoise;\n#if ANISOTROPY_TEX_MODE == 0\nuniform float anisotropyDirection;\n#else\nuniform sampler2D anisotropyDirectionMap;\n#endif\nconst float MIN_ROUGHNESS=0.05;float D_GGX_Anisotropy(float at,float ab,float ToH,float BoH,float NoH){float a2=at*ab;highp vec3 d=vec3(ab*ToH,at*BoH,a2*NoH);highp float d2=dot(d,d);float b2=a2/d2;return a2*b2*b2*(1./PI);}float V_GGX_SmithCorrelated_Anisotropy(float at,float ab,float ToV,float BoV,float ToL,float BoL,float NoV,float NoL){float lambdaV=NoL*length(vec3(at*ToV,ab*BoV,NoV));float lambdaL=NoV*length(vec3(at*ToL,ab*BoL,NoL));float v=0.5/(lambdaV+lambdaL);return saturate(v);}vec3 indirectAnisotropyBentNormal(const in vec3 normal,const in vec3 viewDir,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){vec3 aDirection=anisotropyFactor>=0.?anisotropicB:anisotropicT;vec3 aTangent=cross(aDirection,viewDir);vec3 aNormal=cross(aTangent,aDirection);float bendFactor=abs(anisotropyFactor)*saturate(5.*max(roughness,MIN_ROUGHNESS));return normalize(mix(normal,aNormal,bendFactor));}vec3 BRDF_GGX_Anisotropy(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));float dotTV=dot(anisotropicT,viewDir);float dotBV=dot(anisotropicB,viewDir);float dotTL=dot(anisotropicT,lightDir);float dotBL=dot(anisotropicB,lightDir);float dotTH=dot(anisotropicT,halfDir);float dotBH=dot(anisotropicB,halfDir);float aspect=sqrt(1.-min(1.-MIN_ROUGHNESS,abs(anisotropyFactor)*0.9));if(anisotropyFactor>0.)aspect=1./aspect;float at=roughness*aspect;float ab=roughness/aspect;vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated_Anisotropy(at,ab,dotTV,dotBV,dotTL,dotBL,dotNV,dotNL);float D=D_GGX_Anisotropy(at,ab,dotTH,dotBH,dotNH);return F*(V*D);}"}
            ` + (s ? U("anisotropyDirectionMap", s, n.capabilities.isWebGL2) : "");
                    e.fragmentShader = e.fragmentShader.replace("#include <bsdfs>", o), e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_begin>", i.WdD.lights_fragment_begin), e.fragmentShader = e.fragmentShader.replace("IncidentLight directLight;", "float rnd=(random2(vUv.xy,frameCount)-0.5)*anisotropyNoise*material.roughness;\n#if ANISOTROPY_TEX_MODE < 2\n#if ANISOTROPY_TEX_MODE == 0 \nfloat rot=saturate(anisotropyDirection);\n#else \nfloat rot=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).r);\n#endif\nrot=rot*2.*PI+rnd;vec2 rot2=vec2(sin(rot),cos(rot));\n#else \nvec2 rot2=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vUv)).rg*2.-1.)+vec2(rnd,rnd);rot2=normalize(rot2);const float anisoSpecMultiplier=0.25;float matSpecAniso=(length(material.specularColor.rgb))*2.*PI;rot2=mix(rot2,vec2(sin(matSpecAniso),cos(matSpecAniso)),anisoSpecMultiplier);rot2=normalize(rot2);\n#endif\nvec3 anisotropicT=(tangent*rot2.x+bitangent*rot2.y);anisotropicT=normalize(anisotropicT-normal*dot(anisotropicT,normal));vec3 anisotropicB=normalize(cross(normal,anisotropicT));IncidentLight directLight;").replaceAll("RE_Direct( directLight, geometry, material, reflectedLight )", "RE_Direct( directLight, geometry, material, reflectedLight, anisotropicT, anisotropicB )");
                    const a = i.WdD.lights_physical_pars_fragment.replace("void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {", "void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight, const in vec3 anisotropicT, const in vec3 anisotropicB ) {").replace("BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness )", "BRDF_GGX_Anisotropy( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness, anisotropicT, anisotropicB )");
                    e.fragmentShader = e.fragmentShader.replace("#include <lights_physical_pars_fragment>", a);
                    const l = M `
                #if defined( USE_ENVMAP )
                vec3 anisotropyBentNormal = indirectAnisotropyBentNormal(geometry.normal, geometry.viewDir, material.roughness, anisotropicT, anisotropicB);
                #endif
            ` + i.WdD.lights_fragment_maps.replace("getIBLIrradiance( geometry.normal )", "getIBLIrradiance( anisotropyBentNormal )").replace("getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness )", "getIBLRadiance( geometry.viewDir, anisotropyBentNormal, material.roughness )");
                    e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_maps>", l), e.vertexUvs = !0, e.vertexTangents = !0
                },
                onObjectRender: (e, t) => {
                    var n;
                    const r = t.materialObject.userData;
                    if (!(null == r ? void 0 : r._isAnisotropic)) return;
                    const i = e;
                    if (!i.isMesh || !i.geometry) return;
                    if (!i.geometry.attributes.tangent) throw new Error("No tangents on the geometry");
                    this._uniforms.anisotropyFactor.value = r._anisotropyFactor, this._uniforms.anisotropyNoise.value = r._anisotropyNoise, this._uniforms.anisotropyDirectionMap.value = (null === (n = r._anisotropyDirectionMap) || void 0 === n ? void 0 : n.isTexture) ? r._anisotropyDirectionMap : null, this._uniforms.anisotropyDirection.value = r._anisotropyDirection;
                    let s = this.enabled ? 1 : 0;
                    t.materialObject.defines.ANISOTROPY_ENABLED !== s && (t.materialObject.defines.ANISOTROPY_ENABLED = s, t.materialObject.needsUpdate = !0), s = +this._defines.ANISOTROPY_DEBUG, t.materialObject.defines.ANISOTROPY_DEBUG !== s && (t.materialObject.defines.ANISOTROPY_DEBUG = s, t.materialObject.needsUpdate = !0), s = r._anisotropyDirectionMode, this._uniforms.anisotropyDirectionMap.value || (s = "CONSTANT"), s = "DIRECTION" === s ? 2 : "ROTATION" === s ? 1 : 0, t.materialObject.defines.ANISOTROPY_TEX_MODE !== s && (t.materialObject.defines.ANISOTROPY_TEX_MODE = s, t.materialObject.needsUpdate = !0)
                },
                extraUniforms: { ...this._uniforms
                },
                computeCacheKey: e => {
                    var t, n, r;
                    return (this.enabled ? "1" : "0") + ((null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._isAnisotropic) ? "1" : "0") + (null === (r = null === (n = e.materialObject.userData) || void 0 === n ? void 0 : n._anisotropyDirectionMap) || void 0 === r ? void 0 : r.uuid)
                },
                isCompatible: e => e.isMeshStandardMaterial2,
                updaters: () => {
                    var e;
                    return [null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer]
                },
                getUiConfig: e => {
                    const t = this.makeAnisotropic,
                        n = {
                            type: "folder",
                            label: "Anisotropy",
                            children: [{
                                type: "checkbox",
                                label: "Enabled",
                                get value() {
                                    return e.materialObject.userData._isAnisotropic || !1
                                },
                                set value(r) {
                                    var i;
                                    r !== e.materialObject.userData._isAnisotropic && (r ? t(e) || alert("One or more geometries cannot be made anisotropic.") : (e.materialObject.userData._isAnisotropic = !1, e.materialObject.needsUpdate = !0), null === (i = n.uiRefresh) || void 0 === i || i.call(n, "postFrame", !0))
                                },
                                onChange: this.setDirty
                            }, {
                                type: "slider",
                                label: "Factor",
                                bounds: [-2, 2],
                                hidden: () => !e.materialObject.userData._isAnisotropic,
                                property: [e.materialObject.userData, "_anisotropyFactor"],
                                onChange: this.setDirty
                            }, {
                                type: "slider",
                                label: "Noise",
                                bounds: [0, 2],
                                hidden: () => !e.materialObject.userData._isAnisotropic,
                                property: [e.materialObject.userData, "_anisotropyNoise"],
                                onChange: this.setDirty
                            }, {
                                type: "image",
                                label: "Texture",
                                hidden: () => !e.materialObject.userData._isAnisotropic,
                                property: [e.materialObject.userData, "_anisotropyDirectionMap"],
                                onChange: () => {
                                    e.materialObject.needsUpdate = !0, this.setDirty()
                                }
                            }, {
                                type: "dropdown",
                                label: "Mode",
                                hidden: () => !e.materialObject.userData._isAnisotropic,
                                property: [e.materialObject.userData, "_anisotropyDirectionMode"],
                                children: ["CONSTANT", "ROTATION", "DIRECTION"].map((e => ({
                                    label: e
                                }))),
                                onChange: () => {
                                    e.materialObject.needsUpdate = !0, this.setDirty()
                                }
                            }]
                        };
                    return n
                }
            }, this.setDirty = () => {
                var e;
                null === (e = this._viewer) || void 0 === e || e.setDirty()
            }, this.makeSelectedAnisotropic = () => {
                var e, t, n;
                const r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material;
                return "material" === (null == r ? void 0 : r.assetType) && this.makeAnisotropic(r)
            }, this._loaderCreate = this._loaderCreate.bind(this)
        }
        makeAnisotropic(e) {
            var t;
            const n = null === (t = e.materialObject) || void 0 === t ? void 0 : t.userData;
            if (!n) return !1;
            if (void 0 === n._isAnisotropic) {
                const e = n.appliedMeshes;
                let t = !0;
                if (e)
                    for (const {
                            geometry: n
                        } of e) !n || n.index && n.attributes.position && n.attributes.normal && n.attributes.uv || (t = !1), t && !n.attributes.tangent && n.computeTangents();
                if (!t) return !1
            }
            return n._isAnisotropic = !0, void 0 === n._anisotropyFactor && (n._anisotropyFactor = 1), void 0 === n._anisotropyNoise && (n._anisotropyNoise = 0), void 0 === n._anisotropyDirectionMode && (n._anisotropyDirectionMode = "DIRECTION"), e.materialObject.needsUpdate = !0, !0
        }
        _loaderCreate({
            loader: e
        }) {
            e.isGLTFLoader2 && e.register((e => new Pc(e)))
        }
        async onAdded(e) {
            var t, n, r, i, s;
            await super.onAdded(e);
            const o = e.getPlugin(Vs);
            null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Dc)
        }
        async onRemove(e) {
            var t, n, r, i;
            return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e)
        }
    };
    kc.PluginType = "AnisotropyPlugin", kc.ANISOTROPY_GLTF_EXTENSION = "WEBGI_materials_anisotropy", Rc([Ve("Enabled", (e => ({
        onChange: e.setDirty
    }))), xe()], kc.prototype, "enabled", void 0), Rc([Xe("Make Anisotropy", (e => ({
        hidden: () => {
            var t;
            return !(null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca))
        }
    })))], kc.prototype, "makeSelectedAnisotropic", void 0), kc = Rc([Qe("Anisotropy Materials")], kc);
    class Pc {
        constructor(e) {
            this.parser = e, this.name = kc.ANISOTROPY_GLTF_EXTENSION
        }
        async extendMaterialParams(e, t) {
            var n, r, s;
            const o = this.parser,
                a = o.json.materials[e];
            if (!a.extensions || !a.extensions[this.name]) return Promise.resolve();
            const l = [],
                c = a.extensions[this.name];
            t.userData || (t.userData = {}), t.userData._isAnisotropic = !0, t.userData._anisotropyFactor = null !== (n = c.anisotropyFactor) && void 0 !== n ? n : 0, t.userData._anisotropyNoise = null !== (s = null !== (r = c.anisotropyNoiseFactor) && void 0 !== r ? r : c.anisotropyNoise) && void 0 !== s ? s : 0;
            let {
                anisotropyDirectionMode: u,
                anisotropyDirection: p
            } = c;
            return u || (u = c.anisotropyTextureMode), p || (p = c.anisotropyRotation), t.userData._anisotropyDirectionMode = u && "number" == typeof(null == p ? void 0 : p.index) ? u : "CONSTANT", "ROTATION" === u || "DIRECTION" === u ? l.push(o.assignTexture(t.userData, "_anisotropyDirectionMap", p).then((e => {
                e.encoding = i.knz
            }))) : t.userData._anisotropyDirection = null != p ? p : 0, Promise.all(l)
        }
        afterRoot(e) {
            return e.scene.traverse((e => {
                var t, n;
                if (!(null === (n = null === (t = e.material) || void 0 === t ? void 0 : t.userData) || void 0 === n ? void 0 : n._isAnisotropic)) return;
                const r = e.geometry;
                r.attributes.tangent || (r.computeTangents(), r.attributes.tangent.needsUpdate = !0)
            })), null
        }
    }
    const Dc = e => ({
        writeMaterial: (t, n) => {
            if (!t.isMeshStandardMaterial || !t.userData._isAnisotropic) return;
            if ((t.userData._anisotropyFactor || 0) < .001) return;
            n.extensions = n.extensions || {};
            const r = {};
            if (r.anisotropyFactor = t.userData._anisotropyFactor || 1, r.anisotropyNoiseFactor = t.userData._anisotropyNoise || 0, r.anisotropyDirectionMode = t.userData._anisotropyDirectionMode || "CONSTANT", t.userData._anisotropyDirectionMap && "CONSTANT" !== r.anisotropyDirectionMode) {
                const n = {
                    index: e.processTexture(t.userData._anisotropyDirectionMap)
                };
                e.applyTextureTransform(n, t.userData._anisotropyDirectionMap), r.anisotropyDirection = n
            } else r.anisotropyDirectionMode = "CONSTANT", r.anisotropyDirection = t.userData._anisotropyDirection || 0;
            n.extensions[kc.ANISOTROPY_GLTF_EXTENSION] = r, e.extensionsUsed[kc.ANISOTROPY_GLTF_EXTENSION] = !0
        }
    });
    class Oc extends Ft {
        constructor(e, t) {
            super({
                vertexShader: s.vertexShader,
                fragmentShader: t + "\n" + mo + "\n#include <common>\nvarying vec2 vUv;uniform vec2 previousRTSize;uniform mat4 lastProjectionViewMatrix;uniform mat4 currentProjectionViewMatrix;uniform mat4 inverseViewMatrix;uniform vec2 jitterSample;uniform vec2 feedBack;uniform bool firstFrame;\n#if HAS_VELOCITY_BUFFER == 1\nuniform sampler2D tVelocity;\n#endif\nvec3 find_closest_fragment_3x3(const in vec2 uv){const vec3 offset=vec3(-1.,1.,0.);vec2 texelSize=1./previousRTSize;vec3 dtr=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtc=vec3(0,1,getDepth(uv+offset.zx*texelSize));vec3 dtl=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dml=vec3(-1,0,getDepth(uv+offset.yz*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dmr=vec3(1,0,getDepth(uv+offset.xz*texelSize));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbc=vec3(0,-1,getDepth(uv+offset.zy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtc.z)dmin=dtc;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dml.z)dmin=dml;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dmr.z)dmin=dmr;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbc.z)dmin=dbc;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+texelSize.xy*dmin.xy,dmin.z);}vec3 find_closest_fragment_5tap(const in vec2 uv){vec2 texelSize=1./previousRTSize;vec2 offset=vec2(1.,-1.);vec3 dtl=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtr=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+dmin.xy*texelSize,dmin.z);}vec4 clip_aabb(const in vec4 aabb_min,const in vec4 aabb_max,vec4 p){const float FLT_EPS=1e-8;vec4 p_clip=0.5*(aabb_max+aabb_min);vec4 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=p-p_clip;vec4 v_unit=abs(v_clip/e_clip);float ma_unit=max(v_unit.x,max(v_unit.y,v_unit.z));if(ma_unit>1.)return p_clip+v_clip/ma_unit;else return p;}\n#if HAS_VELOCITY_BUFFER == 0\nvec2 computeScreenSpaceVelocity(const in vec3 worldPosition){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(worldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(worldPosition,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}\n#endif\nvec4 computeTAA(const in vec2 uv,const in vec2 screenSpaceVelocity){vec2 jitterOffset=jitterSample/previousRTSize;vec2 uvUnJitter=uv;vec4 currentColor=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter));vec4 previousColor=previousRTTexelToLinear(texture2D(previousRT,uv-screenSpaceVelocity));const vec3 offset=vec3(1.,-1.,0.);vec2 texelSize=1./previousRTSize;float texelSpeed=length(screenSpaceVelocity);vec4 tl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yx*texelSize));vec4 tc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zx*texelSize));vec4 tr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xx*texelSize));vec4 ml=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yz*texelSize));vec4 mc=currentColor;vec4 mr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xz*texelSize));vec4 bl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yy*texelSize));vec4 bc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zy*texelSize));vec4 br=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xy*texelSize));vec4 corners=2.*(tr+bl+br+tl)-2.*mc;mc+=(mc-(corners*0.166667))*2.718282*0.3;mc=max(vec4(0.),mc);vec4 min5=min(tc,min(ml,min(mc,min(mr,bc))));vec4 max5=max(tc,max(ml,max(mc,max(mr,bc))));vec4 cmin=min(min5,min(tl,min(tr,min(bl,br))));vec4 cmax=max(min5,max(tl,max(tr,max(bl,br))));;cmin=0.5*(cmin+min5);cmax=0.5*(cmax+max5);previousColor=clip_aabb(cmin,cmax,previousColor);float lum0=linearToRelativeLuminance(currentColor.rgb);float lum1=linearToRelativeLuminance(previousColor.rgb);float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedBack.x,feedBack.y,unbiased_weight_sqr);return mix(currentColor,previousColor,k_feedback);}vec3 getWorldPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return(inverseViewMatrix*vec4(xe,ye,viewDepth,1.)).xyz;}void main(){vec2 jitterOffset=jitterSample/previousRTSize;\n#if QUALITY == 1\nvec3 c_frag=find_closest_fragment_3x3(vUv);\n#else\nvec3 c_frag=find_closest_fragment_5tap(vUv);\n#endif\nif(c_frag.z>=0.999){gl_FragColor=currentRTTexelToLinear(texture2D(currentRT,vUv-jitterOffset));}else{float sampleViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,c_frag.z);vec3 worldPosition=getWorldPositionFromViewZ(c_frag.xy,sampleViewZ);\n#if HAS_VELOCITY_BUFFER == 0\nvec2 screenSpaceVelocity=computeScreenSpaceVelocity(worldPosition);\n#else\nvec2 screenSpaceVelocity=(texture2D(tVelocity,vUv).xy*2.-1.);screenSpaceVelocity=sign(screenSpaceVelocity)*pow(abs(screenSpaceVelocity),vec2(4.));\n#endif\ngl_FragColor=firstFrame?currentRTTexelToLinear(texture2D(currentRT,vUv)):computeTAA(vUv,screenSpaceVelocity);}\n#include <encodings_fragment>\n}",
                uniforms: {
                    currentRT: {
                        value: null
                    },
                    previousRT: {
                        value: null
                    },
                    previousRTSize: {
                        value: new i.FM8
                    },
                    cameraNearFar: {
                        value: new i.FM8
                    },
                    lastProjectionViewMatrix: {
                        value: new i.yGw
                    },
                    currentProjectionViewMatrix: {
                        value: new i.yGw
                    },
                    projection: {
                        value: new i.yGw
                    },
                    inverseViewMatrix: {
                        value: new i.yGw
                    },
                    jitterSample: {
                        value: new i.FM8
                    },
                    firstFrame: {
                        value: !0
                    },
                    tNormalDepth: {
                        value: null
                    },
                    tVelocity: {
                        value: null
                    }
                },
                defines: {
                    HAS_VELOCITY_BUFFER: 0,
                    QUALITY: 1,
                    UNJITTER: 0
                }
            }, "currentRT", "previousRT"), this.taaEnabled = !0, this.feedBack = new i.FM8(.88, .97), this.uiConfig = {
                type: "folder",
                label: "Temporal AA",
                children: [{
                    type: "checkbox",
                    label: "Enabled",
                    property: [this, "enabled"],
                    onChange: () => this.onSizeUpdate()
                }, {
                    type: "input",
                    label: "Feedback",
                    property: [this, "feedBack"],
                    onChange: this.setDirty
                }]
            }, this.onSizeUpdate = this.onSizeUpdate.bind(this), this.target = e, this.clear = !1, this.needsSwap = !0
        }
        render(e, t, n, r, i) {
            if (!this.taaEnabled || !this.enabled) return void(this.needsSwap = !1);
            this.needsSwap = !0;
            const s = this.uniforms.tVelocity.value ? 1 : 0;
            s !== this.material.defines.HAS_VELOCITY_BUFFER && (this.material.defines.HAS_VELOCITY_BUFFER = s, this.material.needsUpdate = !0), this.uniforms.previousRT.value = this.target.texture, super.render(e, t, n, r, i), this.uniforms.lastProjectionViewMatrix.value.copy(this.uniforms.currentProjectionViewMatrix.value), this.uniforms.firstFrame.value = !1
        }
        updateCameraProperties(e) {
            e && (this.uniforms.currentProjectionViewMatrix.value.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this.uniforms.inverseViewMatrix.value.copy(e.matrixWorld))
        }
        onSizeUpdate() {
            this.uniforms.firstFrame.value = !0, this.setDirty()
        }
        setSize(e, t) {
            super.setSize(e, t), this.onSizeUpdate()
        }
    }! function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        s > 3 && o && Object.defineProperty(t, n, o)
    }([xe(), V()], Oc.prototype, "feedBack", void 0);
    class Lc extends Ws {
        constructor() {
            super(...arguments), this.passId = "taa", this._beforeFilters = ["progressive"], this._afterFilters = [], this._requiredFilters = ["render", "progressive"], this.dependencies = [Ys]
        }
        passCtor(e) {
            if (!e.getPlugin(co)) throw "Add ProgressivePlugin before TAA";
            const t = new Oc(e.getPlugin(co).lastFrame, e.getPlugin(Ys).getUnpackSnippet());
            return e.renderer.addEventListener("resize", t.onSizeUpdate), t
        }
        setDirty() {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setDirty()
        }
        async onDispose(e) {
            return this.pass && e.renderer.removeEventListener("resize", this.pass.passObject.onSizeUpdate), super.onDispose(e)
        }
        _update(e) {
            if (!super._update(e)) return !1;
            const t = e.renderer.frameCount,
                n = this._pass.passObject;
            if (n.taaEnabled = t < 1, !n.taaEnabled) return !1;
            const r = e.scene.activeCamera;
            return n.updateShaderProperties([e.getPlugin(Ys), r, e.getPluginByType("VelocityBuffer")]), n.target = e.getPlugin(co).lastFrame, n.updateCameraProperties(null == r ? void 0 : r.cameraObject), !0
        }
        get uiConfig() {
            var e;
            return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig
        }
    }
    Lc.PluginType = "TAA";
    class Ic {
        static async GetDataUrl(e, {
            mimeType: t = "image/png",
            rect: n = {
                x: 0,
                y: 0,
                width: e.width,
                height: e.height,
                assumeClientRect: !1
            },
            displayPixelRatio: r = 1,
            scale: i = 1
        }) {
            var s, o, a;
            const l = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            l.width = n.width * i * r, l.height = n.height * i * r, n.assumeClientRect && (n.x *= e.width / (r * e.clientWidth), n.y *= e.height / (r * e.clientHeight), n.width *= e.width / (r * e.clientWidth), n.height *= e.height / (r * e.clientHeight));
            const c = l.getContext("2d");
            if (!c) return console.error("snapshot: cannot create context"), "";
            const u = e.style.background || (null === (s = e.parentElement) || void 0 === s ? void 0 : s.style.background) || "";
            if (u.includes("url")) {
                const t = null === (o = /url\("(.*)"\)/gi.exec(u)) || void 0 === o ? void 0 : o[1];
                if (t) {
                    const i = new Image;
                    i.src = t, await new Promise(((e, t) => {
                        i.onload = () => e(), i.onerror = () => t(), i.complete && e()
                    })), c.drawImage(i, i.width * n.x * r / e.width, i.height * n.y * r / e.height, i.width * n.width * r / e.width, i.height * n.height * r / e.height, 0, 0, l.width, l.height)
                }
            } else c.fillStyle = e.style.background || (null === (a = e.parentElement) || void 0 === a ? void 0 : a.style.backgroundColor) || "#00000000", c.fillRect(0, 0, l.width, l.height);
            null == c || c.drawImage(e, n.x * r, n.y * r, n.width * r, n.height * r, 0, 0, l.width, l.height);
            const p = c.canvas.toDataURL(t);
            return l.remove(), p
        }
        static async GetImage(e, t = {}) {
            const n = await this.GetDataUrl(e, t);
            return new Promise(((e, t) => {
                const r = new Image;
                r.onload = () => {
                    e(r)
                }, r.src = n
            }))
        }
        static async GetBlob(e, t = {}) {
            return await (await fetch(await this.GetDataUrl(e, t))).blob()
        }
        static async GetFile(e, t = "image.png", n = {}) {
            var r;
            return n.getDataUrl ? await this.GetDataUrl(e, n) : new File([await this.GetBlob(e, n)], t, {
                type: null !== (r = n.mimeType) && void 0 !== r ? r : "image/png",
                lastModified: Ct()
            })
        }
    }
    var Fc = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let Nc = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.downloadSnapshot = this.downloadSnapshot.bind(this)
        }
        async getFile(e, t = {}) {
            return t.getDataUrl = !1, await this._getFile(e, t)
        }
        async getDataUrl(e = {}) {
            var t;
            return e.getDataUrl = !0, null !== (t = await this._getFile("", e)) && void 0 !== t ? t : ""
        }
        async _getFile(e, t = {}) {
            var n, r, i;
            const s = null === (n = this._viewer) || void 0 === n ? void 0 : n.canvas;
            if (s) {
                const n = this._viewer.renderer.displayCanvasScaling;
                void 0 !== t.displayPixelRatio && t.displayPixelRatio !== n && (this._viewer.renderer.displayCanvasScaling = t.displayPixelRatio);
                const o = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPlugin(co);
                if (t.waitForProgressive && o && void 0 === t.timeout)
                    for (; !o.isConverged(!0);) await _c(64);
                else await _c(null !== (i = t.timeout) && void 0 !== i ? i : 200);
                t.displayPixelRatio = 1;
                const a = await Ic.GetFile(s, e, t);
                return t.displayPixelRatio = this._viewer.renderer.displayCanvasScaling, this._viewer.renderer.displayCanvasScaling = n, a
            }
        }
        async downloadSnapshot(e = "snapshot.png", t = {}) {
            const n = await this.getFile(e, t);
            n && xt(n)
        }
    };
    Nc.PluginType = "CanvasSnipper", Fc([Xe("Download .png", {
        limitedUi: !0
    })], Nc.prototype, "downloadSnapshot", null), Nc = Fc([Qe("Canvas Snipper")], Nc);
    var Uc = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let Bc = 1,
        jc = class {
            constructor(e, t, n, r, s) {
                this.position = new i.Pa4, this.target = new i.Pa4, this.quaternion = new i._fP, this.up = new i.Pa4, this.name = "Camera View", this.snap = "", this.focusView = () => {}, this.deleteView = () => {}, this.uiConfig = $e(this.name, this), e && (this.position = e), t && (this.target = t), n && (this.up = n), r && (this.quaternion = r), s && (this.snap = s), this.name = "Camera View" + Bc++
            }
            _nameChanged() {
                var e, t;
                this.uiConfig && (this.uiConfig.label = this.name, null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e))
            }
        };
    Uc([xe(), We()], jc.prototype, "position", void 0), Uc([xe(), We()], jc.prototype, "target", void 0), Uc([xe(), We()], jc.prototype, "quaternion", void 0), Uc([xe(), We()], jc.prototype, "up", void 0), Uc([xe(), qe()], jc.prototype, "name", void 0), Uc([Ze()], jc.prototype, "snap", void 0), Uc([Xe()], jc.prototype, "focusView", void 0), Uc([Xe()], jc.prototype, "deleteView", void 0), jc = Uc([Ae("CameraView")], jc);
    class zc extends Gs {
        constructor() {
            super(), this.enabled = !0, this._cameraViews = [], this.viewLooping = !1, this.viewPauseTime = 200, this.animEase = "easeInOutSine", this.animDuration = 1e3, this.rotationOffset = .25, this.interpolateMode = "spherical", this.animateOnScroll = !1, this.seekOnScroll = !1, this._animating = !1, this.dependencies = [], this._scrollAnimationState = 0, this.scrollAnimationDamping = .1, this._updaters = [], this._lastFrameTime = 0, this._fadeDisabled = !1, this._viewQueue = [], this._animationLooping = !1, this._infiniteLooping = !0, this._driver = e => ({
                start: () => this._updaters.push({
                    u: e,
                    time: 0
                }),
                stop: () => this._updaters.splice(this._updaters.findIndex((t => t.u === e)), 1)
            }), this.focusNext = (e = !0) => {
                if (this._animating) return;
                if (this._cameraViews.length < 2) return;
                let t = this._cameraViews.findIndex((e => e === this._currentView));
                t < 0 && (t = -1), t += 1, e ? t %= this._cameraViews.length : t = Math.min(t, this._cameraViews.length - 1), this.focusView(this._cameraViews[t])
            }, this.focusPrevious = (e = !0) => {
                if (this._animating) return;
                if (this._cameraViews.length < 2 || !this._currentView) return;
                let t = this._cameraViews.findIndex((e => e === this._currentView));
                t < 0 && (t = 0), t -= 1, t = e ? (t + this._cameraViews.length) % this._cameraViews.length : Math.max(t, 0), this.focusView(this._cameraViews[t])
            }, this._popAnimations = [], this.uiConfig = {
                type: "folder",
                label: "Camera Views",
                children: [() => [...this._cameraViews.map((e => e.uiConfig))], ...Je(this)]
            }, this.addCurrentView = this.addCurrentView.bind(this), this.animateAllViews = this.animateAllViews.bind(this), this.recordAllViews = this.recordAllViews.bind(this), this.resetToFirstView = this.resetToFirstView.bind(this), this._wheel = this._wheel.bind(this), this._pointerMove = this._pointerMove.bind(this), this._postFrame = this._postFrame.bind(this)
        }
        get camViews() {
            return this._cameraViews
        }
        _wheel(e) {
            this.enabled && (this.seekOnScroll && !this._animating || Math.abs(e.deltaY) > .001 && (this._scrollAnimationState = -1 * Math.sign(e.deltaY)))
        }
        _pointerMove(e) {
            var t;
            if (this.enabled && !this._animating && this.seekOnScroll) {
                const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.activeCamera;
                if (!n) return;
                const r = new i.$V,
                    s = n.position,
                    o = n.target,
                    a = (new i._fP).setFromUnitVectors(n.cameraObject.up, new i.Pa4(0, 1, 0)),
                    l = a.clone().invert(),
                    c = s.clone().sub(o);
                c.applyQuaternion(a), r.setFromVector3(c), r.theta += this.rotationOffset * e.movementX / this._viewer.canvas.clientWidth, r.phi += this.rotationOffset * e.movementY / this._viewer.canvas.clientHeight, r.makeSafe(), c.setFromSpherical(r), c.applyQuaternion(l), s.copy(o).add(c), n.positionUpdated(!1), n.targetUpdated()
            }
        }
        async onAdded(e) {
            await super.onAdded(e);
            let t = !1;
            e.addEventListener("preFrame", (e => {
                this.seekOnScroll || this._animating ? this._viewer.scene.activeCamera.interactionsEnabled && (this._viewer.scene.activeCamera.interactionsEnabled = !1, t = !0) : t && (this._viewer.scene.activeCamera.interactionsEnabled = !0, t = !1)
            })), e.addEventListener("postFrame", this._postFrame), window.addEventListener("wheel", this._wheel), window.addEventListener("pointermove", this._pointerMove)
        }
        _postFrame() {
            var e, t;
            if (!this._viewer) return;
            if (!this.enabled || !this._animating) return this._lastFrameTime = 0, void(this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(zc.PluginType), this._fadeDisabled = !1));
            const n = Ct() / 1e3;
            this._lastFrameTime < 1 && (this._lastFrameTime = n - 1 / 60);
            let r = n - this._lastFrameTime;
            this._lastFrameTime = n, r *= this.animateOnScroll ? this._scrollAnimationState : 1;
            const i = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();
            if (i && i > 0 && (r = i), 0 !== i && (r *= 1e3, !(r <= 0 || (this._updaters.forEach((e => {
                    let t = r;
                    e.time + t < 0 && (t = -e.time), e.time += t, Math.abs(t) > .001 && e.u(t)
                })), this._scrollAnimationState < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping, this._fadeDisabled)))) {
                const e = this._viewer.getPluginByType("FrameFade");
                e && (e.disable(zc.PluginType), this._fadeDisabled = !0)
            }
        }
        async onRemove(e) {
            return e.removeEventListener("postFrame", this._postFrame), window.removeEventListener("wheel", this._wheel), window.removeEventListener("pointermove", this._pointerMove), super.onRemove(e)
        }
        async _animationLoop() {
            if (!this._animationLooping) {
                for (this._animationLooping = !0;
                    (this.viewLooping || !this._infiniteLooping) && this.enabled && !(this._cameraViews.length < 1);) {
                    if (0 === this._viewQueue.length) {
                        if (!this._infiniteLooping) break;
                        this._viewQueue.push(...this._cameraViews)
                    }
                    await this.animateToView(this._viewQueue.shift()), await _c(2 + this.viewPauseTime)
                }
                this._animationLooping = !1
            }
        }
        async animateAllViews() {
            if (this.enabled && !(this.viewLooping || this._cameraViews.length < 2)) {
                for (; this._viewQueue.length > 0;) this._viewQueue.pop();
                this._viewQueue.push(...this._cameraViews), this._viewQueue.push(this._viewQueue.shift()), this._infiniteLooping = !1, await this._animationLoop(), this._infiniteLooping = !0
            }
        }
        async resetToFirstView(e = 100) {
            this.enabled && (this._currentView = void 0, await this.animateToView(this._cameraViews[0], e), await _c(2))
        }
        async recordAllViews(e) {
            var t;
            if (!this.enabled) return;
            const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("CanvasRecorder");
            return n && n.enabled && (await this.resetToFirstView(), n.startRecording()) ? new Promise(((t, r) => {
                const i = () => {
                        n.removeEventListener("start", s), n.removeEventListener("stop", i), n.removeEventListener("error", o)
                    },
                    s = async () => {
                        i(), null == e || e(), await this.animateAllViews();
                        const r = await n.stopRecording();
                        r && vt(r, "recording.mp4"), t()
                    },
                    o = async () => {
                        i(), r()
                    };
                n.addEventListener("start", s), n.addEventListener("stop", i), n.addEventListener("error", o)
            })) : void 0
        }
        async addCurrentView() {
            var e, t, n, r, i;
            if (!this.enabled) return;
            const s = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.activeCamera;
            if (!s) return;
            const o = this.getCurrentCameraView(s);
            o.snap = await (null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Nc)) || void 0 === n ? void 0 : n.getDataUrl({
                displayPixelRatio: .25,
                mimeType: "image/jpg"
            })) || "", this._cameraViews.push(o), null === (i = (r = this.uiConfig).uiRefresh) || void 0 === i || i.call(r)
        }
        getCurrentCameraView(e) {
            const t = new i.Pa4,
                n = e.cameraObject.matrixWorld;
            t.x = n.elements[4], t.y = n.elements[5], t.z = n.elements[6];
            const r = new jc(e.position.clone(), e.target.clone(), t.normalize(), e.cameraObject.quaternion.clone(), "");
            return r.focusView = async () => this.focusView(r), r.deleteView = () => this.deleteView(r), r
        }
        async focusView(e) {
            return this.animateToView(e)
        }
        deleteView(e) {
            var t, n;
            const r = this._cameraViews.indexOf(e);
            r >= 0 && this._cameraViews.splice(r, 1), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t)
        }
        async animateToView(e, t, n) {
            var r;
            const s = null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.activeCamera;
            if (!s) return;
            if (this._animating && (this._popAnimations.forEach((e => {
                    var t;
                    return null === (t = null == e ? void 0 : e.stop) || void 0 === t ? void 0 : t.call(e)
                })), await _c(100), this._animating)) return void console.warn("todo: still animating?");
            this._currentView = e, this._animating = !0, this.dispatchEvent({
                type: "startViewChange",
                view: e
            }), void 0 === t && (t = this.animDuration);
            const o = "function" == typeof n ? n : fc[n || this.animEase],
                a = this._driver,
                l = [];
            this._popAnimations = [];
            const c = this._popAnimations;
            if ("spherical" === this.interpolateMode) l.push(async function(e, t, n, r, s, o) {
                const a = e.target.clone(),
                    l = new i.Pa4,
                    c = new i.Pa4,
                    u = Gc(e.cameraObject, a),
                    p = Gc(t, t.target),
                    h = new i.$V;
                return Vc({
                    from: 0,
                    to: 1,
                    duration: n,
                    ease: r,
                    driver: s,
                    onUpdate: n => {
                        h.phi = Hc(u.phi, p.phi, n), h.theta = Hc(u.theta, p.theta, n), h.radius = ee(u.radius, p.radius, n), l.copy(a).lerp(t.target, n), c.setFromSpherical(h), c.add(l), e.position = c, e.target = l, e.positionUpdated(!1), e.targetUpdated()
                    },
                    onComplete: () => {
                        e.position = t.position, e.target = t.target, e.positionUpdated(!1), e.targetUpdated()
                    }
                }, o)
            }(s, e, t, o, a, c));
            else if ("linear" === this.interpolateMode) {
                l.push(Vc({
                    from: s.position.clone(),
                    to: e.position.clone(),
                    duration: t,
                    ease: o,
                    driver: a,
                    onUpdate: e => s.position = e,
                    onComplete: () => s.position = e.position
                }, c)), l.push(Vc({
                    from: s.target.clone(),
                    to: e.target.clone(),
                    duration: t,
                    ease: o,
                    driver: a,
                    onUpdate: e => {
                        s.target = e, s.targetUpdated()
                    },
                    onComplete: () => {
                        s.target = e.target, s.targetUpdated()
                    }
                }, c));
                const n = s.cameraObject.quaternion.clone(),
                    r = new i._fP;
                l.push(Vc({
                    from: 0,
                    to: 1,
                    duration: t,
                    ease: o,
                    driver: a,
                    onUpdate: t => {
                        r.copy(n).slerp(e.quaternion, t), s.cameraObject.quaternion.copy(r), s.cameraObject.updateProjectionMatrix()
                    },
                    onComplete: () => {
                        s.cameraObject.quaternion.copy(e.quaternion), s.cameraObject.updateProjectionMatrix()
                    }
                }, c))
            }
            await Promise.all(l), this._animating = !1, this.dispatchEvent({
                type: "viewChange",
                view: e
            }), await _c(10)
        }
        fromJSON(e, t) {
            var n, r;
            return super.fromJSON(e, t) ? (this._cameraViews.forEach((e => e.focusView = async () => this.focusView(e))), this._cameraViews.forEach((e => e.deleteView = () => this.deleteView(e))), null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n), this) : null
        }
    }
    async function Vc(e, t) {
        const n = e.onComplete,
            r = e.onStop;
        return e = { ...e
        }, new Promise(((i, s) => {
            e.onComplete = () => {
                null == n || n(), i()
            }, e.onStop = () => {
                null == r || r(), i()
            };
            const o = dc(e);
            t.push(o)
        }))
    }

    function Gc(e, t) {
        const n = e.position.clone();
        n.sub(t);
        const r = (new i.$V).setFromVector3(n);
        return r.makeSafe(), r
    }

    function Hc(e, t, n) {
        const r = t - e;
        return r >= Math.PI ? e + (r - 2 * Math.PI) * n : r <= -Math.PI ? e + (r + 2 * Math.PI) * n : e + r * n
    }

    function Wc(e, t, n) {
        const r = (1 - n) * Math.cos(e) + n * Math.cos(t),
            i = (1 - n) * Math.sin(e) + n * Math.sin(t);
        return Math.atan2(i, r)
    }
    zc.PluginType = "CameraViews", Uc([xe("cameraViews")], zc.prototype, "_cameraViews", void 0), Uc([C(zc.prototype._animationLoop), xe(), Ve("Loop All Views", {
        limitedUi: !0
    })], zc.prototype, "viewLooping", void 0), Uc([xe(), qe("View Pause Time")], zc.prototype, "viewPauseTime", void 0), Uc([xe(), Ke("Ease", Object.keys(fc).map((e => ({
        label: e
    }))))], zc.prototype, "animEase", void 0), Uc([xe(), He("Duration", [10, 1e4], 10, {
        limitedUi: !0
    })], zc.prototype, "animDuration", void 0), Uc([xe(), He("RotationOffset", [.2, .75], .01)], zc.prototype, "rotationOffset", void 0), Uc([xe(), Ke("Interpolation", ["spherical", "linear"].map((e => ({
        label: e
    }))))], zc.prototype, "interpolateMode", void 0), Uc([Ve(), xe()], zc.prototype, "seekOnScroll", void 0), Uc([Xe("Animate All Views", {
        limitedUi: !0
    })], zc.prototype, "animateAllViews", null), Uc([Xe("Record All Views")], zc.prototype, "recordAllViews", null), Uc([Xe("Add Current View")], zc.prototype, "addCurrentView", null), Uc([Xe("Focus Next")], zc.prototype, "focusNext", void 0), Uc([Xe("Focus Previous")], zc.prototype, "focusPrevious", void 0);
    const Kc = new i.Pa4;

    function Xc(e, t, n) {
        let r = e.dot(t);
        r = Math.min(Math.max(r, -1), 1);
        const i = Math.acos(r) * n;
        return Kc.copy(e).multiplyScalar(r).sub(t).negate().normalize(), e.multiplyScalar(Math.cos(i)).add(Kc.multiplyScalar(Math.sin(i)))
    }
    var qc = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class Yc extends Is {
        constructor(e, t, n, r) {
            super(e, t), this._shadowParams = {
                enabled: !0,
                radius: 2,
                width: 1024,
                height: 1024,
                bias: -.001,
                normalBias: 0,
                near: 1.5,
                far: 4,
                frustumSize: 4
            }, this._randomParams = {
                focus: 1,
                spread: .01,
                distanceScale: 50,
                minDistanceScale: new i.Pa4(10, 10, 10),
                normalDirection: new i.Pa4(.01, .98, .01).normalize(),
                direction: new i.Pa4(-.9, .5, -1)
            }, this.isRandomizedDirectionalLight = !0, this.shadowParams = null != n ? n : {}, this.randomParams = null != r ? r : {}, this.updateShadowParams = this.updateShadowParams.bind(this)
        }
        get shadowParams() {
            return this._shadowParams
        }
        set shadowParams(e) {
            Object.keys(e).forEach((t => void 0 === e[t] && delete e[t])), this._shadowParams = { ...this._shadowParams,
                ...e
            }, this.updateShadowParams()
        }
        get randomParams() {
            return this._randomParams
        }
        set randomParams(e) {
            Object.keys(e).forEach((t => void 0 === e[t] && delete e[t])), Object.assign(this._randomParams, e)
        }
        updateShadowParams() {
            this.castShadow = this._shadowParams.enabled, this.shadow.mapSize.x = this._shadowParams.width, this.shadow.mapSize.y = this._shadowParams.height, this.shadow.bias = this._shadowParams.bias, this.shadow.normalBias = this._shadowParams.normalBias, this.refreshShadowCamNearFar(), this.shadow.radius = this._shadowParams.radius, this.shadow.camera.right = this._shadowParams.frustumSize / 2, this.shadow.camera.left = -this._shadowParams.frustumSize / 2, this.shadow.camera.top = this._shadowParams.frustumSize / 2, this.shadow.camera.bottom = -this._shadowParams.frustumSize / 2, this.shadow.camera.updateProjectionMatrix(), this.matrixWorldNeedsUpdate = !0
        }
        randomizePosition(e = null, t = null) {
            const n = new i.FM8(Math.random() * Math.PI * 2, Math.asin(2 * Math.random() - 1));
            let r = new i.Pa4(Math.cos(n.x) * Math.cos(n.y), Math.sin(n.y), Math.sin(n.x) * Math.cos(n.y));
            for (let n = 0; n < 5; n++) {
                r = Zc(this._randomParams.normalDirection, .4), Math.random() < Math.sqrt(null != e ? e : this._randomParams.focus) && (r = Zc(this._randomParams.direction, Math.pow((null != t ? t : this._randomParams.spread) / 2, 2)));
                const n = r.dot(this._randomParams.normalDirection);
                if (n > 0 && n < .4) break
            }
            r.normalize(), r.multiplyScalar(this._randomParams.distanceScale), this.position.set(0, 0, 0), this.target.position.copy(r.normalize().negate()), this.target.updateMatrixWorld(), this.refreshShadowCamNearFar(), this.updateMatrixWorld()
        }
        refreshShadowCamNearFar() {
            const e = (new i.Pa4).subVectors(this.target.position, this.shadow.camera.position).length();
            this.shadow.camera.near = e - this._shadowParams.near * this._shadowParams.frustumSize / 2, this.shadow.camera.far = e + this._shadowParams.far * this._shadowParams.frustumSize / 2
        }
        dispose() {}
        get uiConfig() {
            if (this._uiConfig) return this._uiConfig
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t) ? (this.updateShadowParams(), this) : null
        }
    }

    function Zc(e, t) {
        e = e.clone().normalize();
        const n = new i.Pa4(0, -e.z, e.y).normalize(),
            r = (new i.Pa4).crossVectors(e, n).normalize(),
            s = (new i.FM8).random();
        s.x = 2 * s.x * Math.PI, s.y = 1 - s.y * t;
        const o = Math.sqrt(1 - s.y * s.y);
        return n.multiplyScalar(Math.cos(s.x) * o).add(r.multiplyScalar(Math.sin(s.x) * o)).add(e.multiplyScalar(s.y))
    }
    qc([xe("shadowParams")], Yc.prototype, "_shadowParams", void 0), qc([xe("randomParams")], Yc.prototype, "_randomParams", void 0);
    var Jc = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class $c extends Gs {
        constructor(e = !0) {
            super(), this.enabled = !0, this.light = new Yc("#cceeff", 1), this.lightLayers = 1, this._preRender = () => {
                var e, t, n;
                this.enabled ? ((null !== (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer.frameCount) && void 0 !== t ? t : 0) > 3 && this.light.randomizePosition(), this.light.layers.mask = this.lightLayers, this.light.updateShadowParams(), null === (n = this._cameraHelper) || void 0 === n || n.update()) : this.light.layers.mask = 0
            }, this._setDirty = this._setDirty.bind(this), this.enabled = e
        }
        get cameraHelper() {
            return this._cameraHelper
        }
        async onAdded(e) {
            await super.onAdded(e), this._cameraHelper = new i.Rki(this.light.shadow.camera), this._cameraHelper.visible = !1, this._cameraHelper.userData.bboxVisible = !1, e.scene.add(this._cameraHelper), e.scene.addLight(this.light, {
                addToRoot: !0
            }), e.addEventListener("preRender", this._preRender)
        }
        async onRemove(e) {
            return e.removeEventListener("preRender", this._preRender), this.light.removeFromParent(), super.onRemove(e)
        }
        _setDirty(e = !1) {
            var t, n;
            e ? null === (t = this._viewer) || void 0 === t || t.scene.setDirty() : null === (n = this._viewer) || void 0 === n || n.setDirty()
        }
        get uiConfig() {
            return this._uiConfig ? this._uiConfig : this._uiConfig = {
                type: "folder",
                label: "Progressive Shadow",
                children: [{
                    type: "checkbox",
                    label: "Enabled",
                    property: [this, "enabled"],
                    onChange: this._setDirty
                }, {
                    type: "folder",
                    label: "Directional Light",
                    children: [{
                        type: "checkbox",
                        label: "Visible",
                        property: [this.light, "visible"],
                        onChange: this._setDirty
                    }, {
                        type: "slider",
                        label: "Intensity",
                        bounds: [0, 10],
                        property: [this.light, "intensity"],
                        onChange: this._setDirty
                    }, {
                        type: "checkbox",
                        label: "Shadow Enabled",
                        property: [this.light.shadowParams, "enabled"],
                        onChange: [this.light.updateShadowParams, this._setDirty]
                    }, {
                        type: "slider",
                        bounds: [0, 1],
                        property: [this.light.randomParams, "focus"],
                        onChange: this._setDirty
                    }, {
                        type: "slider",
                        bounds: [0, 1],
                        property: [this.light.randomParams, "spread"],
                        onChange: this._setDirty
                    }, {
                        type: "slider",
                        bounds: [.01, 60],
                        property: [this.light.randomParams, "distanceScale"],
                        onChange: this._setDirty
                    }, {
                        type: "vec3",
                        bounds: [-5, 5],
                        property: [this.light.randomParams, "direction"],
                        onChange: this._setDirty
                    }, {
                        type: "slider",
                        bounds: [.01, 10],
                        property: [this.light.shadowParams, "radius"],
                        onChange: [this.light.updateShadowParams, this._setDirty]
                    }, {
                        type: "slider",
                        bounds: [.01, 30],
                        property: [this.light.shadowParams, "frustumSize"],
                        onChange: [this.light.updateShadowParams, this._setDirty]
                    }, {
                        type: "slider",
                        bounds: [-.01, .01],
                        property: [this.light.shadowParams, "bias"],
                        onChange: [this.light.updateShadowParams, this._setDirty]
                    }]
                }]
            }
        }
    }
    $c.PluginType = "RandomizedDirectionalLight", Jc([xe()], $c.prototype, "enabled", void 0), Jc([xe("rdLight")], $c.prototype, "light", void 0), Jc([xe()], $c.prototype, "lightLayers", void 0);
    var Qc, eu = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let tu = Qc = class extends Gs {
        constructor(e = !1) {
            super(), this.enabled = !1, this.worldRadius = 100, this.tripodHeight = 10, this._paramsChanged = this._paramsChanged.bind(this), this.enabled = e
        }
        _paramsChanged() {
            var e, t, n, r, s, o, a, l, c, u, p;
            const h = null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground(!0);
            if (this.enabled && h && h !== io)
                if (h.isDataTexture) h.mapping = i.dSO;
                else if (confirm("Background must be same as environment, do you want to change it?")) {
                const e = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("SimpleBackgroundEnvUiPlugin1");
                e ? (e.envmapBg = !0, null === (r = (n = e.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0)) : null === (s = this._viewer) || void 0 === s || s.setBackground(io)
            } else this.enabled = !1;
            const d = null === (c = null === (l = null === (a = null === (o = this._viewer) || void 0 === o ? void 0 : o.renderer) || void 0 === a ? void 0 : a.rendererObject) || void 0 === l ? void 0 : l.background.getBoxMesh2()) || void 0 === c ? void 0 : c.material,
                f = null !== (u = null == d ? void 0 : d.uniforms) && void 0 !== u ? u : i.Vj0.cube.uniforms;
            f.tripodHeight || (f.tripodHeight = {
                value: 1
            }), f.worldRadius || (f.worldRadius = {
                value: 1
            }), f.tripodHeight.value = this.tripodHeight, f.worldRadius.value = this.worldRadius, d && (!this.enabled && d.defines.HDRi_GROUND_PROJ ? delete d.defines.HDRi_GROUND_PROJ : this.enabled && (d.defines.HDRi_GROUND_PROJ = "1"), d.needsUpdate = !0), null === (p = this._viewer) || void 0 === p || p.setDirty()
        }
        async onAdded(e) {
            var t, n, r;
            await super.onAdded(e), (null === (r = null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.renderer) || void 0 === n ? void 0 : n.rendererObject) || void 0 === r ? void 0 : r.background.getBoxMesh()) && console.error("HDRi Ground Plugin must be added before setting any cube or env map"), i.Vj0.cube.fragmentShader = i.Vj0.cube.fragmentShader.replace("void main() {", "\n#ifdef HDRi_GROUND_PROJ\nfloat intersectPlane1(const in vec3 r0,const in vec3 rd,const in vec3 n,const in vec3 p0){float t=dot(p0-r0,n)/(dot(n,rd)+1e-6);return t<0.?1000.:t;}float intersectSphere1(in vec3 ro,in vec3 rd,in vec3 sph,in float rad){vec3 oc=ro-sph;float b=dot(oc,rd);float c=dot(oc,oc)-rad*rad;float t=b*b-c;return t<0.?t:-b+sqrt(t);}\n#define PI_HALF 1.5707963267948966\nuniform float worldRadius;uniform float tripodHeight;vec3 hdriProject(){vec3 p=normalize(vWorldDirection);vec3 camPos=cameraPosition;camPos.y-=tripodHeight;float t=intersectSphere1(camPos,p,vec3(0.,0.,0.),worldRadius);if(t>0.){float t2=intersectPlane1(camPos,p,vec3(0,-1,0),vec3(0.,-tripodHeight,0.));p=(camPos+min(t,t2)*p)/worldRadius;}else p=vec3(0.,1.,0.);return p;}\n#endif\n\nvoid main() {"), i.Vj0.cube.fragmentShader = i.Vj0.cube.fragmentShader.replace("vec3 vReflect = vWorldDirection;", "\nvec3 vReflect = \n#ifdef HDRi_GROUND_PROJ\nhdriProject()\n#else\nvWorldDirection\n#endif\n;\n"), e.scene.addEventListener("environmentChanged", this._paramsChanged)
        }
    };
    tu.PluginType = "HDRiGroundPlugin", eu([xe(), C(Qc.prototype._paramsChanged), Ve("Enabled")], tu.prototype, "enabled", void 0), eu([xe(), C(Qc.prototype._paramsChanged), He("World Radius", [1, 1e3])], tu.prototype, "worldRadius", void 0), eu([xe(), C(Qc.prototype._paramsChanged), He("Tripod height", [0, 50])], tu.prototype, "tripodHeight", void 0), tu = Qc = eu([Qe("HDRi Ground")], tu);
    var nu = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let ru = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.dependencies = [Vs], this._defines = {}, this._uniforms = {
                thinBaseLayerFactors: {
                    value: new i.Ltg
                },
                thinNoiseLayerFactors: {
                    value: new i.Ltg
                },
                thinColorNoiseParams: {
                    value: new i.Ltg
                },
                thinFilmFactor: {
                    value: .8
                }
            }, this.materialExtension = {
                parsFragmentSnippet: (e, t) => {
                    var n;
                    return this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._thinFilmLayer) || void 0 === n ? void 0 : n.hasThinFilm) ? vo + "\n#ifndef VORONOISE_HELPER\n#define VORONOISE_HELPER\nfloat voronoise(in vec2 p,float u,float v){float k=1.+63.*pow(1.-v,6.);vec2 i=floor(p);vec2 f=fract(p);vec2 a=vec2(0.,0.);for(int y=-2;y<=2;y++)for(int x=-2;x<=2;x++){vec2 g=vec2(x,y);vec3 o=hash3(i+g)*vec3(u,u,1.);vec2 d=g-f+o.xy;float w=pow(1.-smoothstep(0.,1.414,length(d)),k);a+=vec2(o.z*w,w);}return a.x/a.y;}vec3 voronoise3(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),voronoise(p-vec2(0.83,0.45),u,v));}vec3 voronoiseNormal(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),1.);}\n#endif\n\n#ifndef HSV_HELPERS\n#define HSV_HELPERS\nvec3 hsv2rgb(vec3 c){vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=c.g<c.b?vec4(c.bg,K.wz):vec4(c.gb,K.xy);vec4 q=c.r<p.x?vec4(p.xyw,c.r):vec4(c.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}\n#endif \n\nuniform vec4 thinBaseLayerFactors;\nuniform vec4 thinNoiseLayerFactors;\nuniform vec4 thinColorNoiseParams;\nuniform float thinFilmFactor;\n        " : ""
                },
                shaderExtender: (e, t, n) => {
                    var r;
                    if (!this.enabled || !(null === (r = t.materialObject.userData._thinFilmLayer) || void 0 === r ? void 0 : r.hasThinFilm)) return;
                    const i = "#glMarker beforeAccumulation";
                    e.fragmentShader = e.fragmentShader.replace(i, "vec3 incident=normalize(vViewPosition.xyz);float hWeight=1.-dot(normal,incident);vec3 noiseV=voronoise3(vUv.xy*thinColorNoiseParams.xy*60.,thinColorNoiseParams.z,thinColorNoiseParams.w);float hWeight2=1.-dot(normalize(noiseV),incident);vec3 film=hsv2rgb(vec3(fract(hWeight+thinBaseLayerFactors.x),thinBaseLayerFactors.y,thinBaseLayerFactors.z))*thinBaseLayerFactors.a;vec3 film2=hsv2rgb(vec3(fract(hWeight2+thinNoiseLayerFactors.x),thinNoiseLayerFactors.y,thinNoiseLayerFactors.z))*thinNoiseLayerFactors.a;film=(film+film2)/(thinBaseLayerFactors.a+thinNoiseLayerFactors.a);diffuseColor.rgb=mix(diffuseColor.rgb,film,thinFilmFactor);" + i), e.vertexUvs = !0
                },
                onObjectRender: (e, t) => {
                    var n;
                    const r = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._thinFilmLayer;
                    if (!(null == r ? void 0 : r.hasThinFilm)) return;
                    this._uniforms.thinBaseLayerFactors.value.fromArray(r.baseLayerFactors), this._uniforms.thinNoiseLayerFactors.value.fromArray(r.noiseLayerFactors), this._uniforms.thinColorNoiseParams.value.fromArray(r.colorNoiseParams), this._uniforms.thinFilmFactor.value = r.filmFactor;
                    const i = this.enabled ? 1 : 0;
                    t.materialObject.defines.THIN_FILM_LAYER_ENABLED !== i && (t.materialObject.defines.THIN_FILM_LAYER_ENABLED = i, t.materialObject.needsUpdate = !0)
                },
                extraUniforms: { ...this._uniforms
                },
                computeCacheKey: e => {
                    var t, n;
                    return (this.enabled ? "1" : "0") + ((null === (n = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._thinFilmLayer) || void 0 === n ? void 0 : n.hasThinFilm) ? "1" : "0")
                },
                isCompatible: e => e.isMeshStandardMaterial2,
                updaters: () => [],
                getUiConfig: e => {
                    const t = {
                        type: "folder",
                        label: "ThinFilmLayer",
                        children: [{
                            type: "checkbox",
                            label: "Enabled",
                            get value() {
                                var t;
                                return (null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm) || !1
                            },
                            set value(n) {
                                var r, i;
                                n !== (null === (r = e.materialObject.userData._thinFilmLayer) || void 0 === r ? void 0 : r.hasThinFilm) && (n ? iu(e.materialObject) || alert("Cannot add thin film.") : (e.materialObject.userData._thinFilmLayer.hasThinFilm = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0))
                            },
                            onChange: this.setDirty
                        }, () => ({
                            type: "slider",
                            bounds: [0, 1],
                            label: "Intensity",
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm)
                            },
                            property: [e.materialObject.userData._thinFilmLayer, "filmFactor"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "vec4",
                            label: "Base Layer",
                            bounds: [0, 1],
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm)
                            },
                            property: [e.materialObject.userData._thinFilmLayer, "baseLayerFactors"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "vec4",
                            label: "Noise Layer",
                            bounds: [0, 1],
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm)
                            },
                            property: [e.materialObject.userData._thinFilmLayer, "noiseLayerFactors"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "vec4",
                            label: "Noise Params",
                            bounds: [0, 1],
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._thinFilmLayer) || void 0 === t ? void 0 : t.hasThinFilm)
                            },
                            property: [e.materialObject.userData._thinFilmLayer, "colorNoiseParams"],
                            onChange: this.setDirty
                        })]
                    };
                    return t
                }
            }, this.setDirty = () => {
                var e;
                null === (e = this._viewer) || void 0 === e || e.setDirty()
            }, this._loaderCreate = this._loaderCreate.bind(this)
        }
        addThinFilmLayer(e) {
            return iu(e.materialObject)
        }
        _loaderCreate({
            loader: e
        }) {
            e.isGLTFLoader2 && e.register((e => new su(e)))
        }
        async onAdded(e) {
            var t, n, r, i, s;
            await super.onAdded(e);
            const o = e.getPlugin(Vs);
            null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(ou)
        }
        async onRemove(e) {
            var t, n, r, i;
            return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e)
        }
    };

    function iu(e) {
        const t = null == e ? void 0 : e.userData;
        if (!t) return !1;
        t._thinFilmLayer || (t._thinFilmLayer = {});
        const n = t._thinFilmLayer;
        return n.hasThinFilm = !0, void 0 === n.baseLayerFactors && (n.baseLayerFactors = [.3, .6, 1, .9]), void 0 === n.noiseLayerFactors && (n.noiseLayerFactors = [.7, .5, .9, .7]), void 0 === n.colorNoiseParams && (n.colorNoiseParams = [.5, .5, .5, .7]), void 0 === n.filmFactor && (n.filmFactor = .3), e.isMaterial && (e.needsUpdate = !0), !0
    }
    ru.PluginType = "ThinFilmLayerPlugin", ru.THIN_FILM_LAYER_GLTF_EXTENSION = "WEBGI_materials_thin_film_layer", nu([Ve("Enabled", (e => ({
        onChange: e.setDirty
    }))), xe()], ru.prototype, "enabled", void 0), ru = nu([Qe("ThinFilmLayer Materials")], ru);
    class su {
        constructor(e) {
            this.parser = e, this.name = ru.THIN_FILM_LAYER_GLTF_EXTENSION
        }
        async extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const r = n.extensions[this.name];
            return t.userData || (t.userData = {}), iu(t), t.userData._thinFilmLayer = Te(r, t.userData._thinFilmLayer, !1, {}), Promise.resolve()
        }
    }
    const ou = e => ({
        writeMaterial: (t, n) => {
            if (!t.isMeshStandardMaterial || !t.userData._thinFilmLayer) return;
            if (!t.userData._thinFilmLayer.hasThinFilm) return;
            n.extensions = n.extensions || {};
            const r = Me(t.userData._thinFilmLayer, !1);
            n.extensions[ru.THIN_FILM_LAYER_GLTF_EXTENSION] = r, e.extensionsUsed[ru.THIN_FILM_LAYER_GLTF_EXTENSION] = !0
        }
    });
    var au = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let lu = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.dependencies = [Vs], this._defines = {}, this._uniforms = {
                ccTintColor: {
                    value: new ve
                },
                ccThickness: {
                    value: 0
                },
                ccIor: {
                    value: 0
                }
            }, this.materialExtension = {
                parsFragmentSnippet: (e, t) => {
                    var n;
                    return this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._clearcoatTint) || void 0 === n ? void 0 : n.enableTint) && t.materialObject.clearcoat > 0 ? "\nuniform vec3 ccTintColor;\nuniform float ccThickness;\nuniform float ccIor;\nvec3 clearcoatTint(const in float dotNV, const in float dotNL, const in float clearcoat) {\n    vec3 tint = ( ccThickness > 0. ? 1. - ccTintColor : ccTintColor); // Set thickness < 0 for glow.\n    tint = exp(tint * -(ccThickness * ((dotNL + dotNV) / max(dotNL * dotNV, 1e-3)))); // beer's law\n    return mix(vec3(1.0), tint, clearcoat);\n}\n        " : ""
                },
                shaderExtender: (e, t, n) => {
                    var r;
                    if (!(this.enabled && (null === (r = null == t ? void 0 : t.materialObject.userData._clearcoatTint) || void 0 === r ? void 0 : r.enableTint) && t.materialObject.clearcoat > 0)) return;
                    const i = "outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;",
                        s = "float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );";
                    e.fragmentShader.includes(s) && e.fragmentShader.includes(i) || console.error("ClearcoatTintPlugin: shaderExtender cannot patch shader, version changed?"), e.fragmentShader = e.fragmentShader.replace(s, "\n            float dotNVcc = saturate( dot( geometry.clearcoatNormal, -refract(geometry.viewDir, geometry.clearcoatNormal, 1./ccIor) ) );\n            "), e.fragmentShader = e.fragmentShader.replace(i, "\n            outgoingLight *= clearcoatTint(dotNVcc, dotNVcc, material.clearcoat);\n            " + i), e.vertexUvs = !0
                },
                onObjectRender: (e, t) => {
                    var n;
                    const r = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._clearcoatTint;
                    if (!(null == r ? void 0 : r.enableTint)) return;
                    this._uniforms.ccTintColor.value.set(r.tintColor), this._uniforms.ccThickness.value = r.thickness, this._uniforms.ccIor.value = r.ior;
                    const i = this.enabled ? 1 : 0;
                    t.materialObject.defines.CLEARCOAT_TINT_ENABLED !== i && (t.materialObject.defines.CLEARCOAT_TINT_ENABLED = i, t.materialObject.needsUpdate = !0)
                },
                extraUniforms: { ...this._uniforms
                },
                computeCacheKey: e => {
                    var t, n;
                    return (this.enabled ? "1" : "0") + ((null === (n = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._clearcoatTint) || void 0 === n ? void 0 : n.enableTint) ? "1" : "0") + (e.materialObject.clearcoat > 0 ? "1" : "0")
                },
                isCompatible: e => e.isMeshStandardMaterial2,
                updaters: () => [],
                getUiConfig: e => {
                    const t = {
                        type: "folder",
                        label: "ClearcoatTint",
                        children: [{
                            type: "checkbox",
                            label: "Enabled",
                            get value() {
                                var t;
                                return (null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint) || !1
                            },
                            set value(n) {
                                var r, i;
                                n !== (null === (r = e.materialObject.userData._clearcoatTint) || void 0 === r ? void 0 : r.enableTint) && (n ? cu(e.materialObject) || alert("Cannot add clearcoat tint.") : (e.materialObject.userData._clearcoatTint.enableTint = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0))
                            },
                            onChange: this.setDirty
                        }, () => ({
                            type: "color",
                            label: "Tint color",
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint)
                            },
                            property: [e.materialObject.userData._clearcoatTint, "tintColor"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "input",
                            label: "Thickness",
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint)
                            },
                            property: [e.materialObject.userData._clearcoatTint, "thickness"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "slider",
                            bounds: [.8, 2.5],
                            label: "IOR",
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._clearcoatTint) || void 0 === t ? void 0 : t.enableTint)
                            },
                            property: [e.materialObject.userData._clearcoatTint, "ior"],
                            onChange: this.setDirty
                        })]
                    };
                    return t
                }
            }, this.setDirty = () => {
                var e;
                null === (e = this._viewer) || void 0 === e || e.setDirty()
            }, this._loaderCreate = this._loaderCreate.bind(this)
        }
        addClearcoatTint(e) {
            return cu(e.materialObject)
        }
        _loaderCreate({
            loader: e
        }) {
            e.isGLTFLoader2 && e.register((e => new uu(e)))
        }
        async onAdded(e) {
            var t, n, r, i, s;
            await super.onAdded(e);
            const o = e.getPlugin(Vs);
            null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(pu)
        }
        async onRemove(e) {
            var t, n, r, i;
            return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e)
        }
    };

    function cu(e) {
        const t = null == e ? void 0 : e.userData;
        if (!t) return !1;
        t._clearcoatTint || (t._clearcoatTint = {});
        const n = t._clearcoatTint;
        return n.enableTint = !0, void 0 === n.tintColor && (n.tintColor = 16777215), void 0 === n.thickness && (n.thickness = .1), void 0 === n.ior && (n.ior = 1.5), e.isMaterial && (e.needsUpdate = !0), !0
    }
    lu.PluginType = "ClearcoatTintPlugin", lu.CLEARCOAT_TINT_GLTF_EXTENSION = "WEBGI_materials_clearcoat_tint", au([Ve("Enabled", (e => ({
        onChange: e.setDirty
    }))), xe()], lu.prototype, "enabled", void 0), lu = au([Qe("ClearcoatTint Materials")], lu);
    class uu {
        constructor(e) {
            this.parser = e, this.name = lu.CLEARCOAT_TINT_GLTF_EXTENSION
        }
        async extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const r = n.extensions[this.name];
            return t.userData || (t.userData = {}), cu(t), t.userData._clearcoatTint = Te(r, t.userData._clearcoatTint, !1, {}), Promise.resolve()
        }
    }
    const pu = e => ({
        writeMaterial: (t, n) => {
            if (!t.isMeshStandardMaterial || !t.userData._clearcoatTint) return;
            if (!t.userData._clearcoatTint.enableTint) return;
            n.extensions = n.extensions || {};
            const r = Me(t.userData._clearcoatTint, !1);
            n.extensions[lu.CLEARCOAT_TINT_GLTF_EXTENSION] = r, e.extensionsUsed[lu.CLEARCOAT_TINT_GLTF_EXTENSION] = !0
        }
    });
    var hu = "vec2 poisson_disk_samples[16];void setPds(){poisson_disk_samples[0]=vec2(-0.399691779231,0.728591545584);poisson_disk_samples[1]=vec2(-0.48622557676,-0.84016533712);poisson_disk_samples[2]=vec2(0.770309468987,-0.24906070432);poisson_disk_samples[3]=vec2(0.556596796154,0.820359876432);poisson_disk_samples[4]=vec2(-0.933902004071,0.0600539051593);poisson_disk_samples[5]=vec2(0.330144964342,0.207477293384);poisson_disk_samples[6]=vec2(0.289013230975,-0.686749271417);poisson_disk_samples[7]=vec2(-0.0832470893559,-0.187351643125);poisson_disk_samples[8]=vec2(-0.296314525615,0.254474834305);poisson_disk_samples[9]=vec2(-0.850977666059,0.484642744689);poisson_disk_samples[10]=vec2(0.829287915319,0.2345063545);poisson_disk_samples[11]=vec2(-0.773042143899,-0.543741521254);poisson_disk_samples[12]=vec2(0.0561133030864,0.928419742597);poisson_disk_samples[13]=vec2(-0.205799249508,-0.562072714492);poisson_disk_samples[14]=vec2(-0.526991665882,-0.193690188118);poisson_disk_samples[15]=vec2(-0.051789270667,-0.935374050821);}",
        du = function(e, t, n, r) {
            var i, s = arguments.length,
                o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
            else
                for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
            return s > 3 && o && Object.defineProperty(t, n, o), o
        };
    const fu = {
            uniforms: {
                colorTexture: {
                    value: null
                },
                tNormalDepth: {
                    value: null
                },
                blurTexture: {
                    value: null
                },
                cocTexture: {
                    value: null
                },
                cocTextureSize: {
                    value: new i.FM8
                },
                cameraNearFar: {
                    value: new i.FM8
                }
            },
            vertexShader: _o,
            fragmentShader: jt + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 cocTextureSize;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;uniform vec2 crossCenter;uniform float crossRadius;uniform float crossAlpha;uniform vec3 crossColor;float smoothBoundary(float d,float smooothFactor){smooothFactor*=0.5;float value=smoothstep(-smooothFactor,smooothFactor,d);return value;}float circle(vec2 p,float r){return min((length(p)-r),-(length(p)-r-0.01));}float computeCoc(){float depth=getDepth(vUv);if(depth>1.-0.01)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){vec4 blur=blurTextureTexelToLinear(texture2D(blurTexture,vUv));float scale=0.5;blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,-1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,-1.)/cocTextureSize));blur/=5.;vec2 uvNearest=(floor(vUv*cocTextureSize)+0.5)/cocTextureSize;float coc=abs(min(2.*cocTextureTexelToLinear(texture2D(cocTexture,uvNearest)).a-1.,computeCoc()));float cocLower=0.005;float cocHigher=0.3;vec4 outColor=vec4(mix(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,blur.rgb,smoothstep(cocLower,cocHigher,coc)),1.);vec2 d=vUv-crossCenter;if(length(d)>crossRadius+0.05){float dist=circle(d,crossRadius);gl_FragColor=outColor;}else{d.x*=cocTextureSize.x/cocTextureSize.y;float dist=circle(d,crossRadius);dist=smoothBoundary(dist,2.*fwidth(dist));vec4 color=outColor;vec3 dofCircleColor=mix(crossColor,color.rgb,1.-crossAlpha);gl_FragColor=vec4(mix(color.rgb,dofCircleColor,dist),color.a);}\n#include <encodings_fragment>\n}"
        },
        _u = (It({
            uniforms: {
                cocTexture: {
                    value: null
                },
                colorTexture: {
                    value: null
                },
                colorTextureSize: {
                    value: new i.FM8
                },
                direction: {
                    value: new i.FM8
                }
            },
            vertexShader: _o,
            fragmentShader: "#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;const float MAXIMUM_BLUR_SIZE=16.;const float SIGMA=5.;const int NUM_SAMPLES=4;float normpdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}vec3 weightedBlur(){float cocIn=2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv)).a-1.;float kernelRadius=MAXIMUM_BLUR_SIZE*cocIn;vec2 invSize=1./colorTextureSize;cocIn*=cocIn*cocIn;float centreSpaceWeight=normpdf(0.,SIGMA)*abs(cocIn);float weightSum=centreSpaceWeight;vec3 centreSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb;vec3 diffuseSum=centreSample*weightSum;vec2 delta=invSize*kernelRadius/float(NUM_SAMPLES);for(int i=1;i<=NUM_SAMPLES;i++){float spaceWeight=normpdf(float(i),SIGMA);vec2 texcoord=direction*delta*float(i);vec4 rightSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv+texcoord));vec4 leftSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv-texcoord));float leftCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv-texcoord)).a-1.);float rightCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv+texcoord)).a-1.);leftCocWeight*=leftCocWeight*leftCocWeight;rightCocWeight*=rightCocWeight*rightCocWeight;diffuseSum+=((leftSample.rgb*leftCocWeight)+(rightSample.rgb*rightCocWeight))*spaceWeight;weightSum+=(spaceWeight*(leftCocWeight+rightCocWeight));}return diffuseSum/weightSum;}void main(){gl_FragColor=vec4(weightedBlur(),1.);\n#include <encodings_fragment>\n}"
        }, "colorTexture", "cocTexture"), It({
            uniforms: {
                colorTexture: {
                    value: null
                },
                colorTextureSize: {
                    value: new i.FM8
                },
                direction: {
                    value: new i.FM8
                },
                frameCount: {
                    value: 0
                },
                blurRadius: {
                    value: 16
                }
            },
            vertexShader: _o,
            fragmentShader: vo + "\n" + hu + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform float blurRadius;vec4 CircularBlur(){vec4 color=colorTextureTexelToLinear(texture2D(colorTexture,vUv));\n#ifdef DOF_MODE\nfloat blurDist=blurRadius*(2.*color.a-1.);\n#else\nfloat blurDist=blurRadius*color.a;\n#endif\nfloat rnd=PI2*random3(vec3(vUv,frameCount*0.1));float costheta=cos(rnd);float sintheta=sin(rnd);vec4 rotationMatrix=vec4(costheta,-sintheta,sintheta,costheta);vec3 colorSum=vec3(0.);float weightSum=0.001;vec2 ofs;vec4 sampleColor;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));sampleColor=colorTextureTexelToLinear(texture2D(colorTexture,vUv+blurDist*ofs/colorTextureSize.xy));\n#ifdef DOF_MODE\nsampleColor.a=abs(sampleColor.a*2.-1.);sampleColor.a*=sampleColor.a*sampleColor.a;\n#endif\ncolorSum+=sampleColor.rgb*sampleColor.a;weightSum+=sampleColor.a;}\n#pragma unroll_loop_end\ncolorSum/=weightSum;return vec4(saturate(colorSum),1.);}void main(){gl_FragColor=CircularBlur();\n#include <encodings_fragment>\n}",
            defines: {
                DOF_MODE: 1
            }
        }, "colorTexture"));
    class mu extends Ft {
        constructor() {
            super(fu, "colorTexture", "cocTexture", "blurTexture"), this.dofBlurMaterial = _u, this.nearFarBlurScale = new i.FM8(.25, .25), this.focalDepthRange = new i.FM8(.5, 1.5), this.crossCenter = new i.FM8(.5, .5), this.crossRadius = .04, this.crossAlpha = 1, this.crossColor = new ve(16750848), this.uiConfig = {
                type: "folder",
                label: "Depth of Field",
                children: [{
                    type: "checkbox",
                    label: "Enabled",
                    limitedUi: !0,
                    property: [this, "enabled"]
                }, {
                    type: "slider",
                    label: "Depth Range",
                    bounds: [.5, 3],
                    property: [this.focalDepthRange, "y"]
                }, {
                    type: "slider",
                    label: "Near Blur scale",
                    bounds: [0, 1],
                    property: [this.nearFarBlurScale, "x"]
                }, {
                    type: "slider",
                    label: "Far Blur scale",
                    bounds: [0, 1],
                    property: [this.nearFarBlurScale, "y"]
                }]
            }, this.material.extensions.derivatives = !0, this.computeCocMaterial = It({
                uniforms: {
                    colorTexture: {
                        value: null
                    },
                    tNormalDepth: this.uniforms.tNormalDepth,
                    cameraNearFar: this.uniforms.cameraNearFar,
                    nearFarBlurScale: this.uniforms.nearFarBlurScale,
                    focalDepthRange: this.uniforms.focalDepthRange
                },
                vertexShader: _o,
                fragmentShader: jt + "\n#include <common>\n#include <packing>\nvarying vec2 vUv;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;float computeCoc(){float depth=getDepth(vUv);if(depth==1.)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*computeCoc()+0.5);\n#include <encodings_fragment>\n}"
            }, "colorTexture"), this.expandCocMaterial = It({
                uniforms: {
                    colorTexture: {
                        value: null
                    },
                    colorTextureSize: {
                        value: new i.FM8
                    },
                    direction: {
                        value: new i.FM8
                    },
                    tNormalDepth: this.uniforms.tNormalDepth,
                    nearFarBlurScale: this.uniforms.nearFarBlurScale
                },
                vertexShader: _o,
                fragmentShader: jt + "\n#include <common>\nvarying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;uniform vec2 nearFarBlurScale;const float MAXIMUM_BLUR_SIZE=4.;float expandNear(const in vec2 offset,const in bool isBackground){float coc=0.;vec2 sampleOffsets=MAXIMUM_BLUR_SIZE*offset/5.;float coc0=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv)).a-1.;float coc1=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-5.*sampleOffsets)).a-1.;float coc2=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-4.*sampleOffsets)).a-1.;float coc3=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-3.*sampleOffsets)).a-1.;float coc4=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-2.*sampleOffsets)).a-1.;float coc5=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-1.*sampleOffsets)).a-1.;float coc6=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+1.*sampleOffsets)).a-1.;float coc7=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+2.*sampleOffsets)).a-1.;float coc8=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+3.*sampleOffsets)).a-1.;float coc9=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+4.*sampleOffsets)).a-1.;float coc10=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+5.*sampleOffsets)).a-1.;if(isBackground){coc=abs(coc0)*0.095474+(abs(coc1)+abs(coc10))*0.084264+(abs(coc2)+abs(coc9))*0.088139+(abs(coc3)+abs(coc8))*0.091276+(abs(coc4)+abs(coc7))*0.093585+(abs(coc5)+abs(coc6))*0.094998;}else{coc=min(coc0,0.);coc=min(coc1*0.3,coc);coc=min(coc2*0.5,coc);coc=min(coc3*0.75,coc);coc=min(coc4*0.8,coc);coc=min(coc5*0.95,coc);coc=min(coc6*0.95,coc);coc=min(coc7*0.8,coc);coc=min(coc8*0.75,coc);coc=min(coc9*0.5,coc);coc=min(coc10*0.3,coc);if(abs(coc0)>abs(coc))coc=coc0;}return coc;}void main(){vec2 offset=2.*direction/colorTextureSize;bool isBackground=getDepth(vUv)>1.-0.001;float coc=expandNear(offset,isBackground);gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*coc+0.5);\n#include <encodings_fragment>\n}"
            }, "colorTexture")
        }
        render(e, t, n, r, s) {
            if (!this.enabled) return;
            const o = e.baseRenderer,
                a = {
                    minFilter: i.TyD,
                    magFilter: i.TyD,
                    type: i.cLu,
                    encoding: i.rnI,
                    sizeMultiplier: .5,
                    isAntialiased: !1,
                    format: i.wk1,
                    depthBuffer: !1,
                    generateMipmaps: !1
                },
                l = o.getTempTarget(a),
                c = o.getTempTarget(a);
            if (this.computeCocMaterial.uniforms.colorTexture.value = n.texture, o.blit(void 0, l, {
                    material: this.computeCocMaterial
                }), this.expandCocMaterial.uniforms.colorTexture.value = l.texture, this.expandCocMaterial.uniforms.direction.value.set(1, 0), o.blit(void 0, c, {
                    material: this.expandCocMaterial
                }), this.expandCocMaterial.uniforms.colorTexture.value = c.texture, this.expandCocMaterial.uniforms.direction.value.set(0, 1), o.blit(void 0, l, {
                    material: this.expandCocMaterial
                }), this.dofBlurMaterial.uniforms.frameCount) this.dofBlurMaterial.uniforms.colorTexture.value = l.texture, o.blit(void 0, c, {
                material: this.dofBlurMaterial
            });
            else {
                const e = o.getTempTarget(a);
                this.dofBlurMaterial.uniforms.cocTexture.value = l.texture, this.dofBlurMaterial.uniforms.colorTexture.value = l.texture, this.dofBlurMaterial.uniforms.direction.value.set(1, 0), o.blit(void 0, e, {
                    material: this.dofBlurMaterial
                }), this.dofBlurMaterial.uniforms.colorTexture.value = e.texture, this.dofBlurMaterial.uniforms.direction.value.set(0, 1), o.blit(void 0, c, {
                    material: this.dofBlurMaterial
                }), o.releaseTempTarget(e)
            }
            this.material.uniforms.blurTexture.value = c.texture, this.material.uniforms.cocTexture.value = l.texture, super.render(e, t, n, r, s), o.releaseTempTarget(l), o.releaseTempTarget(c)
        }
    }
    du([xe(), V()], mu.prototype, "nearFarBlurScale", void 0), du([xe(), V()], mu.prototype, "focalDepthRange", void 0), du([V()], mu.prototype, "crossCenter", void 0), du([V()], mu.prototype, "crossRadius", void 0), du([V()], mu.prototype, "crossAlpha", void 0), du([V()], mu.prototype, "crossColor", void 0);
    var gu = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class vu extends Ws {
        constructor(e = !0, t = !1) {
            super(), this.passId = "depthOfField", this._beforeFilters = ["progressive", "tonemap", "screen"], this._afterFilters = ["render"], this._requiredFilters = ["render"], this.dependencies = [Ys], this.enableEdit = !1, this._focalPointHit = new i.Pa4(0, 0, 0), this.crossFadeTime = 200, this._focalPointHitTime = 0, this._tempVec = new i.Pa4, this.enabled = e, this.enableEdit = t, this._onObjectHit = this._onObjectHit.bind(this), this.setDirty = this.setDirty.bind(this)
        }
        passCtor(e) {
            return new mu
        }
        get _frameFadeTime() {
            return 2.5 * this.crossFadeTime
        }
        _onObjectHit(e) {
            var t, n;
            this._pass && e.intersects.intersect && this.enabled && this.enableEdit && (this._focalPointHit.copy(e.intersects.intersect.point), this._focalPointHitTime = e.time, e.intersects.selectedObject = null, null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Ea)) || void 0 === n || n.startTransition(this._frameFadeTime), this.setDirty())
        }
        async onAdded(e) {
            var t;
            await super.onAdded(e), e.getPluginByType("Picking") || console.warn("DepthOfFieldPlugin requires PickingPlugin for editing."), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("hitObject", this._onObjectHit)
        }
        async onRemove(e) {
            var t;
            return null === (t = e.getPluginByType("Picking")) || void 0 === t || t.removeEventListener("hitObject", this._onObjectHit), super.onRemove(e)
        }
        setDirty() {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setDirty()
        }
        _update(e) {
            var t, n;
            if (!super._update(e)) return !1;
            const r = null === (t = this.pass) || void 0 === t ? void 0 : t.passObject;
            if (!r) return !1;
            const s = e.getPlugin(Ys);
            null == s || s.updateShaderProperties(r.material), r.dofBlurMaterial.uniforms.frameCount && (null === (n = e.renderer) || void 0 === n || n.updateShaderProperties(r.dofBlurMaterial));
            const o = e.scene.activeCamera;
            if (!o) return !1;
            o.cameraObject.updateMatrixWorld(!0), o.updateShaderProperties(r.material), this._tempVec.subVectors(this._focalPointHit, o.cameraObject.position), r.focalDepthRange.x = this._tempVec.length(), r.focalDepthRange.x *= o.cameraObject.getWorldDirection(new i.Pa4).dot(this._tempVec.normalize());
            let a = (Ct() - this._focalPointHitTime) / this.crossFadeTime;
            if (a = 1 - Math.min(1, Math.max(0, a)), Math.abs(a - r.crossAlpha) > .01 && (r.crossAlpha = a, this.setDirty()), a > 0) {
                const e = this._tempVec.copy(this._focalPointHit).project(o.cameraObject).addScalar(1).divideScalar(2);
                r.crossCenter.set(e.x, e.y), r.computeCocMaterial.uniformsNeedUpdate = !0, r.expandCocMaterial.uniformsNeedUpdate = !0
            }
            return !0
        }
        get uiConfig() {
            var e, t, n, r, i;
            if (this._uiConfig) return this._uiConfig;
            const s = null === (t = null === (e = this._pass) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig;
            return s ? (null === (r = null === (n = s.children) || void 0 === n ? void 0 : n.map((e => x(e)))) || void 0 === r || r.flat(2).forEach((e => e && (e.onChange = this.setDirty))), null === (i = s.children) || void 0 === i || i.push({
                type: "checkbox",
                label: "Enable Edit",
                limitedUi: !0,
                property: [this, "enableEdit"]
            }), this._uiConfig = s, s) : {}
        }
    }
    vu.PluginType = "DepthOfField", gu([xe()], vu.prototype, "enableEdit", void 0), gu([xe("focalPoint")], vu.prototype, "_focalPointHit", void 0), gu([xe()], vu.prototype, "crossFadeTime", void 0);
    var bu = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let xu = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.dependencies = [Vs], this._defines = {}, this._uniforms = {
                noiseBumpParams: {
                    value: new i.FM8
                },
                noiseBumpScale: {
                    value: .05
                },
                noiseBumpFlakeScale: {
                    value: 1e3
                },
                noiseFlakeClamp: {
                    value: 1
                },
                noiseFlakeRadius: {
                    value: .5
                },
                noiseFlakeRoughnessMod: {
                    value: 1
                }
            }, this.materialExtension = {
                parsFragmentSnippet: (e, t) => {
                    var n;
                    return this.enabled && (null === (n = null == t ? void 0 : t.materialObject.userData._noiseBumpMat) || void 0 === n ? void 0 : n.hasBump) ? vo + "\n#ifndef VORONOI_HELPER\n#define VORONOI_HELPER\nfloat voronoi_distance(vec2 a,vec2 b,float metric){return distance(a,b);}float voronoi_f1_2d(in vec2 coord,in float randomness,in float flakeClamp,in float flakeRadius,inout vec3 outColor){vec2 cellPosition=floor(coord);vec2 localPosition=coord-cellPosition;float minDistance=8.;vec2 targetOffset,targetPosition;for(int j=-1;j<=1;j++){for(int i=-1;i<=1;i++){vec2 cellOffset=vec2(i,j);vec2 pointPosition=cellOffset+hash3(cellPosition+cellOffset).xy*randomness;float distanceToPoint=voronoi_distance(pointPosition,localPosition,1.);if(distanceToPoint<minDistance){targetOffset=cellOffset;minDistance=distanceToPoint;targetPosition=pointPosition;}}}float outDistance=minDistance;float dist=step(flakeRadius,outDistance);outColor=hash3(cellPosition+hash3(cellPosition+targetOffset).xy*randomness+targetOffset);vec3 outColor1=minDistance<flakeRadius?outColor:vec3(0.5,0.5,1.);outDistance=mix(dist,minDistance,flakeClamp);outColor=mix(outColor1,outColor,flakeClamp);return outDistance;}\n#endif\n\nuniform vec2 noiseBumpParams;uniform float noiseBumpScale;uniform float noiseBumpFlakeScale;uniform float noiseFlakeClamp;uniform float noiseFlakeRadius;uniform float noiseFlakeRoughnessMod;vec3 perturbNormalArb_nb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n" : ""
                },
                shaderExtender: (e, t, n) => {
                    var r;
                    if (!this.enabled || !(null === (r = t.materialObject.userData._noiseBumpMat) || void 0 === r ? void 0 : r.hasBump)) return;
                    const i = "#glMarker beforeAccumulation";
                    e.fragmentShader = e.fragmentShader.replace(i, "\n            vec3 outColor; \n            float voronoiDist = clamp(voronoi_f1_2d( noiseBumpFlakeScale * noiseBumpParams.xy * vUv, 1., noiseFlakeClamp, noiseFlakeRadius, outColor ), 0.0, 1.0);\n            normal = perturbNormalArb_nb( - vViewPosition, normal, (2. * outColor.xy - 1.) * noiseBumpScale, faceDirection ); \n            float avg = (outColor.r + outColor.g)*0.5; \n            diffuseColor *= (clamp(avg+0.5, 0.3, 1.));\n            float roughnessModifier = mix(1. - avg, 1., noiseFlakeRoughnessMod);\n            roughnessFactor *= roughnessModifier;\n            \n" + i), e.vertexUvs = !0, e.extensionDerivatives = !0
                },
                onObjectRender: (e, t) => {
                    var n;
                    const r = null === (n = t.materialObject.userData) || void 0 === n ? void 0 : n._noiseBumpMat;
                    if (!(null == r ? void 0 : r.hasBump)) return;
                    this._uniforms.noiseBumpParams.value.fromArray(r.bumpNoiseParams), this._uniforms.noiseBumpScale.value = r.bumpScale, this._uniforms.noiseBumpFlakeScale.value = r.flakeScale, this._uniforms.noiseFlakeClamp.value = r.flakeClamp, this._uniforms.noiseFlakeRadius.value = r.flakeRadius, this._uniforms.noiseFlakeRoughnessMod.value = r.flakeRoughnessMod;
                    const i = this.enabled ? 1 : 0;
                    t.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED !== i && (t.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED = i, t.materialObject.needsUpdate = !0)
                },
                extraUniforms: { ...this._uniforms
                },
                computeCacheKey: e => {
                    var t, n;
                    return (this.enabled ? "1" : "0") + ((null === (n = null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._noiseBumpMat) || void 0 === n ? void 0 : n.hasBump) ? "1" : "0")
                },
                isCompatible: e => e.isMeshStandardMaterial2,
                updaters: () => [],
                getUiConfig: e => {
                    const t = {
                        type: "folder",
                        label: "NoiseBumpMaterial",
                        children: [{
                            type: "checkbox",
                            label: "Enabled",
                            get value() {
                                var t;
                                return (null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump) || !1
                            },
                            set value(n) {
                                var r, i;
                                n !== (null === (r = e.materialObject.userData._noiseBumpMat) || void 0 === r ? void 0 : r.hasBump) && (n ? yu(e.materialObject) || alert("Cannot add noise bump.") : (e.materialObject.userData._noiseBumpMat.hasBump = !1, e.materialObject.needsUpdate = !0), null === (i = t.uiRefresh) || void 0 === i || i.call(t, "postFrame", !0))
                            },
                            onChange: this.setDirty
                        }, () => ({
                            type: "vec4",
                            label: "Bump Noise Params",
                            bounds: [0, 1],
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump)
                            },
                            property: [e.materialObject.userData._noiseBumpMat, "bumpNoiseParams"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "slider",
                            label: "Bump Scale",
                            bounds: [0, .01],
                            stepSize: 1e-5,
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump)
                            },
                            property: [e.materialObject.userData._noiseBumpMat, "bumpScale"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "slider",
                            label: "Flake Scale",
                            bounds: [100, 1e4],
                            stepSize: 1e-4,
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump)
                            },
                            property: [e.materialObject.userData._noiseBumpMat, "flakeScale"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "slider",
                            label: "Flake Clamp",
                            bounds: [0, 1],
                            stepSize: 1,
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump)
                            },
                            property: [e.materialObject.userData._noiseBumpMat, "flakeClamp"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "slider",
                            label: "Flake Radius",
                            bounds: [.1, 1],
                            stepSize: .01,
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump)
                            },
                            property: [e.materialObject.userData._noiseBumpMat, "flakeRadius"],
                            onChange: this.setDirty
                        }), () => ({
                            type: "slider",
                            label: "Flake Roughness Modifier",
                            bounds: [0, 1],
                            stepSize: 1,
                            hidden: () => {
                                var t;
                                return !(null === (t = e.materialObject.userData._noiseBumpMat) || void 0 === t ? void 0 : t.hasBump)
                            },
                            property: [e.materialObject.userData._noiseBumpMat, "flakeRoughnessMod"],
                            onChange: this.setDirty
                        })]
                    };
                    return t
                }
            }, this.setDirty = () => {
                var e;
                null === (e = this._viewer) || void 0 === e || e.setDirty()
            }, this._loaderCreate = this._loaderCreate.bind(this)
        }
        addNoiseBumpMaterial(e) {
            return yu(e.materialObject)
        }
        _loaderCreate({
            loader: e
        }) {
            e.isGLTFLoader2 && e.register((e => new wu(e)))
        }
        async onAdded(e) {
            var t, n, r, i, s;
            await super.onAdded(e);
            const o = e.getPlugin(Vs);
            null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(Su)
        }
        async onRemove(e) {
            var t, n, r, i;
            return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e)
        }
    };

    function yu(e) {
        const t = null == e ? void 0 : e.userData;
        if (!t) return !1;
        t._noiseBumpMat || (t._noiseBumpMat = {});
        const n = t._noiseBumpMat;
        return n.hasBump = !0, void 0 === n.bumpNoiseParams && (n.bumpNoiseParams = [.5, .5]), void 0 === n.bumpScale && (n.bumpScale = .05), void 0 === n.flakeScale && (n.flakeScale = .05), void 0 === n.flakeClamp && (n.flakeClamp = 1), void 0 === n.flakeRadius && (n.flakeRadius = .3), void 0 === n.flakeRoughnessMod && (n.flakeRoughnessMod = 1), e.isMaterial && (e.needsUpdate = !0), !0
    }
    xu.PluginType = "NoiseBumpMaterialPlugin", xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_noise_bump", bu([Ve("Enabled", (e => ({
        onChange: e.setDirty
    }))), xe()], xu.prototype, "enabled", void 0), xu = bu([Qe("NoiseBumpMaterial Materials")], xu);
    class wu {
        constructor(e) {
            this.parser = e, this.name = xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION
        }
        async extendMaterialParams(e, t) {
            const n = this.parser.json.materials[e];
            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
            const r = n.extensions[this.name];
            return t.userData || (t.userData = {}), yu(t), t.userData._noiseBumpMat = Te(r, t.userData._noiseBumpMat, !1, {}), Promise.resolve()
        }
    }
    const Su = e => ({
        writeMaterial: (t, n) => {
            if (!t.isMeshStandardMaterial || !t.userData._noiseBumpMat) return;
            if (!t.userData._noiseBumpMat.hasBump) return;
            n.extensions = n.extensions || {};
            const r = Me(t.userData._noiseBumpMat, !1);
            n.extensions[xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = r, e.extensionsUsed[xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = !0
        }
    });
    class Mu {
        constructor(e = 4) {
            this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
        }
        _initWorker(e) {
            if (!this.workers[e]) {
                const t = this.workerCreator();
                t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t
            }
        }
        _getIdleWorker() {
            for (let e = 0; e < this.pool; e++)
                if (!(this.workerStatus & 1 << e)) return e;
            return -1
        }
        _onMessage(e, t) {
            const n = this.workersResolve[e];
            if (n && n(t), this.queue.length) {
                const {
                    resolve: t,
                    msg: n,
                    transfer: r
                } = this.queue.shift();
                this.workersResolve[e] = t, this.workers[e].postMessage(n, r)
            } else this.workerStatus ^= 1 << e
        }
        setWorkerCreator(e) {
            this.workerCreator = e
        }
        setWorkerLimit(e) {
            this.pool = e
        }
        postMessage(e, t) {
            return new Promise((n => {
                const r = this._getIdleWorker(); - 1 !== r ? (this._initWorker(r), this.workerStatus |= 1 << r, this.workersResolve[r] = n, this.workers[r].postMessage(e, t)) : this.queue.push({
                    resolve: n,
                    msg: e,
                    transfer: t
                })
            }))
        }
        dispose() {
            this.workers.forEach((e => e.terminate())), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
        }
    }
    const Tu = 0,
        Eu = 1,
        Au = 2,
        Cu = 3,
        Ru = 0,
        ku = 0,
        Pu = 2,
        Du = 0,
        Ou = 1,
        Lu = 160,
        Iu = 161,
        Fu = 162,
        Nu = 163,
        Uu = 0,
        Bu = 1,
        ju = 0,
        zu = 1,
        Vu = 2,
        Gu = 3,
        Hu = 4,
        Wu = 5,
        Ku = 6,
        Xu = 7,
        qu = 8,
        Yu = 9,
        Zu = 10,
        Ju = 11,
        $u = 12,
        Qu = 13,
        ep = 14,
        tp = 15,
        np = 16,
        rp = 17,
        ip = 18,
        sp = 0,
        op = 1,
        ap = 2,
        lp = 3,
        cp = 4,
        up = 5,
        pp = 6,
        hp = 7,
        dp = 8,
        fp = 9,
        _p = 10,
        mp = 11,
        gp = 0,
        vp = 1,
        bp = 2,
        xp = 13,
        yp = 14,
        wp = 15,
        Sp = 128,
        Mp = 64,
        Tp = 32,
        Ep = 16,
        Ap = 0,
        Cp = 1,
        Rp = 2,
        kp = 3,
        Pp = 4,
        Dp = 5,
        Op = 6,
        Lp = 7,
        Ip = 8,
        Fp = 9,
        Np = 10,
        Up = 13,
        Bp = 14,
        jp = 15,
        zp = 16,
        Vp = 17,
        Gp = 20,
        Hp = 21,
        Wp = 22,
        Kp = 23,
        Xp = 24,
        qp = 27,
        Yp = 28,
        Zp = 29,
        Jp = 30,
        $p = 31,
        Qp = 34,
        eh = 35,
        th = 36,
        nh = 37,
        rh = 38,
        ih = 41,
        sh = 42,
        oh = 43,
        ah = 44,
        lh = 45,
        ch = 48,
        uh = 49,
        ph = 50,
        hh = 58,
        dh = 59,
        fh = 62,
        _h = 63,
        mh = 64,
        gh = 65,
        vh = 68,
        bh = 69,
        xh = 70,
        yh = 71,
        wh = 74,
        Sh = 75,
        Mh = 76,
        Th = 77,
        Eh = 78,
        Ah = 81,
        Ch = 82,
        Rh = 83,
        kh = 84,
        Ph = 85,
        Dh = 88,
        Oh = 89,
        Lh = 90,
        Ih = 91,
        Fh = 92,
        Nh = 95,
        Uh = 96,
        Bh = 97,
        jh = 98,
        zh = 99,
        Vh = 100,
        Gh = 101,
        Hh = 102,
        Wh = 103,
        Kh = 104,
        Xh = 105,
        qh = 106,
        Yh = 107,
        Zh = 108,
        Jh = 109,
        $h = 110,
        Qh = 111,
        ed = 112,
        td = 113,
        nd = 114,
        rd = 115,
        id = 116,
        sd = 117,
        od = 118,
        ad = 119,
        ld = 120,
        cd = 121,
        ud = 122,
        pd = 123,
        hd = 124,
        dd = 125,
        fd = 126,
        _d = 127,
        md = 128,
        gd = 129,
        vd = 130,
        bd = 131,
        xd = 132,
        yd = 133,
        wd = 134,
        Sd = 135,
        Md = 136,
        Td = 137,
        Ed = 138,
        Ad = 139,
        Cd = 140,
        Rd = 141,
        kd = 142,
        Pd = 143,
        Dd = 144,
        Od = 145,
        Ld = 146,
        Id = 147,
        Fd = 148,
        Nd = 149,
        Ud = 150,
        Bd = 151,
        jd = 152,
        zd = 153,
        Vd = 154,
        Gd = 155,
        Hd = 156,
        Wd = 157,
        Kd = 158,
        Xd = 159,
        qd = 160,
        Yd = 161,
        Zd = 162,
        Jd = 163,
        $d = 164,
        Qd = 165,
        ef = 166,
        tf = 167,
        nf = 168,
        rf = 169,
        sf = 170,
        of = 171,
        af = 172,
        lf = 173,
        cf = 174,
        uf = 175,
        pf = 176,
        hf = 177,
        df = 178,
        ff = 179,
        _f = 180,
        mf = 181,
        gf = 182,
        vf = 183,
        bf = 184,
        xf = 1000156007,
        yf = 1000156008,
        wf = 1000156009,
        Sf = 1000156010,
        Mf = 1000156011,
        Tf = 1000156017,
        Ef = 1000156018,
        Af = 1000156019,
        Cf = 1000156020,
        Rf = 1000156021,
        kf = 1000054e3,
        Pf = 1000054001,
        Df = 1000054002,
        Of = 1000054003,
        Lf = 1000054004,
        If = 1000054005,
        Ff = 1000054006,
        Nf = 1000054007,
        Uf = 1000066e3,
        Bf = 1000066001,
        jf = 1000066002,
        zf = 1000066003,
        Vf = 1000066004,
        Gf = 1000066005,
        Hf = 1000066006,
        Wf = 1000066007,
        Kf = 1000066008,
        Xf = 1000066009,
        qf = 1000066010,
        Yf = 1000066011,
        Zf = 1000066012,
        Jf = 1000066013,
        $f = 100034e4,
        Qf = 1000340001;
    class e_ {
        constructor() {
            this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
                vendorId: 0,
                descriptorType: 0,
                descriptorBlockSize: 0,
                versionNumber: 2,
                colorModel: 0,
                colorPrimaries: 1,
                transferFunction: 2,
                flags: 0,
                texelBlockDimension: [0, 0, 0, 0],
                bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                samples: []
            }], this.keyValue = {}, this.globalData = null
        }
    }
    class t_ {
        constructor(e, t, n, r) {
            this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = r, this._offset = 0
        }
        _nextUint8() {
            const e = this._dataView.getUint8(this._offset);
            return this._offset += 1, e
        }
        _nextUint16() {
            const e = this._dataView.getUint16(this._offset, this._littleEndian);
            return this._offset += 2, e
        }
        _nextUint32() {
            const e = this._dataView.getUint32(this._offset, this._littleEndian);
            return this._offset += 4, e
        }
        _nextUint64() {
            const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
            return this._offset += 8, e
        }
        _nextInt32() {
            const e = this._dataView.getInt32(this._offset, this._littleEndian);
            return this._offset += 4, e
        }
        _skip(e) {
            return this._offset += e, this
        }
        _scan(e, t = 0) {
            const n = this._offset;
            let r = 0;
            for (; this._dataView.getUint8(this._offset) !== t && r < e;) r++, this._offset++;
            return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r)
        }
    }
    const n_ = new Uint8Array([0]),
        r_ = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

    function i_(e) {
        return "undefined" != typeof TextEncoder ? (new TextEncoder).encode(e) : Buffer.from(e)
    }

    function s_(e) {
        return "undefined" != typeof TextDecoder ? (new TextDecoder).decode(e) : Buffer.from(e).toString("utf8")
    }

    function o_(e) {
        let t = 0;
        for (const n of e) t += n.byteLength;
        const n = new Uint8Array(t);
        let r = 0;
        for (const t of e) n.set(new Uint8Array(t), r), r += t.byteLength;
        return n
    }

    function a_(e) {
        const t = new Uint8Array(e.buffer, e.byteOffset, r_.length);
        if (t[0] !== r_[0] || t[1] !== r_[1] || t[2] !== r_[2] || t[3] !== r_[3] || t[4] !== r_[4] || t[5] !== r_[5] || t[6] !== r_[6] || t[7] !== r_[7] || t[8] !== r_[8] || t[9] !== r_[9] || t[10] !== r_[10] || t[11] !== r_[11]) throw new Error("Missing KTX 2.0 identifier.");
        const n = new e_,
            r = 17 * Uint32Array.BYTES_PER_ELEMENT,
            i = new t_(e, r_.length, r, !0);
        n.vkFormat = i._nextUint32(), n.typeSize = i._nextUint32(), n.pixelWidth = i._nextUint32(), n.pixelHeight = i._nextUint32(), n.pixelDepth = i._nextUint32(), n.layerCount = i._nextUint32(), n.faceCount = i._nextUint32();
        const s = i._nextUint32();
        n.supercompressionScheme = i._nextUint32();
        const o = i._nextUint32(),
            a = i._nextUint32(),
            l = i._nextUint32(),
            c = i._nextUint32(),
            u = i._nextUint64(),
            p = i._nextUint64(),
            h = new t_(e, r_.length + r, 3 * s * 8, !0);
        for (let t = 0; t < s; t++) n.levels.push({
            levelData: new Uint8Array(e.buffer, e.byteOffset + h._nextUint64(), h._nextUint64()),
            uncompressedByteLength: h._nextUint64()
        });
        const d = new t_(e, o, a, !0),
            f = {
                vendorId: d._skip(4)._nextUint16(),
                descriptorType: d._nextUint16(),
                versionNumber: d._nextUint16(),
                descriptorBlockSize: d._nextUint16(),
                colorModel: d._nextUint8(),
                colorPrimaries: d._nextUint8(),
                transferFunction: d._nextUint8(),
                flags: d._nextUint8(),
                texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
                bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
                samples: []
            },
            _ = (f.descriptorBlockSize / 4 - 6) / 4;
        for (let e = 0; e < _; e++) {
            const t = {
                bitOffset: d._nextUint16(),
                bitLength: d._nextUint8(),
                channelType: d._nextUint8(),
                samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
                sampleLower: -1 / 0,
                sampleUpper: 1 / 0
            };
            64 & t.channelType ? (t.sampleLower = d._nextInt32(), t.sampleUpper = d._nextInt32()) : (t.sampleLower = d._nextUint32(), t.sampleUpper = d._nextUint32()), f.samples[e] = t
        }
        n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(f);
        const m = new t_(e, l, c, !0);
        for (; m._offset < c;) {
            const e = m._nextUint32(),
                t = m._scan(e),
                r = s_(t),
                i = m._scan(e - t.byteLength);
            n.keyValue[r] = r.match(/^ktx/i) ? s_(i) : i, m._offset % 4 && m._skip(4 - m._offset % 4)
        }
        if (p <= 0) return n;
        const g = new t_(e, u, p, !0),
            v = g._nextUint16(),
            b = g._nextUint16(),
            x = g._nextUint32(),
            y = g._nextUint32(),
            w = g._nextUint32(),
            S = g._nextUint32(),
            M = [];
        for (let e = 0; e < s; e++) M.push({
            imageFlags: g._nextUint32(),
            rgbSliceByteOffset: g._nextUint32(),
            rgbSliceByteLength: g._nextUint32(),
            alphaSliceByteOffset: g._nextUint32(),
            alphaSliceByteLength: g._nextUint32()
        });
        const T = u + g._offset,
            E = T + x,
            A = E + y,
            C = A + w,
            R = new Uint8Array(e.buffer, e.byteOffset + T, x),
            k = new Uint8Array(e.buffer, e.byteOffset + E, y),
            P = new Uint8Array(e.buffer, e.byteOffset + A, w),
            D = new Uint8Array(e.buffer, e.byteOffset + C, S);
        return n.globalData = {
            endpointCount: v,
            selectorCount: b,
            imageDescs: M,
            endpointsData: R,
            selectorsData: k,
            tablesData: P,
            extendedData: D
        }, n
    }

    function l_() {
        return (l_ = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }).apply(this, arguments)
    }
    const c_ = {
        keepWriter: !1
    };

    function u_(e, t = {}) {
        t = l_({}, c_, t);
        let n = new ArrayBuffer(0);
        if (e.globalData) {
            const t = new ArrayBuffer(20 + 5 * e.globalData.imageDescs.length * 4),
                r = new DataView(t);
            r.setUint16(0, e.globalData.endpointCount, !0), r.setUint16(2, e.globalData.selectorCount, !0), r.setUint32(4, e.globalData.endpointsData.byteLength, !0), r.setUint32(8, e.globalData.selectorsData.byteLength, !0), r.setUint32(12, e.globalData.tablesData.byteLength, !0), r.setUint32(16, e.globalData.extendedData.byteLength, !0);
            for (let t = 0; t < e.globalData.imageDescs.length; t++) {
                const n = e.globalData.imageDescs[t];
                r.setUint32(20 + 5 * t * 4 + 0, n.imageFlags, !0), r.setUint32(20 + 5 * t * 4 + 4, n.rgbSliceByteOffset, !0), r.setUint32(20 + 5 * t * 4 + 8, n.rgbSliceByteLength, !0), r.setUint32(20 + 5 * t * 4 + 12, n.alphaSliceByteOffset, !0), r.setUint32(20 + 5 * t * 4 + 16, n.alphaSliceByteLength, !0)
            }
            n = o_([t, e.globalData.endpointsData, e.globalData.selectorsData, e.globalData.tablesData, e.globalData.extendedData])
        }
        const r = [];
        let i = e.keyValue;
        t.keepWriter || (i = l_({}, e.keyValue, {
            KTXwriter: "KTX-Parse v0.3.1"
        }));
        for (const e in i) {
            const t = i[e],
                n = i_(e),
                s = "string" == typeof t ? i_(t) : t,
                o = n.byteLength + 1 + s.byteLength + 1,
                a = o % 4 ? 4 - o % 4 : 0;
            r.push(o_([new Uint32Array([o]), n, n_, s, n_, new Uint8Array(a).fill(0)]))
        }
        const s = o_(r);
        if (1 !== e.dataFormatDescriptor.length || 0 !== e.dataFormatDescriptor[0].descriptorType) throw new Error("Only BASICFORMAT Data Format Descriptor output supported.");
        const o = e.dataFormatDescriptor[0],
            a = new ArrayBuffer(28 + 16 * o.samples.length),
            l = new DataView(a),
            c = 24 + 16 * o.samples.length;
        if (l.setUint32(0, a.byteLength, !0), l.setUint16(4, o.vendorId, !0), l.setUint16(6, o.descriptorType, !0), l.setUint16(8, o.versionNumber, !0), l.setUint16(10, c, !0), l.setUint8(12, o.colorModel), l.setUint8(13, o.colorPrimaries), l.setUint8(14, o.transferFunction), l.setUint8(15, o.flags), !Array.isArray(o.texelBlockDimension)) throw new Error("texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.");
        l.setUint8(16, o.texelBlockDimension[0]), l.setUint8(17, o.texelBlockDimension[1]), l.setUint8(18, o.texelBlockDimension[2]), l.setUint8(19, o.texelBlockDimension[3]);
        for (let e = 0; e < 8; e++) l.setUint8(20 + e, o.bytesPlane[e]);
        for (let e = 0; e < o.samples.length; e++) {
            const t = o.samples[e],
                n = 28 + 16 * e;
            if (t.channelID) throw new Error("channelID has been renamed to channelType.");
            l.setUint16(n + 0, t.bitOffset, !0), l.setUint8(n + 2, t.bitLength), l.setUint8(n + 3, t.channelType), l.setUint8(n + 4, t.samplePosition[0]), l.setUint8(n + 5, t.samplePosition[1]), l.setUint8(n + 6, t.samplePosition[2]), l.setUint8(n + 7, t.samplePosition[3]), 64 & t.channelType ? (l.setInt32(n + 8, t.sampleLower, !0), l.setInt32(n + 12, t.sampleUpper, !0)) : (l.setUint32(n + 8, t.sampleLower, !0), l.setUint32(n + 12, t.sampleUpper, !0))
        }
        const u = r_.length + 68 + 3 * e.levels.length * 8,
            p = u + a.byteLength;
        let h = n.byteLength > 0 ? p + s.byteLength : 0;
        h % 8 && (h += 8 - h % 8);
        const d = [],
            f = new DataView(new ArrayBuffer(3 * e.levels.length * 8));
        let _ = (h || p + s.byteLength) + n.byteLength;
        for (let t = 0; t < e.levels.length; t++) {
            const n = e.levels[t];
            d.push(n.levelData), f.setBigUint64(24 * t + 0, BigInt(_), !0), f.setBigUint64(24 * t + 8, BigInt(n.levelData.byteLength), !0), f.setBigUint64(24 * t + 16, BigInt(n.uncompressedByteLength), !0), _ += n.levelData.byteLength
        }
        const m = new ArrayBuffer(68),
            g = new DataView(m);
        return g.setUint32(0, e.vkFormat, !0), g.setUint32(4, e.typeSize, !0), g.setUint32(8, e.pixelWidth, !0), g.setUint32(12, e.pixelHeight, !0), g.setUint32(16, e.pixelDepth, !0), g.setUint32(20, e.layerCount, !0), g.setUint32(24, e.faceCount, !0), g.setUint32(28, e.levels.length, !0), g.setUint32(32, e.supercompressionScheme, !0), g.setUint32(36, u, !0), g.setUint32(40, a.byteLength, !0), g.setUint32(44, p, !0), g.setUint32(48, s.byteLength, !0), g.setBigUint64(52, BigInt(n.byteLength > 0 ? h : 0), !0), g.setBigUint64(60, BigInt(n.byteLength), !0), new Uint8Array(o_([new Uint8Array(r_).buffer, m, f.buffer, a, s, h > 0 ? new ArrayBuffer(h - (p + s.byteLength)) : new ArrayBuffer(0), n, ...d]))
    }
    const {
        read: p_,
        KHR_DF_FLAG_ALPHA_PREMULTIPLIED: h_,
        KHR_DF_TRANSFER_SRGB: d_,
        VK_FORMAT_UNDEFINED: f_,
        VK_FORMAT_R16_SFLOAT: __,
        VK_FORMAT_R16G16_SFLOAT: m_,
        VK_FORMAT_R16G16B16A16_SFLOAT: g_,
        VK_FORMAT_R32_SFLOAT: v_,
        VK_FORMAT_R32G32_SFLOAT: b_,
        VK_FORMAT_R32G32B32A32_SFLOAT: x_,
        VK_FORMAT_R8_SRGB: y_,
        VK_FORMAT_R8_UNORM: w_,
        VK_FORMAT_R8G8_SRGB: S_,
        VK_FORMAT_R8G8_UNORM: M_,
        VK_FORMAT_R8G8B8A8_SRGB: T_,
        VK_FORMAT_R8G8B8A8_UNORM: E_
    } = e, A_ = new WeakMap;
    let C_ = 0;
    class R_ extends i.aNw {
        constructor(e) {
            super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Mu, this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
        }
        setTranscoderPath(e) {
            return this.transcoderPath = e, this
        }
        setWorkerLimit(e) {
            return this.workerPool.setWorkerLimit(e), this
        }
        detectSupport(e) {
            return this.workerConfig = {
                astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
                etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
                etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
                dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
                bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
                pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
            }, e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this
        }
        init() {
            if (!this.transcoderPending) {
                const e = new i.hH6(this.manager);
                e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
                const t = e.loadAsync("basis_transcoder.js"),
                    n = new i.hH6(this.manager);
                n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
                const r = n.loadAsync("basis_transcoder.wasm");
                this.transcoderPending = Promise.all([t, r]).then((([e, t]) => {
                    const n = R_.BasisWorker.toString(),
                        r = ["/* constants */", "let _EngineFormat = " + JSON.stringify(R_.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(R_.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(R_.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([r])), this.transcoderBinary = t, this.workerPool.setWorkerCreator((() => {
                        const e = new Worker(this.workerSourceURL),
                            t = this.transcoderBinary.slice(0);
                        return e.postMessage({
                            type: "init",
                            config: this.workerConfig,
                            transcoderBinary: t
                        }, [t]), e
                    }))
                })), C_ > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), C_++
            }
            return this.transcoderPending
        }
        load(e, t, n, r) {
            if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
            const s = new i.hH6(this.manager);
            s.setResponseType("arraybuffer"), s.setWithCredentials(this.withCredentials), s.load(e, (e => {
                if (A_.has(e)) return A_.get(e).promise.then(t).catch(r);
                this.createTexture(e).then((e => t ? t(e) : null)).catch(r)
            }), n, r)
        }
        _createTextureFrom(e) {
            const {
                mipmaps: t,
                width: n,
                height: r,
                format: s,
                type: o,
                error: a,
                dfdTransferFn: l,
                dfdFlags: c
            } = e;
            if ("error" === o) return Promise.reject(a);
            const u = new i.EB7(t, n, r, s, i.ywz);
            return u.minFilter = 1 === t.length ? i.wem : i.D1R, u.magFilter = i.wem, u.generateMipmaps = !1, u.needsUpdate = !0, u.encoding = l === d_ ? i.knz : i.rnI, u.premultiplyAlpha = !!(c & h_), u
        }
        createTexture(e, t = {}) {
            const n = p_(new Uint8Array(e));
            if (n.vkFormat !== f_) return function(e) {
                const {
                    vkFormat: t,
                    pixelWidth: n,
                    pixelHeight: r,
                    pixelDepth: s
                } = e;
                if (void 0 === k_[t]) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
                let o;
                const a = e.levels[0].levelData;
                o = P_[t] === i.VzW ? new Float32Array(a.buffer, a.byteOffset, a.byteLength / Float32Array.BYTES_PER_ELEMENT) : P_[t] === i.cLu ? new Uint16Array(a.buffer, a.byteOffset, a.byteLength / Uint16Array.BYTES_PER_ELEMENT) : a;
                const l = 0 === s ? new i.IEO(o, n, r) : new i.JUT(o, n, r, s);
                return l.type = P_[t], l.format = k_[t], l.encoding = D_[t] || i.rnI, l.needsUpdate = !0, Promise.resolve(l)
            }(n);
            const r = t,
                s = this.init().then((() => this.workerPool.postMessage({
                    type: "transcode",
                    buffer: e,
                    taskConfig: r
                }, [e]))).then((e => this._createTextureFrom(e.data)));
            return A_.set(e, {
                promise: s
            }), s
        }
        dispose() {
            return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), C_--, this
        }
    }
    R_.BasisFormat = {
        ETC1S: 0,
        UASTC_4x4: 1
    }, R_.TranscoderFormat = {
        ETC1: 0,
        ETC2: 1,
        BC1: 2,
        BC3: 3,
        BC4: 4,
        BC5: 5,
        BC7_M6_OPAQUE_ONLY: 6,
        BC7_M5: 7,
        PVRTC1_4_RGB: 8,
        PVRTC1_4_RGBA: 9,
        ASTC_4x4: 10,
        ATC_RGB: 11,
        ATC_RGBA_INTERPOLATED_ALPHA: 12,
        RGBA32: 13,
        RGB565: 14,
        BGR565: 15,
        RGBA4444: 16
    }, R_.EngineFormat = {
        RGBAFormat: i.wk1,
        RGBA_ASTC_4x4_Format: i.ptH,
        RGBA_BPTC_Format: i.bsb,
        RGBA_ETC2_EAC_Format: i.ekQ,
        RGBA_PVRTC_4BPPV1_Format: i.eaV,
        RGBA_S3TC_DXT5_Format: i.ILR,
        RGB_ETC1_Format: i.fto,
        RGB_ETC2_Format: i.l0P,
        RGB_PVRTC_4BPPV1_Format: i._AM,
        RGB_S3TC_DXT1_Format: i.wuA
    }, R_.BasisWorker = function() {
        let e, t, n;
        const r = _EngineFormat,
            i = _TranscoderFormat,
            s = _BasisFormat;
        self.addEventListener("message", (function(o) {
            const u = o.data;
            switch (u.type) {
                case "init":
                    e = u.config, p = u.transcoderBinary, t = new Promise((e => {
                        n = {
                            wasmBinary: p,
                            onRuntimeInitialized: e
                        }, BASIS(n)
                    })).then((() => {
                        n.initializeBasis(), void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                    }));
                    break;
                case "transcode":
                    t.then((() => {
                        try {
                            const {
                                width: t,
                                height: o,
                                hasAlpha: p,
                                mipmaps: h,
                                format: d,
                                dfdTransferFn: f,
                                dfdFlags: _
                            } = function(t) {
                                const o = new n.KTX2File(new Uint8Array(t));

                                function u() {
                                    o.close(), o.delete()
                                }
                                if (!o.isValid()) throw u(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                                const p = o.isUASTC() ? s.UASTC_4x4 : s.ETC1S,
                                    h = o.getWidth(),
                                    d = o.getHeight(),
                                    f = o.getLevels(),
                                    _ = o.getHasAlpha(),
                                    m = o.getDFDTransferFunc(),
                                    g = o.getDFDFlags(),
                                    {
                                        transcoderFormat: v,
                                        engineFormat: b
                                    } = function(t, n, o, u) {
                                        let p, h;
                                        const d = t === s.ETC1S ? a : l;
                                        for (let r = 0; r < d.length; r++) {
                                            const i = d[r];
                                            if (e[i.if] && i.basisFormat.includes(t) && !(u && i.transcoderFormat.length < 2) && (!i.needsPowerOfTwo || c(n) && c(o))) return p = i.transcoderFormat[u ? 1 : 0], h = i.engineFormat[u ? 1 : 0], {
                                                transcoderFormat: p,
                                                engineFormat: h
                                            }
                                        }
                                        return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), p = i.RGBA32, h = r.RGBAFormat, {
                                            transcoderFormat: p,
                                            engineFormat: h
                                        }
                                    }(p, h, d, _);
                                if (!h || !d || !f) throw u(), new Error("THREE.KTX2Loader:\tInvalid texture");
                                if (!o.startTranscoding()) throw u(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                                const x = [];
                                for (let e = 0; e < f; e++) {
                                    const t = o.getImageLevelInfo(e, 0, 0),
                                        n = t.origWidth,
                                        r = t.origHeight,
                                        i = new Uint8Array(o.getImageTranscodedSizeInBytes(e, 0, 0, v));
                                    if (!o.transcodeImage(i, e, 0, 0, v, 0, -1, -1)) throw u(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                    x.push({
                                        data: i,
                                        width: n,
                                        height: r
                                    })
                                }
                                return u(), {
                                    width: h,
                                    height: d,
                                    hasAlpha: _,
                                    mipmaps: x,
                                    format: b,
                                    dfdTransferFn: m,
                                    dfdFlags: g
                                }
                            }(u.buffer), m = [];
                            for (let e = 0; e < h.length; ++e) m.push(h[e].data.buffer);
                            self.postMessage({
                                type: "transcode",
                                id: u.id,
                                width: t,
                                height: o,
                                hasAlpha: p,
                                mipmaps: h,
                                format: d,
                                dfdTransferFn: f,
                                dfdFlags: _
                            }, m)
                        } catch (e) {
                            console.error(e), self.postMessage({
                                type: "error",
                                id: u.id,
                                error: e.message
                            })
                        }
                    }))
            }
            var p
        }));
        const o = [{
                if: "astcSupported",
                basisFormat: [s.UASTC_4x4],
                transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4],
                engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format],
                priorityETC1S: 1 / 0,
                priorityUASTC: 1,
                needsPowerOfTwo: !1
            }, {
                if: "bptcSupported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.BC7_M5, i.BC7_M5],
                engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: !1
            }, {
                if: "dxtSupported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.BC1, i.BC3],
                engineFormat: [r.RGB_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: !1
            }, {
                if: "etc2Supported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.ETC1, i.ETC2],
                engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: !1
            }, {
                if: "etc1Supported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.ETC1],
                engineFormat: [r.RGB_ETC1_Format],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: !1
            }, {
                if: "pvrtcSupported",
                basisFormat: [s.ETC1S, s.UASTC_4x4],
                transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA],
                engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: !0
            }],
            a = o.sort((function(e, t) {
                return e.priorityETC1S - t.priorityETC1S
            })),
            l = o.sort((function(e, t) {
                return e.priorityUASTC - t.priorityUASTC
            }));

        function c(e) {
            return e <= 2 || 0 == (e & e - 1) && 0 !== e
        }
    };
    const k_ = {
            [x_]: i.wk1,
            [g_]: i.wk1,
            [E_]: i.wk1,
            [T_]: i.wk1,
            [b_]: i.av9,
            [m_]: i.av9,
            [M_]: i.av9,
            [S_]: i.av9,
            [v_]: i.hEm,
            [__]: i.hEm,
            [y_]: i.hEm,
            [w_]: i.hEm
        },
        P_ = {
            [x_]: i.VzW,
            [g_]: i.cLu,
            [E_]: i.ywz,
            [T_]: i.ywz,
            [b_]: i.VzW,
            [m_]: i.cLu,
            [M_]: i.ywz,
            [S_]: i.ywz,
            [v_]: i.VzW,
            [__]: i.cLu,
            [y_]: i.ywz,
            [w_]: i.ywz
        },
        D_ = {
            [T_]: i.knz,
            [S_]: i.knz,
            [y_]: i.knz
        },
        O_ = "KHR_texture_basisu";
    class L_ extends r {
        constructor() {
            super(...arguments), this.dependencies = [Vs]
        }
        async onAdded(e) {
            var t, n, r, i;
            this._importer || (this._importer = new $t(class extends R_ {
                constructor(t) {
                    super(t), this.setTranscoderPath("https://cdn.jsdelivr.net/gh/BinomialLLC/basis_universal@master/webgl/transcoder/build/").detectSupport(e.renderer.rendererObject)
                }
                async createTexture(e, t) {
                    const n = e.map((e => new Uint8Array(e.slice(0)))),
                        r = await super.createTexture(e, t);
                    return r.source._sourceImgBuffer = n, r.userData.mimeType = "image/ktx2", r
                }
            }, ["ktx2"], !1)), Us.Importers.push(this._importer), null === (i = null === (r = null === (n = null === (t = e.getManager()) || void 0 === t ? void 0 : t.exporter) || void 0 === n ? void 0 : n.getExporter("gltf", "glb")) || void 0 === r ? void 0 : r.extensions) || void 0 === i || i.push(I_)
        }
        async onDispose(e) {
            this._importer = void 0
        }
        async onRemove(e) {
            this._importer && Us.Importers.splice(Us.Importers.indexOf(this._importer), 1), this._importer = void 0
        }
    }
    L_.PluginType = "KTX2LoadPlugin";
    const I_ = e => ({
        writeTexture: (t, n) => {
            if (!e.options.embedImages) return;
            if ("image/ktx2" !== t.userData.mimeType) return;
            if (n.source) return void console.warn("source already set");
            const r = t.source._sourceImgBuffer;
            if (!r || !r.length) return void console.warn("no source buffer for ktx2");
            n.extensions = n.extensions || {};
            const i = {},
                s = new Blob(Array.isArray(r) ? r : [r], {
                    type: "image/ktx2"
                });
            i.source = e.processImageBlob(s, t), n.extensions[O_] = i, e.extensionsUsed[O_] = !0
        }
    });
    var F_ = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let N_ = class extends Nt {
        constructor(e, t, n) {
            super(e, t, null != n ? n : new U_, new ve(0, 0, 0), 1), this.enabled = !0, this._firstCall = !0
        }
        render(e, t, n, r, i) {
            if (!this.enabled) return;
            const s = this.overrideMaterial;
            s.uniforms.currentProjectionViewMatrix.value.copy(this.camera.projectionMatrix).multiply(this.camera.matrixWorldInverse), this._firstCall && (s.uniforms.lastProjectionViewMatrix.value.copy(s.uniforms.currentProjectionViewMatrix.value), this._firstCall = !1), super.render(e, t, n, r, i), s.uniforms.lastProjectionViewMatrix.value.copy(s.uniforms.currentProjectionViewMatrix.value)
        }
    };
    F_([Ve("Enabled")], N_.prototype, "enabled", void 0), N_ = F_([Qe("Velocity Buffer (TAA)")], N_);
    class U_ extends i.jyz {
        constructor() {
            super({
                vertexShader: "#ifdef USE_ALPHAMAP\n#define USE_UV\n#endif\n#include <uv_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 modelMatrixPrevious;void main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\nvec4 mvPosition=vec4(transformed,1.);\n#ifdef USE_INSTANCING\nmvPosition=instanceMatrix*mvPosition;\n#endif\nvWorldPosition=(modelMatrix*mvPosition).xyz;vWorldPositionPrevious=(modelMatrixPrevious*mvPosition).xyz;mvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n}",
                fragmentShader: "varying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 currentProjectionViewMatrix;uniform mat4 lastProjectionViewMatrix;vec2 computeScreenSpaceVelocity2(){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(vWorldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(vWorldPositionPrevious,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}void main(){vec2 velocity=clamp(computeScreenSpaceVelocity2(),-1.,1.);velocity=sign(velocity)*pow(abs(velocity),vec2(1./4.));velocity=velocity*0.5+0.5;gl_FragColor=vec4(velocity.x,velocity.y,1.,1.);}",
                uniforms: {
                    cameraNearFar: {
                        value: new i.FM8(.1, 1e3)
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaTest: {
                        value: null
                    },
                    currentProjectionViewMatrix: {
                        value: new i.yGw
                    },
                    lastProjectionViewMatrix: {
                        value: new i.yGw
                    }
                }
            }), this.extraUniformsToUpload = {
                modelMatrixPrevious: {
                    value: (new i.yGw).identity()
                }
            }, this._previousWorldMatrices = {}
        }
        onBeforeRender(e, t, n, r, s) {
            var o, a;
            const l = this._previousWorldMatrices[s.uuid];
            this.extraUniformsToUpload.modelMatrixPrevious.value.copy(null != l ? l : s.matrixWorld), l ? l.copy(s.matrixWorld) : this._previousWorldMatrices[s.uuid] = s.matrixWorld.clone();
            let c = s.material;
            Array.isArray(c) && (c = c[0]), this.uniforms.alphaMap.value = null !== (o = null == c ? void 0 : c.alphaMap) && void 0 !== o ? o : null, this.uniforms.alphaTest.value = !c || !c.alphaTest || c.alphaTest < 1e-7 ? .001 : c.alphaTest;
            let u = this.uniforms.alphaMap.value ? 1 : void 0;
            u !== this.defines.USE_ALPHAMAP && (this.defines.USE_ALPHAMAP = u, this.needsUpdate = !0), u = c.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0, u !== this.defines.ALPHA_I_RGBA_PACKING && (this.defines.ALPHA_I_RGBA_PACKING = u, this.needsUpdate = !0), this.side = null !== (a = c.side) && void 0 !== a ? a : i.ehD
        }
    }
    class B_ extends Ws {
        constructor(e = !0) {
            super(), this.passId = "velocityBuffer", this._beforeFilters = ["render"], this._afterFilters = [], this._requiredFilters = ["render"], this._velocityBuffers = [], this.enabled = e
        }
        passCtor(e) {
            const t = e.renderer.createTarget({
                depthBuffer: !0,
                type: i.ywz
            });
            t.texture.name = "velocityBuffer", this._velocityBuffers.push(t);
            const n = e.getPluginByType("debug");
            n && n.addTexture("velocityBuffer", (() => t.texture), [40, 50, 400, 200]);
            const r = new Set,
                s = new Set;
            return new class extends N_ {
                render(n, i, o, a, l) {
                    if (e.renderer.frameCount > 0) return;
                    const c = n.getRenderTarget(),
                        u = n.getActiveCubeFace(),
                        p = n.getActiveMipmapLevel();
                    this.scene.traverse((({
                        material: e
                    }) => {
                        e && ((e.transparent && e.userData.renderToDepth || !e.transparent && 0 === e.transmission && !1 === e.userData.renderToDepth) && (r.add(e), e.transparent = !e.transparent), Math.abs(e.transmission || 0) > 0 && e.userData.renderToDepth && (s.add([e, e.transmission]), e.transmission = 0))
                    })), K(n, {
                        shadowMapRender: !1,
                        backgroundRender: !1,
                        opaqueRender: !0,
                        transparentRender: !1,
                        transmissionRender: !1,
                        mainRenderPass: !1
                    }, (() => super.render(n, i, t, a, l))), r.forEach((e => e.transparent = !e.transparent)), r.clear(), s.forEach((([e, t]) => e.transmission = t)), s.clear(), n.setRenderTarget(c, u, p)
                }
            }
        }
        _update(e) {
            if (!super._update(e)) return !1;
            if (e.renderer.frameCount > 0) return !1;
            const t = this.pass.passObject;
            return t.scene = e.scene.modelObject, e.scene.activeCamera.updateShaderProperties(t.overrideMaterial), t.camera = e.scene.activeCamera.cameraObject, !0
        }
        getVelocityBuffer() {
            return this._velocityBuffers.length > 0 ? this._velocityBuffers[0] : void 0
        }
        async onDispose(e) {}
        async onRemove(e) {
            return this._velocityBuffers.forEach((t => {
                var n;
                return e.renderer.disposeTarget(null === (n = null == t ? void 0 : t.dispose) || void 0 === n ? void 0 : n.call(t))
            })), super.onRemove(e)
        }
        updateShaderProperties(e) {
            var t, n;
            return e.uniforms.tVelocity ? e.uniforms.tVelocity.value = this.enabled && null !== (n = null === (t = this.getVelocityBuffer()) || void 0 === t ? void 0 : t.texture) && void 0 !== n ? n : null : console.warn("BaseRenderer: no uniform: tVelocity"), this
        }
        get uiConfig() {
            var e;
            return null === (e = this.pass) || void 0 === e ? void 0 : e.passObject.uiConfig
        }
    }
    B_.PluginType = "VelocityBuffer";
    class j_ extends r {
        constructor() {
            super(...arguments), this.dirty = !1, this.counters = {}, this._generators = new Map, this._preRender = () => this._showDebug("preRender"), this._postRender = () => this._showDebug("postRender")
        }
        async onAdded(e) {
            this._viewer = e, e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender)
        }
        addTexture(e, t, n, r, o, a = "postRender", l = !1) {
            var c;
            this._generators.has(a) || this._generators.set(a, []), null === (c = this._generators.get(a)) || void 0 === c || c.push({
                key: e,
                fn: t,
                rect: n ? [...n] : void 0,
                frag: o || r || l ? new i.jyz({
                    vertexShader: s.vertexShader,
                    uniforms: {
                        tDiffuse: {
                            value: null
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    fragmentShader: null != o ? o : `\n        #include <common>\n        #include <packing>\n        uniform float opacity;\n\t\tuniform ${l?"samplerCube":"sampler2D"} tDiffuse;\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvec4 texel = ${l?"textureCube( tDiffuse, vec3(cos(vUv.y * PI2) * cos(vUv.x * PI2), sin(vUv.y * PI2), cos(vUv.y * PI2) * sin(vUv.x * PI2)) )":"texture2D( tDiffuse, vUv )"};\n\t\t\t${null!=r?r:""}\n\t\t\tgl_FragColor = opacity * texel;\n\t\t}\n            `
                }) : void 0
            })
        }
        removeTexture(e, t = "postRender") {
            var n, r;
            this._generators.set(t, null !== (r = null === (n = this._generators.get(t)) || void 0 === n ? void 0 : n.filter((t => t.key !== e))) && void 0 !== r ? r : [])
        }
        async onDispose(e) {
            return Promise.resolve(void 0)
        }
        async onRemove(e) {
            return e.removeEventListener("preRender", this._preRender), e.removeEventListener("postRender", this._postRender), this._viewer = void 0, Promise.resolve(void 0)
        }
        _showDebug(e) {
            var t;
            const n = this._viewer,
                r = null == n ? void 0 : n.renderer;
            r && n && (null === (t = this._generators.get(e)) || void 0 === t || t.forEach((({
                key: e,
                fn: t,
                rect: i,
                frag: s
            }) => {
                const o = t(n);
                if (o) {
                    if (o.image && i) {
                        const e = o.image.width / o.image.height;
                        i[2] < 1 && i[3] < 1 && (i[2] = 200), i[2] < 1 && (i[2] = i[3] * e), i[3] < 1 && (i[3] = i[2] / e)
                    }
                    r.blit(o, void 0, {
                        viewport: i,
                        clear: !1,
                        material: s
                    })
                }
            })))
        }
    }
    j_.PluginType = "debug";
    class z_ extends i.Tn7 {
        constructor() {
            super(...arguments), this.typeSlug = "fsShadow", this.assetType = "material", this._uniforms = {}, this.lastFrameTexture = null
        }
        get materialObject() {
            return this
        }
        onBeforeCompile(e, t) {
            e.vertexShader = e.vertexShader.replace("#include <project_vertex>", "\n#include <project_vertex>\ngl_Position = vec4(uv*2.-1., 0, 1.); \n        "), e.vertexShader = e.vertexShader.replace("void main() {", "\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n        "), e.fragmentShader = e.fragmentShader.replace("void main() {", "\nvarying vec2 vUv;\nuniform sampler2D tLastThis;\nvoid main() {\n        "), e.fragmentShader = e.fragmentShader.replace("gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );", M `
float shadow = getShadowMask();

//shift the color by dither_shift
shadow = clamp(shadow + mix(-1./512., 1./512., rand( gl_FragCoord.xy )), 0., 1.);

float last = unpackRGBAToDepth(texture2D(tLastThis, vUv));
gl_FragColor = packDepthToRGBA(mix(last, shadow, opacity));
//if not useMovingAverage:
//gl_FragColor = packDepthToRGBA(shadow * opacity + last);
        `), Object.assign(e.uniforms, this._uniforms), super.onBeforeCompile(e, t)
        }
        customProgramCacheKey() {
            return super.customProgramCacheKey()
        }
        toJSON(e) {
            throw new Error("Method not supported for this material.")
        }
        fromJSON(e, t) {
            throw new Error("Method not supported for this material.")
        }
        copyProps(e) {
            throw new Error("Method not supported for this material.")
        }
    }

    function V_(e, t, n, {
        replaceAll: r = !1,
        prepend: i = !1,
        append: s = !1
    } = {}) {
        if (!e.includes(t)) return console.error(`${t} not found in shader`), e;
        let o = n;
        return i ? o = n + t : s && (o = t + n), r ? e.replaceAll(t, o) : e.replace(t, o)
    }! function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        s > 3 && o && Object.defineProperty(t, n, o)
    }([V({
        propKey: "tLastThis"
    })], z_.prototype, "lastFrameTexture", void 0);
    var G_ = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class H_ {
        constructor(e) {
            this.enabled = !0, this._lightLayer = 5, this._frameNumber = 0, this.maxFrameNumber = 400, this.groundMapMode = "aoMap", this.alphaVignette = !0, this.alphaVignetteAxis = "xy", this.shadowAutoUpdate = !0, this.materialExtension = {
                shaderExtender: (e, t, n) => {
                    "aoMap" === this.groundMapMode ? e.fragmentShader = V_(e.fragmentShader, "#include <aomap_fragment>", V_(i.WdD.aomap_fragment, "float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;", "float ambientOcclusion = ( unpackRGBAToDepth(texture2D( aoMap, vUv2 ) ) - 1.0) * aoMapIntensity + 1.0;")) : "map" === this.groundMapMode ? e.fragmentShader = V_(e.fragmentShader, "#include <map_fragment>", V_(i.WdD.map_fragment, "diffuseColor *= sampledDiffuseColor;", "float groundShadow = unpackRGBAToDepth(sampledDiffuseColor); diffuseColor.rgb *= groundShadow; diffuseColor.a *= max(0., 1.-groundShadow);")) : "alphaMap" === this.groundMapMode && (e.fragmentShader = V_(e.fragmentShader, "#include <alphamap_fragment>", V_(i.WdD.alphamap_fragment, "texture2D( alphaMap, vUv ).g", "1. - unpackRGBAToDepth( texture2D( alphaMap, vUv ) )", {
                        replaceAll: !0
                    }))), this.alphaVignette && n.capabilities.isWebGL2 && (e.fragmentShader = V_(e.fragmentShader, "#include <output_fragment>", M `#include <output_fragment>
                    #ifndef OPAQUE
                    float weight = 0.;
                    #ifdef USE_UV
                    weight = 2.*abs(length(0.5 - vUv.${this.alphaVignetteAxis}));
                    #endif
                    #if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
                    weight = 2.*abs(length(0.5 - vUv2.${this.alphaVignetteAxis}));
                    #endif
                    weight = min(1., max(0., weight))-0.5;
                    weight = min(1., max(0., 1.0-2.*weight));
                    weight = pow(weight, 1.5);
                    gl_FragColor.a *= weight;
                    //gl_FragColor.rgb /= max(0.01, weight);
                    gl_FragColor = saturate(gl_FragColor);
                    //gl_FragColor.a = 0.5;
                    #endif
                    `))
                },
                computeCacheKey: () => this.groundMapMode + "." + this.alphaVignette + "." + this.alphaVignetteAxis,
                onObjectRender: (e, t) => {
                    t.materialObject.userData.gMapMode !== this.groundMapMode && (t.materialObject.userData.gMapMode = this.groundMapMode, t.materialObject.needsUpdate = !0)
                },
                isCompatible: e => e.isMeshStandardMaterial2
            }, this._viewer = e;
            const t = new Yc(16777215, 10, {
                near: 1.5,
                far: 20,
                bias: 0,
                frustumSize: 4,
                width: 1024,
                height: 1024,
                enabled: !0,
                radius: 10,
                normalBias: 0
            }, {
                direction: new i.Pa4(.2, 1, .2).normalize(),
                spread: .9,
                focus: 1,
                distanceScale: 20,
                minDistanceScale: new i.Pa4(10, 10, 10),
                normalDirection: new i.Pa4(0, 1, 0)
            });
            t.shadow.camera.updateProjectionMatrix(), t.layers.disableAll(), t.layers.set(this._lightLayer), this._light = t, e.scene.addLight(this._light, {
                addToRoot: !0
            }), this._shadowMat = new z_({
                color: "#ffffff",
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                premultipliedAlpha: !1,
                opacity: 1,
                transparent: !1,
                blending: i.jFi
            })
        }
        get attachedMesh() {
            return this._attachedMesh
        }
        set attachedMesh(e) {
            this._attachedMesh !== e && (this._attachedMesh && this.cleanupMaterial(), this._attachedMesh = e, this._attachedMesh && this._updateMaterial())
        }
        get target() {
            return this._target
        }
        get light() {
            return this._light
        }
        dispose() {
            this._shadowMat.dispose(), this._target = void 0, this.reset()
        }
        cleanupMaterial() {
            this._updateMaterial(!0)
        }
        _groundMapModeChanged() {
            this._attachedMesh && (this.cleanupMaterial(), this._updateMaterial(), "alphaMap" === this.groundMapMode ? this._attachedMesh.material.transparent = !0 : this._attachedMesh.material.transparent = !1), this.reset()
        }
        _alphaVignetteChanged() {
            var e, t, n;
            null === (t = null === (e = this.materialExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e), null === (n = this._viewer) || void 0 === n || n.setDirty()
        }
        fromJSON(e, t) {
            return Te(e, this, !0, t), this.reset(), this
        }
        reset() {
            this._frameNumber = 0
        }
        autoUpdateShadow() {
            this.shadowAutoUpdate && this.updateShadow()
        }
        updateShadow() {
            if (!this.enabled) return !1;
            const e = this._attachedMesh;
            if (++this._frameNumber > this.maxFrameNumber || !e) return !1;
            const t = 1024;
            this._target || (this._target = this._viewer.renderer.createTarget({
                isAntialiased: !1,
                type: i.ywz,
                depthBuffer: !1,
                size: new i.FM8(t, t),
                sizeMultiplier: void 0,
                encoding: i.rnI,
                format: i.wk1
            })), this._frameNumber < 3 ? this._light.randomizePosition(1, 0) : this._light.randomizePosition(), e.castShadow = !1;
            const n = this._viewer.renderer.rendererObject,
                r = n.shadowMap,
                s = r.type,
                o = r.needsUpdate,
                a = r.autoUpdate;
            r.type = i._MY, r.needsUpdate = !0, r.autoUpdate = !1;
            const l = this._viewer.scene,
                c = new i.S9g;
            c.disableAll(), l.modelObject.traverse((e => {
                e.isLight && e !== this._light.lightObject && (e.userData.__gp_layers = e.layers, e.layers = c)
            }));
            const u = l.activeCamera.cameraObject;
            if (0 != (u.layers.mask & 1 << this._lightLayer)) throw "Camera can render pseudo directional light, check layers";
            u.layers.enable(this._lightLayer), e.layers.disable(this._lightLayer), K(n, {
                shadowMapRender: !0,
                backgroundRender: !1,
                sceneRender: !1
            }, (() => this._viewer.renderer.renderScene(l))), u.layers.disable(this._lightLayer);
            const p = u.layers.mask;
            u.layers.set(this._lightLayer), e.layers.enable(this._lightLayer);
            const h = this._viewer.renderer.getTempTarget({
                    isAntialiased: !1,
                    type: i.ywz,
                    depthBuffer: !1,
                    size: new i.FM8(t, t),
                    encoding: i.rnI,
                    format: i.wk1
                }),
                d = h.texture.encoding;
            h.texture.encoding = i.rnI, this._viewer.renderer.blit(this._target.texture, h, {
                clear: !0
            }); {
                const t = l.modelObject.environment,
                    r = l.modelObject.background,
                    i = e.material,
                    s = e.frustumCulled,
                    o = n.getRenderTarget(),
                    a = n.getActiveCubeFace(),
                    c = n.getActiveMipmapLevel();
                l.modelObject.background = null, l.modelObject.environment = null, e.material = this._shadowMat, e.frustumCulled = !1, n.setRenderTarget(this._target);
                const u = !1;
                this._shadowMat.opacity = u ? 1 / this.maxFrameNumber : Math.max(1 / this.maxFrameNumber, 1 / this._frameNumber), this._shadowMat.lastFrameTexture = h.texture, this._shadowMat.needsUpdate = !0, K(n, {
                    shadowMapRender: !1,
                    backgroundRender: !1,
                    opaqueRender: !0,
                    transparentRender: !1,
                    transmissionRender: !1
                }, (() => this._viewer.renderer.renderScene(l))), n.setRenderTarget(o, a, c), e.frustumCulled = s, e.material = i, l.modelObject.environment = t, l.modelObject.background = r
            }
            return h.texture.encoding = d, this._viewer.renderer.releaseTempTarget(h), e.layers.disable(this._lightLayer), u.layers.mask = p, l.modelObject.traverse((e => {
                e.isLight && e !== this._light.lightObject && (e.layers = e.userData.__gp_layers, delete e.userData.__gp_layers)
            })), r.type = s, r.needsUpdate = o, r.autoUpdate = a, e.castShadow = !0, (this._frameNumber < 2 || this._frameNumber > Math.min(30, this.maxFrameNumber) && this._frameNumber % 150 == 0) && (this._updateMaterial(), this._viewer.setDirty(), e.dispatchEvent({
                type: "materialUpdate"
            })), !0
        }
        _updateMaterial(e = !1) {
            var t, n, r;
            this._attachedMesh && (e ? (this._attachedMesh.material.alphaMap === (null === (t = this._target) || void 0 === t ? void 0 : t.texture) && (this._attachedMesh.material.alphaMap = null), this._attachedMesh.material.aoMap === (null === (n = this._target) || void 0 === n ? void 0 : n.texture) && (this._attachedMesh.material.aoMap = null), this._attachedMesh.material.map === (null === (r = this._target) || void 0 === r ? void 0 : r.texture) && (this._attachedMesh.material.map = null)) : this._target && ("alphaMap" === this.groundMapMode && (this._attachedMesh.material.alphaMap = this._target.texture), "aoMap" === this.groundMapMode && (this._attachedMesh.material.aoMap = this._target.texture), "map" === this.groundMapMode && (this._attachedMesh.material.map = this._target.texture)), this._attachedMesh.material && (this._attachedMesh.material.userData.ALPHA_I_RGBA_PACKING = !e && "alphaMap" === this.groundMapMode, this._attachedMesh.material.alphaTest = e || "alphaMap" !== this.groundMapMode ? 0 : .001, this._attachedMesh.material.needsUpdate = !0))
        }
    }
    G_([xe("randomizedLight")], H_.prototype, "_light", void 0), G_([C(H_.prototype.reset), xe()], H_.prototype, "maxFrameNumber", void 0), G_([C(H_.prototype._groundMapModeChanged), xe()], H_.prototype, "groundMapMode", void 0), G_([xe(), C(H_.prototype._alphaVignetteChanged)], H_.prototype, "alphaVignette", void 0), G_([xe(), C(H_.prototype._alphaVignetteChanged)], H_.prototype, "alphaVignetteAxis", void 0);
    var W_ = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class K_ extends i.Kj0 {
        constructor(e, t, n = 0) {
            super(e), this.type = "Reflector", this.isReflector2 = !0, this.enabled = !0, this.reflectorModePhysical = !0, this.reflectionTargetNeedsUpdate = !0, this.transparentReflectionBackground = !0, this.materialExtension = {
                extraUniforms: {
                    tRefDepth: {
                        value: null
                    },
                    tRefDiffuse: {
                        value: null
                    },
                    tRefDiffuseSize: {
                        value: new i.FM8
                    },
                    refTextureMatrix: {
                        value: null
                    },
                    frameCount: {
                        value: 0
                    },
                    sceneBoundingRadius: {
                        value: 0
                    }
                },
                updaters: [],
                shaderExtender: (e, t, n) => {
                    if (this.enabled) {
                        e.vertexShader = e.vertexShader.replace("void main() {", "void main() {\nvRefUv = refTextureMatrix * vec4( position, 1.0 );");
                        const t = "#glMarker beforeModulation";
                        e.fragmentShader = e.fragmentShader.replace(t, "\n                    if(roughnessFactor < 0.95) {\n                        float d = 0.;//textureProj(tRefDepth, vRefUv).r;\n                        d = min(2., max(0., (d-0.06) * ((7./3.-ior)) * sceneBoundingRadius));\n                        vec4 refBaseColor = getReflectionColor(material.roughness, material.roughness * d);\n                        // refBaseColor.rgb = vec3(refBaseColor.a);\n                        // refBaseColor.a *= 1.0 - clamp(material.roughness * .3, 0., 1.);\n                        " + (this.reflectorModePhysical ? "\n                        #if !defined(SSR_ENABLED) || SSR_ENABLED < 1 \n                        vec3 specularColor = EnvironmentBRDF(geometry.normal, geometry.viewDir, material.specularColor.rgb, material.specularF90, material.roughness);\n                        #endif\n                        reflectedLight.indirectSpecular = mix(vec3(reflectedLight.indirectSpecular), saturate(specularColor.rgb * refBaseColor.rgb), refBaseColor.a);\n                        " : "\n                        reflectedLight.indirectSpecular = saturate(diffuseColor.rgb * refBaseColor.rgb);\n                        diffuseColor.a *= refBaseColor.a;\n                        ") + "}\n" + t)
                    }
                },
                parsVertexSnippet: () => this.enabled ? "\n\t\tuniform mat4 refTextureMatrix;\n\t\tvarying vec4 vRefUv;\n" : "",
                parsFragmentSnippet: () => this.enabled ? hu + "\n" + vo + "\n#ifndef D_sceneBoundingRadius\n#define D_sceneBoundingRadius\nuniform float sceneBoundingRadius;\n#endif\nvarying vec4 vRefUv;uniform sampler2D tRefDiffuse;uniform vec2 tRefDiffuseSize;uniform sampler2D tRefDepth;float getSpecularMIPLevel(const in float roughness,const in float maxMIPLevel){float sigma=PI*roughness*roughness/(1.+roughness);float desiredMIPLevel=maxMIPLevel+log2(sigma);return clamp(desiredMIPLevel,0.,maxMIPLevel);}vec4 getReflectionColor(const in float roughness,const in float depthModifier){float mip=getSpecularMIPLevel(roughness+depthModifier,5.);vec4 color=texture2D(tRefDiffuse,vRefUv.xy/vRefUv.w,mip);float blurDist=saturate(2./(1.+pow(abs(vViewPosition.z),0.25)))*mip*32.*color.a;float rnd=PI2*random3(vec3(vRefUv.xy,frameCount*0.1));vec4 rotationMatrix=vec4(cos(rnd),-sin(rnd),0.,0.);rotationMatrix.z=-rotationMatrix.y;rotationMatrix.w=rotationMatrix.x;vec3 colorSum=color.rgb*color.a;float weightSum=0.001+color.a;vec2 ofs;setPds();\n#pragma unroll_loop_start\nfor(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));ofs=vRefUv.xy+vRefUv.w*blurDist*ofs/tRefDiffuseSize.xy;color=texture2D(tRefDiffuse,ofs/vRefUv.w,mip);colorSum+=color.rgb*color.a;weightSum+=color.a;}\n#pragma unroll_loop_end\nreturn vec4(colorSum/weightSum,1.);}" : "",
                computeCacheKey: e => this.enabled + " " + e.materialObject.transparent + " " + this.reflectorModePhysical + " ",
                onObjectRender: (e, {
                    materialObject: t
                }) => {
                    t.userData.__lastTransparent !== t.transparent && (t.needsUpdate = !0, t.userData.__lastTransparent = t.transparent)
                },
                isCompatible: e => e.isMeshStandardMaterial2
            }, this.material = void 0, this._renderTarget = t, this._renderTarget.depthTexture = new i.$YQ(t.width / 2, t.height / 2, i.ywz);
            const r = new i.JOQ,
                s = new i.Pa4,
                o = new i.Pa4,
                a = new i.Pa4,
                l = new i.yGw,
                c = new i.Pa4(0, 0, -1),
                u = new i.Ltg,
                p = new i.Pa4,
                h = new i.Pa4,
                d = new i.Ltg,
                f = new i.yGw,
                _ = new i.cPb;
            i.M8C.isPowerOfTwo(t.texture.image.width) && i.M8C.isPowerOfTwo(t.texture.image.height) || (this._renderTarget.texture.generateMipmaps = !1), this.onBeforeRender = (e, t, i) => {
                if (!this.enabled || !e.userData.mainRenderPass) return;
                if (!this.reflectionTargetNeedsUpdate) return;
                const m = i.view ? Object.assign({}, i.view) : null;
                if (m && i.clearViewOffset && i.clearViewOffset(), o.setFromMatrixPosition(this.matrixWorld), a.setFromMatrixPosition(i.matrixWorld), l.extractRotation(this.matrixWorld), s.set(0, 0, 1), s.applyMatrix4(l), p.subVectors(o, a), p.dot(s) > 0) return;
                p.reflect(s).negate(), p.add(o), l.extractRotation(i.matrixWorld), c.set(0, 0, -1), c.applyMatrix4(l), c.add(a), h.subVectors(o, c), h.reflect(s).negate(), h.add(o), _.position.copy(p), _.up.set(0, 1, 0), _.up.applyMatrix4(l), _.up.reflect(s), _.lookAt(h), _.far = 2, _.near = 0, _.updateMatrixWorld(), _.projectionMatrix.copy(i.projectionMatrix), f.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), f.multiply(_.projectionMatrix), f.multiply(_.matrixWorldInverse), f.multiply(this.matrixWorld), r.setFromNormalAndCoplanarPoint(s, o), r.applyMatrix4(_.matrixWorldInverse), u.set(r.normal.x, r.normal.y, r.normal.z, r.constant);
                const g = _.projectionMatrix;
                d.x = (Math.sign(u.x) + g.elements[8]) / g.elements[0], d.y = (Math.sign(u.y) + g.elements[9]) / g.elements[5], d.z = -1, d.w = (1 + g.elements[10]) / g.elements[14], u.multiplyScalar(2 / u.dot(d)), g.elements[2] = u.x, g.elements[6] = u.y, g.elements[10] = u.z + 1 - n, g.elements[14] = u.w, this.visible = !1;
                const v = e.getRenderTarget(),
                    b = e.xr.enabled,
                    x = e.shadowMap.autoUpdate;
                e.xr.enabled = !1, e.shadowMap.autoUpdate = !1, e.setRenderTarget(this._renderTarget), e.state.buffers.depth.setMask(!0), !1 === e.autoClear && e.clear();
                const y = t.background;
                this.transparentReflectionBackground && (t.background = null);
                const w = !this.transparentReflectionBackground;
                y && w && (y.userData.flipX = !y.userData.flipX), K(e, {
                    shadowMapRender: !1,
                    backgroundRender: w,
                    opaqueRender: !0,
                    transparentRender: !0,
                    transmissionRender: !1,
                    screenSpaceRendering: !1
                }, (() => e.render(t, _))), y && w && (y.userData.flipX = !y.userData.flipX || void 0), this.transparentReflectionBackground && (t.background = y), e.xr.enabled = b, e.shadowMap.autoUpdate = x, e.setRenderTarget(v), (null == m ? void 0 : m.enabled) && i.setViewOffset && i.setViewOffset(m.fullWidth, m.fullHeight, m.offsetX, m.offsetY, m.width, m.height);
                const S = i.viewport;
                void 0 !== S && e.state.viewport(S), this.visible = !0, this.reflectionTargetNeedsUpdate = !1
            }, this.textureMatrix = f, this.materialExtension.extraUniforms.tRefDiffuse.value = this._renderTarget.texture, this.materialExtension.extraUniforms.tRefDiffuseSize.value = new i.FM8(this._renderTarget.width, this._renderTarget.height), this.materialExtension.extraUniforms.tRefDepth.value = this._renderTarget.depthTexture, this.materialExtension.extraUniforms.refTextureMatrix.value = f
        }
        _updateExtension() {
            var e, t;
            this.transparentReflectionBackground = this.reflectorModePhysical, null === (t = null === (e = this.materialExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e)
        }
        getRenderTarget() {
            return this._renderTarget
        }
    }
    W_([C(K_.prototype._updateExtension)], K_.prototype, "enabled", void 0), W_([C(K_.prototype._updateExtension)], K_.prototype, "reflectorModePhysical", void 0), K_.prototype.isReflector = !0;
    var X_ = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class q_ extends Gs {
        constructor(e = {}) {
            super(), this._transformNeedRefresh = !0, this.dependencies = [Vs], this.visible = !0, this.size = 8, this.yOffset = 0, this.renderToDepth = !0, this.tonemapGround = !0, this._refreshMaterial = this._refreshMaterial.bind(this), this._refreshTransform = this._refreshTransform.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._refreshOptions2 = this._refreshOptions2.bind(this), this._onSceneUpdate = this._onSceneUpdate.bind(this), this._preRender = this._preRender.bind(this), this._postFrame = this._postFrame.bind(this), this._geometry = new i.BKK(1, 1, 1, 1), this._geometry.attributes.uv2 = this._geometry.attributes.uv.clone(), this._geometry.attributes.uv2.needsUpdate = !0, this._options = {
                shape: "",
                up: [0, 100, 0],
                autoAdjustTransform: !0
            }, this.setOptions(e)
        }
        get enabled() {
            return this.visible
        }
        set enabled(e) {
            this.visible = e
        }
        get material() {
            return this._material
        }
        get mesh() {
            return this._iMesh
        }
        _createMesh() {
            return new i.Kj0(this._geometry)
        }
        async onAdded(e) {
            var t, n;
            await super.onAdded(e), e.getPluginByType("TweakpaneUi") && console.error("TweakpaneUiPlugin must be added after Ground Plugin"), this._manager = e.getPlugin(Vs);
            const r = this._createMesh();
            r.userData.physicsMass = 0, this._iMesh = await (null === (t = this._manager) || void 0 === t ? void 0 : t.addImportedSingle(r, {
                pseudoCenter: !1,
                autoScale: !1,
                addToRoot: !0
            })), this._mesh = null === (n = this._iMesh) || void 0 === n ? void 0 : n.modelObject, this._mesh && (this._mesh.userData.userSelectable = !1, this._mesh.castShadow = !0, this._mesh.receiveShadow = !0, this._mesh.name = "Ground Plane"), e.scene.addEventListener("sceneUpdate", this._onSceneUpdate), e.scene.addEventListener("addSceneObject", this._onSceneUpdate), e.addEventListener("preRender", this._preRender), e.addEventListener("postFrame", this._postFrame), this.refreshOptions()
        }
        _postFrame() {
            this._transformNeedRefresh && this._refreshTransform(), this._viewer
        }
        _preRender() {
            this._viewer
        }
        async onDispose(e) {
            var t;
            return this._geometry.dispose(), null === (t = this._iMesh) || void 0 === t || t.dispose(), super.onDispose(e)
        }
        async onRemove(e) {
            return this._removeMaterial(), e.scene.removeEventListener("sceneUpdate", this._onSceneUpdate), e.scene.removeEventListener("addSceneObject", this._onSceneUpdate), e.removeEventListener("postFrame", this._postFrame), e.removeEventListener("preRender", this._preRender), this._manager = void 0, super.onRemove(e)
        }
        _removeMaterial() {
            var e, t;
            this._material && (null === (t = null === (e = this._manager) || void 0 === e ? void 0 : e.materials) || void 0 === t || t.unregisterMaterial(this._material), this._material.userData.renderToDepth = this._material.userData.__renderToDepth, this._material.userData.__renderToDepth = void 0, this._material = void 0)
        }
        _onSceneUpdate(e) {
            !1 !== e.geometryChanged && !1 !== e.updateGround && this.refreshTransform()
        }
        refreshTransform() {
            this._transformNeedRefresh = !0
        }
        _refreshOptions2() {
            this.refreshOptions()
        }
        refreshOptions() {
            this._viewer && (this._refreshMaterial(), this.refreshTransform())
        }
        _refreshTransform() {
            var e;
            if (!this._mesh) return;
            if (!this._viewer) return;
            let t = !1;
            if (this.visible !== this._mesh.visible && (this._mesh.visible = this.visible, t = !0), this.enabled) {
                if (this._options.autoAdjustTransform) {
                    this._mesh.userData.bboxVisible = !1;
                    const e = this._viewer.scene.getBounds(!0);
                    this._mesh.userData.bboxVisible = !0;
                    const n = e.getCenter(new i.Pa4).sub(new i.Pa4(0, e.getSize(new i.Pa4).y / 2 + this.yOffset, 0));
                    t = t || n.clone().sub(this._mesh.position).length() > 1e-4, t && this._mesh.position.copy(n)
                }
                t = t || Math.abs(this._mesh.scale.x - this.size) > 1e-4, t && (this._mesh.scale.setScalar(this.size), this._mesh.setRotationFromEuler(new i.USm(-Math.PI / 2, 0, 0)), this._mesh.matrixWorldNeedsUpdate = !0, this._mesh.userData.setDirty()), this._transformNeedRefresh = !1
            } else t && (null === (e = this._viewer) || void 0 === e || e.scene.setDirty())
        }
        _refreshMaterial() {
            var e, t, n, r, i, s, o, a, l;
            if (!this._viewer) return !1;
            if (!this.enabled) return !1;
            this._manager || console.error("GroundPlugin requires asset manager");
            const c = null === (t = null === (e = this._manager) || void 0 === e ? void 0 : e.materials) || void 0 === t ? void 0 : t.findOrCreate(null !== (r = null === (n = this._material) || void 0 === n ? void 0 : n.uuid) && void 0 !== r ? r : "standard", {
                name: "BaseGroundMaterial",
                runtimeMaterial: !0,
                color: 16777215
            });
            let u = !1;
            return (null == c ? void 0 : c.uuid) !== (null === (i = this._material) || void 0 === i ? void 0 : i.uuid) && (this._removeMaterial(), c && (this._material = c), (null === (s = this._material) || void 0 === s ? void 0 : s.uuid) || console.warn("No material found for ground"), this._viewer.scene.setDirty(), this._mesh && this._material && (this._material.roughness = .2, this._material.metalness = .5, (null !== (l = null === (a = null === (o = this._mesh) || void 0 === o ? void 0 : o.userData) || void 0 === a ? void 0 : a.setMaterial) && void 0 !== l ? l : e => {
                this._mesh && (this._mesh.material = e.materialObject)
            })(this._material)), u = !0), this._material && (void 0 === this._material.userData.__renderToDepth && (this._material.userData.__renderToDepth = this._material.userData.renderToDepth), this._material.userData.renderToDepth !== this.renderToDepth && (this._material.userData.renderToDepth = this.renderToDepth, this._viewer.setDirty()), void 0 === this._material.userData.__postTonemap && (this._material.userData.__postTonemap = this._material.userData.postTonemap), this._material.userData.postTonemap !== this.tonemapGround && (this._material.userData.postTonemap = this.tonemapGround, this._viewer.setDirty()), this._material.materialObject.userData.ssaoDisabled = !0, this._material.materialObject.userData.sscsDisabled = !0), u
        }
        setOptions(e) {
            Object.assign(this._options, e), this.refreshOptions()
        }
        fromJSON(e, t) {
            return super.fromJSON(e, t) ? (this.refreshOptions(), this) : null
        }
        _extraUiConfig() {
            return [() => {
                var e;
                return null === (e = this._material) || void 0 === e ? void 0 : e.uiConfig
            }]
        }
        get uiConfig() {
            return this._uiConfig ? this._uiConfig : this._uiConfig = {
                type: "folder",
                label: "Ground",
                children: [{
                    label: "Visible",
                    type: "checkbox",
                    property: [this, "visible"],
                    limitedUi: !0
                }, {
                    label: "Size",
                    type: "input",
                    property: [this, "size"],
                    limitedUi: !0
                }, {
                    label: "Render to Depth",
                    type: "checkbox",
                    property: [this, "renderToDepth"]
                }, {
                    label: "Tonemap",
                    type: "checkbox",
                    property: [this, "tonemapGround"]
                }, {
                    label: "Height",
                    type: "slider",
                    bounds: [-2, 2],
                    property: [this, "yOffset"]
                }, ...this._extraUiConfig()]
            }
        }
    }
    X_([xe("material")], q_.prototype, "_material", void 0), X_([C(q_.prototype.refreshTransform), xe()], q_.prototype, "visible", void 0), X_([C(q_.prototype._onSceneUpdate), xe()], q_.prototype, "size", void 0), X_([C(q_.prototype._onSceneUpdate), xe()], q_.prototype, "yOffset", void 0), X_([C(q_.prototype._refreshOptions2), xe()], q_.prototype, "renderToDepth", void 0), X_([C(q_.prototype._refreshOptions2), xe()], q_.prototype, "tonemapGround", void 0);
    var Y_ = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class Z_ extends q_ {
        constructor(e = {}, t = !1) {
            super(e), this.bakedShadows = !0, this.groundReflection = !0, this.physicalReflections = !1, this._showDebug = t, t && this.dependencies.push(j_), this._onSceneUpdate = this._onSceneUpdate.bind(this)
        }
        get shadowBaker() {
            return this._shadowBaker
        }
        _createMesh() {
            const e = new K_(this._geometry, this._viewer.renderer.createTarget({
                    type: i.ywz,
                    format: i.wk1,
                    encoding: i.rnI,
                    size: {
                        width: 1024,
                        height: 1024
                    },
                    generateMipmaps: !0,
                    depthBuffer: !0,
                    minFilter: i.D1R,
                    magFilter: i.wem,
                    isAntialiased: !1
                })),
                t = e.onBeforeRender;
            return e.onBeforeRender = (...e) => {
                var n, r;
                let i = null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("SSReflection")) || void 0 === r ? void 0 : r.passes.ssr.passObject;
                i && !i.enabled && (i = void 0), i && (i.enabled = !1), t(...e), i && (i.enabled = !0)
            }, e
        }
        async onAdded(e) {
            var t, n;
            await super.onAdded(e), this._showDebug && (null === (t = e.getPlugin(j_)) || void 0 === t || t.addTexture("bake_ground_1", (() => {
                var e, t;
                return null === (t = null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.light.shadow.map) || void 0 === t ? void 0 : t.texture
            }), [100, 100, 200, 200]), null === (n = e.getPlugin(j_)) || void 0 === n || n.addTexture("bake_ground_2", (() => {
                var e, t;
                return null === (t = null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.target) || void 0 === t ? void 0 : t.texture
            }), [100, 400, 400, 400], "texel = vec4(vec3(unpackRGBAToDepth(texel)), 1.0);"))
        }
        _postFrame() {
            var e;
            super._postFrame(), this._viewer && this.enabled && this.bakedShadows && (null === (e = this._shadowBaker) || void 0 === e || e.autoUpdateShadow())
        }
        _preRender() {
            super._preRender(), this._viewer && (this._mesh.reflectionTargetNeedsUpdate = this._viewer.renderer.frameCount < 1)
        }
        async onDispose(e) {
            return super.onDispose(e)
        }
        async onRemove(e) {
            return super.onRemove(e)
        }
        _removeMaterial() {
            var e, t, n, r;
            if (this._material) {
                if (this._shadowBaker && this._material.groundMatExtension && (null === (t = (e = this._material).unregisterMaterialExtensions) || void 0 === t || t.call(e, [this._shadowBaker.materialExtension]), delete this._material.groundMatExtension), this._material.reflectorMatExtension) {
                    const e = this._mesh.materialExtension;
                    e || console.warn("unable to find the extension to unregister"), null === (r = (n = this._material).unregisterMaterialExtensions) || void 0 === r || r.call(n, [e]), delete this._material.reflectorMatExtension
                }
                super._removeMaterial()
            }
        }
        _onSceneUpdate(e) {
            var t;
            super._onSceneUpdate(e), !1 !== e.geometryChanged && (null === (t = this._shadowBaker) || void 0 === t || t.reset())
        }
        refreshOptions() {
            if (!this._viewer) return;
            this.bakedShadows && !this._shadowBaker ? (this._shadowBaker = new H_(this._viewer), this._shadowBaker.attachedMesh = this._mesh) : !this.bakedShadows && this._shadowBaker && (this._shadowBaker.reset(), this._shadowBaker.cleanupMaterial());
            const e = this._mesh;
            e.isReflector2 && (e.enabled = this.groundReflection, e.reflectorModePhysical = this.physicalReflections), super.refreshOptions()
        }
        _refreshMaterial() {
            var e, t, n, r;
            if (!this._viewer) return !1;
            const i = super._refreshMaterial();
            if (!this._material) return i;
            if (this.groundReflection && this._mesh.isReflector2 && !this._material.reflectorMatExtension) {
                const n = this._mesh.materialExtension;
                n.updaters = [this._viewer.scene, this._viewer.renderer], null === (t = (e = this._material).registerMaterialExtensions) || void 0 === t || t.call(e, [n]), this._material.reflectorMatExtension = !0
            }
            return this.bakedShadows && this._shadowBaker && !this._material.groundMatExtension && (null === (r = (n = this._material).registerMaterialExtensions) || void 0 === r || r.call(n, [this._shadowBaker.materialExtension]), this._material.groundMatExtension = !0), this._material.materialObject.userData.ssreflDisabled = this.groundReflection, this._material.materialObject.userData.ssreflNonPhysical = !this.physicalReflections, i
        }
        _extraUiConfig() {
            var e, t, n, r, i, s, o, a, l, c, u, p, h, d, f, _, m, g, v, b, x, y, w, S, M, T, E, A, C, R;
            return [{
                label: "Baked Shadows",
                type: "checkbox",
                property: [this, "bakedShadows"]
            }, {
                label: "Shadow Frames",
                type: "input",
                hidden: () => !this._shadowBaker,
                stepSize: 1,
                bounds: [1, 1e3],
                property: [this._shadowBaker, "maxFrameNumber"]
            }, {
                label: "Alpha Vignette",
                type: "checkbox",
                hidden: () => !this._material || this._material.transmission < 1e-4 && !this._material.transparent,
                property: [this._shadowBaker, "alphaVignette"],
                limitedUi: !0,
                onChange: () => {
                    var e, t;
                    return null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e, "postFrame", !0)
                }
            }, {
                label: "Alpha Vignette Axis",
                type: "dropdown",
                hidden: () => {
                    var e;
                    return !(null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.alphaVignette) || !this._material || this._material.transmission < 1e-4 && !this._material.transparent
                },
                property: [this._shadowBaker, "alphaVignetteAxis"],
                children: ["x", "y", "xy"].map((e => ({
                    label: e,
                    value: e
                }))),
                limitedUi: !0
            }, {
                label: "Planar Reflections",
                type: "checkbox",
                property: [this, "groundReflection"],
                limitedUi: !0
            }, {
                label: "Physical Reflections",
                type: "checkbox",
                property: [this, "physicalReflections"],
                limitedUi: !0
            }, {
                label: "Shadow type",
                type: "dropdown",
                hidden: () => !this._shadowBaker,
                property: [this._shadowBaker, "groundMapMode"],
                children: [{
                    label: "aoMap"
                }, {
                    label: "map"
                }, {
                    label: "alphaMap"
                }],
                limitedUi: !0
            }, {
                type: "folder",
                label: "Randomized Light",
                hidden: () => !this._shadowBaker,
                limitedUi: !0,
                children: [{
                    type: "color",
                    label: "Color",
                    property: [null === (e = this._shadowBaker) || void 0 === e ? void 0 : e.light, "color"]
                }, {
                    type: "slider",
                    label: "Intensity",
                    bounds: [0, 100],
                    property: [null === (t = this._shadowBaker) || void 0 === t ? void 0 : t.light, "intensity"]
                }, {
                    type: "checkbox",
                    label: "Shadow Enabled",
                    property: [null === (r = null === (n = this._shadowBaker) || void 0 === n ? void 0 : n.light) || void 0 === r ? void 0 : r.shadowParams, "enabled"],
                    onChange: [null === (s = null === (i = this._shadowBaker) || void 0 === i ? void 0 : i.light) || void 0 === s ? void 0 : s.updateShadowParams, this._onSceneUpdate]
                }, {
                    type: "slider",
                    bounds: [0, 1],
                    property: [null === (a = null === (o = this._shadowBaker) || void 0 === o ? void 0 : o.light) || void 0 === a ? void 0 : a.randomParams, "focus"],
                    onChange: [this._onSceneUpdate]
                }, {
                    type: "slider",
                    bounds: [0, 1],
                    property: [null === (c = null === (l = this._shadowBaker) || void 0 === l ? void 0 : l.light) || void 0 === c ? void 0 : c.randomParams, "spread"],
                    onChange: [this._onSceneUpdate],
                    limitedUi: !0
                }, {
                    type: "slider",
                    bounds: [.01, 60],
                    property: [null === (p = null === (u = this._shadowBaker) || void 0 === u ? void 0 : u.light) || void 0 === p ? void 0 : p.randomParams, "distanceScale"],
                    onChange: [null === (d = null === (h = this._shadowBaker) || void 0 === h ? void 0 : h.light) || void 0 === d ? void 0 : d.updateShadowParams, this._onSceneUpdate]
                }, {
                    type: "vec3",
                    bounds: [-1, 1],
                    property: [null === (_ = null === (f = this._shadowBaker) || void 0 === f ? void 0 : f.light) || void 0 === _ ? void 0 : _.randomParams, "direction"],
                    onChange: [this._onSceneUpdate],
                    limitedUi: !0
                }, {
                    type: "vec3",
                    bounds: [-1, 1],
                    property: [null === (g = null === (m = this._shadowBaker) || void 0 === m ? void 0 : m.light) || void 0 === g ? void 0 : g.randomParams, "normalDirection"],
                    onChange: [this._onSceneUpdate],
                    limitedUi: !0
                }, {
                    type: "slider",
                    bounds: [.01, 10],
                    property: [null === (b = null === (v = this._shadowBaker) || void 0 === v ? void 0 : v.light) || void 0 === b ? void 0 : b.shadowParams, "radius"],
                    onChange: [null === (y = null === (x = this._shadowBaker) || void 0 === x ? void 0 : x.light) || void 0 === y ? void 0 : y.updateShadowParams, this._onSceneUpdate]
                }, {
                    type: "input",
                    property: [null === (S = null === (w = this._shadowBaker) || void 0 === w ? void 0 : w.light) || void 0 === S ? void 0 : S.shadowParams, "frustumSize"],
                    onChange: [null === (T = null === (M = this._shadowBaker) || void 0 === M ? void 0 : M.light) || void 0 === T ? void 0 : T.updateShadowParams, this._onSceneUpdate]
                }, {
                    type: "slider",
                    bounds: [-.1, .1],
                    property: [null === (A = null === (E = this._shadowBaker) || void 0 === E ? void 0 : E.light) || void 0 === A ? void 0 : A.shadowParams, "bias"],
                    onChange: [null === (R = null === (C = this._shadowBaker) || void 0 === C ? void 0 : C.light) || void 0 === R ? void 0 : R.updateShadowParams, this._onSceneUpdate]
                }]
            }, ...super._extraUiConfig()]
        }
    }
    Z_.PluginType = "Ground", Y_([C(Z_.prototype.refreshOptions), xe()], Z_.prototype, "bakedShadows", void 0), Y_([C(Z_.prototype.refreshOptions), xe()], Z_.prototype, "groundReflection", void 0), Y_([C(Z_.prototype.refreshOptions), xe()], Z_.prototype, "physicalReflections", void 0), Y_([xe("shadowBaker")], Z_.prototype, "_shadowBaker", void 0);
    var J_ = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let $_ = class extends Gs {
        constructor() {
            super(), this.toJSON = void 0, this.enabled = !0, this._lastSize = ["100%", "100%"], this._lastFsElement = null, this._fsChangeHandler = e => {
                var t;
                if (this.isFullScreen()) this.dispatchEvent({
                    type: "enter"
                });
                else {
                    const e = this._lastFsElement || (null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas);
                    e && (e.style.width = this._lastSize[0], e.style.height = this._lastSize[1]), document.removeEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("fullscreenchange", this._fsChangeHandler, !1), document.removeEventListener("MSFullscreenChange", this._fsChangeHandler, !1), this.dispatchEvent({
                        type: "exit"
                    })
                }
            }, this.enter = this.enter.bind(this), this.exit = this.exit.bind(this)
        }
        async enter(e) {
            var t;
            if (this.isFullScreen()) return;
            const n = e || (null === (t = this._viewer) || void 0 === t ? void 0 : t.canvas);
            return n ? (this._lastFsElement = n, document.addEventListener && (document.addEventListener("webkitfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("mozfullscreenchange", this._fsChangeHandler, !1), document.addEventListener("fullscreenchange", this._fsChangeHandler, !1), document.addEventListener("MSFullscreenChange", this._fsChangeHandler, !1)), this._lastSize = [n.style.width, n.style.height], n.style.width = "100%", n.style.height = "100%", n.requestFullscreen ? n.requestFullscreen() : n.mozRequestFullScreen ? n.mozRequestFullScreen() : n.webkitRequestFullscreen ? n.webkitRequestFullscreen() : n.msRequestFullscreen ? n.msRequestFullscreen() : void 0) : void 0
        }
        async exit() {
            return document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : void 0
        }
        async toggle(e) {
            return this.isFullScreen() ? this.exit() : this.enter(e)
        }
        isFullScreen() {
            return document.webkitIsFullScreen || document.mozFullScreen || void 0 !== document.msFullscreenElement
        }
    };
    $_.PluginType = "FullScreenPlugin", J_([Xe("Enter FullScreen")], $_.prototype, "enter", null), J_([Xe("Exit FullScreen")], $_.prototype, "exit", null), J_([Xe("Toggle FullScreen")], $_.prototype, "toggle", null), $_ = J_([Qe("Full Screen")], $_);
    var Q_, em = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let tm = Q_ = class extends Gs {
        constructor(e = !0) {
            super(), this.enabled = !0, this.radius = .015, this.intensity = 1, this.tolerance = 1.5, this._defines = {}, this.onlySSCSDebug = !1, this.stepCount = 2, this.dependencies = [Ys, Vs], this.materialExtension = {
                shaderExtender: (e, t, n) => {
                    if (!e.defines.SSCS_ENABLED) return;
                    const r = M `
                #ifndef D_sceneBoundingRadius
                #define D_sceneBoundingRadius
                uniform float sceneBoundingRadius;
                #endif
                float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, vec3 lightDirection ) {
                    vec3 ray_origin_view = -vViewPosition;
                    float rnd = interleavedGradientNoise(gl_FragCoord.xy, frameCount+34.);
                    float cameraDist = length(cameraPositionWorld);
//                    float radius = mix((cameraNearFar.y) + ray_origin_view.z, -ray_origin_view.z - cameraNearFar.x, rnd * 0.5 + 0.5)*sscsRadius;
                    float radius = mix((cameraDist + sceneBoundingRadius) + ray_origin_view.z, -ray_origin_view.z - max(0.0, cameraDist - sceneBoundingRadius), rnd * 0.5 + 0.5)*sscsRadius;
                    vec3 state = vec3(1.,(rnd+0.5)/float(SSCS_STEP_COUNT),2.);
                    traceRay(ray_origin_view, normalize(lightDirection) * radius, sscsTolerance * radius * 2., state, SSCS_STEP_COUNT);
                    state.z = state.z > 0.99 ? 1. : max(0.,min(state.z * state.z * (1.-sscsIntensity), 1.));
                    
                #if defined(SSCS_DEBUG) && SSCS_DEBUG > 0
                    return state.z;
                #endif
            `,
                        s = `\n#if SSCS_ENABLED\n\n    uniform float sscsIntensity;\n    uniform float sscsRadius;\n    uniform float sscsTolerance;\n\n    ${go}\n    \n    #define THREE_PACKING_INCLUDED\n    ${mo}\n    \n    ${jt}\n    ${vo}\n    \n    ${xo}\n\n#endif\n            \n            ` + i.WdD.shadowmap_pars_fragment.replace("float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {", `${r}\n`).replace("return shadow;", "return min(shadow, state.z);");
                    e.fragmentShader = e.fragmentShader.replace("#include <shadowmap_pars_fragment>", s), e.fragmentShader = e.fragmentShader.replace("#include <lights_fragment_begin>", i.WdD.lights_fragment_begin), e.fragmentShader = e.fragmentShader.replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ], directLight.direction ) : 1.0;").replace("directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;", "directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ], directLight.direction ) : 1.0;")
                },
                onObjectRender: (e, t, n) => {
                    var r;
                    const i = t.materialObject;
                    let s = this.enabled && !1 !== n.userData.screenSpaceRendering && !(null === (r = i.userData) || void 0 === r ? void 0 : r.sscsDisabled) ? 1 : 0;
                    i.defines.SSCS_ENABLED !== s && (i.defines.SSCS_ENABLED = s, i.needsUpdate = !0), s = this._defines.SSCS_STEP_COUNT, i.defines.SSCS_STEP_COUNT !== s && (i.defines.SSCS_STEP_COUNT = s, i.needsUpdate = !0), s = +this._defines.SSCS_DEBUG, i.defines.SSCS_DEBUG !== s && (i.defines.SSCS_DEBUG = s, i.needsUpdate = !0)
                },
                parsFragmentSnippet: () => "\n",
                extraUniforms: { ...Q_._uniforms
                },
                computeCacheKey: e => this.enabled ? "1" : "0",
                isCompatible: e => e.isMeshStandardMaterial2,
                updaters: () => {
                    var e, t, n, r, i;
                    return [null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ys), null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(co), null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.activeCamera, null === (r = this._viewer) || void 0 === r ? void 0 : r.renderer, null === (i = this._viewer) || void 0 === i ? void 0 : i.scene]
                }
            }, this.enabled = e, this.userData = {
                setDirty: () => {
                    var e;
                    null === (e = this._viewer) || void 0 === e || e.setDirty()
                }
            }
        }
        async onAdded(e) {
            var t, n;
            await super.onAdded(e), null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.registerMaterialExtension(this.materialExtension)
        }
        async onRemove(e) {
            var t, n;
            return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), super.onRemove(e)
        }
    };
    tm.PluginType = "SSContactShadows", tm._uniforms = {
        tNormalDepth: {
            value: null
        },
        frameCount: {
            value: 0
        },
        projection: {
            value: new i.yGw
        },
        cameraPositionWorld: {
            value: new i.Pa4
        },
        cameraNearFar: {
            value: new i.FM8(.1, 1e3)
        },
        sceneBoundingRadius: {
            value: 0
        }
    }, em([Ve("Enabled"), xe()], tm.prototype, "enabled", void 0), em([V({
        uniforms: Q_._uniforms,
        propKey: "sscsRadius"
    }), He("Radius", [1e-4, .1], 1e-4), xe()], tm.prototype, "radius", void 0), em([V({
        uniforms: Q_._uniforms,
        propKey: "sscsIntensity"
    }), He("Intensity", [1e-4, 1], 1e-4), xe()], tm.prototype, "intensity", void 0), em([V({
        uniforms: Q_._uniforms,
        propKey: "sscsTolerance"
    }), He("Tolerance", [.1, 5]), xe()], tm.prototype, "tolerance", void 0), em([G("SSCS_DEBUG", void 0, !0), Ve("Debug only SSCS"), xe()], tm.prototype, "onlySSCSDebug", void 0), em([G("SSCS_STEP_COUNT", void 0, !0), He("Step count", [1, 8], 1), xe()], tm.prototype, "stepCount", void 0), tm = Q_ = em([Qe("Screen Space Contact Shadows")], tm);
    class nm {
        constructor(e) {
            this.presets = [], this.name = "", this.selected = void 0, e && (this.name = e)
        }
        async apply(e, t, n) {
            var r, i;
            if (!t) return void(this.selected = void 0);
            let s = this.presets.find((e => e.path === t.path));
            return s || (this.presets.push(t), s = t), this.selected = s, null === (i = null === (r = e.getManager()) || void 0 === r ? void 0 : r.importer) || void 0 === i ? void 0 : i.importAsset(s, n)
        }
    }
    class rm extends nm {
        constructor() {
            super(...arguments), this.name = "Background"
        }
        async apply(e, t) {
            const n = await super.apply(e, t),
                r = null == n ? void 0 : n[0];
            return r && (r.encoding = i.knz, await e.setBackground(r)), r
        }
    }
    class im extends nm {
        constructor() {
            super(...arguments), this.name = "Environment"
        }
        async apply(e, t) {
            const n = await super.apply(e, t),
                r = null == n ? void 0 : n[0];
            return r && await e.scene.setEnvironment(r), r
        }
    }
    class sm extends nm {
        constructor() {
            super(...arguments), this.name = "GemEnvironment"
        }
        async apply(e, t) {
            const n = await super.apply(e, t),
                r = null == n ? void 0 : n[0];
            return g(e.getPluginByType("Diamond"), "envMap", r), r
        }
    }
    class om extends nm {
        async apply(e, t) {
            var n, r;
            const i = await super.apply(e, t, {
                processImported: !1
            });
            return i ? null === (r = null === (n = e.getManager()) || void 0 === n ? void 0 : n.importer) || void 0 === r ? void 0 : r.processImported(i) : void 0
        }
    }
    class am extends om {
        constructor() {
            super(...arguments), this.name = "MaterialLibraries"
        }
        async apply(e, t) {
            const n = await super.apply(e, t);
            return n && alert("Material Library successfully imported."), n
        }
    }
    class lm extends Gs {
        constructor() {
            super(...arguments), this.toJSON = null, this.enabled = !0, this.presetGroups = [], this.uiConfig = {
                type: "folder",
                label: "Presets",
                expanded: !0,
                limitedUi: !0,
                children: [() => this.presetGroups.map((e => ({
                    type: "dropdown",
                    label: e.name,
                    limitedUi: !0,
                    children: [{
                        value: "",
                        label: "none"
                    }, ...e.presets.map((e => ({
                        label: e.path.split("/").pop(),
                        value: e.path
                    })))],
                    getValue: () => {
                        var t;
                        return (null === (t = e.selected) || void 0 === t ? void 0 : t.path) || ""
                    },
                    setValue: t => {
                        e.apply(this._viewer, e.presets.find((e => e.path === t)))
                    }
                }))), {
                    type: "button",
                    label: "Download Selection",
                    limitedUi: !0,
                    value: () => {
                        const e = this.exportPresets();
                        xt(new File([JSON.stringify(e, null, 2)], "preset.template.json", {
                            type: "application/json"
                        }))
                    }
                }, {
                    type: "button",
                    label: "Export Preset Groups",
                    hidden: !0,
                    limitedUi: !1,
                    value: () => {
                        const e = this.exportPresetGroups();
                        xt(new File([JSON.stringify(e, null, 2)], "presetGroups.json", {
                            type: "application/json"
                        }))
                    }
                }]
            }
        }
        async onAdded(e) {
            var t, n;
            await super.onAdded(e), this.presetGroups.push(new rm), this.presetGroups.push(new im), this.presetGroups.push(new sm), this.presetGroups.push(new om("Ground")), this.presetGroups.push(new om("CameraViews")), this.presetGroups.push(new om("MaterialConfiguration")), this.presetGroups.push(new am), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t, "postFrame", !0)
        }
        exportPresets() {
            const e = Object.fromEntries(this.presetGroups.map((e => {
                var t;
                return [e.name, (null === (t = e.selected) || void 0 === t ? void 0 : t.path) || void 0]
            })).filter((([, e]) => e)));
            return e.type = lm.PluginType, e
        }
        async fromJSON(e, t) {
            var n, r;
            if (!super.fromJSON(e, t)) return null;
            const i = { ...e
            };
            delete i.type;
            const s = [];
            for (const [e, t] of Object.entries(i)) {
                const n = this.presetGroups.find((t => t.name === e)),
                    r = null == n ? void 0 : n.presets;
                if (!n || !r) continue;
                const i = "string" == typeof t ? {
                    path: t
                } : t;
                s.push(n.apply(this._viewer, i))
            }
            return await Promise.all(s), null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0), this
        }
        loadPresetGroups(e) {
            var t;
            for (const [n, r] of Object.entries(e)) {
                const e = null === (t = this.presetGroups.find((e => e.name === n))) || void 0 === t ? void 0 : t.presets;
                null == e || e.push(...r)
            }
        }
        exportPresetGroups() {
            return Object.fromEntries(this.presetGroups.map((e => [e.name, e.presets.map((e => e.path))])).filter((([, e]) => e.length > 0)))
        }
    }
    lm.PluginType = "PresetLibraryPlugin";
    class cm {
        constructor(e, t, n) {
            this._el = e, this._inputEl = t, this._listeners = {
                drop: [],
                dropstart: [],
                droperror: []
            }, this._onDragover = this._onDragover.bind(this), this._onDrop = this._onDrop.bind(this), this._onSelect = this._onSelect.bind(this), null == e || e.addEventListener("dragover", this._onDragover, !1), null == e || e.addEventListener("drop", this._onDrop, !1), null == t || t.addEventListener("change", this._onSelect), n && Object.entries(n).forEach((([e, t]) => t && this.on(e, t)))
        }
        get inputEl() {
            return this._inputEl
        }
        get el() {
            return this._el
        }
        on(e, t) {
            return this._listeners[e].push(t), this
        }
        _emit(e, t) {
            return this._listeners[e].forEach((e => e(t))), this
        }
        destroy() {
            const e = this._el,
                t = this._inputEl;
            null == e || e.removeEventListener("dragover", this._onDragover), null == e || e.removeEventListener("drop", this._onDrop), null == t || t.removeEventListener("change", this._onSelect)
        }
        _onDrop(e) {
            var t, n;
            e.stopPropagation(), e.preventDefault(), this._emit("dropstart");
            const r = Array.from((null === (t = e.dataTransfer) || void 0 === t ? void 0 : t.files) || []),
                i = Array.from((null === (n = e.dataTransfer) || void 0 === n ? void 0 : n.items) || []);
            if (0 !== r.length || 0 !== i.length)
                if (i.length > 0) {
                    const e = i.map((e => e.webkitGetAsEntry()));
                    this._loadNextEntry(new Map, e)
                } else this._emit("drop", {
                    files: new Map(r.map((e => (e.filePath = e.name, [e.filePath, e]))))
                });
            else this._fail("Required drag-and-drop APIs are not supported in this browser.")
        }
        _onDragover(e) {
            e.stopPropagation(), e.preventDefault(), e.dataTransfer && (e.dataTransfer.dropEffect = "copy")
        }
        _onSelect(e) {
            var t;
            if (!this._inputEl) return void console.warn("Invalid Dropzone event ", e);
            this._emit("dropstart");
            const n = [].slice.call(null !== (t = this._inputEl.files) && void 0 !== t ? t : new FileList),
                r = new Map;
            n.forEach((e => {
                e.filePath = e.webkitRelativePath || e.name, r.set(e.filePath, e)
            })), this._emit("drop", {
                files: r
            })
        }
        _loadNextEntry(e, t) {
            const n = t.pop();
            if (n)
                if (n.isFile) n.file((r => {
                    r.filePath = n.fullPath, e.set(n.fullPath, r), this._loadNextEntry(e, t)
                }), (() => console.error("Could not load file: %s", n.fullPath)));
                else if (n.isDirectory) {
                const r = n.createReader(),
                    i = n => {
                        n.length ? (t = t.concat(n), r.readEntries(i)) : this._loadNextEntry(e, t)
                    };
                r.readEntries(i)
            } else console.warn("Unknown asset type: " + n.fullPath), this._loadNextEntry(e, t);
            else this._emit("drop", {
                files: e
            })
        }
        _fail(e) {
            this._emit("droperror", {
                message: e
            })
        }
    }
    class um extends r {
        constructor(e) {
            super(), this._domElement = e, this._allowedExtensions = void 0, this.importerParams = {
                autoScale: !0,
                autoScaleRadius: 2,
                pseudoCenter: !0,
                autoImport: !0,
                autoAdd: !0,
                centerOffset: new i.Pa4(.5, .5, 3)
            }, this.dependencies = [Vs], this.uiConfig = {
                type: "folder",
                label: "Drop Options",
                children: [{
                    label: "Auto Center",
                    type: "checkbox",
                    property: [this.importerParams, "pseudoCenter"],
                    limitedUi: !0
                }, {
                    label: "Auto Scale",
                    type: "checkbox",
                    property: [this.importerParams, "autoScale"],
                    limitedUi: !0
                }, {
                    label: "Auto scale radius",
                    type: "slider",
                    bounds: [.5, 100],
                    property: [this.importerParams, "autoScaleRadius"]
                }]
            }
        }
        async onAdded(e) {
            this._inputEl = document.createElement("input"), this._viewer = e, this._inputEl.type = "file", this._dropzone = new cm(this._domElement || e.canvas, this._inputEl, {
                drop: this._onFileDrop.bind(this)
            })
        }
        async _onFileDrop({
            files: e
        }) {
            var t, n, r, i, s, o;
            if (!e) return;
            const a = this._viewer;
            if (!a) return;
            if (void 0 !== this._allowedExtensions)
                for (const r of e.keys()) this._allowedExtensions.includes(null !== (n = null === (t = r.split(".").pop()) || void 0 === t ? void 0 : t.toLowerCase()) && void 0 !== n ? n : "") || e.delete(r);
            if (e.size < 1) return;
            const l = a.getPlugin(Vs),
                c = {
                    type: "drop",
                    files: e
                };
            if (this.importerParams.autoImport) {
                const t = {
                    allowedExtensions: this.allowedExtensions,
                    ...this.importerParams
                };
                if (c.imported = await (null === (r = l.importer) || void 0 === r ? void 0 : r.importFiles(e, void 0, t)), this.importerParams.autoAdd) {
                    const e = null !== (o = [...null !== (s = null === (i = c.imported) || void 0 === i ? void 0 : i.values()) && void 0 !== s ? s : []].flat(2).filter((e => !!e))) && void 0 !== o ? o : [];
                    c.assets = l.addProcessedAssets(e, { ...this.importerParams
                    }), t.rootSceneImported || a.resetCamera(this.importerParams)
                }
            }
            this.dispatchEvent(c)
        }
        promptForFile() {
            var e;
            null === (e = this._inputEl) || void 0 === e || e.click()
        }
        async onDispose(e) {}
        async onRemove(e) {
            var t;
            null === (t = this._dropzone) || void 0 === t || t.destroy(), this._dropzone = void 0, this._viewer = void 0
        }
        get allowedExtensions() {
            return this._allowedExtensions
        }
        set allowedExtensions(e) {
            this._allowedExtensions = e, this._inputEl && (this._inputEl.accept = e ? e.map((e => "." + e)).join(", ") : "")
        }
    }
    um.PluginType = "Dropzone";
    var pm, hm = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let dm = pm = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.dependencies = [Vs], this.bicubicFiltering = !0, this._defines = {
                CUSTOM_BUMP_MAP_DEBUG: !1,
                CUSTOM_BUMP_MAP_BICUBIC: !0
            }, this._uniforms = {
                customBumpUvTransform: {
                    value: new i.Vkp
                },
                customBumpScale: {
                    value: .001
                },
                customBumpMap: {
                    value: null
                }
            }, this.materialExtension = {
                parsFragmentSnippet: (e, t) => this.enabled && (null == t ? void 0 : t.materialObject.userData._hasCustomBump) ? "#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n#if CUSTOM_BUMP_MAP_BICUBIC > 0  \nvec4 cubic(float v){vec4 n=vec4(1.,2.,3.,4.)-v;vec4 s=n*n*n;float x=s.x;float y=s.y-4.*s.x;float z=s.z-4.*s.y+6.*s.x;float w=6.-x-y-z;return vec4(x,y,z,w)*(1./6.);}vec4 textureBicubic(sampler2D sampler,vec2 texCoords){vec2 texSize=vec2(textureSize(sampler,0));vec2 invTexSize=1./texSize;texCoords=texCoords*texSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic(fxy.x);vec4 ycubic=cubic(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,+1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture(sampler,offset.xz);vec4 sample1=texture(sampler,offset.yz);vec4 sample2=texture(sampler,offset.xw);vec4 sample3=texture(sampler,offset.yw);float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}\n#endif\nvarying vec2 vCustomBumpUv;uniform sampler2D customBumpMap;uniform float customBumpScale;vec2 dHdxy_fwd_cb(){vec2 dSTdx=dFdx(vCustomBumpUv);vec2 dSTdy=dFdy(vCustomBumpUv);\n#if CUSTOM_BUMP_MAP_BICUBIC > 0\nfloat Hll=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*textureBicubic(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#else\nfloat Hll=customBumpScale*texture2D(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;\n#endif\nreturn vec2(dBx,dBy);}\n#ifndef USE_BUMPMAP\nvec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n#endif\n#endif\n" : "",
                shaderExtender: (e, t, n) => {
                    var r;
                    this.enabled && t.materialObject.userData._hasCustomBump && (null === (r = t.materialObject.userData) || void 0 === r ? void 0 : r._customBumpMap) && (e.fragmentShader = V_(e.fragmentShader, "#glMarker beforeAccumulation", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd_cb(), faceDirection );\n#endif\n                ", {
                        prepend: !0
                    }), e.vertexShader = V_(e.vertexShader, "#include <uv_pars_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                varying vec2 vCustomBumpUv;\n                uniform mat3 customBumpUvTransform;\n#endif\n                ", {
                        prepend: !0
                    }), e.vertexShader = V_(e.vertexShader, "#include <uv_vertex>", "\n#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0\n                vCustomBumpUv = ( customBumpUvTransform * vec3( uv, 1 ) ).xy;\n#endif\n                ", {
                        prepend: !0
                    }), e.vertexUvs = !0)
                },
                onObjectRender: (e, t) => {
                    var n;
                    const r = t.materialObject.userData;
                    if (!(null == r ? void 0 : r._hasCustomBump)) return;
                    const i = e;
                    if (!i.isMesh || !i.geometry) return;
                    const s = (null === (n = r._customBumpMap) || void 0 === n ? void 0 : n.isTexture) ? r._customBumpMap : null;
                    this._uniforms.customBumpMap.value = s, this._uniforms.customBumpScale.value = s ? r._customBumpScale : 0, s && (s.updateMatrix(), this._uniforms.customBumpUvTransform.value.copy(s.matrix));
                    let o = this.enabled && s ? 1 : 0;
                    t.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED = o, t.materialObject.needsUpdate = !0), o = +this._defines.CUSTOM_BUMP_MAP_DEBUG, t.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG = o, t.materialObject.needsUpdate = !0), o = +this._defines.CUSTOM_BUMP_MAP_BICUBIC, t.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC !== o && (t.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC = o, t.materialObject.needsUpdate = !0)
                },
                extraUniforms: { ...this._uniforms
                },
                computeCacheKey: e => {
                    var t, n, r;
                    return (this.enabled ? "1" : "0") + ((null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t._hasCustomBump) ? "1" : "0") + (null === (r = null === (n = e.materialObject.userData) || void 0 === n ? void 0 : n._customBumpMap) || void 0 === r ? void 0 : r.uuid)
                },
                isCompatible: e => e.isMeshStandardMaterial2,
                updaters: () => [],
                getUiConfig: e => {
                    const t = this.enableCustomBump,
                        n = {
                            type: "folder",
                            label: "CustomBumpMap",
                            children: [{
                                type: "checkbox",
                                label: "Enabled",
                                get value() {
                                    return e.materialObject.userData._hasCustomBump || !1
                                },
                                set value(r) {
                                    var i;
                                    r !== e.materialObject.userData._hasCustomBump && (r ? t(e) || alert("One or more geometries cannot be made anisotropic.") : (e.materialObject.userData._hasCustomBump = !1, e.materialObject.needsUpdate = !0), null === (i = n.uiRefresh) || void 0 === i || i.call(n, "postFrame", !0))
                                },
                                onChange: this.setDirty
                            }, {
                                type: "slider",
                                label: "Bump Scale",
                                hidden: () => !e.materialObject.userData._hasCustomBump,
                                property: [e.materialObject.userData, "_customBumpScale"],
                                onChange: this.setDirty
                            }, {
                                type: "image",
                                label: "Bump Map",
                                hidden: () => !e.materialObject.userData._hasCustomBump,
                                property: [e.materialObject.userData, "_customBumpMap"],
                                onChange: () => {
                                    e.materialObject.needsUpdate = !0, this.setDirty()
                                }
                            }]
                        };
                    return n
                }
            }, this.setDirty = () => {
                var e, t, n;
                null === (t = (e = this.materialExtension).setDirty) || void 0 === t || t.call(e), null === (n = this._viewer) || void 0 === n || n.setDirty()
            }, this.enableCustomBumpSelected = () => {
                var e, t, n;
                const r = null === (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject()) || void 0 === n ? void 0 : n.material;
                return "material" === (null == r ? void 0 : r.assetType) && this.enableCustomBump(r)
            }, this._loaderCreate = this._loaderCreate.bind(this)
        }
        enableCustomBump(e, t, n) {
            var r, i;
            const s = null === (r = e.materialObject) || void 0 === r ? void 0 : r.userData;
            if (!s) return !1;
            if (void 0 === s._hasCustomBump) {
                const e = s.appliedMeshes;
                let t = !0;
                if (e)
                    for (const {
                            geometry: n
                        } of e) !n || n.attributes.position && n.attributes.normal && n.attributes.uv || (t = !1);
                if (!t) return !1
            }
            return s._hasCustomBump = !0, s._customBumpScale = null !== (i = null != n ? n : s._customBumpScale) && void 0 !== i ? i : .001, s._customBumpMap = null != t ? t : s._customBumpMap, e.materialObject.needsUpdate = !0, !0
        }
        _loaderCreate({
            loader: e
        }) {
            e.isGLTFLoader2 && e.register((e => new fm(e)))
        }
        async onAdded(e) {
            var t, n, r, i, s;
            await super.onAdded(e);
            const o = e.getPlugin(Vs);
            null === (t = null == o ? void 0 : o.materials) || void 0 === t || t.registerMaterialExtension(this.materialExtension), null === (n = null == o ? void 0 : o.importer) || void 0 === n || n.addEventListener("loaderCreate", this._loaderCreate), null === (s = null === (i = null === (r = null == o ? void 0 : o.exporter) || void 0 === r ? void 0 : r.getExporter("gltf", "glb")) || void 0 === i ? void 0 : i.extensions) || void 0 === s || s.push(_m)
        }
        async onRemove(e) {
            var t, n, r, i;
            return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this.materialExtension), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.removeEventListener("loaderCreate", this._loaderCreate), super.onRemove(e)
        }
    };
    dm.PluginType = "CustomBumpMapPlugin", dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION = "WEBGI_materials_custom_bump_map", hm([Ve("Enabled", (e => ({
        onChange: e.setDirty
    }))), xe()], dm.prototype, "enabled", void 0), hm([Ve("Bicubic", (e => ({
        onChange: e.setDirty
    }))), G("CUSTOM_BUMP_MAP_BICUBIC", void 0, !0, pm.prototype.setDirty), xe()], dm.prototype, "bicubicFiltering", void 0), hm([Xe("Enable CustomBumpMap", (e => ({
        hidden: () => {
            var t;
            return !(null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca))
        }
    })))], dm.prototype, "enableCustomBumpSelected", void 0), dm = pm = hm([Qe("CustomBumpMap Materials")], dm);
    class fm {
        constructor(e) {
            this.parser = e, this.name = dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION
        }
        async extendMaterialParams(e, t) {
            var n;
            const r = this.parser,
                s = r.json.materials[e];
            if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
            const o = [],
                a = s.extensions[this.name];
            t.userData || (t.userData = {}), t.userData._hasCustomBump = !0, t.userData._customBumpScale = null !== (n = a.customBumpScale) && void 0 !== n ? n : 0;
            const l = a.customBumpMap;
            return l && o.push(r.assignTexture(t.userData, "_customBumpMap", l).then((e => {
                e.encoding = i.knz
            }))), Promise.all(o)
        }
    }
    const _m = e => ({
        writeMaterial: (t, n) => {
            if (!t.isMeshStandardMaterial || !t.userData._hasCustomBump) return;
            if ((t.userData._customBumpScale || 0) < .001) return;
            n.extensions = n.extensions || {};
            const r = {};
            if (r.customBumpScale = t.userData._customBumpScale || 1, t.userData._customBumpMap) {
                const n = {
                    index: e.processTexture(t.userData._customBumpMap)
                };
                e.applyTextureTransform(n, t.userData._customBumpMap), r.customBumpMap = n
            }
            n.extensions[dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = r, e.extensionsUsed[dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = !0
        }
    });
    var mm = __webpackgi_require__(701),
        gm = __webpackgi_require__.n(mm),
        vm = __webpackgi_require__(236),
        bm = __webpackgi_require__.n(vm),
        xm = __webpackgi_require__(80),
        ym = __webpackgi_require__.n(xm),
        wm = __webpackgi_require__(850),
        Sm = __webpackgi_require__.n(wm),
        Mm = __webpackgi_require__(182),
        Tm = __webpackgi_require__.n(Mm),
        Em = __webpackgi_require__(213),
        Am = __webpackgi_require__.n(Em),
        Cm = __webpackgi_require__(987),
        Rm = {};
    Rm.styleTagTransform = Am(), Rm.setAttributes = Sm(), Rm.insert = ym().bind(null, "head"), Rm.domAPI = bm(), Rm.insertStyleElement = Tm(), gm()(Cm.Z, Rm), Cm.Z && Cm.Z.locals && Cm.Z.locals;
    var km, Pm = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let Dm = km = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.dependencies = [Vs], this._popupDiv = wt({
                id: "assetManagerPopup",
                addToBody: !1,
                innerHTML: ""
            });
            const e = wt({
                id: "assetManagerPopupClose",
                addToBody: !1,
                innerHTML: "&#10005"
            });
            e.addEventListener("click", (() => {
                this._popupDiv.style.display = "none"
            })), this._popupContent = wt({
                id: "assetManagerPopupContent",
                addToBody: !1,
                innerHTML: ""
            }), this.enabled || (this._popupDiv.style.display = "none"), this._popupDiv.appendChild(e), this._popupDiv.appendChild(this._popupContent)
        }
        _onEnabledChange() {
            this.enabled || (this._popupDiv.style.display = "none")
        }
        _updatePopupDiv(e) {
            if (!this._popupContent) return;
            if (!this.enabled) return void(this._popupDiv.style.display = "none");
            let t = "";
            e.forEach(((e, n) => {
                t += `<span class="processState">${e}</span>: ${n.split("/").pop()}<br>`
            })), this._popupContent.innerHTML = t, 0 === e.size ? this._popupDiv.style.display = "none" : this._popupDiv.style.display = "block"
        }
        async onAdded(e) {
            var t, n, r, i;
            await super.onAdded(e), e.container.appendChild(this._popupDiv);
            const s = new Map;
            null === (n = null === (t = e.getManager()) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.addEventListener("importFile", (e => {
                "done" !== e.state ? s.set(e.path, e.state) : s.delete(e.path), this._updatePopupDiv(s)
            })), null === (i = null === (r = e.getManager()) || void 0 === r ? void 0 : r.exporter) || void 0 === i || i.addEventListener("exportFile", (e => {
                "done" !== e.state ? s.set(e.obj.name, e.state) : s.delete(e.obj.name), this._updatePopupDiv(s)
            }))
        }
    };
    async function Om(e, {
        ground: t = !0,
        bloom: n = !0,
        depthTonemap: r = !1
    } = {}) {
        await e.addPlugin(Ys), await e.addPlugin($_), await e.addPlugin(new co(32)), await e.addPlugin(new fo(r || !e.useRgbm)), await e.addPlugin(To), await e.addPlugin(ko), await e.addPlugin(Pa), await e.addPlugin(Ea), await e.addPlugin(wc), t && await e.addPlugin(Z_), n && await e.addPlugin(Cc), await e.addPlugin(kc), await e.addPlugin(ru), await e.addPlugin(xu), await e.addPlugin(dm), await e.addPlugin(lu), await e.addPlugin(B_, !1), await e.addPlugin(Lc), await e.addPlugin(zc), await e.addPlugin($c, !1), await e.addPlugin(tu, !1), await e.addPlugin(vu, !1), await e.addPlugin(tm, !1), await e.addPlugin(L_), await e.addPlugin(lm)
    }
    async function Lm(e, {
        debug: t = !1,
        ground: n = !0,
        bloom: r = !0,
        depthTonemap: i = !1,
        importPopup: s = !0
    } = {}) {
        var o;
        const a = new ro(e);
        t && await a.addPlugin(j_);
        const l = await a.addPlugin(Vs, void 0, void 0, {
            storage: caches ? await caches.open("webgi-cache-storage") : void 0
        });
        return s && await a.addPlugin(Dm), await Om(a, {
            ground: n,
            bloom: r,
            depthTonemap: i
        }), a.renderer.refreshPipeline(), null === (o = l.importer) || void 0 === o || o.processors.add("model", {
            forAssetType: "model",
            process: (e, t) => e
        }), a
    }
    Dm.PluginType = "AssetImportPopupPluginBasic", Pm([Ve("Enabled"), C(km.prototype._onEnabledChange), xe()], Dm.prototype, "enabled", void 0), Dm = km = Pm([Qe("Asset import popup")], Dm);
    let Im = 0;
    class Fm extends HTMLElement {
        constructor() {
            super(), this._initialized = !1, this._state = {
                src: "",
                environment: ""
            }, this._models = {}, this._refreshingModels = !1, this._refreshingEnvironment = !1, this.viewerIndex = Im++, this.canvasId = "webgi-viewer-" + this.viewerIndex, this.attachShadow({
                mode: "open"
            }), this.wrapper = document.createElement("div"), this.wrapper.style.width = "100%", this.wrapper.style.height = "100%", this.wrapper.style.display = "block", this.canvas = mt(), this.canvas.setAttribute("id", this.canvasId);
            const e = document.createElement("style");
            e.textContent = T `
            #${this.canvasId}{
              width: 100%; height: 100%; z-index: 1;
              display: block;
            }
        `, this.wrapper.append(this.canvas), this.shadowRoot.append(e, this.wrapper), this._initialize().then((async () => this.refreshAll()))
        }
        async refreshAll() {
            await Promise.all([this.refreshModelSource(), this.refreshEnvironment()])
        }
        async _initialize() {
            this._initialized || (this.viewer = await Lm({
                canvas: this.canvas,
                useRgbm: "true" === this._getAttr("rgbm", "true"),
                useGBufferDepth: "true" === this._getAttr("depth-prepass", "true")
            }, {
                debug: "true" === this._getAttr("debug", "false"),
                ground: "baked" === this._getAttr("ground", "baked"),
                bloom: "true" === this._getAttr("bloom", "true"),
                depthTonemap: !0
            }), this._initialized = !0, this.dispatchEvent(new Event("initialized")))
        }
        connectedCallback() {
            console.log("WebGiViewerElement added to page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = !0)
        }
        disconnectedCallback() {
            console.log("WebGiViewerElement removed from page."), this.viewer && (this.viewer.enabled = !1)
        }
        adoptedCallback() {
            console.log("WebGiViewerElement moved to new page."), this.viewer && (this.viewer.resize(), this.viewer.enabled = !0)
        }
        static get observedAttributes() {
            return ["src", "environment"]
        }
        attributeChangedCallback(e, t, n) {
            console.log("WebGiViewerElement attributes changed.", e, t, n), this.refreshAll()
        }
        clearModels() {}
        async refreshModelSource() {
            if (!this.viewer) return;
            const e = this._getAttr("src", "");
            if (e === this._state.src) return;
            if (this._refreshingModels) return;
            this._refreshingModels = !0;
            const t = [e],
                n = [],
                r = [];
            for (const e of t) !this._models[e] && e && (this._models[e] = this.viewer.getManager().importer.importPath(e, {
                autoScale: this._getAttr("auto-scale", "true"),
                autoCenter: this._getAttr("auto-center", "true"),
                processImported: !1
            }));
            for (const [e, i] of Object.entries(this._models)) t.includes(e) ? n.push(i) : r.push(i);
            await Promise.all([Promise.all(n).then((async e => Promise.all(e.map((async e => this.viewer.getManager().importer.processImported(e)))))).then((e => {
                for (const t of e)
                    for (const e of t) e && "model" === e.assetType && this.viewer.scene.addSceneObject(e)
            })), Promise.all(r).then((e => {
                for (const t of e)
                    for (const e of t) e && "model" === e.assetType && e.modelObject.removeFromParent()
            }))]), this._state.src = e, this._refreshingModels = !1
        }
        async refreshEnvironment() {
            if (!this.viewer) return;
            if (!this.hasAttribute("environment")) return void(this._state.environment = null);
            const e = this._getAttr("environment", "");
            if (e === this._state.src) return;
            if (this._refreshingEnvironment) return;
            this._refreshingEnvironment = !0;
            const t = this.viewer.scene.getEnvironment(),
                n = e ? await this.viewer.getManager().importer.importSinglePath(e) : void 0;
            n && "texture" !== n.assetType || await this.viewer.scene.setEnvironment(n), null == t || t.dispose(), this._state.environment = e, this._refreshingEnvironment = !1
        }
        _getAttr(e, t) {
            return this.hasAttribute(e) ? this.getAttribute(e) : t
        }
    }
    window && window.customElements && !window.customElements.get("webgi-viewer") && window.customElements.define("webgi-viewer", Fm);
    class Nm {
        constructor(e) {
            var t, n, r;
            this._basePath = null !== (t = null == e ? void 0 : e.basePath) && void 0 !== t ? t : "", this._assets = null !== (r = null === (n = null == e ? void 0 : e.assets) || void 0 === n ? void 0 : n.map((e => this._resolveAsset(e)))) && void 0 !== r ? r : []
        }
        get basePath() {
            return this._basePath
        }
        get assets() {
            return this._assets
        }
        find(e) {
            const t = this._assets.find(e);
            return null != t ? t : void 0
        }
        _resolveAsset(e) {
            return { ...e,
                path: gt([this._basePath, e.path])
            }
        }
    }
    class Um extends r {
        constructor(...e) {
            super(), this._assets = e
        }
        addAssetList(e) {
            this._assets.push(e)
        }
        removeAssetList(e) {
            const t = this._assets.indexOf(e);
            t >= 0 && this._assets.splice(t, 1)
        }
        async findAssetRegex(e) {
            for (const t of this._assets) {
                const n = t.find((t => {
                    var n, r;
                    return t && (e.test(t.path) || e.test(null !== (r = null === (n = t.file) || void 0 === n ? void 0 : n.name) && void 0 !== r ? r : ""))
                }));
                if (n) return n
            }
            console.warn("Asset not found:", e)
        }
        async findAsset(e) {
            return this.findAssetRegex(e.query)
        }
        async findAssetSimple(e, t = !1) {
            return this.findAssetRegex(new RegExp(e, t ? "i" : ""))
        }
    }
    var Bm = {},
        jm = function(e) {
            return URL.createObjectURL(new Blob([e], {
                type: "text/javascript"
            }))
        },
        zm = function(e) {
            return new Worker(e)
        };
    try {
        URL.revokeObjectURL(jm(""))
    } catch (Eu) {
        jm = function(e) {
            return "data:application/javascript;charset=UTF-8," + encodeURI(e)
        }, zm = function(e) {
            return new Worker(e, {
                type: "module"
            })
        }
    }
    var Vm = Uint8Array,
        Gm = Uint16Array,
        Hm = Uint32Array,
        Wm = new Vm([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
        Km = new Vm([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
        Xm = new Vm([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
        qm = function(e, t) {
            for (var n = new Gm(31), r = 0; r < 31; ++r) n[r] = t += 1 << e[r - 1];
            var i = new Hm(n[30]);
            for (r = 1; r < 30; ++r)
                for (var s = n[r]; s < n[r + 1]; ++s) i[s] = s - n[r] << 5 | r;
            return [n, i]
        },
        Ym = qm(Wm, 2),
        Zm = Ym[0],
        Jm = Ym[1];
    Zm[28] = 258, Jm[258] = 28;
    for (var $m = qm(Km, 0), Qm = $m[0], eg = $m[1], tg = new Gm(32768), ng = 0; ng < 32768; ++ng) {
        var rg = (43690 & ng) >>> 1 | (21845 & ng) << 1;
        rg = (61680 & (rg = (52428 & rg) >>> 2 | (13107 & rg) << 2)) >>> 4 | (3855 & rg) << 4, tg[ng] = ((65280 & rg) >>> 8 | (255 & rg) << 8) >>> 1
    }
    var ig = function(e, t, n) {
            for (var r = e.length, i = 0, s = new Gm(t); i < r; ++i) ++s[e[i] - 1];
            var o, a = new Gm(t);
            for (i = 0; i < t; ++i) a[i] = a[i - 1] + s[i - 1] << 1;
            if (n) {
                o = new Gm(1 << t);
                var l = 15 - t;
                for (i = 0; i < r; ++i)
                    if (e[i])
                        for (var c = i << 4 | e[i], u = t - e[i], p = a[e[i] - 1]++ << u, h = p | (1 << u) - 1; p <= h; ++p) o[tg[p] >>> l] = c
            } else
                for (o = new Gm(r), i = 0; i < r; ++i) e[i] && (o[i] = tg[a[e[i] - 1]++] >>> 15 - e[i]);
            return o
        },
        sg = new Vm(288);
    for (ng = 0; ng < 144; ++ng) sg[ng] = 8;
    for (ng = 144; ng < 256; ++ng) sg[ng] = 9;
    for (ng = 256; ng < 280; ++ng) sg[ng] = 7;
    for (ng = 280; ng < 288; ++ng) sg[ng] = 8;
    var og = new Vm(32);
    for (ng = 0; ng < 32; ++ng) og[ng] = 5;
    var ag = ig(sg, 9, 0),
        lg = ig(sg, 9, 1),
        cg = ig(og, 5, 0),
        ug = ig(og, 5, 1),
        pg = function(e) {
            for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);
            return t
        },
        hg = function(e, t, n) {
            var r = t / 8 | 0;
            return (e[r] | e[r + 1] << 8) >> (7 & t) & n
        },
        dg = function(e, t) {
            var n = t / 8 | 0;
            return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t)
        },
        fg = function(e) {
            return (e / 8 | 0) + (7 & e && 1)
        },
        _g = function(e, t, n) {
            (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length);
            var r = new(e instanceof Gm ? Gm : e instanceof Hm ? Hm : Vm)(n - t);
            return r.set(e.subarray(t, n)), r
        },
        mg = function(e, t, n) {
            var r = e.length;
            if (!r || n && !n.l && r < 5) return t || new Vm(0);
            var i = !t || n,
                s = !n || n.i;
            n || (n = {}), t || (t = new Vm(3 * r));
            var o = function(e) {
                    var n = t.length;
                    if (e > n) {
                        var r = new Vm(Math.max(2 * n, e));
                        r.set(t), t = r
                    }
                },
                a = n.f || 0,
                l = n.p || 0,
                c = n.b || 0,
                u = n.l,
                p = n.d,
                h = n.m,
                d = n.n,
                f = 8 * r;
            do {
                if (!u) {
                    n.f = a = hg(e, l, 1);
                    var _ = hg(e, l + 1, 3);
                    if (l += 3, !_) {
                        var m = e[(A = fg(l) + 4) - 4] | e[A - 3] << 8,
                            g = A + m;
                        if (g > r) {
                            if (s) throw "unexpected EOF";
                            break
                        }
                        i && o(c + m), t.set(e.subarray(A, g), c), n.b = c += m, n.p = l = 8 * g;
                        continue
                    }
                    if (1 == _) u = lg, p = ug, h = 9, d = 5;
                    else {
                        if (2 != _) throw "invalid block type";
                        var v = hg(e, l, 31) + 257,
                            b = hg(e, l + 10, 15) + 4,
                            x = v + hg(e, l + 5, 31) + 1;
                        l += 14;
                        for (var y = new Vm(x), w = new Vm(19), S = 0; S < b; ++S) w[Xm[S]] = hg(e, l + 3 * S, 7);
                        l += 3 * b;
                        var M = pg(w),
                            T = (1 << M) - 1,
                            E = ig(w, M, 1);
                        for (S = 0; S < x;) {
                            var A, C = E[hg(e, l, T)];
                            if (l += 15 & C, (A = C >>> 4) < 16) y[S++] = A;
                            else {
                                var R = 0,
                                    k = 0;
                                for (16 == A ? (k = 3 + hg(e, l, 3), l += 2, R = y[S - 1]) : 17 == A ? (k = 3 + hg(e, l, 7), l += 3) : 18 == A && (k = 11 + hg(e, l, 127), l += 7); k--;) y[S++] = R
                            }
                        }
                        var P = y.subarray(0, v),
                            D = y.subarray(v);
                        h = pg(P), d = pg(D), u = ig(P, h, 1), p = ig(D, d, 1)
                    }
                    if (l > f) {
                        if (s) throw "unexpected EOF";
                        break
                    }
                }
                i && o(c + 131072);
                for (var O = (1 << h) - 1, L = (1 << d) - 1, I = l;; I = l) {
                    var F = (R = u[dg(e, l) & O]) >>> 4;
                    if ((l += 15 & R) > f) {
                        if (s) throw "unexpected EOF";
                        break
                    }
                    if (!R) throw "invalid length/literal";
                    if (F < 256) t[c++] = F;
                    else {
                        if (256 == F) {
                            I = l, u = null;
                            break
                        }
                        var N = F - 254;
                        if (F > 264) {
                            var U = Wm[S = F - 257];
                            N = hg(e, l, (1 << U) - 1) + Zm[S], l += U
                        }
                        var B = p[dg(e, l) & L],
                            j = B >>> 4;
                        if (!B) throw "invalid distance";
                        if (l += 15 & B, D = Qm[j], j > 3 && (U = Km[j], D += dg(e, l) & (1 << U) - 1, l += U), l > f) {
                            if (s) throw "unexpected EOF";
                            break
                        }
                        i && o(c + 131072);
                        for (var z = c + N; c < z; c += 4) t[c] = t[c - D], t[c + 1] = t[c + 1 - D], t[c + 2] = t[c + 2 - D], t[c + 3] = t[c + 3 - D];
                        c = z
                    }
                }
                n.l = u, n.p = I, n.b = c, u && (a = 1, n.m = h, n.d = p, n.n = d)
            } while (!a);
            return c == t.length ? t : _g(t, 0, c)
        },
        gg = function(e, t, n) {
            n <<= 7 & t;
            var r = t / 8 | 0;
            e[r] |= n, e[r + 1] |= n >>> 8
        },
        vg = function(e, t, n) {
            n <<= 7 & t;
            var r = t / 8 | 0;
            e[r] |= n, e[r + 1] |= n >>> 8, e[r + 2] |= n >>> 16
        },
        bg = function(e, t) {
            for (var n = [], r = 0; r < e.length; ++r) e[r] && n.push({
                s: r,
                f: e[r]
            });
            var i = n.length,
                s = n.slice();
            if (!i) return [Eg, 0];
            if (1 == i) {
                var o = new Vm(n[0].s + 1);
                return o[n[0].s] = 1, [o, 1]
            }
            n.sort((function(e, t) {
                return e.f - t.f
            })), n.push({
                s: -1,
                f: 25001
            });
            var a = n[0],
                l = n[1],
                c = 0,
                u = 1,
                p = 2;
            for (n[0] = {
                    s: -1,
                    f: a.f + l.f,
                    l: a,
                    r: l
                }; u != i - 1;) a = n[n[c].f < n[p].f ? c++ : p++], l = n[c != u && n[c].f < n[p].f ? c++ : p++], n[u++] = {
                s: -1,
                f: a.f + l.f,
                l: a,
                r: l
            };
            var h = s[0].s;
            for (r = 1; r < i; ++r) s[r].s > h && (h = s[r].s);
            var d = new Gm(h + 1),
                f = xg(n[u - 1], d, 0);
            if (f > t) {
                r = 0;
                var _ = 0,
                    m = f - t,
                    g = 1 << m;
                for (s.sort((function(e, t) {
                        return d[t.s] - d[e.s] || e.f - t.f
                    })); r < i; ++r) {
                    var v = s[r].s;
                    if (!(d[v] > t)) break;
                    _ += g - (1 << f - d[v]), d[v] = t
                }
                for (_ >>>= m; _ > 0;) {
                    var b = s[r].s;
                    d[b] < t ? _ -= 1 << t - d[b]++ - 1 : ++r
                }
                for (; r >= 0 && _; --r) {
                    var x = s[r].s;
                    d[x] == t && (--d[x], ++_)
                }
                f = t
            }
            return [new Vm(d), f]
        },
        xg = function(e, t, n) {
            return -1 == e.s ? Math.max(xg(e.l, t, n + 1), xg(e.r, t, n + 1)) : t[e.s] = n
        },
        yg = function(e) {
            for (var t = e.length; t && !e[--t];);
            for (var n = new Gm(++t), r = 0, i = e[0], s = 1, o = function(e) {
                    n[r++] = e
                }, a = 1; a <= t; ++a)
                if (e[a] == i && a != t) ++s;
                else {
                    if (!i && s > 2) {
                        for (; s > 138; s -= 138) o(32754);
                        s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0)
                    } else if (s > 3) {
                        for (o(i), --s; s > 6; s -= 6) o(8304);
                        s > 2 && (o(s - 3 << 5 | 8208), s = 0)
                    }
                    for (; s--;) o(i);
                    s = 1, i = e[a]
                }
            return [n.subarray(0, r), t]
        },
        wg = function(e, t) {
            for (var n = 0, r = 0; r < t.length; ++r) n += e[r] * t[r];
            return n
        },
        Sg = function(e, t, n) {
            var r = n.length,
                i = fg(t + 2);
            e[i] = 255 & r, e[i + 1] = r >>> 8, e[i + 2] = 255 ^ e[i], e[i + 3] = 255 ^ e[i + 1];
            for (var s = 0; s < r; ++s) e[i + s + 4] = n[s];
            return 8 * (i + 4 + r)
        },
        Mg = function(e, t, n, r, i, s, o, a, l, c, u) {
            gg(t, u++, n), ++i[256];
            for (var p = bg(i, 15), h = p[0], d = p[1], f = bg(s, 15), _ = f[0], m = f[1], g = yg(h), v = g[0], b = g[1], x = yg(_), y = x[0], w = x[1], S = new Gm(19), M = 0; M < v.length; ++M) S[31 & v[M]]++;
            for (M = 0; M < y.length; ++M) S[31 & y[M]]++;
            for (var T = bg(S, 7), E = T[0], A = T[1], C = 19; C > 4 && !E[Xm[C - 1]]; --C);
            var R, k, P, D, O = c + 5 << 3,
                L = wg(i, sg) + wg(s, og) + o,
                I = wg(i, h) + wg(s, _) + o + 14 + 3 * C + wg(S, E) + (2 * S[16] + 3 * S[17] + 7 * S[18]);
            if (O <= L && O <= I) return Sg(t, u, e.subarray(l, l + c));
            if (gg(t, u, 1 + (I < L)), u += 2, I < L) {
                R = ig(h, d, 0), k = h, P = ig(_, m, 0), D = _;
                var F = ig(E, A, 0);
                for (gg(t, u, b - 257), gg(t, u + 5, w - 1), gg(t, u + 10, C - 4), u += 14, M = 0; M < C; ++M) gg(t, u + 3 * M, E[Xm[M]]);
                u += 3 * C;
                for (var N = [v, y], U = 0; U < 2; ++U) {
                    var B = N[U];
                    for (M = 0; M < B.length; ++M) {
                        var j = 31 & B[M];
                        gg(t, u, F[j]), u += E[j], j > 15 && (gg(t, u, B[M] >>> 5 & 127), u += B[M] >>> 12)
                    }
                }
            } else R = ag, k = sg, P = cg, D = og;
            for (M = 0; M < a; ++M)
                if (r[M] > 255) {
                    j = r[M] >>> 18 & 31, vg(t, u, R[j + 257]), u += k[j + 257], j > 7 && (gg(t, u, r[M] >>> 23 & 31), u += Wm[j]);
                    var z = 31 & r[M];
                    vg(t, u, P[z]), u += D[z], z > 3 && (vg(t, u, r[M] >>> 5 & 8191), u += Km[z])
                } else vg(t, u, R[r[M]]), u += k[r[M]];
            return vg(t, u, R[256]), u + k[256]
        },
        Tg = new Hm([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
        Eg = new Vm(0),
        Ag = function(e, t, n, r, i, s) {
            var o = e.length,
                a = new Vm(r + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
                l = a.subarray(r, a.length - i),
                c = 0;
            if (!t || o < 8)
                for (var u = 0; u <= o; u += 65535) {
                    var p = u + 65535;
                    p < o ? c = Sg(l, c, e.subarray(u, p)) : (l[u] = s, c = Sg(l, c, e.subarray(u, o)))
                } else {
                    for (var h = Tg[t - 1], d = h >>> 13, f = 8191 & h, _ = (1 << n) - 1, m = new Gm(32768), g = new Gm(_ + 1), v = Math.ceil(n / 3), b = 2 * v, x = function(t) {
                            return (e[t] ^ e[t + 1] << v ^ e[t + 2] << b) & _
                        }, y = new Hm(25e3), w = new Gm(288), S = new Gm(32), M = 0, T = 0, E = (u = 0, 0), A = 0, C = 0; u < o; ++u) {
                        var R = x(u),
                            k = 32767 & u,
                            P = g[R];
                        if (m[k] = P, g[R] = k, A <= u) {
                            var D = o - u;
                            if ((M > 7e3 || E > 24576) && D > 423) {
                                c = Mg(e, l, 0, y, w, S, T, E, C, u - C, c), E = M = T = 0, C = u;
                                for (var O = 0; O < 286; ++O) w[O] = 0;
                                for (O = 0; O < 30; ++O) S[O] = 0
                            }
                            var L = 2,
                                I = 0,
                                F = f,
                                N = k - P & 32767;
                            if (D > 2 && R == x(u - N))
                                for (var U = Math.min(d, D) - 1, B = Math.min(32767, u), j = Math.min(258, D); N <= B && --F && k != P;) {
                                    if (e[u + L] == e[u + L - N]) {
                                        for (var z = 0; z < j && e[u + z] == e[u + z - N]; ++z);
                                        if (z > L) {
                                            if (L = z, I = N, z > U) break;
                                            var V = Math.min(N, z - 2),
                                                G = 0;
                                            for (O = 0; O < V; ++O) {
                                                var H = u - N + O + 32768 & 32767,
                                                    W = H - m[H] + 32768 & 32767;
                                                W > G && (G = W, P = H)
                                            }
                                        }
                                    }
                                    N += (k = P) - (P = m[k]) + 32768 & 32767
                                }
                            if (I) {
                                y[E++] = 268435456 | Jm[L] << 18 | eg[I];
                                var K = 31 & Jm[L],
                                    X = 31 & eg[I];
                                T += Wm[K] + Km[X], ++w[257 + K], ++S[X], A = u + L, ++M
                            } else y[E++] = e[u], ++w[e[u]]
                        }
                    }
                    c = Mg(e, l, s, y, w, S, T, E, C, u - C, c), !s && 7 & c && (c = Sg(l, c + 1, Eg))
                }
            return _g(a, 0, r + fg(c) + i)
        },
        Cg = function() {
            for (var e = new Hm(256), t = 0; t < 256; ++t) {
                for (var n = t, r = 9; --r;) n = (1 & n && 3988292384) ^ n >>> 1;
                e[t] = n
            }
            return e
        }(),
        Rg = function() {
            var e = -1;
            return {
                p: function(t) {
                    for (var n = e, r = 0; r < t.length; ++r) n = Cg[255 & n ^ t[r]] ^ n >>> 8;
                    e = n
                },
                d: function() {
                    return ~e
                }
            }
        },
        kg = function() {
            var e = 1,
                t = 0;
            return {
                p: function(n) {
                    for (var r = e, i = t, s = n.length, o = 0; o != s;) {
                        for (var a = Math.min(o + 2655, s); o < a; ++o) i += r += n[o];
                        r = (65535 & r) + 15 * (r >> 16), i = (65535 & i) + 15 * (i >> 16)
                    }
                    e = r, t = i
                },
                d: function() {
                    return (255 & (e %= 65521)) << 24 | e >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8
                }
            }
        },
        Pg = function(e, t, n, r, i) {
            return Ag(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, n, r, !i)
        },
        Dg = function(e, t) {
            var n = {};
            for (var r in e) n[r] = e[r];
            for (var r in t) n[r] = t[r];
            return n
        },
        Og = function(e, t, n) {
            for (var r = e(), i = e.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < r.length; ++o) {
                var a = r[o],
                    l = s[o];
                if ("function" == typeof a) {
                    t += ";" + l + "=";
                    var c = a.toString();
                    if (a.prototype)
                        if (-1 != c.indexOf("[native code]")) {
                            var u = c.indexOf(" ", 8) + 1;
                            t += c.slice(u, c.indexOf("(", u))
                        } else
                            for (var p in t += c, a.prototype) t += ";" + l + ".prototype." + p + "=" + a.prototype[p].toString();
                    else t += c
                } else n[l] = a
            }
            return [t, n]
        },
        Lg = [],
        Ig = function(e, t, n, r) {
            var i;
            if (!Lg[n]) {
                for (var s = "", o = {}, a = e.length - 1, l = 0; l < a; ++l) s = (i = Og(e[l], s, o))[0], o = i[1];
                Lg[n] = Og(e[a], s, o)
            }
            var c = Dg({}, Lg[n][1]);
            return function(e, t, n, r, i) {
                var s = zm(Bm[t] || (Bm[t] = jm(e)));
                return s.onerror = function(e) {
                    return i(e.error, null)
                }, s.onmessage = function(e) {
                    return i(null, e.data)
                }, s.postMessage(n, r), s
            }(Lg[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", n, c, function(e) {
                var t = [];
                for (var n in e)(e[n] instanceof Vm || e[n] instanceof Gm || e[n] instanceof Hm) && t.push((e[n] = new e[n].constructor(e[n])).buffer);
                return t
            }(c), r)
        },
        Fg = function() {
            return [Vm, Gm, Hm, Wm, Km, Xm, Zm, Qm, lg, ug, tg, ig, pg, hg, dg, fg, _g, mg, pv, Vg, Gg]
        },
        Ng = function() {
            return [Vm, Gm, Hm, Wm, Km, Xm, Jm, eg, ag, sg, cg, og, tg, Tg, Eg, ig, gg, vg, bg, xg, yg, wg, Sg, Mg, fg, _g, Ag, Pg, av, Vg]
        },
        Ug = function() {
            return [Jg, ev, Zg, Rg, Cg]
        },
        Bg = function() {
            return [$g, Qg]
        },
        jg = function() {
            return [tv, Zg, kg]
        },
        zg = function() {
            return [nv]
        },
        Vg = function(e) {
            return postMessage(e, [e.buffer])
        },
        Gg = function(e) {
            return e && e.size && new Vm(e.size)
        },
        Hg = function(e, t, n, r, i, s) {
            var o = Ig(n, r, i, (function(e, t) {
                o.terminate(), s(e, t)
            }));
            return o.postMessage([e, t], t.consume ? [e.buffer] : []),
                function() {
                    o.terminate()
                }
        },
        Wg = function(e) {
            return e.ondata = function(e, t) {
                    return postMessage([e, t], [e.buffer])
                },
                function(t) {
                    return e.push(t.data[0], t.data[1])
                }
        },
        Kg = function(e, t, n, r, i) {
            var s, o = Ig(e, r, i, (function(e, n) {
                e ? (o.terminate(), t.ondata.call(t, e)) : (n[1] && o.terminate(), t.ondata.call(t, e, n[0], n[1]))
            }));
            o.postMessage(n), t.push = function(e, n) {
                if (s) throw "stream finished";
                if (!t.ondata) throw "no stream handler";
                o.postMessage([e, s = n], [e.buffer])
            }, t.terminate = function() {
                o.terminate()
            }
        },
        Xg = function(e, t) {
            return e[t] | e[t + 1] << 8
        },
        qg = function(e, t) {
            return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0
        },
        Yg = function(e, t) {
            return qg(e, t) + 4294967296 * qg(e, t + 4)
        },
        Zg = function(e, t, n) {
            for (; n; ++t) e[t] = n, n >>>= 8
        },
        Jg = function(e, t) {
            var n = t.filename;
            if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && Zg(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), n) {
                e[3] = 8;
                for (var r = 0; r <= n.length; ++r) e[r + 10] = n.charCodeAt(r)
            }
        },
        $g = function(e) {
            if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data";
            var t = e[3],
                n = 10;
            4 & t && (n += e[10] | 2 + (e[11] << 8));
            for (var r = (t >> 3 & 1) + (t >> 4 & 1); r > 0; r -= !e[n++]);
            return n + (2 & t)
        },
        Qg = function(e) {
            var t = e.length;
            return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0
        },
        ev = function(e) {
            return 10 + (e.filename && e.filename.length + 1 || 0)
        },
        tv = function(e, t) {
            var n = t.level,
                r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2;
            e[0] = 120, e[1] = r << 6 | (r ? 32 - 2 * r : 1)
        },
        nv = function(e) {
            if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data";
            if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported"
        };

    function rv(e, t) {
        return t || "function" != typeof e || (t = e, e = {}), this.ondata = t, e
    }
    var iv = function() {
            function e(e, t) {
                t || "function" != typeof e || (t = e, e = {}), this.ondata = t, this.o = e || {}
            }
            return e.prototype.p = function(e, t) {
                this.ondata(Pg(e, this.o, 0, 0, !t), t)
            }, e.prototype.push = function(e, t) {
                if (this.d) throw "stream finished";
                if (!this.ondata) throw "no stream handler";
                this.d = t, this.p(e, t || !1)
            }, e
        }(),
        sv = function() {
            return function(e, t) {
                Kg([Ng, function() {
                    return [Wg, iv]
                }], this, rv.call(this, e, t), (function(e) {
                    var t = new iv(e.data);
                    onmessage = Wg(t)
                }), 6)
            }
        }();

    function ov(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return Hg(e, t, [Ng], (function(e) {
            return Vg(av(e.data[0], e.data[1]))
        }), 0, n)
    }

    function av(e, t) {
        return Pg(e, t || {}, 0, 0)
    }
    var lv = function() {
            function e(e) {
                this.s = {}, this.p = new Vm(0), this.ondata = e
            }
            return e.prototype.e = function(e) {
                if (this.d) throw "stream finished";
                if (!this.ondata) throw "no stream handler";
                var t = this.p.length,
                    n = new Vm(t + e.length);
                n.set(this.p), n.set(e, t), this.p = n
            }, e.prototype.c = function(e) {
                this.d = this.s.i = e || !1;
                var t = this.s.b,
                    n = mg(this.p, this.o, this.s);
                this.ondata(_g(n, t, this.s.b), this.d), this.o = _g(n, this.s.b - 32768), this.s.b = this.o.length, this.p = _g(this.p, this.s.p / 8 | 0), this.s.p &= 7
            }, e.prototype.push = function(e, t) {
                this.e(e), this.c(t)
            }, e
        }(),
        cv = function() {
            return function(e) {
                this.ondata = e, Kg([Fg, function() {
                    return [Wg, lv]
                }], this, 0, (function() {
                    var e = new lv;
                    onmessage = Wg(e)
                }), 7)
            }
        }();

    function uv(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return Hg(e, t, [Fg], (function(e) {
            return Vg(pv(e.data[0], Gg(e.data[1])))
        }), 1, n)
    }

    function pv(e, t) {
        return mg(e, t)
    }
    var hv = function() {
            function e(e, t) {
                this.c = Rg(), this.l = 0, this.v = 1, iv.call(this, e, t)
            }
            return e.prototype.push = function(e, t) {
                iv.prototype.push.call(this, e, t)
            }, e.prototype.p = function(e, t) {
                this.c.p(e), this.l += e.length;
                var n = Pg(e, this.o, this.v && ev(this.o), t && 8, !t);
                this.v && (Jg(n, this.o), this.v = 0), t && (Zg(n, n.length - 8, this.c.d()), Zg(n, n.length - 4, this.l)), this.ondata(n, t)
            }, e
        }(),
        dv = function() {
            return function(e, t) {
                Kg([Ng, Ug, function() {
                    return [Wg, iv, hv]
                }], this, rv.call(this, e, t), (function(e) {
                    var t = new hv(e.data);
                    onmessage = Wg(t)
                }), 8)
            }
        }();

    function fv(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return Hg(e, t, [Ng, Ug, function() {
            return [_v]
        }], (function(e) {
            return Vg(_v(e.data[0], e.data[1]))
        }), 2, n)
    }

    function _v(e, t) {
        t || (t = {});
        var n = Rg(),
            r = e.length;
        n.p(e);
        var i = Pg(e, t, ev(t), 8),
            s = i.length;
        return Jg(i, t), Zg(i, s - 8, n.d()), Zg(i, s - 4, r), i
    }
    var mv = function() {
            function e(e) {
                this.v = 1, lv.call(this, e)
            }
            return e.prototype.push = function(e, t) {
                if (lv.prototype.e.call(this, e), this.v) {
                    var n = this.p.length > 3 ? $g(this.p) : 4;
                    if (n >= this.p.length && !t) return;
                    this.p = this.p.subarray(n), this.v = 0
                }
                if (t) {
                    if (this.p.length < 8) throw "invalid gzip stream";
                    this.p = this.p.subarray(0, -8)
                }
                lv.prototype.c.call(this, t)
            }, e
        }(),
        gv = function() {
            return function(e) {
                this.ondata = e, Kg([Fg, Bg, function() {
                    return [Wg, lv, mv]
                }], this, 0, (function() {
                    var e = new mv;
                    onmessage = Wg(e)
                }), 9)
            }
        }();

    function vv(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return Hg(e, t, [Fg, Bg, function() {
            return [bv]
        }], (function(e) {
            return Vg(bv(e.data[0]))
        }), 3, n)
    }

    function bv(e, t) {
        return mg(e.subarray($g(e), -8), t || new Vm(Qg(e)))
    }
    var xv = function() {
            function e(e, t) {
                this.c = kg(), this.v = 1, iv.call(this, e, t)
            }
            return e.prototype.push = function(e, t) {
                iv.prototype.push.call(this, e, t)
            }, e.prototype.p = function(e, t) {
                this.c.p(e);
                var n = Pg(e, this.o, this.v && 2, t && 4, !t);
                this.v && (tv(n, this.o), this.v = 0), t && Zg(n, n.length - 4, this.c.d()), this.ondata(n, t)
            }, e
        }(),
        yv = function() {
            return function(e, t) {
                Kg([Ng, jg, function() {
                    return [Wg, iv, xv]
                }], this, rv.call(this, e, t), (function(e) {
                    var t = new xv(e.data);
                    onmessage = Wg(t)
                }), 10)
            }
        }();

    function wv(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return Hg(e, t, [Ng, jg, function() {
            return [Sv]
        }], (function(e) {
            return Vg(Sv(e.data[0], e.data[1]))
        }), 4, n)
    }

    function Sv(e, t) {
        t || (t = {});
        var n = kg();
        n.p(e);
        var r = Pg(e, t, 2, 4);
        return tv(r, t), Zg(r, r.length - 4, n.d()), r
    }
    var Mv = function() {
            function e(e) {
                this.v = 1, lv.call(this, e)
            }
            return e.prototype.push = function(e, t) {
                if (lv.prototype.e.call(this, e), this.v) {
                    if (this.p.length < 2 && !t) return;
                    this.p = this.p.subarray(2), this.v = 0
                }
                if (t) {
                    if (this.p.length < 4) throw "invalid zlib stream";
                    this.p = this.p.subarray(0, -4)
                }
                lv.prototype.c.call(this, t)
            }, e
        }(),
        Tv = function() {
            return function(e) {
                this.ondata = e, Kg([Fg, zg, function() {
                    return [Wg, lv, Mv]
                }], this, 0, (function() {
                    var e = new Mv;
                    onmessage = Wg(e)
                }), 11)
            }
        }();

    function Ev(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return Hg(e, t, [Fg, zg, function() {
            return [Av]
        }], (function(e) {
            return Vg(Av(e.data[0], Gg(e.data[1])))
        }), 5, n)
    }

    function Av(e, t) {
        return mg((nv(e), e.subarray(2, -4)), t)
    }
    var Cv = function() {
            function e(e) {
                this.G = mv, this.I = lv, this.Z = Mv, this.ondata = e
            }
            return e.prototype.push = function(e, t) {
                if (!this.ondata) throw "no stream handler";
                if (this.s) this.s.push(e, t);
                else {
                    if (this.p && this.p.length) {
                        var n = new Vm(this.p.length + e.length);
                        n.set(this.p), n.set(e, this.p.length)
                    } else this.p = e;
                    if (this.p.length > 2) {
                        var r = this,
                            i = function() {
                                r.ondata.apply(r, arguments)
                            };
                        this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i), this.s.push(this.p, t), this.p = null
                    }
                }
            }, e
        }(),
        Rv = function() {
            function e(e) {
                this.G = gv, this.I = cv, this.Z = Tv, this.ondata = e
            }
            return e.prototype.push = function(e, t) {
                Cv.prototype.push.call(this, e, t)
            }, e
        }();

    function kv(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        return 31 == e[0] && 139 == e[1] && 8 == e[2] ? vv(e, t, n) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? uv(e, t, n) : Ev(e, t, n)
    }

    function Pv(e, t) {
        return 31 == e[0] && 139 == e[1] && 8 == e[2] ? bv(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? pv(e, t) : Av(e, t)
    }
    var Dv = function(e, t, n, r) {
            for (var i in e) {
                var s = e[i],
                    o = t + i;
                s instanceof Vm ? n[o] = [s, r] : Array.isArray(s) ? n[o] = [s[0], Dg(r, s[1])] : Dv(s, o + "/", n, r)
            }
        },
        Ov = "undefined" != typeof TextEncoder && new TextEncoder,
        Lv = "undefined" != typeof TextDecoder && new TextDecoder,
        Iv = 0;
    try {
        Lv.decode(Eg, {
            stream: !0
        }), Iv = 1
    } catch (Eu) {}
    var Fv = function(e) {
            for (var t = "", n = 0;;) {
                var r = e[n++],
                    i = (r > 127) + (r > 223) + (r > 239);
                if (n + i > e.length) return [t, _g(e, n - 1)];
                i ? 3 == i ? (r = ((15 & r) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536, t += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t += 1 & i ? String.fromCharCode((31 & r) << 6 | 63 & e[n++]) : String.fromCharCode((15 & r) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) : t += String.fromCharCode(r)
            }
        },
        Nv = function() {
            function e(e) {
                this.ondata = e, Iv ? this.t = new TextDecoder : this.p = Eg
            }
            return e.prototype.push = function(e, t) {
                if (!this.ondata) throw "no callback";
                if (t = !!t, this.t) {
                    if (this.ondata(this.t.decode(e, {
                            stream: !0
                        }), t), t) {
                        if (this.t.decode().length) throw "invalid utf-8 data";
                        this.t = null
                    }
                } else {
                    if (!this.p) throw "stream finished";
                    var n = new Vm(this.p.length + e.length);
                    n.set(this.p), n.set(e, this.p.length);
                    var r = Fv(n),
                        i = r[0],
                        s = r[1];
                    if (t) {
                        if (s.length) throw "invalid utf-8 data";
                        this.p = null
                    } else this.p = s;
                    this.ondata(i, t)
                }
            }, e
        }(),
        Uv = function() {
            function e(e) {
                this.ondata = e
            }
            return e.prototype.push = function(e, t) {
                if (!this.ondata) throw "no callback";
                if (this.d) throw "stream finished";
                this.ondata(Bv(e), this.d = t || !1)
            }, e
        }();

    function Bv(e, t) {
        if (t) {
            for (var n = new Vm(e.length), r = 0; r < e.length; ++r) n[r] = e.charCodeAt(r);
            return n
        }
        if (Ov) return Ov.encode(e);
        var i = e.length,
            s = new Vm(e.length + (e.length >> 1)),
            o = 0,
            a = function(e) {
                s[o++] = e
            };
        for (r = 0; r < i; ++r) {
            if (o + 5 > s.length) {
                var l = new Vm(o + 8 + (i - r << 1));
                l.set(s), s = l
            }
            var c = e.charCodeAt(r);
            c < 128 || t ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++r)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c))
        }
        return _g(s, 0, o)
    }

    function jv(e, t) {
        if (t) {
            for (var n = "", r = 0; r < e.length; r += 16384) n += String.fromCharCode.apply(null, e.subarray(r, r + 16384));
            return n
        }
        if (Lv) return Lv.decode(e);
        var i = Fv(e),
            s = i[0];
        if (i[1].length) throw "invalid utf-8 data";
        return s
    }
    var zv = function(e) {
            return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0
        },
        Vv = function(e, t) {
            return t + 30 + Xg(e, t + 26) + Xg(e, t + 28)
        },
        Gv = function(e, t, n) {
            var r = Xg(e, t + 28),
                i = jv(e.subarray(t + 46, t + 46 + r), !(2048 & Xg(e, t + 8))),
                s = t + 46 + r,
                o = qg(e, t + 20),
                a = n && 4294967295 == o ? Hv(e, s) : [o, qg(e, t + 24), qg(e, t + 42)],
                l = a[0],
                c = a[1],
                u = a[2];
            return [Xg(e, t + 10), l, c, i, s + Xg(e, t + 30) + Xg(e, t + 32), u]
        },
        Hv = function(e, t) {
            for (; 1 != Xg(e, t); t += 4 + Xg(e, t + 2));
            return [Yg(e, t + 12), Yg(e, t + 4), Yg(e, t + 20)]
        },
        Wv = function(e) {
            var t = 0;
            if (e)
                for (var n in e) {
                    var r = e[n].length;
                    if (r > 65535) throw "extra field too long";
                    t += r + 4
                }
            return t
        },
        Kv = function(e, t, n, r, i, s, o, a) {
            var l = r.length,
                c = n.extra,
                u = a && a.length,
                p = Wv(c);
            Zg(e, t, null != o ? 33639248 : 67324752), t += 4, null != o && (e[t++] = 20, e[t++] = n.os), e[t] = 20, t += 2, e[t++] = n.flag << 1 | (null == s && 8), e[t++] = i && 8, e[t++] = 255 & n.compression, e[t++] = n.compression >> 8;
            var h = new Date(null == n.mtime ? Date.now() : n.mtime),
                d = h.getFullYear() - 1980;
            if (d < 0 || d > 119) throw "date not in range 1980-2099";
            if (Zg(e, t, d << 25 | h.getMonth() + 1 << 21 | h.getDate() << 16 | h.getHours() << 11 | h.getMinutes() << 5 | h.getSeconds() >>> 1), t += 4, null != s && (Zg(e, t, n.crc), Zg(e, t + 4, s), Zg(e, t + 8, n.size)), Zg(e, t + 12, l), Zg(e, t + 14, p), t += 16, null != o && (Zg(e, t, u), Zg(e, t + 6, n.attrs), Zg(e, t + 10, o), t += 14), e.set(r, t), t += l, p)
                for (var f in c) {
                    var _ = c[f],
                        m = _.length;
                    Zg(e, t, +f), Zg(e, t + 2, m), e.set(_, t + 4), t += 4 + m
                }
            return u && (e.set(a, t), t += u), t
        },
        Xv = function(e, t, n, r, i) {
            Zg(e, t, 101010256), Zg(e, t + 8, n), Zg(e, t + 10, n), Zg(e, t + 12, r), Zg(e, t + 16, i)
        },
        qv = function() {
            function e(e) {
                this.filename = e, this.c = Rg(), this.size = 0, this.compression = 0
            }
            return e.prototype.process = function(e, t) {
                this.ondata(null, e, t)
            }, e.prototype.push = function(e, t) {
                if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
                this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1)
            }, e
        }(),
        Yv = function() {
            function e(e, t) {
                var n = this;
                t || (t = {}), qv.call(this, e), this.d = new iv(t, (function(e, t) {
                    n.ondata(null, e, t)
                })), this.compression = 8, this.flag = zv(t.level)
            }
            return e.prototype.process = function(e, t) {
                try {
                    this.d.push(e, t)
                } catch (e) {
                    this.ondata(e, null, t)
                }
            }, e.prototype.push = function(e, t) {
                qv.prototype.push.call(this, e, t)
            }, e
        }(),
        Zv = function() {
            function e(e, t) {
                var n = this;
                t || (t = {}), qv.call(this, e), this.d = new sv(t, (function(e, t, r) {
                    n.ondata(e, t, r)
                })), this.compression = 8, this.flag = zv(t.level), this.terminate = this.d.terminate
            }
            return e.prototype.process = function(e, t) {
                this.d.push(e, t)
            }, e.prototype.push = function(e, t) {
                qv.prototype.push.call(this, e, t)
            }, e
        }(),
        Jv = function() {
            function e(e) {
                this.ondata = e, this.u = [], this.d = 1
            }
            return e.prototype.add = function(e) {
                var t = this;
                if (2 & this.d) throw "stream finished";
                var n = Bv(e.filename),
                    r = n.length,
                    i = e.comment,
                    s = i && Bv(i),
                    o = r != e.filename.length || s && i.length != s.length,
                    a = r + Wv(e.extra) + 30;
                if (r > 65535) throw "filename too long";
                var l = new Vm(a);
                Kv(l, 0, e, n, o);
                var c = [l],
                    u = function() {
                        for (var e = 0, n = c; e < n.length; e++) {
                            var r = n[e];
                            t.ondata(null, r, !1)
                        }
                        c = []
                    },
                    p = this.d;
                this.d = 0;
                var h = this.u.length,
                    d = Dg(e, {
                        f: n,
                        u: o,
                        o: s,
                        t: function() {
                            e.terminate && e.terminate()
                        },
                        r: function() {
                            if (u(), p) {
                                var e = t.u[h + 1];
                                e ? e.r() : t.d = 1
                            }
                            p = 1
                        }
                    }),
                    f = 0;
                e.ondata = function(n, r, i) {
                    if (n) t.ondata(n, r, i), t.terminate();
                    else if (f += r.length, c.push(r), i) {
                        var s = new Vm(16);
                        Zg(s, 0, 134695760), Zg(s, 4, e.crc), Zg(s, 8, f), Zg(s, 12, e.size), c.push(s), d.c = f, d.b = a + f + 16, d.crc = e.crc, d.size = e.size, p && d.r(), p = 1
                    } else p && u()
                }, this.u.push(d)
            }, e.prototype.end = function() {
                var e = this;
                if (2 & this.d) {
                    if (1 & this.d) throw "stream finishing";
                    throw "stream finished"
                }
                this.d ? this.e() : this.u.push({
                    r: function() {
                        1 & e.d && (e.u.splice(-1, 1), e.e())
                    },
                    t: function() {}
                }), this.d = 3
            }, e.prototype.e = function() {
                for (var e = 0, t = 0, n = 0, r = 0, i = this.u; r < i.length; r++) n += 46 + (l = i[r]).f.length + Wv(l.extra) + (l.o ? l.o.length : 0);
                for (var s = new Vm(n + 22), o = 0, a = this.u; o < a.length; o++) {
                    var l = a[o];
                    Kv(s, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + Wv(l.extra) + (l.o ? l.o.length : 0), t += l.b
                }
                Xv(s, e, this.u.length, n, t), this.ondata(null, s, !0), this.d = 2
            }, e.prototype.terminate = function() {
                for (var e = 0, t = this.u; e < t.length; e++) t[e].t();
                this.d = 2
            }, e
        }();

    function $v(e, t, n) {
        if (n || (n = t, t = {}), "function" != typeof n) throw "no callback";
        var r = {};
        Dv(e, "", r, t);
        var i = Object.keys(r),
            s = i.length,
            o = 0,
            a = 0,
            l = s,
            c = new Array(s),
            u = [],
            p = function() {
                for (var e = 0; e < u.length; ++e) u[e]()
            },
            h = function() {
                var e = new Vm(a + 22),
                    t = o,
                    r = a - o;
                a = 0;
                for (var i = 0; i < l; ++i) {
                    var s = c[i];
                    try {
                        var u = s.c.length;
                        Kv(e, a, s, s.f, s.u, u);
                        var p = 30 + s.f.length + Wv(s.extra),
                            h = a + p;
                        e.set(s.c, h), Kv(e, o, s, s.f, s.u, u, a, s.m), o += 16 + p + (s.m ? s.m.length : 0), a = h + u
                    } catch (e) {
                        return n(e, null)
                    }
                }
                Xv(e, o, c.length, r, t), n(null, e)
            };
        s || h();
        for (var d = function(e) {
                var t = i[e],
                    l = r[t],
                    d = l[0],
                    f = l[1],
                    _ = Rg(),
                    m = d.length;
                _.p(d);
                var g = Bv(t),
                    v = g.length,
                    b = f.comment,
                    x = b && Bv(b),
                    y = x && x.length,
                    w = Wv(f.extra),
                    S = 0 == f.level ? 0 : 8,
                    M = function(r, i) {
                        if (r) p(), n(r, null);
                        else {
                            var l = i.length;
                            c[e] = Dg(f, {
                                size: m,
                                crc: _.d(),
                                c: i,
                                f: g,
                                m: x,
                                u: v != t.length || x && b.length != y,
                                compression: S
                            }), o += 30 + v + w + l, a += 76 + 2 * (v + w) + (y || 0) + l, --s || h()
                        }
                    };
                if (v > 65535 && M("filename too long", null), S)
                    if (m < 16e4) try {
                        M(null, av(d, f))
                    } catch (e) {
                        M(e, null)
                    } else u.push(ov(d, f, M));
                    else M(null, d)
            }, f = 0; f < l; ++f) d(f);
        return p
    }

    function Qv(e, t) {
        t || (t = {});
        var n = {},
            r = [];
        Dv(e, "", n, t);
        var i = 0,
            s = 0;
        for (var o in n) {
            var a = n[o],
                l = a[0],
                c = a[1],
                u = 0 == c.level ? 0 : 8,
                p = (S = Bv(o)).length,
                h = c.comment,
                d = h && Bv(h),
                f = d && d.length,
                _ = Wv(c.extra);
            if (p > 65535) throw "filename too long";
            var m = u ? av(l, c) : l,
                g = m.length,
                v = Rg();
            v.p(l), r.push(Dg(c, {
                size: l.length,
                crc: v.d(),
                c: m,
                f: S,
                m: d,
                u: p != o.length || d && h.length != f,
                o: i,
                compression: u
            })), i += 30 + p + _ + g, s += 76 + 2 * (p + _) + (f || 0) + g
        }
        for (var b = new Vm(s + 22), x = i, y = s - i, w = 0; w < r.length; ++w) {
            var S = r[w];
            Kv(b, S.o, S, S.f, S.u, S.c.length);
            var M = 30 + S.f.length + Wv(S.extra);
            b.set(S.c, S.o + M), Kv(b, i, S, S.f, S.u, S.c.length, S.o, S.m), i += 16 + M + (S.m ? S.m.length : 0)
        }
        return Xv(b, i, r.length, y, x), b
    }
    var eb = function() {
            function e() {}
            return e.prototype.push = function(e, t) {
                this.ondata(null, e, t)
            }, e.compression = 0, e
        }(),
        tb = function() {
            function e() {
                var e = this;
                this.i = new lv((function(t, n) {
                    e.ondata(null, t, n)
                }))
            }
            return e.prototype.push = function(e, t) {
                try {
                    this.i.push(e, t)
                } catch (n) {
                    this.ondata(n, e, t)
                }
            }, e.compression = 8, e
        }(),
        nb = function() {
            function e(e, t) {
                var n = this;
                t < 32e4 ? this.i = new lv((function(e, t) {
                    n.ondata(null, e, t)
                })) : (this.i = new cv((function(e, t, r) {
                    n.ondata(e, t, r)
                })), this.terminate = this.i.terminate)
            }
            return e.prototype.push = function(e, t) {
                this.i.terminate && (e = _g(e, 0)), this.i.push(e, t)
            }, e.compression = 8, e
        }(),
        rb = function() {
            function e(e) {
                this.onfile = e, this.k = [], this.o = {
                    0: eb
                }, this.p = Eg
            }
            return e.prototype.push = function(e, t) {
                var n = this;
                if (!this.onfile) throw "no callback";
                if (!this.p) throw "stream finished";
                if (this.c > 0) {
                    var r = Math.min(this.c, e.length),
                        i = e.subarray(0, r);
                    if (this.c -= r, this.d ? this.d.push(i, !this.c) : this.k[0].push(i), (e = e.subarray(r)).length) return this.push(e, t)
                } else {
                    var s = 0,
                        o = 0,
                        a = void 0,
                        l = void 0;
                    this.p.length ? e.length ? ((l = new Vm(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;
                    for (var c = l.length, u = this.c, p = u && this.d, h = function() {
                            var e, t = qg(l, o);
                            if (67324752 == t) {
                                s = 1, a = o, d.d = null, d.c = 0;
                                var r = Xg(l, o + 6),
                                    i = Xg(l, o + 8),
                                    p = 2048 & r,
                                    h = 8 & r,
                                    f = Xg(l, o + 26),
                                    _ = Xg(l, o + 28);
                                if (c > o + 30 + f + _) {
                                    var m = [];
                                    d.k.unshift(m), s = 2;
                                    var g, v = qg(l, o + 18),
                                        b = qg(l, o + 22),
                                        x = jv(l.subarray(o + 30, o += 30 + f), !p);
                                    4294967295 == v ? (e = h ? [-2] : Hv(l, o), v = e[0], b = e[1]) : h && (v = -1), o += _, d.c = v;
                                    var y = {
                                        name: x,
                                        compression: i,
                                        start: function() {
                                            if (!y.ondata) throw "no callback";
                                            if (v) {
                                                var e = n.o[i];
                                                if (!e) throw "unknown compression type " + i;
                                                (g = v < 0 ? new e(x) : new e(x, v, b)).ondata = function(e, t, n) {
                                                    y.ondata(e, t, n)
                                                };
                                                for (var t = 0, r = m; t < r.length; t++) {
                                                    var s = r[t];
                                                    g.push(s, !1)
                                                }
                                                n.k[0] == m && n.c ? n.d = g : g.push(Eg, !0)
                                            } else y.ondata(null, Eg, !0)
                                        },
                                        terminate: function() {
                                            g && g.terminate && g.terminate()
                                        }
                                    };
                                    v >= 0 && (y.size = v, y.originalSize = b), d.onfile(y)
                                }
                                return "break"
                            }
                            if (u) {
                                if (134695760 == t) return a = o += 12 + (-2 == u && 8), s = 3, d.c = 0, "break";
                                if (33639248 == t) return a = o -= 4, s = 3, d.c = 0, "break"
                            }
                        }, d = this; o < c - 4 && "break" !== h(); ++o);
                    if (this.p = Eg, u < 0) {
                        var f = s ? l.subarray(0, a - 12 - (-2 == u && 8) - (134695760 == qg(l, a - 16) && 4)) : l.subarray(0, o);
                        p ? p.push(f, !!s) : this.k[+(2 == s)].push(f)
                    }
                    if (2 & s) return this.push(l.subarray(o), t);
                    this.p = l.subarray(o)
                }
                if (t) {
                    if (this.c) throw "invalid zip file";
                    this.p = null
                }
            }, e.prototype.register = function(e) {
                this.o[e.compression] = e
            }, e
        }();

    function ib(e, t) {
        if ("function" != typeof t) throw "no callback";
        for (var n = [], r = function() {
                for (var e = 0; e < n.length; ++e) n[e]()
            }, i = {}, s = e.length - 22; 101010256 != qg(e, s); --s)
            if (!s || e.length - s > 65558) return void t("invalid zip file", null);
        var o = Xg(e, s + 8);
        o || t(null, {});
        var a = o,
            l = qg(e, s + 16),
            c = 4294967295 == l;
        if (c) {
            if (s = qg(e, s - 12), 101075792 != qg(e, s)) return void t("invalid zip file", null);
            a = o = qg(e, s + 32), l = qg(e, s + 48)
        }
        for (var u = function(s) {
                var a = Gv(e, l, c),
                    u = a[0],
                    p = a[1],
                    h = a[2],
                    d = a[3],
                    f = a[4],
                    _ = a[5],
                    m = Vv(e, _);
                l = f;
                var g = function(e, n) {
                    e ? (r(), t(e, null)) : (i[d] = n, --o || t(null, i))
                };
                if (u)
                    if (8 == u) {
                        var v = e.subarray(m, m + p);
                        if (p < 32e4) try {
                            g(null, pv(v, new Vm(h)))
                        } catch (e) {
                            g(e, null)
                        } else n.push(uv(v, {
                            size: h
                        }, g))
                    } else g("unknown compression type " + u, null);
                else g(null, _g(e, m, m + p))
            }, p = 0; p < a; ++p) u();
        return r
    }

    function sb(e) {
        for (var t = {}, n = e.length - 22; 101010256 != qg(e, n); --n)
            if (!n || e.length - n > 65558) throw "invalid zip file";
        var r = Xg(e, n + 8);
        if (!r) return {};
        var i = qg(e, n + 16),
            s = 4294967295 == i;
        if (s) {
            if (n = qg(e, n - 12), 101075792 != qg(e, n)) throw "invalid zip file";
            r = qg(e, n + 32), i = qg(e, n + 48)
        }
        for (var o = 0; o < r; ++o) {
            var a = Gv(e, i, s),
                l = a[0],
                c = a[1],
                u = a[2],
                p = a[3],
                h = a[4],
                d = a[5],
                f = Vv(e, d);
            if (i = h, l) {
                if (8 != l) throw "unknown compression type " + l;
                t[p] = pv(e.subarray(f, f + c), new Vm(u))
            } else t[p] = _g(e, f, f + c)
        }
        return t
    }
    class ob extends i.yxD {
        constructor(e) {
            super(e), this.type = i.cLu
        }
        parse(e) {
            const t = 65536,
                r = 14,
                s = 65537,
                o = Math.pow(2.7182818, 2.2),
                a = {
                    l: 0,
                    c: 0,
                    lc: 0
                };

            function l(e, t, n, r, i) {
                for (; n < e;) t = t << 8 | B(r, i), n += 8;
                n -= e, a.l = t >> n & (1 << e) - 1, a.c = t, a.lc = n
            }
            const c = new Array(59);

            function u(e) {
                return 63 & e
            }

            function p(e) {
                return e >> 6
            }
            const h = {
                c: 0,
                lc: 0
            };

            function d(e, t, n, r) {
                e = e << 8 | B(n, r), t += 8, h.c = e, h.lc = t
            }
            const f = {
                c: 0,
                lc: 0
            };

            function _(e, t, n, r, i, s, o, a, l) {
                if (e == t) {
                    r < 8 && (d(n, r, i, s), n = h.c, r = h.lc);
                    let e = n >> (r -= 8);
                    if (e = new Uint8Array([e])[0], a.value + e > l) return !1;
                    const t = o[a.value - 1];
                    for (; e-- > 0;) o[a.value++] = t
                } else {
                    if (!(a.value < l)) return !1;
                    o[a.value++] = e
                }
                f.c = n, f.lc = r
            }

            function m(e) {
                return 65535 & e
            }

            function g(e) {
                const t = m(e);
                return t > 32767 ? t - 65536 : t
            }
            const v = {
                a: 0,
                b: 0
            };

            function b(e, t) {
                const n = g(e),
                    r = g(t),
                    i = n + (1 & r) + (r >> 1),
                    s = i,
                    o = i - r;
                v.a = s, v.b = o
            }

            function x(e, t) {
                const n = m(e),
                    r = m(t),
                    i = n - (r >> 1) & 65535,
                    s = r + i - 32768 & 65535;
                v.a = s, v.b = i
            }

            function y(e, t, n, r, i, s, o) {
                const a = o < 16384,
                    l = n > i ? i : n;
                let c, u, p = 1;
                for (; p <= l;) p <<= 1;
                for (p >>= 1, c = p, p >>= 1; p >= 1;) {
                    u = 0;
                    const o = u + s * (i - c),
                        l = s * p,
                        h = s * c,
                        d = r * p,
                        f = r * c;
                    let _, m, g, y;
                    for (; u <= o; u += h) {
                        let i = u;
                        const s = u + r * (n - c);
                        for (; i <= s; i += f) {
                            const n = i + d,
                                r = i + l,
                                s = r + d;
                            a ? (b(e[i + t], e[r + t]), _ = v.a, g = v.b, b(e[n + t], e[s + t]), m = v.a, y = v.b, b(_, m), e[i + t] = v.a, e[n + t] = v.b, b(g, y), e[r + t] = v.a, e[s + t] = v.b) : (x(e[i + t], e[r + t]), _ = v.a, g = v.b, x(e[n + t], e[s + t]), m = v.a, y = v.b, x(_, m), e[i + t] = v.a, e[n + t] = v.b, x(g, y), e[r + t] = v.a, e[s + t] = v.b)
                        }
                        if (n & p) {
                            const n = i + l;
                            a ? b(e[i + t], e[n + t]) : x(e[i + t], e[n + t]), _ = v.a, e[n + t] = v.b, e[i + t] = _
                        }
                    }
                    if (i & p) {
                        let i = u;
                        const s = u + r * (n - c);
                        for (; i <= s; i += f) {
                            const n = i + d;
                            a ? b(e[i + t], e[n + t]) : x(e[i + t], e[n + t]), _ = v.a, e[n + t] = v.b, e[i + t] = _
                        }
                    }
                    c = p, p >>= 1
                }
                return u
            }

            function w(e, t, n, i, o, m) {
                const g = n.value,
                    v = U(t, n),
                    b = U(t, n);
                n.value += 4;
                const x = U(t, n);
                if (n.value += 4, v < 0 || v >= s || b < 0 || b >= s) throw new Error("Something wrong with HUF_ENCSIZE");
                const y = new Array(s),
                    w = new Array(16384);
                if (function(e) {
                        for (let t = 0; t < 16384; t++) e[t] = {}, e[t].len = 0, e[t].lit = 0, e[t].p = null
                    }(w), function(e, t, n, r, i, o) {
                        const u = t;
                        let p = 0,
                            h = 0;
                        for (; r <= i; r++) {
                            if (u.value - t.value > n) return !1;
                            l(6, p, h, e, u);
                            const s = a.l;
                            if (p = a.c, h = a.lc, o[r] = s, 63 == s) {
                                if (u.value - t.value > n) throw new Error("Something wrong with hufUnpackEncTable");
                                l(8, p, h, e, u);
                                let s = a.l + 6;
                                if (p = a.c, h = a.lc, r + s > i + 1) throw new Error("Something wrong with hufUnpackEncTable");
                                for (; s--;) o[r++] = 0;
                                r--
                            } else if (s >= 59) {
                                let e = s - 59 + 2;
                                if (r + e > i + 1) throw new Error("Something wrong with hufUnpackEncTable");
                                for (; e--;) o[r++] = 0;
                                r--
                            }
                        }! function(e) {
                            for (let e = 0; e <= 58; ++e) c[e] = 0;
                            for (let t = 0; t < s; ++t) c[e[t]] += 1;
                            let t = 0;
                            for (let e = 58; e > 0; --e) {
                                const n = t + c[e] >> 1;
                                c[e] = t, t = n
                            }
                            for (let t = 0; t < s; ++t) {
                                const n = e[t];
                                n > 0 && (e[t] = n | c[n]++ << 6)
                            }
                        }(o)
                    }(e, n, i - (n.value - g), v, b, y), x > 8 * (i - (n.value - g))) throw new Error("Something wrong with hufUncompress");
                ! function(e, t, n, i) {
                    for (; t <= n; t++) {
                        const n = p(e[t]),
                            s = u(e[t]);
                        if (n >> s) throw new Error("Invalid table entry");
                        if (s > r) {
                            const e = i[n >> s - r];
                            if (e.len) throw new Error("Invalid table entry");
                            if (e.lit++, e.p) {
                                const t = e.p;
                                e.p = new Array(e.lit);
                                for (let n = 0; n < e.lit - 1; ++n) e.p[n] = t[n]
                            } else e.p = new Array(1);
                            e.p[e.lit - 1] = t
                        } else if (s) {
                            let e = 0;
                            for (let o = 1 << r - s; o > 0; o--) {
                                const o = i[(n << r - s) + e];
                                if (o.len || o.p) throw new Error("Invalid table entry");
                                o.len = s, o.lit = t, e++
                            }
                        }
                    }
                }(y, v, b, w),
                function(e, t, n, i, s, o, a, l, c) {
                    let m = 0,
                        g = 0;
                    const v = a,
                        b = Math.trunc(i.value + (s + 7) / 8);
                    for (; i.value < b;)
                        for (d(m, g, n, i), m = h.c, g = h.lc; g >= r;) {
                            const s = t[m >> g - r & 16383];
                            if (s.len) g -= s.len, _(s.lit, o, m, g, n, i, l, c, v), m = f.c, g = f.lc;
                            else {
                                if (!s.p) throw new Error("hufDecode issues");
                                let t;
                                for (t = 0; t < s.lit; t++) {
                                    const r = u(e[s.p[t]]);
                                    for (; g < r && i.value < b;) d(m, g, n, i), m = h.c, g = h.lc;
                                    if (g >= r && p(e[s.p[t]]) == (m >> g - r & (1 << r) - 1)) {
                                        g -= r, _(s.p[t], o, m, g, n, i, l, c, v), m = f.c, g = f.lc;
                                        break
                                    }
                                }
                                if (t == s.lit) throw new Error("hufDecode issues")
                            }
                        }
                    const x = 8 - s & 7;
                    for (m >>= x, g -= x; g > 0;) {
                        const e = t[m << r - g & 16383];
                        if (!e.len) throw new Error("hufDecode issues");
                        g -= e.len, _(e.lit, o, m, g, n, i, l, c, v), m = f.c, g = f.lc
                    }
                }(y, w, e, n, x, b, m, o, {
                    value: 0
                })
            }

            function S(e) {
                for (let t = 1; t < e.length; t++) {
                    const n = e[t - 1] + e[t] - 128;
                    e[t] = n
                }
            }

            function M(e, t) {
                let n = 0,
                    r = Math.floor((e.length + 1) / 2),
                    i = 0;
                const s = e.length - 1;
                for (; !(i > s || (t[i++] = e[n++], i > s));) t[i++] = e[r++]
            }

            function T(e) {
                let t = e.byteLength;
                const n = new Array;
                let r = 0;
                const i = new DataView(e);
                for (; t > 0;) {
                    const e = i.getInt8(r++);
                    if (e < 0) {
                        const s = -e;
                        t -= s + 1;
                        for (let e = 0; e < s; e++) n.push(i.getUint8(r++))
                    } else {
                        const s = e;
                        t -= 2;
                        const o = i.getUint8(r++);
                        for (let e = 0; e < s + 1; e++) n.push(o)
                    }
                }
                return n
            }

            function E(e, t, n) {
                let r, i = 1;
                for (; i < 64;) r = t[e.value], 65280 == r ? i = 64 : r >> 8 == 255 ? i += 255 & r : (n[i] = r, i++), e.value++
            }

            function A(e) {
                const t = .5 * Math.cos(.7853975),
                    n = .5 * Math.cos(3.14159 / 16),
                    r = .5 * Math.cos(3.14159 / 8),
                    i = .5 * Math.cos(3 * 3.14159 / 16),
                    s = .5 * Math.cos(.981746875),
                    o = .5 * Math.cos(3 * 3.14159 / 8),
                    a = .5 * Math.cos(1.374445625),
                    l = new Array(4),
                    c = new Array(4),
                    u = new Array(4),
                    p = new Array(4);
                for (let h = 0; h < 8; ++h) {
                    const d = 8 * h;
                    l[0] = r * e[d + 2], l[1] = o * e[d + 2], l[2] = r * e[d + 6], l[3] = o * e[d + 6], c[0] = n * e[d + 1] + i * e[d + 3] + s * e[d + 5] + a * e[d + 7], c[1] = i * e[d + 1] - a * e[d + 3] - n * e[d + 5] - s * e[d + 7], c[2] = s * e[d + 1] - n * e[d + 3] + a * e[d + 5] + i * e[d + 7], c[3] = a * e[d + 1] - s * e[d + 3] + i * e[d + 5] - n * e[d + 7], u[0] = t * (e[d + 0] + e[d + 4]), u[3] = t * (e[d + 0] - e[d + 4]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], p[0] = u[0] + u[1], p[1] = u[3] + u[2], p[2] = u[3] - u[2], p[3] = u[0] - u[1], e[d + 0] = p[0] + c[0], e[d + 1] = p[1] + c[1], e[d + 2] = p[2] + c[2], e[d + 3] = p[3] + c[3], e[d + 4] = p[3] - c[3], e[d + 5] = p[2] - c[2], e[d + 6] = p[1] - c[1], e[d + 7] = p[0] - c[0]
                }
                for (let h = 0; h < 8; ++h) l[0] = r * e[16 + h], l[1] = o * e[16 + h], l[2] = r * e[48 + h], l[3] = o * e[48 + h], c[0] = n * e[8 + h] + i * e[24 + h] + s * e[40 + h] + a * e[56 + h], c[1] = i * e[8 + h] - a * e[24 + h] - n * e[40 + h] - s * e[56 + h], c[2] = s * e[8 + h] - n * e[24 + h] + a * e[40 + h] + i * e[56 + h], c[3] = a * e[8 + h] - s * e[24 + h] + i * e[40 + h] - n * e[56 + h], u[0] = t * (e[h] + e[32 + h]), u[3] = t * (e[h] - e[32 + h]), u[1] = l[0] + l[3], u[2] = l[1] - l[2], p[0] = u[0] + u[1], p[1] = u[3] + u[2], p[2] = u[3] - u[2], p[3] = u[0] - u[1], e[0 + h] = p[0] + c[0], e[8 + h] = p[1] + c[1], e[16 + h] = p[2] + c[2], e[24 + h] = p[3] + c[3], e[32 + h] = p[3] - c[3], e[40 + h] = p[2] - c[2], e[48 + h] = p[1] - c[1], e[56 + h] = p[0] - c[0]
            }

            function C(e) {
                for (let t = 0; t < 64; ++t) {
                    const n = e[0][t],
                        r = e[1][t],
                        i = e[2][t];
                    e[0][t] = n + 1.5747 * i, e[1][t] = n - .1873 * r - .4682 * i, e[2][t] = n + 1.8556 * r
                }
            }

            function R(e, t, n) {
                for (let s = 0; s < 64; ++s) t[n + s] = i.A5E.toHalfFloat((r = e[s]) <= 1 ? Math.sign(r) * Math.pow(Math.abs(r), 2.2) : Math.sign(r) * Math.pow(o, Math.abs(r) - 1));
                var r
            }

            function k(e) {
                return new DataView(e.array.buffer, e.offset.value, e.size)
            }

            function P(e) {
                const t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size),
                    n = new Uint8Array(T(t)),
                    r = new Uint8Array(n.length);
                return S(n), M(n, r), new DataView(r.buffer)
            }

            function D(e) {
                const t = e.array.slice(e.offset.value, e.offset.value + e.size);
                void 0 === n && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                const r = Av(t),
                    i = new Uint8Array(r.length);
                return S(r), M(r, i), new DataView(i.buffer)
            }

            function O(e) {
                const n = e.viewer,
                    r = {
                        value: e.offset.value
                    },
                    i = new Uint16Array(e.width * e.scanlineBlockSize * (e.channels * e.type)),
                    s = new Uint8Array(8192);
                let o = 0;
                const a = new Array(e.channels);
                for (let t = 0; t < e.channels; t++) a[t] = {}, a[t].start = o, a[t].end = a[t].start, a[t].nx = e.width, a[t].ny = e.lines, a[t].size = e.type, o += a[t].nx * a[t].ny * a[t].size;
                const l = W(n, r),
                    c = W(n, r);
                if (c >= 8192) throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
                if (l <= c)
                    for (let e = 0; e < c - l + 1; e++) s[e + l] = j(n, r);
                const u = new Uint16Array(t),
                    p = function(e, n) {
                        let r = 0;
                        for (let i = 0; i < t; ++i)(0 == i || e[i >> 3] & 1 << (7 & i)) && (n[r++] = i);
                        const i = r - 1;
                        for (; r < t;) n[r++] = 0;
                        return i
                    }(s, u),
                    h = U(n, r);
                w(e.array, n, r, h, i, o);
                for (let t = 0; t < e.channels; ++t) {
                    const e = a[t];
                    for (let n = 0; n < a[t].size; ++n) y(i, e.start + n, e.nx, e.size, e.ny, e.nx * e.size, p)
                }! function(e, t, n) {
                    for (let r = 0; r < n; ++r) t[r] = e[t[r]]
                }(u, i, o);
                let d = 0;
                const f = new Uint8Array(i.buffer.byteLength);
                for (let t = 0; t < e.lines; t++)
                    for (let t = 0; t < e.channels; t++) {
                        const e = a[t],
                            n = e.nx * e.size,
                            r = new Uint8Array(i.buffer, 2 * e.end, 2 * n);
                        f.set(r, d), d += 2 * n, e.end += n
                    }
                return new DataView(f.buffer)
            }

            function L(e) {
                const t = e.array.slice(e.offset.value, e.offset.value + e.size);
                void 0 === n && console.error("THREE.EXRLoader: External library fflate.min.js required.");
                const r = Av(t),
                    i = e.lines * e.channels * e.width,
                    s = 1 == e.type ? new Uint16Array(i) : new Uint32Array(i);
                let o = 0,
                    a = 0;
                const l = new Array(4);
                for (let t = 0; t < e.lines; t++)
                    for (let t = 0; t < e.channels; t++) {
                        let t = 0;
                        switch (e.type) {
                            case 1:
                                l[0] = o, l[1] = l[0] + e.width, o = l[1] + e.width;
                                for (let n = 0; n < e.width; ++n) t += r[l[0]++] << 8 | r[l[1]++], s[a] = t, a++;
                                break;
                            case 2:
                                l[0] = o, l[1] = l[0] + e.width, l[2] = l[1] + e.width, o = l[2] + e.width;
                                for (let n = 0; n < e.width; ++n) t += r[l[0]++] << 24 | r[l[1]++] << 16 | r[l[2]++] << 8, s[a] = t, a++
                        }
                    }
                return new DataView(s.buffer)
            }

            function I(e) {
                const t = e.viewer,
                    n = {
                        value: e.offset.value
                    },
                    r = new Uint8Array(e.width * e.lines * (e.channels * e.type * 2)),
                    i = {
                        version: z(t, n),
                        unknownUncompressedSize: z(t, n),
                        unknownCompressedSize: z(t, n),
                        acCompressedSize: z(t, n),
                        dcCompressedSize: z(t, n),
                        rleCompressedSize: z(t, n),
                        rleUncompressedSize: z(t, n),
                        rleRawSize: z(t, n),
                        totalAcUncompressedCount: z(t, n),
                        totalDcUncompressedCount: z(t, n),
                        acCompression: z(t, n)
                    };
                if (i.version < 2) throw new Error("EXRLoader.parse: " + J.compression + " version " + i.version + " is unsupported");
                const s = new Array;
                let o = W(t, n) - 2;
                for (; o > 0;) {
                    const e = F(t.buffer, n),
                        r = j(t, n),
                        i = r >> 2 & 3,
                        a = new Int8Array([(r >> 4) - 1])[0],
                        l = j(t, n);
                    s.push({
                        name: e,
                        index: a,
                        type: l,
                        compression: i
                    }), o -= e.length + 3
                }
                const a = J.channels,
                    l = new Array(e.channels);
                for (let t = 0; t < e.channels; ++t) {
                    const n = l[t] = {},
                        r = a[t];
                    n.name = r.name, n.compression = 0, n.decoded = !1, n.type = r.pixelType, n.pLinear = r.pLinear, n.width = e.width, n.height = e.lines
                }
                const c = {
                    idx: new Array(3)
                };
                for (let t = 0; t < e.channels; ++t) {
                    const e = l[t];
                    for (let n = 0; n < s.length; ++n) {
                        const r = s[n];
                        e.name == r.name && (e.compression = r.compression, r.index >= 0 && (c.idx[r.index] = t), e.offset = t)
                    }
                }
                let u, p, h;
                if (i.acCompressedSize > 0) switch (i.acCompression) {
                    case 0:
                        u = new Uint16Array(i.totalAcUncompressedCount), w(e.array, t, n, i.acCompressedSize, u, i.totalAcUncompressedCount);
                        break;
                    case 1:
                        const r = Av(e.array.slice(n.value, n.value + i.totalAcUncompressedCount));
                        u = new Uint16Array(r.buffer), n.value += i.totalAcUncompressedCount
                }
                if (i.dcCompressedSize > 0) {
                    const t = {
                        array: e.array,
                        offset: n,
                        size: i.dcCompressedSize
                    };
                    p = new Uint16Array(D(t).buffer), n.value += i.dcCompressedSize
                }
                i.rleRawSize > 0 && (h = T(Av(e.array.slice(n.value, n.value + i.rleCompressedSize)).buffer), n.value += i.rleCompressedSize);
                let d = 0;
                const f = new Array(l.length);
                for (let e = 0; e < f.length; ++e) f[e] = new Array;
                for (let t = 0; t < e.lines; ++t)
                    for (let t = 0; t < l.length; ++t) f[t].push(d), d += l[t].width * e.type * 2;
                ! function(e, t, n, r, i, s) {
                    let o = new DataView(s.buffer);
                    const a = n[e.idx[0]].width,
                        l = n[e.idx[0]].height,
                        c = Math.floor(a / 8),
                        u = Math.ceil(a / 8),
                        p = Math.ceil(l / 8),
                        h = a - 8 * (u - 1),
                        d = l - 8 * (p - 1),
                        f = {
                            value: 0
                        },
                        _ = new Array(3),
                        m = new Array(3),
                        g = new Array(3),
                        v = new Array(3),
                        b = new Array(3);
                    for (let n = 0; n < 3; ++n) b[n] = t[e.idx[n]], _[n] = n < 1 ? 0 : _[n - 1] + u * p, m[n] = new Float32Array(64), g[n] = new Uint16Array(64), v[n] = new Uint16Array(64 * u);
                    for (let t = 0; t < p; ++t) {
                        let s = 8;
                        t == p - 1 && (s = d);
                        let a = 8;
                        for (let e = 0; e < u; ++e) {
                            e == u - 1 && (a = h);
                            for (let e = 0; e < 3; ++e) g[e].fill(0), g[e][0] = i[_[e]++], E(f, r, g[e]), x = g[e], (y = m[e])[0] = H(x[0]), y[1] = H(x[1]), y[2] = H(x[5]), y[3] = H(x[6]), y[4] = H(x[14]), y[5] = H(x[15]), y[6] = H(x[27]), y[7] = H(x[28]), y[8] = H(x[2]), y[9] = H(x[4]), y[10] = H(x[7]), y[11] = H(x[13]), y[12] = H(x[16]), y[13] = H(x[26]), y[14] = H(x[29]), y[15] = H(x[42]), y[16] = H(x[3]), y[17] = H(x[8]), y[18] = H(x[12]), y[19] = H(x[17]), y[20] = H(x[25]), y[21] = H(x[30]), y[22] = H(x[41]), y[23] = H(x[43]), y[24] = H(x[9]), y[25] = H(x[11]), y[26] = H(x[18]), y[27] = H(x[24]), y[28] = H(x[31]), y[29] = H(x[40]), y[30] = H(x[44]), y[31] = H(x[53]), y[32] = H(x[10]), y[33] = H(x[19]), y[34] = H(x[23]), y[35] = H(x[32]), y[36] = H(x[39]), y[37] = H(x[45]), y[38] = H(x[52]), y[39] = H(x[54]), y[40] = H(x[20]), y[41] = H(x[22]), y[42] = H(x[33]), y[43] = H(x[38]), y[44] = H(x[46]), y[45] = H(x[51]), y[46] = H(x[55]), y[47] = H(x[60]), y[48] = H(x[21]), y[49] = H(x[34]), y[50] = H(x[37]), y[51] = H(x[47]), y[52] = H(x[50]), y[53] = H(x[56]), y[54] = H(x[59]), y[55] = H(x[61]), y[56] = H(x[35]), y[57] = H(x[36]), y[58] = H(x[48]), y[59] = H(x[49]), y[60] = H(x[57]), y[61] = H(x[58]), y[62] = H(x[62]), y[63] = H(x[63]), A(m[e]);
                            C(m);
                            for (let t = 0; t < 3; ++t) R(m[t], v[t], 64 * e)
                        }
                        let l = 0;
                        for (let r = 0; r < 3; ++r) {
                            const i = n[e.idx[r]].type;
                            for (let e = 8 * t; e < 8 * t + s; ++e) {
                                l = b[r][e];
                                for (let t = 0; t < c; ++t) {
                                    const n = 64 * t + 8 * (7 & e);
                                    o.setUint16(l + 0 * i, v[r][n + 0], !0), o.setUint16(l + 2 * i, v[r][n + 1], !0), o.setUint16(l + 4 * i, v[r][n + 2], !0), o.setUint16(l + 6 * i, v[r][n + 3], !0), o.setUint16(l + 8 * i, v[r][n + 4], !0), o.setUint16(l + 10 * i, v[r][n + 5], !0), o.setUint16(l + 12 * i, v[r][n + 6], !0), o.setUint16(l + 14 * i, v[r][n + 7], !0), l += 16 * i
                                }
                            }
                            if (c != u)
                                for (let e = 8 * t; e < 8 * t + s; ++e) {
                                    const t = b[r][e] + 8 * c * 2 * i,
                                        n = 64 * c + 8 * (7 & e);
                                    for (let e = 0; e < a; ++e) o.setUint16(t + 2 * e * i, v[r][n + e], !0)
                                }
                        }
                    }
                    var x, y;
                    const w = new Uint16Array(a);
                    o = new DataView(s.buffer);
                    for (let t = 0; t < 3; ++t) {
                        n[e.idx[t]].decoded = !0;
                        const r = n[e.idx[t]].type;
                        if (2 == n[t].type)
                            for (let e = 0; e < l; ++e) {
                                const n = b[t][e];
                                for (let e = 0; e < a; ++e) w[e] = o.getUint16(n + 2 * e * r, !0);
                                for (let e = 0; e < a; ++e) o.setFloat32(n + 2 * e * r, H(w[e]), !0)
                            }
                    }
                }(c, f, l, u, p, r);
                for (let t = 0; t < l.length; ++t) {
                    const n = l[t];
                    if (!n.decoded) switch (n.compression) {
                        case 2:
                            let i = 0,
                                s = 0;
                            for (let o = 0; o < e.lines; ++o) {
                                let e = f[t][i];
                                for (let t = 0; t < n.width; ++t) {
                                    for (let t = 0; t < 2 * n.type; ++t) r[e++] = h[s + t * n.width * n.height];
                                    s++
                                }
                                i++
                            }
                            break;
                        case 1:
                        default:
                            throw new Error("EXRLoader.parse: unsupported channel compression")
                    }
                }
                return new DataView(r.buffer)
            }

            function F(e, t) {
                const n = new Uint8Array(e);
                let r = 0;
                for (; 0 != n[t.value + r];) r += 1;
                const i = (new TextDecoder).decode(n.slice(t.value, t.value + r));
                return t.value = t.value + r + 1, i
            }

            function N(e, t) {
                const n = e.getInt32(t.value, !0);
                return t.value = t.value + 4, n
            }

            function U(e, t) {
                const n = e.getUint32(t.value, !0);
                return t.value = t.value + 4, n
            }

            function B(e, t) {
                const n = e[t.value];
                return t.value = t.value + 1, n
            }

            function j(e, t) {
                const n = e.getUint8(t.value);
                return t.value = t.value + 1, n
            }
            const z = function(e, t) {
                const n = Number(e.getBigInt64(t.value, !0));
                return t.value += 8, n
            };

            function V(e, t) {
                const n = e.getFloat32(t.value, !0);
                return t.value += 4, n
            }

            function G(e, t) {
                return i.A5E.toHalfFloat(V(e, t))
            }

            function H(e) {
                const t = (31744 & e) >> 10,
                    n = 1023 & e;
                return (e >> 15 ? -1 : 1) * (t ? 31 === t ? n ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14)
            }

            function W(e, t) {
                const n = e.getUint16(t.value, !0);
                return t.value += 2, n
            }

            function K(e, t) {
                return H(W(e, t))
            }

            function X(e, t, n, r, i) {
                return "string" === r || "stringvector" === r || "iccProfile" === r ? function(e, t, n) {
                    const r = (new TextDecoder).decode(new Uint8Array(e).slice(t.value, t.value + n));
                    return t.value = t.value + n, r
                }(t, n, i) : "chlist" === r ? function(e, t, n, r) {
                    const i = n.value,
                        s = [];
                    for (; n.value < i + r - 1;) {
                        const r = F(t, n),
                            i = N(e, n),
                            o = j(e, n);
                        n.value += 3;
                        const a = N(e, n),
                            l = N(e, n);
                        s.push({
                            name: r,
                            pixelType: i,
                            pLinear: o,
                            xSampling: a,
                            ySampling: l
                        })
                    }
                    return n.value += 1, s
                }(e, t, n, i) : "chromaticities" === r ? function(e, t) {
                    return {
                        redX: V(e, t),
                        redY: V(e, t),
                        greenX: V(e, t),
                        greenY: V(e, t),
                        blueX: V(e, t),
                        blueY: V(e, t),
                        whiteX: V(e, t),
                        whiteY: V(e, t)
                    }
                }(e, n) : "compression" === r ? function(e, t) {
                    return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][j(e, t)]
                }(e, n) : "box2i" === r ? function(e, t) {
                    return {
                        xMin: U(e, t),
                        yMin: U(e, t),
                        xMax: U(e, t),
                        yMax: U(e, t)
                    }
                }(e, n) : "lineOrder" === r ? function(e, t) {
                    return ["INCREASING_Y"][j(e, t)]
                }(e, n) : "float" === r ? V(e, n) : "v2f" === r ? function(e, t) {
                    return [V(e, t), V(e, t)]
                }(e, n) : "v3f" === r ? function(e, t) {
                    return [V(e, t), V(e, t), V(e, t)]
                }(e, n) : "int" === r ? N(e, n) : "rational" === r ? function(e, t) {
                    return [N(e, t), U(e, t)]
                }(e, n) : "timecode" === r ? function(e, t) {
                    return [U(e, t), U(e, t)]
                }(e, n) : "preview" === r ? (n.value += i, "skipped") : void(n.value += i)
            }
            const q = new DataView(e),
                Y = new Uint8Array(e),
                Z = {
                    value: 0
                },
                J = function(e, t, n) {
                    const r = {};
                    if (20000630 != e.getUint32(0, !0)) throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");
                    r.version = e.getUint8(4);
                    const i = e.getUint8(5);
                    r.spec = {
                        singleTile: !!(2 & i),
                        longName: !!(4 & i),
                        deepFormat: !!(8 & i),
                        multiPart: !!(16 & i)
                    }, n.value = 8;
                    let s = !0;
                    for (; s;) {
                        const i = F(t, n);
                        if (0 == i) s = !1;
                        else {
                            const s = F(t, n),
                                o = X(e, t, n, s, U(e, n));
                            void 0 === o ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${s}'.`) : r[i] = o
                        }
                    }
                    if (0 != (-5 & i)) throw console.error("EXRHeader:", r), new Error("THREE.EXRLoader: provided file is currently unsupported.");
                    return r
                }(q, e, Z),
                $ = function(e, t, n, r, s) {
                    const o = {
                        size: 0,
                        viewer: t,
                        array: n,
                        offset: r,
                        width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
                        height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
                        channels: e.channels.length,
                        bytesPerLine: null,
                        lines: null,
                        inputSize: null,
                        type: e.channels[0].pixelType,
                        uncompress: null,
                        getter: null,
                        format: null,
                        encoding: null
                    };
                    switch (e.compression) {
                        case "NO_COMPRESSION":
                            o.lines = 1, o.uncompress = k;
                            break;
                        case "RLE_COMPRESSION":
                            o.lines = 1, o.uncompress = P;
                            break;
                        case "ZIPS_COMPRESSION":
                            o.lines = 1, o.uncompress = D;
                            break;
                        case "ZIP_COMPRESSION":
                            o.lines = 16, o.uncompress = D;
                            break;
                        case "PIZ_COMPRESSION":
                            o.lines = 32, o.uncompress = O;
                            break;
                        case "PXR24_COMPRESSION":
                            o.lines = 16, o.uncompress = L;
                            break;
                        case "DWAA_COMPRESSION":
                            o.lines = 32, o.uncompress = I;
                            break;
                        case "DWAB_COMPRESSION":
                            o.lines = 256, o.uncompress = I;
                            break;
                        default:
                            throw new Error("EXRLoader.parse: " + e.compression + " is unsupported")
                    }
                    if (o.scanlineBlockSize = o.lines, 1 == o.type) switch (s) {
                        case i.VzW:
                            o.getter = K, o.inputSize = 2;
                            break;
                        case i.cLu:
                            o.getter = W, o.inputSize = 2
                    } else {
                        if (2 != o.type) throw new Error("EXRLoader.parse: unsupported pixelType " + o.type + " for " + e.compression + ".");
                        switch (s) {
                            case i.VzW:
                                o.getter = V, o.inputSize = 4;
                                break;
                            case i.cLu:
                                o.getter = G, o.inputSize = 4
                        }
                    }
                    o.blockCount = (e.dataWindow.yMax + 1) / o.scanlineBlockSize;
                    for (let e = 0; e < o.blockCount; e++) z(t, r);
                    o.outputChannels = 3 == o.channels ? 4 : o.channels;
                    const a = o.width * o.height * o.outputChannels;
                    switch (s) {
                        case i.VzW:
                            o.byteArray = new Float32Array(a), o.channels < o.outputChannels && o.byteArray.fill(1, 0, a);
                            break;
                        case i.cLu:
                            o.byteArray = new Uint16Array(a), o.channels < o.outputChannels && o.byteArray.fill(15360, 0, a);
                            break;
                        default:
                            console.error("THREE.EXRLoader: unsupported type: ", s)
                    }
                    return o.bytesPerLine = o.width * o.inputSize * o.channels, 4 == o.outputChannels ? (o.format = i.wk1, o.encoding = i.rnI) : (o.format = i.hEm, o.encoding = i.rnI), o
                }(J, q, Y, Z, this.type),
                Q = {
                    value: 0
                },
                ee = {
                    R: 0,
                    G: 1,
                    B: 2,
                    A: 3,
                    Y: 0
                };
            for (let e = 0; e < $.height / $.scanlineBlockSize; e++) {
                const t = U(q, Z);
                $.size = U(q, Z), $.lines = t + $.scanlineBlockSize > $.height ? $.height - t : $.scanlineBlockSize;
                const n = $.size < $.lines * $.bytesPerLine ? $.uncompress($) : k($);
                Z.value += $.size;
                for (let t = 0; t < $.scanlineBlockSize; t++) {
                    const r = t + e * $.scanlineBlockSize;
                    if (r >= $.height) break;
                    for (let e = 0; e < $.channels; e++) {
                        const i = ee[J.channels[e].name];
                        for (let s = 0; s < $.width; s++) {
                            Q.value = (t * ($.channels * $.width) + e * $.width + s) * $.inputSize;
                            const o = ($.height - 1 - r) * ($.width * $.outputChannels) + s * $.outputChannels + i;
                            $.byteArray[o] = $.getter(n, Q)
                        }
                    }
                }
            }
            return {
                header: J,
                width: $.width,
                height: $.height,
                data: $.byteArray,
                format: $.format,
                encoding: $.encoding,
                type: this.type
            }
        }
        setDataType(e) {
            return this.type = e, this
        }
        load(e, t, n, r) {
            return super.load(e, (function(e, n) {
                e.encoding = n.encoding, e.minFilter = i.wem, e.magFilter = i.wem, e.generateMipmaps = !1, e.flipY = !1, t && t(e, n)
            }), n, r)
        }
    }
    class ab extends r {
        constructor() {
            super(...arguments), this.dependencies = [Vs]
        }
        async onAdded(e) {
            this._importer || (this._importer = new $t(class extends ob {
                constructor(t) {
                    super(t), this.setDataType(Bs(e.renderer.rendererObject))
                }
            }, ["exr"], !1)), Us.Importers.push(this._importer)
        }
        async onDispose(e) {
            this._importer = void 0
        }
        async onRemove(e) {
            this._importer && Us.Importers.splice(Us.Importers.indexOf(this._importer), 1), this._importer = void 0
        }
    }

    function lb(e, t, n) {
        const r = n.length - e - 1;
        if (t >= n[r]) return r - 1;
        if (t <= n[e]) return e;
        let i = e,
            s = r,
            o = Math.floor((i + s) / 2);
        for (; t < n[o] || t >= n[o + 1];) t < n[o] ? s = o : i = o, o = Math.floor((i + s) / 2);
        return o
    }

    function cb(e, t) {
        let n = 1;
        for (let t = 2; t <= e; ++t) n *= t;
        let r = 1;
        for (let e = 2; e <= t; ++e) r *= e;
        for (let n = 2; n <= e - t; ++n) r *= n;
        return n / r
    }
    ab.PluginType = "EXRLoadPlugin";
    class ub extends i.Hyl {
        constructor(e, t, n, r, s) {
            super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = r || 0, this.endKnot = s || this.knots.length - 1;
            for (let e = 0; e < n.length; ++e) {
                const t = n[e];
                this.controlPoints[e] = new i.Ltg(t.x, t.y, t.z, t.w)
            }
        }
        getPoint(e, t = new i.Pa4) {
            const n = t,
                r = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
                s = function(e, t, n, r) {
                    const s = lb(e, r, t),
                        o = function(e, t, n, r) {
                            const i = [],
                                s = [],
                                o = [];
                            i[0] = 1;
                            for (let a = 1; a <= n; ++a) {
                                s[a] = t - r[e + 1 - a], o[a] = r[e + a] - t;
                                let n = 0;
                                for (let e = 0; e < a; ++e) {
                                    const t = o[e + 1],
                                        r = s[a - e],
                                        l = i[e] / (t + r);
                                    i[e] = n + t * l, n = r * l
                                }
                                i[a] = n
                            }
                            return i
                        }(s, r, e, t),
                        a = new i.Ltg(0, 0, 0, 0);
                    for (let t = 0; t <= e; ++t) {
                        const r = n[s - e + t],
                            i = o[t],
                            l = r.w * i;
                        a.x += r.x * l, a.y += r.y * l, a.z += r.z * l, a.w += r.w * i
                    }
                    return a
                }(this.degree, this.knots, this.controlPoints, r);
            return 1 !== s.w && s.divideScalar(s.w), n.set(s.x, s.y, s.z)
        }
        getTangent(e, t = new i.Pa4) {
            const n = t,
                r = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]),
                s = function(e, t, n, r, s) {
                    return function(e) {
                        const t = e.length,
                            n = [],
                            r = [];
                        for (let s = 0; s < t; ++s) {
                            const t = e[s];
                            n[s] = new i.Pa4(t.x, t.y, t.z), r[s] = t.w
                        }
                        const s = [];
                        for (let e = 0; e < t; ++e) {
                            const t = n[e].clone();
                            for (let n = 1; n <= e; ++n) t.sub(s[e - n].clone().multiplyScalar(cb(e, n) * r[n]));
                            s[e] = t.divideScalar(r[0])
                        }
                        return s
                    }(function(e, t, n, r, s) {
                        const o = s < e ? s : e,
                            a = [],
                            l = lb(e, r, t),
                            c = function(e, t, n, r, i) {
                                const s = [];
                                for (let e = 0; e <= n; ++e) s[e] = 0;
                                const o = [];
                                for (let e = 0; e <= r; ++e) o[e] = s.slice(0);
                                const a = [];
                                for (let e = 0; e <= n; ++e) a[e] = s.slice(0);
                                a[0][0] = 1;
                                const l = s.slice(0),
                                    c = s.slice(0);
                                for (let r = 1; r <= n; ++r) {
                                    l[r] = t - i[e + 1 - r], c[r] = i[e + r] - t;
                                    let n = 0;
                                    for (let e = 0; e < r; ++e) {
                                        const t = c[e + 1],
                                            i = l[r - e];
                                        a[r][e] = t + i;
                                        const s = a[e][r - 1] / a[r][e];
                                        a[e][r] = n + t * s, n = i * s
                                    }
                                    a[r][r] = n
                                }
                                for (let e = 0; e <= n; ++e) o[0][e] = a[e][n];
                                for (let e = 0; e <= n; ++e) {
                                    let t = 0,
                                        i = 1;
                                    const l = [];
                                    for (let e = 0; e <= n; ++e) l[e] = s.slice(0);
                                    l[0][0] = 1;
                                    for (let s = 1; s <= r; ++s) {
                                        let r = 0;
                                        const c = e - s,
                                            u = n - s;
                                        e >= s && (l[i][0] = l[t][0] / a[u + 1][c], r = l[i][0] * a[c][u]);
                                        const p = e - 1 <= u ? s - 1 : n - e;
                                        for (let e = c >= -1 ? 1 : -c; e <= p; ++e) l[i][e] = (l[t][e] - l[t][e - 1]) / a[u + 1][c + e], r += l[i][e] * a[c + e][u];
                                        e <= u && (l[i][s] = -l[t][s - 1] / a[u + 1][e], r += l[i][s] * a[e][u]), o[s][e] = r;
                                        const h = t;
                                        t = i, i = h
                                    }
                                }
                                let u = n;
                                for (let e = 1; e <= r; ++e) {
                                    for (let t = 0; t <= n; ++t) o[e][t] *= u;
                                    u *= n - e
                                }
                                return o
                            }(l, r, e, o, t),
                            u = [];
                        for (let e = 0; e < n.length; ++e) {
                            const t = n[e].clone(),
                                r = t.w;
                            t.x *= r, t.y *= r, t.z *= r, u[e] = t
                        }
                        for (let t = 0; t <= o; ++t) {
                            const n = u[l - e].clone().multiplyScalar(c[t][0]);
                            for (let r = 1; r <= e; ++r) n.add(u[l - e + r].clone().multiplyScalar(c[t][r]));
                            a[t] = n
                        }
                        for (let e = o + 1; e <= s + 1; ++e) a[e] = new i.Ltg(0, 0, 0);
                        return a
                    }(e, t, n, r, s))
                }(this.degree, this.knots, this.controlPoints, r, 1);
            return n.copy(s[1]).normalize(), n
        }
    }
    let pb, hb, db;
    class fb extends i.aNw {
        constructor(e) {
            super(e)
        }
        load(e, t, n, r) {
            const s = this,
                o = "" === s.path ? i.Zp0.extractUrlBase(e) : s.path,
                a = new i.hH6(this.manager);
            a.setPath(s.path), a.setResponseType("arraybuffer"), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, (function(n) {
                try {
                    t(s.parse(n, o))
                } catch (t) {
                    r ? r(t) : console.error(t), s.manager.itemError(e)
                }
            }), n, r)
        }
        parse(e, t) {
            if (function(e) {
                    const t = "Kaydara FBX Binary  \0";
                    return e.byteLength >= t.length && t === Pb(e, 0, t.length)
                }(e)) pb = (new bb).parse(e);
            else {
                const t = Pb(e);
                if (! function(e) {
                        const t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
                        let n = 0;

                        function r(t) {
                            const r = e[t - 1];
                            return e = e.slice(n + t), n++, r
                        }
                        for (let e = 0; e < t.length; ++e)
                            if (r(1) === t[e]) return !1;
                        return !0
                    }(t)) throw new Error("THREE.FBXLoader: Unknown format.");
                if (wb(t) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + wb(t));
                pb = (new vb).parse(t)
            }
            const n = new i.dpR(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
            return new _b(n, this.manager).parse(pb)
        }
    }
    class _b {
        constructor(e, t) {
            this.textureLoader = e, this.manager = t
        }
        parse() {
            hb = this.parseConnections();
            const e = this.parseImages(),
                t = this.parseTextures(e),
                n = this.parseMaterials(t),
                r = this.parseDeformers(),
                i = (new mb).parse(r);
            return this.parseScene(r, i, n), db
        }
        parseConnections() {
            const e = new Map;
            return "Connections" in pb && pb.Connections.connections.forEach((function(t) {
                const n = t[0],
                    r = t[1],
                    i = t[2];
                e.has(n) || e.set(n, {
                    parents: [],
                    children: []
                });
                const s = {
                    ID: r,
                    relationship: i
                };
                e.get(n).parents.push(s), e.has(r) || e.set(r, {
                    parents: [],
                    children: []
                });
                const o = {
                    ID: n,
                    relationship: i
                };
                e.get(r).children.push(o)
            })), e
        }
        parseImages() {
            const e = {},
                t = {};
            if ("Video" in pb.Objects) {
                const n = pb.Objects.Video;
                for (const r in n) {
                    const i = n[r];
                    if (e[parseInt(r)] = i.RelativeFilename || i.Filename, "Content" in i) {
                        const e = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0,
                            s = "string" == typeof i.Content && "" !== i.Content;
                        if (e || s) {
                            const e = this.parseImage(n[r]);
                            t[i.RelativeFilename || i.Filename] = e
                        }
                    }
                }
            }
            for (const n in e) {
                const r = e[n];
                void 0 !== t[r] ? e[n] = t[r] : e[n] = e[n].split("\\").pop()
            }
            return e
        }
        parseImage(e) {
            const t = e.Content,
                n = e.RelativeFilename || e.Filename,
                r = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
            let i;
            switch (r) {
                case "bmp":
                    i = "image/bmp";
                    break;
                case "jpg":
                case "jpeg":
                    i = "image/jpeg";
                    break;
                case "png":
                    i = "image/png";
                    break;
                case "tif":
                    i = "image/tiff";
                    break;
                case "tga":
                    null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n), i = "image/tga";
                    break;
                default:
                    return void console.warn('FBXLoader: Image type "' + r + '" is not supported.')
            }
            if ("string" == typeof t) return "data:" + i + ";base64," + t; {
                const e = new Uint8Array(t);
                return window.URL.createObjectURL(new Blob([e], {
                    type: i
                }))
            }
        }
        parseTextures(e) {
            const t = new Map;
            if ("Texture" in pb.Objects) {
                const n = pb.Objects.Texture;
                for (const r in n) {
                    const i = this.parseTexture(n[r], e);
                    t.set(parseInt(r), i)
                }
            }
            return t
        }
        parseTexture(e, t) {
            const n = this.loadTexture(e, t);
            n.ID = e.id, n.name = e.attrName;
            const r = e.WrapModeU,
                s = e.WrapModeV,
                o = void 0 !== r ? r.value : 0,
                a = void 0 !== s ? s.value : 0;
            if (n.wrapS = 0 === o ? i.rpg : i.uWy, n.wrapT = 0 === a ? i.rpg : i.uWy, "Scaling" in e) {
                const t = e.Scaling.value;
                n.repeat.x = t[0], n.repeat.y = t[1]
            }
            if ("Translation" in e) {
                const t = e.Translation.value;
                n.offset.x = t[0], n.offset.y = t[1]
            }
            return n
        }
        loadTexture(e, t) {
            let n;
            const r = this.textureLoader.path,
                s = hb.get(e.id).children;
            let o;
            void 0 !== s && s.length > 0 && void 0 !== t[s[0].ID] && (n = t[s[0].ID], 0 !== n.indexOf("blob:") && 0 !== n.indexOf("data:") || this.textureLoader.setPath(void 0));
            const a = e.FileName.slice(-3).toLowerCase();
            if ("tga" === a) {
                const t = this.manager.getHandler(".tga");
                null === t ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new i.xEZ) : (t.setPath(this.textureLoader.path), o = t.load(n))
            } else "psd" === a ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new i.xEZ) : o = this.textureLoader.load(n);
            return this.textureLoader.setPath(r), o
        }
        parseMaterials(e) {
            const t = new Map;
            if ("Material" in pb.Objects) {
                const n = pb.Objects.Material;
                for (const r in n) {
                    const i = this.parseMaterial(n[r], e);
                    null !== i && t.set(parseInt(r), i)
                }
            }
            return t
        }
        parseMaterial(e, t) {
            const n = e.id,
                r = e.attrName;
            let s = e.ShadingModel;
            if ("object" == typeof s && (s = s.value), !hb.has(n)) return null;
            const o = this.parseParameters(e, t, n);
            let a;
            switch (s.toLowerCase()) {
                case "phong":
                    a = new i.xoR;
                    break;
                case "lambert":
                    a = new i.YBo;
                    break;
                default:
                    console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), a = new i.xoR
            }
            return a.setValues(o), a.name = r, a
        }
        parseParameters(e, t, n) {
            const r = {};
            e.BumpFactor && (r.bumpScale = e.BumpFactor.value), e.Diffuse ? r.color = (new i.Ilk).fromArray(e.Diffuse.value) : !e.DiffuseColor || "Color" !== e.DiffuseColor.type && "ColorRGB" !== e.DiffuseColor.type || (r.color = (new i.Ilk).fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (r.displacementScale = e.DisplacementFactor.value), e.Emissive ? r.emissive = (new i.Ilk).fromArray(e.Emissive.value) : !e.EmissiveColor || "Color" !== e.EmissiveColor.type && "ColorRGB" !== e.EmissiveColor.type || (r.emissive = (new i.Ilk).fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (r.opacity = parseFloat(e.Opacity.value)), r.opacity < 1 && (r.transparent = !0), e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value), e.Shininess && (r.shininess = e.Shininess.value), e.Specular ? r.specular = (new i.Ilk).fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (r.specular = (new i.Ilk).fromArray(e.SpecularColor.value));
            const s = this;
            return hb.get(n).children.forEach((function(e) {
                const n = e.relationship;
                switch (n) {
                    case "Bump":
                        r.bumpMap = s.getTexture(t, e.ID);
                        break;
                    case "Maya|TEX_ao_map":
                        r.aoMap = s.getTexture(t, e.ID);
                        break;
                    case "DiffuseColor":
                    case "Maya|TEX_color_map":
                        r.map = s.getTexture(t, e.ID), void 0 !== r.map && (r.map.encoding = i.knz);
                        break;
                    case "DisplacementColor":
                        r.displacementMap = s.getTexture(t, e.ID);
                        break;
                    case "EmissiveColor":
                        r.emissiveMap = s.getTexture(t, e.ID), void 0 !== r.emissiveMap && (r.emissiveMap.encoding = i.knz);
                        break;
                    case "NormalMap":
                    case "Maya|TEX_normal_map":
                        r.normalMap = s.getTexture(t, e.ID);
                        break;
                    case "ReflectionColor":
                        r.envMap = s.getTexture(t, e.ID), void 0 !== r.envMap && (r.envMap.mapping = i.dSO, r.envMap.encoding = i.knz);
                        break;
                    case "SpecularColor":
                        r.specularMap = s.getTexture(t, e.ID), void 0 !== r.specularMap && (r.specularMap.encoding = i.knz);
                        break;
                    case "TransparentColor":
                    case "TransparencyFactor":
                        r.alphaMap = s.getTexture(t, e.ID), r.transparent = !0;
                        break;
                    case "AmbientColor":
                    case "ShininessExponent":
                    case "SpecularFactor":
                    case "VectorDisplacementColor":
                    default:
                        console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n)
                }
            })), r
        }
        getTexture(e, t) {
            return "LayeredTexture" in pb.Objects && t in pb.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = hb.get(t).children[0].ID), e.get(t)
        }
        parseDeformers() {
            const e = {},
                t = {};
            if ("Deformer" in pb.Objects) {
                const n = pb.Objects.Deformer;
                for (const r in n) {
                    const i = n[r],
                        s = hb.get(parseInt(r));
                    if ("Skin" === i.attrType) {
                        const t = this.parseSkeleton(s, n);
                        t.ID = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), t.geometryID = s.parents[0].ID, e[r] = t
                    } else if ("BlendShape" === i.attrType) {
                        const e = {
                            id: r
                        };
                        e.rawTargets = this.parseMorphTargets(s, n), e.id = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[r] = e
                    }
                }
            }
            return {
                skeletons: e,
                morphTargets: t
            }
        }
        parseSkeleton(e, t) {
            const n = [];
            return e.children.forEach((function(e) {
                const r = t[e.ID];
                if ("Cluster" !== r.attrType) return;
                const s = {
                    ID: e.ID,
                    indices: [],
                    weights: [],
                    transformLink: (new i.yGw).fromArray(r.TransformLink.a)
                };
                "Indexes" in r && (s.indices = r.Indexes.a, s.weights = r.Weights.a), n.push(s)
            })), {
                rawBones: n,
                bones: []
            }
        }
        parseMorphTargets(e, t) {
            const n = [];
            for (let r = 0; r < e.children.length; r++) {
                const i = e.children[r],
                    s = t[i.ID],
                    o = {
                        name: s.attrName,
                        initialWeight: s.DeformPercent,
                        id: s.id,
                        fullWeights: s.FullWeights.a
                    };
                if ("BlendShapeChannel" !== s.attrType) return;
                o.geoID = hb.get(parseInt(i.ID)).children.filter((function(e) {
                    return void 0 === e.relationship
                }))[0].ID, n.push(o)
            }
            return n
        }
        parseScene(e, t, n) {
            db = new i.ZAu;
            const r = this.parseModels(e.skeletons, t, n),
                s = pb.Objects.Model,
                o = this;
            r.forEach((function(e) {
                const t = s[e.ID];
                o.setLookAtProperties(e, t), hb.get(e.ID).parents.forEach((function(t) {
                    const n = r.get(t.ID);
                    void 0 !== n && n.add(e)
                })), null === e.parent && db.add(e)
            })), this.bindSkeleton(e.skeletons, t, r), this.createAmbientLight(), db.traverse((function(e) {
                if (e.userData.transformData) {
                    e.parent && (e.userData.transformData.parentMatrix = e.parent.matrix, e.userData.transformData.parentMatrixWorld = e.parent.matrixWorld);
                    const t = Cb(e.userData.transformData);
                    e.applyMatrix4(t), e.updateWorldMatrix()
                }
            }));
            const a = (new gb).parse();
            1 === db.children.length && db.children[0].isGroup && (db.children[0].animations = a, db = db.children[0]), db.animations = a
        }
        parseModels(e, t, n) {
            const r = new Map,
                s = pb.Objects.Model;
            for (const o in s) {
                const a = parseInt(o),
                    l = s[o],
                    c = hb.get(a);
                let u = this.buildSkeleton(c, e, a, l.attrName);
                if (!u) {
                    switch (l.attrType) {
                        case "Camera":
                            u = this.createCamera(c);
                            break;
                        case "Light":
                            u = this.createLight(c);
                            break;
                        case "Mesh":
                            u = this.createMesh(c, t, n);
                            break;
                        case "NurbsCurve":
                            u = this.createCurve(c, t);
                            break;
                        case "LimbNode":
                        case "Root":
                            u = new i.N$j;
                            break;
                        case "Null":
                        default:
                            u = new i.ZAu
                    }
                    u.name = l.attrName ? i.iUV.sanitizeNodeName(l.attrName) : "", u.ID = a
                }
                this.getTransformData(u, l), r.set(a, u)
            }
            return r
        }
        buildSkeleton(e, t, n, r) {
            let s = null;
            return e.parents.forEach((function(e) {
                for (const o in t) {
                    const a = t[o];
                    a.rawBones.forEach((function(t, o) {
                        if (t.ID === e.ID) {
                            const e = s;
                            s = new i.N$j, s.matrixWorld.copy(t.transformLink), s.name = r ? i.iUV.sanitizeNodeName(r) : "", s.ID = n, a.bones[o] = s, null !== e && s.add(e)
                        }
                    }))
                }
            })), s
        }
        createCamera(e) {
            let t, n;
            if (e.children.forEach((function(e) {
                    const t = pb.Objects.NodeAttribute[e.ID];
                    void 0 !== t && (n = t)
                })), void 0 === n) t = new i.Tme;
            else {
                let e = 0;
                void 0 !== n.CameraProjectionType && 1 === n.CameraProjectionType.value && (e = 1);
                let r = 1;
                void 0 !== n.NearPlane && (r = n.NearPlane.value / 1e3);
                let s = 1e3;
                void 0 !== n.FarPlane && (s = n.FarPlane.value / 1e3);
                let o = window.innerWidth,
                    a = window.innerHeight;
                void 0 !== n.AspectWidth && void 0 !== n.AspectHeight && (o = n.AspectWidth.value, a = n.AspectHeight.value);
                const l = o / a;
                let c = 45;
                void 0 !== n.FieldOfView && (c = n.FieldOfView.value);
                const u = n.FocalLength ? n.FocalLength.value : null;
                switch (e) {
                    case 0:
                        t = new i.cPb(c, l, r, s), null !== u && t.setFocalLength(u);
                        break;
                    case 1:
                        t = new i.iKG(-o / 2, o / 2, a / 2, -a / 2, r, s);
                        break;
                    default:
                        console.warn("THREE.FBXLoader: Unknown camera type " + e + "."), t = new i.Tme
                }
            }
            return t
        }
        createLight(e) {
            let t, n;
            if (e.children.forEach((function(e) {
                    const t = pb.Objects.NodeAttribute[e.ID];
                    void 0 !== t && (n = t)
                })), void 0 === n) t = new i.Tme;
            else {
                let e;
                e = void 0 === n.LightType ? 0 : n.LightType.value;
                let r = 16777215;
                void 0 !== n.Color && (r = (new i.Ilk).fromArray(n.Color.value));
                let s = void 0 === n.Intensity ? 1 : n.Intensity.value / 100;
                void 0 !== n.CastLightOnObject && 0 === n.CastLightOnObject.value && (s = 0);
                let o = 0;
                void 0 !== n.FarAttenuationEnd && (o = void 0 !== n.EnableFarAttenuation && 0 === n.EnableFarAttenuation.value ? 0 : n.FarAttenuationEnd.value);
                const a = 1;
                switch (e) {
                    case 0:
                        t = new i.cek(r, s, o, a);
                        break;
                    case 1:
                        t = new i.Ox3(r, s);
                        break;
                    case 2:
                        let e = Math.PI / 3;
                        void 0 !== n.InnerAngle && (e = i.M8C.degToRad(n.InnerAngle.value));
                        let l = 0;
                        void 0 !== n.OuterAngle && (l = i.M8C.degToRad(n.OuterAngle.value), l = Math.max(l, 1)), t = new i.PMe(r, s, o, e, l, a);
                        break;
                    default:
                        console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new i.cek(r, s)
                }
                void 0 !== n.CastShadows && 1 === n.CastShadows.value && (t.castShadow = !0)
            }
            return t
        }
        createMesh(e, t, n) {
            let r, s = null,
                o = null;
            const a = [];
            return e.children.forEach((function(e) {
                t.has(e.ID) && (s = t.get(e.ID)), n.has(e.ID) && a.push(n.get(e.ID))
            })), a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new i.xoR({
                color: 13421772
            }), a.push(o)), "color" in s.attributes && a.forEach((function(e) {
                e.vertexColors = !0
            })), s.FBX_Deformer ? (r = new i.TUv(s, o), r.normalizeSkinWeights()) : r = new i.Kj0(s, o), r
        }
        createCurve(e, t) {
            const n = e.children.reduce((function(e, n) {
                    return t.has(n.ID) && (e = t.get(n.ID)), e
                }), null),
                r = new i.nls({
                    color: 3342591,
                    linewidth: 1
                });
            return new i.x12(n, r)
        }
        getTransformData(e, t) {
            const n = {};
            "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), n.eulerOrder = "RotationOrder" in t ? Rb(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n
        }
        setLookAtProperties(e, t) {
            "LookAtProperty" in t && hb.get(e.ID).children.forEach((function(t) {
                if ("LookAtProperty" === t.relationship) {
                    const n = pb.Objects.Model[t.ID];
                    if ("Lcl_Translation" in n) {
                        const t = n.Lcl_Translation.value;
                        void 0 !== e.target ? (e.target.position.fromArray(t), db.add(e.target)) : e.lookAt((new i.Pa4).fromArray(t))
                    }
                }
            }))
        }
        bindSkeleton(e, t, n) {
            const r = this.parsePoseNodes();
            for (const s in e) {
                const o = e[s];
                hb.get(parseInt(o.ID)).parents.forEach((function(e) {
                    if (t.has(e.ID)) {
                        const t = e.ID;
                        hb.get(t).parents.forEach((function(e) {
                            n.has(e.ID) && n.get(e.ID).bind(new i.OdW(o.bones), r[e.ID])
                        }))
                    }
                }))
            }
        }
        parsePoseNodes() {
            const e = {};
            if ("Pose" in pb.Objects) {
                const t = pb.Objects.Pose;
                for (const n in t)
                    if ("BindPose" === t[n].attrType && t[n].NbPoseNodes > 0) {
                        const r = t[n].PoseNode;
                        Array.isArray(r) ? r.forEach((function(t) {
                            e[t.Node] = (new i.yGw).fromArray(t.Matrix.a)
                        })) : e[r.Node] = (new i.yGw).fromArray(r.Matrix.a)
                    }
            }
            return e
        }
        createAmbientLight() {
            if ("GlobalSettings" in pb && "AmbientColor" in pb.GlobalSettings) {
                const e = pb.GlobalSettings.AmbientColor.value,
                    t = e[0],
                    n = e[1],
                    r = e[2];
                if (0 !== t || 0 !== n || 0 !== r) {
                    const e = new i.Ilk(t, n, r);
                    db.add(new i.Mig(e, 1))
                }
            }
        }
    }
    class mb {
        parse(e) {
            const t = new Map;
            if ("Geometry" in pb.Objects) {
                const n = pb.Objects.Geometry;
                for (const r in n) {
                    const i = hb.get(parseInt(r)),
                        s = this.parseGeometry(i, n[r], e);
                    t.set(parseInt(r), s)
                }
            }
            return t
        }
        parseGeometry(e, t, n) {
            switch (t.attrType) {
                case "Mesh":
                    return this.parseMeshGeometry(e, t, n);
                case "NurbsCurve":
                    return this.parseNurbsGeometry(t)
            }
        }
        parseMeshGeometry(e, t, n) {
            const r = n.skeletons,
                i = [],
                s = e.parents.map((function(e) {
                    return pb.Objects.Model[e.ID]
                }));
            if (0 === s.length) return;
            const o = e.children.reduce((function(e, t) {
                return void 0 !== r[t.ID] && (e = r[t.ID]), e
            }), null);
            e.children.forEach((function(e) {
                void 0 !== n.morphTargets[e.ID] && i.push(n.morphTargets[e.ID])
            }));
            const a = s[0],
                l = {};
            "RotationOrder" in a && (l.eulerOrder = Rb(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
            const c = Cb(l);
            return this.genGeometry(t, o, i, c)
        }
        genGeometry(e, t, n, r) {
            const s = new i.u9r;
            e.attrName && (s.name = e.attrName);
            const o = this.parseGeoNode(e, t),
                a = this.genBuffers(o),
                l = new i.a$l(a.vertex, 3);
            if (l.applyMatrix4(r), s.setAttribute("position", l), a.colors.length > 0 && s.setAttribute("color", new i.a$l(a.colors, 3)), t && (s.setAttribute("skinIndex", new i.qlB(a.weightsIndices, 4)), s.setAttribute("skinWeight", new i.a$l(a.vertexWeights, 4)), s.FBX_Deformer = t), a.normal.length > 0) {
                const e = (new i.Vkp).getNormalMatrix(r),
                    t = new i.a$l(a.normal, 3);
                t.applyNormalMatrix(e), s.setAttribute("normal", t)
            }
            if (a.uvs.forEach((function(e, t) {
                    let n = "uv" + (t + 1).toString();
                    0 === t && (n = "uv"), s.setAttribute(n, new i.a$l(a.uvs[t], 2))
                })), o.material && "AllSame" !== o.material.mappingType) {
                let e = a.materialIndex[0],
                    t = 0;
                if (a.materialIndex.forEach((function(n, r) {
                        n !== e && (s.addGroup(t, r - t, e), e = n, t = r)
                    })), s.groups.length > 0) {
                    const t = s.groups[s.groups.length - 1],
                        n = t.start + t.count;
                    n !== a.materialIndex.length && s.addGroup(n, a.materialIndex.length - n, e)
                }
                0 === s.groups.length && s.addGroup(0, a.materialIndex.length, a.materialIndex[0])
            }
            return this.addMorphTargets(s, e, n, r), s
        }
        parseGeoNode(e, t) {
            const n = {};
            if (n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [], n.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
                n.uv = [];
                let t = 0;
                for (; e.LayerElementUV[t];) e.LayerElementUV[t].UV && n.uv.push(this.parseUVs(e.LayerElementUV[t])), t++
            }
            return n.weightTable = {}, null !== t && (n.skeleton = t, t.rawBones.forEach((function(e, t) {
                e.indices.forEach((function(r, i) {
                    void 0 === n.weightTable[r] && (n.weightTable[r] = []), n.weightTable[r].push({
                        id: t,
                        weight: e.weights[i]
                    })
                }))
            }))), n
        }
        genBuffers(e) {
            const t = {
                vertex: [],
                normal: [],
                colors: [],
                uvs: [],
                materialIndex: [],
                vertexWeights: [],
                weightsIndices: []
            };
            let n = 0,
                r = 0,
                i = !1,
                s = [],
                o = [],
                a = [],
                l = [],
                c = [],
                u = [];
            const p = this;
            return e.vertexIndices.forEach((function(h, d) {
                let f, _ = !1;
                h < 0 && (h ^= -1, _ = !0);
                let m = [],
                    g = [];
                if (s.push(3 * h, 3 * h + 1, 3 * h + 2), e.color) {
                    const t = Tb(d, n, h, e.color);
                    a.push(t[0], t[1], t[2])
                }
                if (e.skeleton) {
                    if (void 0 !== e.weightTable[h] && e.weightTable[h].forEach((function(e) {
                            g.push(e.weight), m.push(e.id)
                        })), g.length > 4) {
                        i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0);
                        const e = [0, 0, 0, 0],
                            t = [0, 0, 0, 0];
                        g.forEach((function(n, r) {
                            let i = n,
                                s = m[r];
                            t.forEach((function(t, n, r) {
                                if (i > t) {
                                    r[n] = i, i = t;
                                    const o = e[n];
                                    e[n] = s, s = o
                                }
                            }))
                        })), m = e, g = t
                    }
                    for (; g.length < 4;) g.push(0), m.push(0);
                    for (let e = 0; e < 4; ++e) c.push(g[e]), u.push(m[e])
                }
                if (e.normal) {
                    const t = Tb(d, n, h, e.normal);
                    o.push(t[0], t[1], t[2])
                }
                e.material && "AllSame" !== e.material.mappingType && (f = Tb(d, n, h, e.material)[0]), e.uv && e.uv.forEach((function(e, t) {
                    const r = Tb(d, n, h, e);
                    void 0 === l[t] && (l[t] = []), l[t].push(r[0]), l[t].push(r[1])
                })), r++, _ && (p.genFace(t, e, s, f, o, a, l, c, u, r), n++, r = 0, s = [], o = [], a = [], l = [], c = [], u = [])
            })), t
        }
        genFace(e, t, n, r, i, s, o, a, l, c) {
            for (let u = 2; u < c; u++) e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[3 * (u - 1)]]), e.vertex.push(t.vertexPositions[n[3 * (u - 1) + 1]]), e.vertex.push(t.vertexPositions[n[3 * (u - 1) + 2]]), e.vertex.push(t.vertexPositions[n[3 * u]]), e.vertex.push(t.vertexPositions[n[3 * u + 1]]), e.vertex.push(t.vertexPositions[n[3 * u + 2]]), t.skeleton && (e.vertexWeights.push(a[0]), e.vertexWeights.push(a[1]), e.vertexWeights.push(a[2]), e.vertexWeights.push(a[3]), e.vertexWeights.push(a[4 * (u - 1)]), e.vertexWeights.push(a[4 * (u - 1) + 1]), e.vertexWeights.push(a[4 * (u - 1) + 2]), e.vertexWeights.push(a[4 * (u - 1) + 3]), e.vertexWeights.push(a[4 * u]), e.vertexWeights.push(a[4 * u + 1]), e.vertexWeights.push(a[4 * u + 2]), e.vertexWeights.push(a[4 * u + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[4 * (u - 1)]), e.weightsIndices.push(l[4 * (u - 1) + 1]), e.weightsIndices.push(l[4 * (u - 1) + 2]), e.weightsIndices.push(l[4 * (u - 1) + 3]), e.weightsIndices.push(l[4 * u]), e.weightsIndices.push(l[4 * u + 1]), e.weightsIndices.push(l[4 * u + 2]), e.weightsIndices.push(l[4 * u + 3])), t.color && (e.colors.push(s[0]), e.colors.push(s[1]), e.colors.push(s[2]), e.colors.push(s[3 * (u - 1)]), e.colors.push(s[3 * (u - 1) + 1]), e.colors.push(s[3 * (u - 1) + 2]), e.colors.push(s[3 * u]), e.colors.push(s[3 * u + 1]), e.colors.push(s[3 * u + 2])), t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(r), e.materialIndex.push(r), e.materialIndex.push(r)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[3 * (u - 1)]), e.normal.push(i[3 * (u - 1) + 1]), e.normal.push(i[3 * (u - 1) + 2]), e.normal.push(i[3 * u]), e.normal.push(i[3 * u + 1]), e.normal.push(i[3 * u + 2])), t.uv && t.uv.forEach((function(t, n) {
                void 0 === e.uvs[n] && (e.uvs[n] = []), e.uvs[n].push(o[n][0]), e.uvs[n].push(o[n][1]), e.uvs[n].push(o[n][2 * (u - 1)]), e.uvs[n].push(o[n][2 * (u - 1) + 1]), e.uvs[n].push(o[n][2 * u]), e.uvs[n].push(o[n][2 * u + 1])
            }))
        }
        addMorphTargets(e, t, n, r) {
            if (0 === n.length) return;
            e.morphTargetsRelative = !0, e.morphAttributes.position = [];
            const i = this;
            n.forEach((function(n) {
                n.rawTargets.forEach((function(n) {
                    const s = pb.Objects.Geometry[n.geoID];
                    void 0 !== s && i.genMorphGeometry(e, t, s, r, n.name)
                }))
            }))
        }
        genMorphGeometry(e, t, n, r, s) {
            const o = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [],
                a = void 0 !== n.Vertices ? n.Vertices.a : [],
                l = void 0 !== n.Indexes ? n.Indexes.a : [],
                c = 3 * e.attributes.position.count,
                u = new Float32Array(c);
            for (let e = 0; e < l.length; e++) {
                const t = 3 * l[e];
                u[t] = a[3 * e], u[t + 1] = a[3 * e + 1], u[t + 2] = a[3 * e + 2]
            }
            const p = {
                    vertexIndices: o,
                    vertexPositions: u
                },
                h = this.genBuffers(p),
                d = new i.a$l(h.vertex, 3);
            d.name = s || n.attrName, d.applyMatrix4(r), e.morphAttributes.position.push(d)
        }
        parseNormals(e) {
            const t = e.MappingInformationType,
                n = e.ReferenceInformationType,
                r = e.Normals.a;
            let i = [];
            return "IndexToDirect" === n && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
                dataSize: 3,
                buffer: r,
                indices: i,
                mappingType: t,
                referenceType: n
            }
        }
        parseUVs(e) {
            const t = e.MappingInformationType,
                n = e.ReferenceInformationType,
                r = e.UV.a;
            let i = [];
            return "IndexToDirect" === n && (i = e.UVIndex.a), {
                dataSize: 2,
                buffer: r,
                indices: i,
                mappingType: t,
                referenceType: n
            }
        }
        parseVertexColors(e) {
            const t = e.MappingInformationType,
                n = e.ReferenceInformationType,
                r = e.Colors.a;
            let i = [];
            return "IndexToDirect" === n && (i = e.ColorIndex.a), {
                dataSize: 4,
                buffer: r,
                indices: i,
                mappingType: t,
                referenceType: n
            }
        }
        parseMaterialIndices(e) {
            const t = e.MappingInformationType,
                n = e.ReferenceInformationType;
            if ("NoMappingInformation" === t) return {
                dataSize: 1,
                buffer: [0],
                indices: [0],
                mappingType: "AllSame",
                referenceType: n
            };
            const r = e.Materials.a,
                i = [];
            for (let e = 0; e < r.length; ++e) i.push(e);
            return {
                dataSize: 1,
                buffer: r,
                indices: i,
                mappingType: t,
                referenceType: n
            }
        }
        parseNurbsGeometry(e) {
            if (void 0 === ub) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new i.u9r;
            const t = parseInt(e.Order);
            if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new i.u9r;
            const n = t - 1,
                r = e.KnotVector.a,
                s = [],
                o = e.Points.a;
            for (let e = 0, t = o.length; e < t; e += 4) s.push((new i.Ltg).fromArray(o, e));
            let a, l;
            if ("Closed" === e.Form) s.push(s[0]);
            else if ("Periodic" === e.Form) {
                a = n, l = r.length - 1 - a;
                for (let e = 0; e < n; ++e) s.push(s[e])
            }
            const c = new ub(n, r, s, a, l).getPoints(12 * s.length);
            return (new i.u9r).setFromPoints(c)
        }
    }
    class gb {
        parse() {
            const e = [],
                t = this.parseClips();
            if (void 0 !== t)
                for (const n in t) {
                    const r = t[n],
                        i = this.addClip(r);
                    e.push(i)
                }
            return e
        }
        parseClips() {
            if (void 0 === pb.Objects.AnimationCurve) return;
            const e = this.parseAnimationCurveNodes();
            this.parseAnimationCurves(e);
            const t = this.parseAnimationLayers(e);
            return this.parseAnimStacks(t)
        }
        parseAnimationCurveNodes() {
            const e = pb.Objects.AnimationCurveNode,
                t = new Map;
            for (const n in e) {
                const r = e[n];
                if (null !== r.attrName.match(/S|R|T|DeformPercent/)) {
                    const e = {
                        id: r.id,
                        attr: r.attrName,
                        curves: {}
                    };
                    t.set(e.id, e)
                }
            }
            return t
        }
        parseAnimationCurves(e) {
            const t = pb.Objects.AnimationCurve;
            for (const n in t) {
                const r = {
                        id: t[n].id,
                        times: t[n].KeyTime.a.map(Sb),
                        values: t[n].KeyValueFloat.a
                    },
                    i = hb.get(r.id);
                if (void 0 !== i) {
                    const t = i.parents[0].ID,
                        n = i.parents[0].relationship;
                    n.match(/X/) ? e.get(t).curves.x = r : n.match(/Y/) ? e.get(t).curves.y = r : n.match(/Z/) ? e.get(t).curves.z = r : n.match(/d|DeformPercent/) && e.has(t) && (e.get(t).curves.morph = r)
                }
            }
        }
        parseAnimationLayers(e) {
            const t = pb.Objects.AnimationLayer,
                n = new Map;
            for (const r in t) {
                const t = [],
                    s = hb.get(parseInt(r));
                void 0 !== s && (s.children.forEach((function(n, r) {
                    if (e.has(n.ID)) {
                        const s = e.get(n.ID);
                        if (void 0 !== s.curves.x || void 0 !== s.curves.y || void 0 !== s.curves.z) {
                            if (void 0 === t[r]) {
                                const e = hb.get(n.ID).parents.filter((function(e) {
                                    return void 0 !== e.relationship
                                }))[0].ID;
                                if (void 0 !== e) {
                                    const s = pb.Objects.Model[e.toString()];
                                    if (void 0 === s) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", n);
                                    const o = {
                                        modelName: s.attrName ? i.iUV.sanitizeNodeName(s.attrName) : "",
                                        ID: s.id,
                                        initialPosition: [0, 0, 0],
                                        initialRotation: [0, 0, 0],
                                        initialScale: [1, 1, 1]
                                    };
                                    db.traverse((function(e) {
                                        e.ID === s.id && (o.transform = e.matrix, e.userData.transformData && (o.eulerOrder = e.userData.transformData.eulerOrder))
                                    })), o.transform || (o.transform = new i.yGw), "PreRotation" in s && (o.preRotation = s.PreRotation.value), "PostRotation" in s && (o.postRotation = s.PostRotation.value), t[r] = o
                                }
                            }
                            t[r] && (t[r][s.attr] = s)
                        } else if (void 0 !== s.curves.morph) {
                            if (void 0 === t[r]) {
                                const e = hb.get(n.ID).parents.filter((function(e) {
                                        return void 0 !== e.relationship
                                    }))[0].ID,
                                    s = hb.get(e).parents[0].ID,
                                    o = hb.get(s).parents[0].ID,
                                    a = hb.get(o).parents[0].ID,
                                    l = pb.Objects.Model[a],
                                    c = {
                                        modelName: l.attrName ? i.iUV.sanitizeNodeName(l.attrName) : "",
                                        morphName: pb.Objects.Deformer[e].attrName
                                    };
                                t[r] = c
                            }
                            t[r][s.attr] = s
                        }
                    }
                })), n.set(parseInt(r), t))
            }
            return n
        }
        parseAnimStacks(e) {
            const t = pb.Objects.AnimationStack,
                n = {};
            for (const r in t) {
                const i = hb.get(parseInt(r)).children;
                i.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                const s = e.get(i[0].ID);
                n[r] = {
                    name: t[r].attrName,
                    layer: s
                }
            }
            return n
        }
        addClip(e) {
            let t = [];
            const n = this;
            return e.layer.forEach((function(e) {
                t = t.concat(n.generateTracks(e))
            })), new i.m7l(e.name, -1, t)
        }
        generateTracks(e) {
            const t = [];
            let n = new i.Pa4,
                r = new i._fP,
                s = new i.Pa4;
            if (e.transform && e.transform.decompose(n, r, s), n = n.toArray(), r = (new i.USm).setFromQuaternion(r, e.eulerOrder).toArray(), s = s.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) {
                const r = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
                void 0 !== r && t.push(r)
            }
            if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
                const n = this.generateRotationTrack(e.modelName, e.R.curves, r, e.preRotation, e.postRotation, e.eulerOrder);
                void 0 !== n && t.push(n)
            }
            if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
                const n = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
                void 0 !== n && t.push(n)
            }
            if (void 0 !== e.DeformPercent) {
                const n = this.generateMorphTrack(e);
                void 0 !== n && t.push(n)
            }
            return t
        }
        generateVectorTrack(e, t, n, r) {
            const s = this.getTimesForAllAxes(t),
                o = this.getKeyframeTrackValues(s, t, n);
            return new i.yC1(e + "." + r, s, o)
        }
        generateRotationTrack(e, t, n, r, s, o) {
            void 0 !== t.x && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(i.M8C.degToRad)), void 0 !== t.y && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(i.M8C.degToRad)), void 0 !== t.z && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(i.M8C.degToRad));
            const a = this.getTimesForAllAxes(t),
                l = this.getKeyframeTrackValues(a, t, n);
            void 0 !== r && ((r = r.map(i.M8C.degToRad)).push(o), r = (new i.USm).fromArray(r), r = (new i._fP).setFromEuler(r)), void 0 !== s && ((s = s.map(i.M8C.degToRad)).push(o), s = (new i.USm).fromArray(s), s = (new i._fP).setFromEuler(s).invert());
            const c = new i._fP,
                u = new i.USm,
                p = [];
            for (let e = 0; e < l.length; e += 3) u.set(l[e], l[e + 1], l[e + 2], o), c.setFromEuler(u), void 0 !== r && c.premultiply(r), void 0 !== s && c.multiply(s), c.toArray(p, e / 3 * 4);
            return new i.iLg(e + ".quaternion", a, p)
        }
        generateMorphTrack(e) {
            const t = e.DeformPercent.curves.morph,
                n = t.values.map((function(e) {
                    return e / 100
                })),
                r = db.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
            return new i.dUE(e.modelName + ".morphTargetInfluences[" + r + "]", t.times, n)
        }
        getTimesForAllAxes(e) {
            let t = [];
            if (void 0 !== e.x && (t = t.concat(e.x.times)), void 0 !== e.y && (t = t.concat(e.y.times)), void 0 !== e.z && (t = t.concat(e.z.times)), t = t.sort((function(e, t) {
                    return e - t
                })), t.length > 1) {
                let e = 1,
                    n = t[0];
                for (let r = 1; r < t.length; r++) {
                    const i = t[r];
                    i !== n && (t[e] = i, n = i, e++)
                }
                t = t.slice(0, e)
            }
            return t
        }
        getKeyframeTrackValues(e, t, n) {
            const r = n,
                i = [];
            let s = -1,
                o = -1,
                a = -1;
            return e.forEach((function(e) {
                if (t.x && (s = t.x.times.indexOf(e)), t.y && (o = t.y.times.indexOf(e)), t.z && (a = t.z.times.indexOf(e)), -1 !== s) {
                    const e = t.x.values[s];
                    i.push(e), r[0] = e
                } else i.push(r[0]);
                if (-1 !== o) {
                    const e = t.y.values[o];
                    i.push(e), r[1] = e
                } else i.push(r[1]);
                if (-1 !== a) {
                    const e = t.z.values[a];
                    i.push(e), r[2] = e
                } else i.push(r[2])
            })), i
        }
        interpolateRotations(e) {
            for (let t = 1; t < e.values.length; t++) {
                const n = e.values[t - 1],
                    r = e.values[t] - n,
                    i = Math.abs(r);
                if (i >= 180) {
                    const s = i / 180,
                        o = r / s;
                    let a = n + o;
                    const l = e.times[t - 1],
                        c = (e.times[t] - l) / s;
                    let u = l + c;
                    const p = [],
                        h = [];
                    for (; u < e.times[t];) p.push(u), u += c, h.push(a), a += o;
                    e.times = Db(e.times, t, p), e.values = Db(e.values, t, h)
                }
            }
        }
    }
    class vb {
        getPrevNode() {
            return this.nodeStack[this.currentIndent - 2]
        }
        getCurrentNode() {
            return this.nodeStack[this.currentIndent - 1]
        }
        getCurrentProp() {
            return this.currentProp
        }
        pushStack(e) {
            this.nodeStack.push(e), this.currentIndent += 1
        }
        popStack() {
            this.nodeStack.pop(), this.currentIndent -= 1
        }
        setCurrentProp(e, t) {
            this.currentProp = e, this.currentPropName = t
        }
        parse(e) {
            this.currentIndent = 0, this.allNodes = new yb, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
            const t = this,
                n = e.split(/[\r\n]+/);
            return n.forEach((function(e, r) {
                const i = e.match(/^[\s\t]*;/),
                    s = e.match(/^[\s\t]*$/);
                if (i || s) return;
                const o = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""),
                    a = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
                    l = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
                o ? t.parseNodeBegin(e, o) : a ? t.parseNodeProperty(e, a, n[++r]) : l ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e)
            })), this.allNodes
        }
        parseNodeBegin(e, t) {
            const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
                r = t[2].split(",").map((function(e) {
                    return e.trim().replace(/^"/, "").replace(/"$/, "")
                })),
                i = {
                    name: n
                },
                s = this.parseNodeAttr(r),
                o = this.getCurrentNode();
            0 === this.currentIndent ? this.allNodes.add(n, i) : n in o ? ("PoseNode" === n ? o.PoseNode.push(i) : void 0 !== o[n].id && (o[n] = {}, o[n][o[n].id] = o[n]), "" !== s.id && (o[n][s.id] = i)) : "number" == typeof s.id ? (o[n] = {}, o[n][s.id] = i) : "Properties70" !== n && (o[n] = "PoseNode" === n ? [i] : i), "number" == typeof s.id && (i.id = s.id), "" !== s.name && (i.attrName = s.name), "" !== s.type && (i.attrType = s.type), this.pushStack(i)
        }
        parseNodeAttr(e) {
            let t = e[0];
            "" !== e[0] && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
            let n = "",
                r = "";
            return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), r = e[2]), {
                id: t,
                name: n,
                type: r
            }
        }
        parseNodeProperty(e, t, n) {
            let r = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
                i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
            "Content" === r && "," === i && (i = n.replace(/"/g, "").replace(/,$/, "").trim());
            const s = this.getCurrentNode();
            if ("Properties70" !== s.name) {
                if ("C" === r) {
                    const e = i.split(",").slice(1),
                        t = parseInt(e[0]),
                        n = parseInt(e[1]);
                    let o = i.split(",").slice(3);
                    o = o.map((function(e) {
                            return e.trim().replace(/^"/, "")
                        })), r = "connections", i = [t, n],
                        function(e, t) {
                            for (let n = 0, r = e.length, i = t.length; n < i; n++, r++) e[r] = t[n]
                        }(i, o), void 0 === s[r] && (s[r] = [])
                }
                "Node" === r && (s.id = i), r in s && Array.isArray(s[r]) ? s[r].push(i) : "a" !== r ? s[r] = i : s.a = i, this.setCurrentProp(s, r), "a" === r && "," !== i.slice(-1) && (s.a = kb(i))
            } else this.parseNodeSpecialProperty(e, r, i)
        }
        parseNodePropertyContinued(e) {
            const t = this.getCurrentNode();
            t.a += e, "," !== e.slice(-1) && (t.a = kb(t.a))
        }
        parseNodeSpecialProperty(e, t, n) {
            const r = n.split('",').map((function(e) {
                    return e.trim().replace(/^\"/, "").replace(/\s/, "_")
                })),
                i = r[0],
                s = r[1],
                o = r[2],
                a = r[3];
            let l = r[4];
            switch (s) {
                case "int":
                case "enum":
                case "bool":
                case "ULongLong":
                case "double":
                case "Number":
                case "FieldOfView":
                    l = parseFloat(l);
                    break;
                case "Color":
                case "ColorRGB":
                case "Vector3D":
                case "Lcl_Translation":
                case "Lcl_Rotation":
                case "Lcl_Scaling":
                    l = kb(l)
            }
            this.getPrevNode()[i] = {
                type: s,
                type2: o,
                flag: a,
                value: l
            }, this.setCurrentProp(this.getPrevNode(), i)
        }
    }
    class bb {
        parse(e) {
            const t = new xb(e);
            t.skip(23);
            const n = t.getUint32();
            if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
            const r = new yb;
            for (; !this.endOfContent(t);) {
                const e = this.parseNode(t, n);
                null !== e && r.add(e.name, e)
            }
            return r
        }
        endOfContent(e) {
            return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size()
        }
        parseNode(e, t) {
            const n = {},
                r = t >= 7500 ? e.getUint64() : e.getUint32(),
                i = t >= 7500 ? e.getUint64() : e.getUint32();
            t >= 7500 ? e.getUint64() : e.getUint32();
            const s = e.getUint8(),
                o = e.getString(s);
            if (0 === r) return null;
            const a = [];
            for (let t = 0; t < i; t++) a.push(this.parseProperty(e));
            const l = a.length > 0 ? a[0] : "",
                c = a.length > 1 ? a[1] : "",
                u = a.length > 2 ? a[2] : "";
            for (n.singleProperty = 1 === i && e.getOffset() === r; r > e.getOffset();) {
                const r = this.parseNode(e, t);
                null !== r && this.parseSubNode(o, n, r)
            }
            return n.propertyList = a, "number" == typeof l && (n.id = l), "" !== c && (n.attrName = c), "" !== u && (n.attrType = u), "" !== o && (n.name = o), n
        }
        parseSubNode(e, t, n) {
            if (!0 === n.singleProperty) {
                const e = n.propertyList[0];
                Array.isArray(e) ? (t[n.name] = n, n.a = e) : t[n.name] = e
            } else if ("Connections" === e && "C" === n.name) {
                const e = [];
                n.propertyList.forEach((function(t, n) {
                    0 !== n && e.push(t)
                })), void 0 === t.connections && (t.connections = []), t.connections.push(e)
            } else if ("Properties70" === n.name) Object.keys(n).forEach((function(e) {
                t[e] = n[e]
            }));
            else if ("Properties70" === e && "P" === n.name) {
                let e = n.propertyList[0],
                    r = n.propertyList[1];
                const i = n.propertyList[2],
                    s = n.propertyList[3];
                let o;
                0 === e.indexOf("Lcl ") && (e = e.replace("Lcl ", "Lcl_")), 0 === r.indexOf("Lcl ") && (r = r.replace("Lcl ", "Lcl_")), o = "Color" === r || "ColorRGB" === r || "Vector" === r || "Vector3D" === r || 0 === r.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], t[e] = {
                    type: r,
                    type2: i,
                    flag: s,
                    value: o
                }
            } else void 0 === t[n.name] ? "number" == typeof n.id ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : "PoseNode" === n.name ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n)
        }
        parseProperty(e) {
            const t = e.getString(1);
            let r;
            switch (t) {
                case "C":
                    return e.getBoolean();
                case "D":
                    return e.getFloat64();
                case "F":
                    return e.getFloat32();
                case "I":
                    return e.getInt32();
                case "L":
                    return e.getInt64();
                case "R":
                    return r = e.getUint32(), e.getArrayBuffer(r);
                case "S":
                    return r = e.getUint32(), e.getString(r);
                case "Y":
                    return e.getInt16();
                case "b":
                case "c":
                case "d":
                case "f":
                case "i":
                case "l":
                    const i = e.getUint32(),
                        s = e.getUint32(),
                        o = e.getUint32();
                    if (0 === s) switch (t) {
                        case "b":
                        case "c":
                            return e.getBooleanArray(i);
                        case "d":
                            return e.getFloat64Array(i);
                        case "f":
                            return e.getFloat32Array(i);
                        case "i":
                            return e.getInt32Array(i);
                        case "l":
                            return e.getInt64Array(i)
                    }
                    void 0 === n && console.error("THREE.FBXLoader: External library fflate.min.js required.");
                    const a = Av(new Uint8Array(e.getArrayBuffer(o))),
                        l = new xb(a.buffer);
                    switch (t) {
                        case "b":
                        case "c":
                            return l.getBooleanArray(i);
                        case "d":
                            return l.getFloat64Array(i);
                        case "f":
                            return l.getFloat32Array(i);
                        case "i":
                            return l.getInt32Array(i);
                        case "l":
                            return l.getInt64Array(i)
                    }
                    break;
                default:
                    throw new Error("THREE.FBXLoader: Unknown property type " + t)
            }
        }
    }
    class xb {
        constructor(e, t) {
            this.dv = new DataView(e), this.offset = 0, this.littleEndian = void 0 === t || t
        }
        getOffset() {
            return this.offset
        }
        size() {
            return this.dv.buffer.byteLength
        }
        skip(e) {
            this.offset += e
        }
        getBoolean() {
            return 1 == (1 & this.getUint8())
        }
        getBooleanArray(e) {
            const t = [];
            for (let n = 0; n < e; n++) t.push(this.getBoolean());
            return t
        }
        getUint8() {
            const e = this.dv.getUint8(this.offset);
            return this.offset += 1, e
        }
        getInt16() {
            const e = this.dv.getInt16(this.offset, this.littleEndian);
            return this.offset += 2, e
        }
        getInt32() {
            const e = this.dv.getInt32(this.offset, this.littleEndian);
            return this.offset += 4, e
        }
        getInt32Array(e) {
            const t = [];
            for (let n = 0; n < e; n++) t.push(this.getInt32());
            return t
        }
        getUint32() {
            const e = this.dv.getUint32(this.offset, this.littleEndian);
            return this.offset += 4, e
        }
        getInt64() {
            let e, t;
            return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, e = 4294967295 & ~e, 4294967295 === e && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(4294967296 * t + e)) : 4294967296 * t + e
        }
        getInt64Array(e) {
            const t = [];
            for (let n = 0; n < e; n++) t.push(this.getInt64());
            return t
        }
        getUint64() {
            let e, t;
            return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e
        }
        getFloat32() {
            const e = this.dv.getFloat32(this.offset, this.littleEndian);
            return this.offset += 4, e
        }
        getFloat32Array(e) {
            const t = [];
            for (let n = 0; n < e; n++) t.push(this.getFloat32());
            return t
        }
        getFloat64() {
            const e = this.dv.getFloat64(this.offset, this.littleEndian);
            return this.offset += 8, e
        }
        getFloat64Array(e) {
            const t = [];
            for (let n = 0; n < e; n++) t.push(this.getFloat64());
            return t
        }
        getArrayBuffer(e) {
            const t = this.dv.buffer.slice(this.offset, this.offset + e);
            return this.offset += e, t
        }
        getString(e) {
            let t = [];
            for (let n = 0; n < e; n++) t[n] = this.getUint8();
            const n = t.indexOf(0);
            return n >= 0 && (t = t.slice(0, n)), i.Zp0.decodeText(new Uint8Array(t))
        }
    }
    class yb {
        add(e, t) {
            this[e] = t
        }
    }

    function wb(e) {
        const t = e.match(/FBXVersion: (\d+)/);
        if (t) return parseInt(t[1]);
        throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
    }

    function Sb(e) {
        return e / 46186158e3
    }
    const Mb = [];

    function Tb(e, t, n, r) {
        let i;
        switch (r.mappingType) {
            case "ByPolygonVertex":
                i = e;
                break;
            case "ByPolygon":
                i = t;
                break;
            case "ByVertice":
                i = n;
                break;
            case "AllSame":
                i = r.indices[0];
                break;
            default:
                console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType)
        }
        "IndexToDirect" === r.referenceType && (i = r.indices[i]);
        const s = i * r.dataSize,
            o = s + r.dataSize;
        return function(e, t, n, r) {
            for (let i = n, s = 0; i < r; i++, s++) e[s] = t[i];
            return e
        }(Mb, r.buffer, s, o)
    }
    const Eb = new i.USm,
        Ab = new i.Pa4;

    function Cb(e) {
        const t = new i.yGw,
            n = new i.yGw,
            r = new i.yGw,
            s = new i.yGw,
            o = new i.yGw,
            a = new i.yGw,
            l = new i.yGw,
            c = new i.yGw,
            u = new i.yGw,
            p = new i.yGw,
            h = new i.yGw,
            d = new i.yGw,
            f = e.inheritType ? e.inheritType : 0;
        if (e.translation && t.setPosition(Ab.fromArray(e.translation)), e.preRotation) {
            const t = e.preRotation.map(i.M8C.degToRad);
            t.push(e.eulerOrder), n.makeRotationFromEuler(Eb.fromArray(t))
        }
        if (e.rotation) {
            const t = e.rotation.map(i.M8C.degToRad);
            t.push(e.eulerOrder), r.makeRotationFromEuler(Eb.fromArray(t))
        }
        if (e.postRotation) {
            const t = e.postRotation.map(i.M8C.degToRad);
            t.push(e.eulerOrder), s.makeRotationFromEuler(Eb.fromArray(t)), s.invert()
        }
        e.scale && o.scale(Ab.fromArray(e.scale)), e.scalingOffset && l.setPosition(Ab.fromArray(e.scalingOffset)), e.scalingPivot && a.setPosition(Ab.fromArray(e.scalingPivot)), e.rotationOffset && c.setPosition(Ab.fromArray(e.rotationOffset)), e.rotationPivot && u.setPosition(Ab.fromArray(e.rotationPivot)), e.parentMatrixWorld && (h.copy(e.parentMatrix), p.copy(e.parentMatrixWorld));
        const _ = n.clone().multiply(r).multiply(s),
            m = new i.yGw;
        m.extractRotation(p);
        const g = new i.yGw;
        g.copyPosition(p);
        const v = g.clone().invert().multiply(p),
            b = m.clone().invert().multiply(v),
            x = o,
            y = new i.yGw;
        if (0 === f) y.copy(m).multiply(_).multiply(b).multiply(x);
        else if (1 === f) y.copy(m).multiply(b).multiply(_).multiply(x);
        else {
            const e = (new i.yGw).scale((new i.Pa4).setFromMatrixScale(h)).clone().invert(),
                t = b.clone().multiply(e);
            y.copy(m).multiply(_).multiply(t).multiply(x)
        }
        const w = u.clone().invert(),
            S = a.clone().invert();
        let M = t.clone().multiply(c).multiply(u).multiply(n).multiply(r).multiply(s).multiply(w).multiply(l).multiply(a).multiply(o).multiply(S);
        const T = (new i.yGw).copyPosition(M),
            E = p.clone().multiply(T);
        return d.copyPosition(E), M = d.clone().multiply(y), M.premultiply(p.invert()), M
    }

    function Rb(e) {
        const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
        return 6 === (e = e || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[e]
    }

    function kb(e) {
        return e.split(",").map((function(e) {
            return parseFloat(e)
        }))
    }

    function Pb(e, t, n) {
        return void 0 === t && (t = 0), void 0 === n && (n = e.byteLength), i.Zp0.decodeText(new Uint8Array(e, t, n))
    }

    function Db(e, t, n) {
        return e.slice(0, t).concat(n).concat(e.slice(t))
    }
    class Ob extends r {
        constructor() {
            super(...arguments), this.dependencies = [Vs], this._importer = new $t(fb, ["fbx"], !0)
        }
        async onAdded(e) {
            Us.Importers.push(this._importer)
        }
        async onDispose(e) {}
        async onRemove(e) {
            Us.Importers.splice(Us.Importers.indexOf(this._importer), 1)
        }
    }
    Ob.PluginType = "FBXLoadPlugin";
    const Lb = new WeakMap;
    class Ib extends i.aNw {
        constructor(e) {
            super(e), this.libraryPath = "", this.libraryPending = null, this.libraryBinary = null, this.libraryConfig = {}, this.url = "", this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.workerConfig = {}, this.materials = [], this.warnings = []
        }
        setLibraryPath(e) {
            return this.libraryPath = e, this
        }
        setWorkerLimit(e) {
            return this.workerLimit = e, this
        }
        load(e, t, n, r) {
            const s = new i.hH6(this.manager);
            s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), this.url = e, s.load(e, (n => {
                if (Lb.has(n)) return Lb.get(n).promise.then(t).catch(r);
                this.decodeObjects(n, e).then((e => {
                    e.userData.warnings = this.warnings, t(e)
                })).catch((e => r(e)))
            }), n, r)
        }
        debug() {
            console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
        }
        decodeObjects(e, t) {
            let n, r;
            const i = e.byteLength,
                s = this._getWorker(i).then((t => (n = t, r = this.workerNextTaskID++, new Promise(((t, i) => {
                    n._callbacks[r] = {
                        resolve: t,
                        reject: i
                    }, n.postMessage({
                        type: "decode",
                        id: r,
                        buffer: e
                    }, [e])
                }))))).then((e => this._createGeometry(e.data))).catch((e => {
                    throw e
                }));
            return s.catch((() => !0)).then((() => {
                n && r && this._releaseTask(n, r)
            })), Lb.set(e, {
                url: t,
                promise: s
            }), s
        }
        parse(e, t, n) {
            this.decodeObjects(e, "").then((e => {
                e.userData.warnings = this.warnings, t(e)
            })).catch((e => n(e)))
        }
        _compareMaterials(e) {
            const t = {};
            t.name = e.name, t.color = {}, t.color.r = e.color.r, t.color.g = e.color.g, t.color.b = e.color.b, t.type = e.type;
            for (let e = 0; e < this.materials.length; e++) {
                const n = this.materials[e],
                    r = {};
                if (r.name = n.name, r.color = {}, r.color.r = n.color.r, r.color.g = n.color.g, r.color.b = n.color.b, r.type = n.type, JSON.stringify(t) === JSON.stringify(r)) return n
            }
            return this.materials.push(e), e
        }
        _createMaterial(e) {
            if (void 0 === e) return new i.Wid({
                color: new i.Ilk(1, 1, 1),
                metalness: .8,
                name: "default",
                side: 2
            });
            const t = e.diffuseColor,
                n = new i.Ilk(t.r / 255, t.g / 255, t.b / 255);
            0 === t.r && 0 === t.g && 0 === t.b && (n.r = 1, n.g = 1, n.b = 1);
            const r = new i.Wid({
                    color: n,
                    name: e.name,
                    side: 2,
                    transparent: e.transparency > 0,
                    opacity: 1 - e.transparency
                }),
                s = new i.dpR;
            for (let t = 0; t < e.textures.length; t++) {
                const n = e.textures[t];
                if (null !== n.image) {
                    const e = s.load(n.image);
                    switch (n.type) {
                        case "Diffuse":
                            r.map = e;
                            break;
                        case "Bump":
                            r.bumpMap = e;
                            break;
                        case "Transparency":
                            r.alphaMap = e, r.transparent = !0;
                            break;
                        case "Emap":
                            r.envMap = e
                    }
                    e.wrapS = 0 === n.wrapU ? i.rpg : i.uWy, e.wrapT = 0 === n.wrapV ? i.rpg : i.uWy, e.repeat.set(n.repeat[0], n.repeat[1])
                }
            }
            return r
        }
        _createGeometry(e) {
            const t = new i.Tme,
                n = [],
                r = [],
                s = [];
            t.userData.layers = e.layers, t.userData.groups = e.groups, t.userData.settings = e.settings, t.userData.objectType = "File3dm", t.userData.materials = null, t.name = this.url;
            let o = e.objects;
            const a = e.materials;
            for (let i = 0; i < o.length; i++) {
                const l = o[i],
                    c = l.attributes;
                switch (l.objectType) {
                    case "InstanceDefinition":
                        r.push(l);
                        break;
                    case "InstanceReference":
                        s.push(l);
                        break;
                    default:
                        let i;
                        if (c.materialIndex >= 0) {
                            const e = a[c.materialIndex];
                            let t = this._createMaterial(e);
                            t = this._compareMaterials(t), i = this._createObject(l, t)
                        } else {
                            const e = this._createMaterial();
                            i = this._createObject(l, e)
                        }
                        if (void 0 === i) continue;
                        const o = e.layers[c.layerIndex];
                        i.visible = !o || e.layers[c.layerIndex].visible, c.isInstanceDefinitionObject ? n.push(i) : t.add(i)
                }
            }
            for (let e = 0; e < r.length; e++) {
                const a = r[e];
                o = [];
                for (let e = 0; e < a.attributes.objectIds.length; e++) {
                    const t = a.attributes.objectIds[e];
                    for (let e = 0; e < n.length; e++) t === n[e].userData.attributes.id && o.push(n[e])
                }
                for (let e = 0; e < s.length; e++) {
                    const n = s[e];
                    if (n.geometry.parentIdefId === a.attributes.id) {
                        const e = new i.Tme,
                            r = n.geometry.xform.array,
                            s = new i.yGw;
                        s.set(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]), e.applyMatrix4(s);
                        for (let t = 0; t < o.length; t++) e.add(o[t].clone(!0));
                        t.add(e)
                    }
                }
            }
            return t.userData.materials = this.materials, t
        }
        _createObject(e, t) {
            const n = new i.s4_,
                r = e.attributes;
            let s, o, a, l;
            switch (e.objectType) {
                case "Point":
                case "PointSet":
                    s = n.parse(e.geometry), s.attributes.hasOwnProperty("color") ? o = new i.UY4({
                        vertexColors: !0,
                        sizeAttenuation: !1,
                        size: 2
                    }) : (a = r.drawColor, l = new i.Ilk(a.r / 255, a.g / 255, a.b / 255), o = new i.UY4({
                        color: l,
                        sizeAttenuation: !1,
                        size: 2
                    })), o = this._compareMaterials(o);
                    const c = new i.woe(s, o);
                    return c.userData.attributes = r, c.userData.objectType = e.objectType, r.name && (c.name = r.name), c;
                case "Mesh":
                case "Extrusion":
                case "SubD":
                case "Brep":
                    if (null === e.geometry) return;
                    s = n.parse(e.geometry), s.attributes.hasOwnProperty("color") && (t.vertexColors = !0), null === t && (t = this._createMaterial(), t = this._compareMaterials(t));
                    const u = new i.Kj0(s, t);
                    return u.castShadow = r.castsShadows, u.receiveShadow = r.receivesShadows, u.userData.attributes = r, u.userData.objectType = e.objectType, r.name && (u.name = r.name), u;
                case "Curve":
                    s = n.parse(e.geometry), a = r.drawColor, l = new i.Ilk(a.r / 255, a.g / 255, a.b / 255), o = new i.nls({
                        color: l
                    }), o = this._compareMaterials(o);
                    const p = new i.x12(s, o);
                    return p.userData.attributes = r, p.userData.objectType = e.objectType, r.name && (p.name = r.name), p;
                case "TextDot":
                    s = e.geometry;
                    const h = document.createElement("canvas").getContext("2d"),
                        d = `${s.fontHeight}px ${s.fontFace}`;
                    h.font = d;
                    const f = h.measureText(s.text).width + 10,
                        _ = s.fontHeight + 10,
                        m = window.devicePixelRatio;
                    h.canvas.width = f * m, h.canvas.height = _ * m, h.canvas.style.width = f + "px", h.canvas.style.height = _ + "px", h.setTransform(m, 0, 0, m, 0, 0), h.font = d, h.textBaseline = "middle", h.textAlign = "center", l = r.drawColor, h.fillStyle = `rgba(${l.r},${l.g},${l.b},${l.a})`, h.fillRect(0, 0, f, _), h.fillStyle = "white", h.fillText(s.text, f / 2, _ / 2);
                    const g = new i.ROQ(h.canvas);
                    g.minFilter = i.wem, g.wrapS = i.uWy, g.wrapT = i.uWy, o = new i.xeV({
                        map: g,
                        depthTest: !1
                    });
                    const v = new i.jyi(o);
                    return v.position.set(s.point[0], s.point[1], s.point[2]), v.scale.set(f / 10, _ / 10, 1), v.userData.attributes = r, v.userData.objectType = e.objectType, r.name && (v.name = r.name), v;
                case "Light":
                    let b;
                    switch (s = e.geometry, s.lightStyle.name) {
                        case "LightStyle_WorldPoint":
                            b = new i.cek, b.castShadow = r.castsShadows, b.position.set(s.location[0], s.location[1], s.location[2]), b.shadow.normalBias = .1;
                            break;
                        case "LightStyle_WorldSpot":
                            b = new i.PMe, b.castShadow = r.castsShadows, b.position.set(s.location[0], s.location[1], s.location[2]), b.target.position.set(s.direction[0], s.direction[1], s.direction[2]), b.angle = s.spotAngleRadians, b.shadow.normalBias = .1;
                            break;
                        case "LightStyle_WorldRectangular":
                            b = new i.T_f;
                            const e = Math.abs(s.width[2]),
                                t = Math.abs(s.length[0]);
                            b.position.set(s.location[0] - t / 2, s.location[1], s.location[2] - e / 2), b.height = t, b.width = e, b.lookAt(new i.Pa4(s.direction[0], s.direction[1], s.direction[2]));
                            break;
                        case "LightStyle_WorldDirectional":
                            b = new i.Ox3, b.castShadow = r.castsShadows, b.position.set(s.location[0], s.location[1], s.location[2]), b.target.position.set(s.direction[0], s.direction[1], s.direction[2]), b.shadow.normalBias = .1
                    }
                    return b && (b.intensity = s.intensity, a = s.diffuse, l = new i.Ilk(a.r / 255, a.g / 255, a.b / 255), b.color = l, b.userData.attributes = r, b.userData.objectType = e.objectType), b
            }
        }
        _initLibrary() {
            if (!this.libraryPending) {
                const e = new i.hH6(this.manager);
                e.setPath(this.libraryPath);
                const t = new Promise(((t, n) => {
                        e.load("rhino3dm.js", t, void 0, n)
                    })),
                    n = new i.hH6(this.manager);
                n.setPath(this.libraryPath), n.setResponseType("arraybuffer");
                const r = new Promise(((e, t) => {
                    n.load("rhino3dm.wasm", e, void 0, t)
                }));
                this.libraryPending = Promise.all([t, r]).then((([e, t]) => {
                    this.libraryConfig.wasmBinary = t;
                    const n = Fb.toString(),
                        r = ["/* rhino3dm.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                }))
            }
            return this.libraryPending
        }
        _getWorker(e) {
            return this._initLibrary().then((() => {
                if (this.workerPool.length < this.workerLimit) {
                    const e = new Worker(this.workerSourceURL);
                    e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                        type: "init",
                        libraryConfig: this.libraryConfig
                    }), e.onmessage = t => {
                        const n = t.data;
                        switch (n.type) {
                            case "warning":
                                this.warnings.push(n.data), console.warn(n.data);
                                break;
                            case "decode":
                                e._callbacks[n.id].resolve(n);
                                break;
                            case "error":
                                e._callbacks[n.id].reject(n);
                                break;
                            default:
                                console.error('THREE.Rhino3dmLoader: Unexpected message, "' + n.type + '"')
                        }
                    }, this.workerPool.push(e)
                } else this.workerPool.sort((function(e, t) {
                    return e._taskLoad > t._taskLoad ? -1 : 1
                }));
                const t = this.workerPool[this.workerPool.length - 1];
                return t._taskLoad += e, t
            }))
        }
        _releaseTask(e, t) {
            e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
        }
        dispose() {
            for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
            return this.workerPool.length = 0, this
        }
    }

    function Fb() {
        let e, t, n, r;

        function i(e, t) {
            const i = e.geometry(),
                a = e.attributes();
            let l, c, u, p, h, d = i.objectType;
            switch (d) {
                case n.ObjectType.Curve:
                    const e = o(i, 100);
                    u = {}, c = {}, p = {}, u.itemSize = 3, u.type = "Float32Array", u.array = [];
                    for (let t = 0; t < e.length; t++) u.array.push(e[t][0]), u.array.push(e[t][1]), u.array.push(e[t][2]);
                    c.position = u, p.attributes = c, l = {
                        data: p
                    };
                    break;
                case n.ObjectType.Point:
                    const f = i.location;
                    u = {};
                    const _ = {};
                    c = {}, p = {}, u.itemSize = 3, u.type = "Float32Array", u.array = [f[0], f[1], f[2]];
                    const m = a.drawColor(t);
                    _.itemSize = 3, _.type = "Float32Array", _.array = [m.r / 255, m.g / 255, m.b / 255], c.position = u, c.color = _, p.attributes = c, l = {
                        data: p
                    };
                    break;
                case n.ObjectType.PointSet:
                case n.ObjectType.Mesh:
                    l = i.toThreejsJSON();
                    break;
                case n.ObjectType.Brep:
                    const g = i.faces();
                    h = new n.Mesh;
                    for (let e = 0; e < g.count; e++) {
                        const t = g.get(e),
                            r = t.getMesh(n.MeshType.Any);
                        r && (h.append(r), r.delete()), t.delete()
                    }
                    h.faces().count > 0 && (h.compact(), l = h.toThreejsJSON(), g.delete()), h.delete();
                    break;
                case n.ObjectType.Extrusion:
                    h = i.getMesh(n.MeshType.Any), h && (l = h.toThreejsJSON(), h.delete());
                    break;
                case n.ObjectType.TextDot:
                    l = s(i);
                    break;
                case n.ObjectType.Light:
                    l = s(i), "LightStyle_WorldLinear" === l.lightStyle.name && self.postMessage({
                        type: "warning",
                        id: r,
                        data: {
                            message: `THREE.3DMLoader: No conversion exists for ${d.constructor.name} ${l.lightStyle.name}`,
                            type: "no conversion",
                            guid: a.id
                        }
                    });
                    break;
                case n.ObjectType.InstanceReference:
                    l = s(i), l.xform = s(i.xform), l.xform.array = i.xform.toFloatArray(!0);
                    break;
                case n.ObjectType.SubD:
                    i.subdivide(3), h = n.Mesh.createFromSubDControlNet(i), h && (l = h.toThreejsJSON(), h.delete());
                    break;
                default:
                    self.postMessage({
                        type: "warning",
                        id: r,
                        data: {
                            message: `THREE.3DMLoader: Conversion not implemented for ${d.constructor.name}`,
                            type: "not implemented",
                            guid: a.id
                        }
                    })
            }
            if (l) return c = s(a), c.geometry = s(i), a.groupCount > 0 && (c.groupIds = a.getGroupList()), a.userStringCount > 0 && (c.userStrings = a.getUserStrings()), i.userStringCount > 0 && (c.geometry.userStrings = i.getUserStrings()), c.drawColor = a.drawColor(t), d = d.constructor.name, d = d.substring(11, d.length), {
                geometry: l,
                attributes: c,
                objectType: d
            };
            self.postMessage({
                type: "warning",
                id: r,
                data: {
                    message: `THREE.3DMLoader: ${d.constructor.name} has no associated mesh geometry.`,
                    type: "missing mesh",
                    guid: a.id
                }
            })
        }

        function s(e) {
            const t = {};
            for (const n in e) {
                const r = e[n];
                "function" != typeof r && ("object" == typeof r && null !== r && r.hasOwnProperty("constructor") ? t[n] = {
                    name: r.constructor.name,
                    value: r.value
                } : t[n] = r)
            }
            return t
        }

        function o(e, t) {
            let r = t,
                i = [];
            const s = [];
            if (e instanceof n.LineCurve) return [e.pointAtStart, e.pointAtEnd];
            if (e instanceof n.PolylineCurve) {
                r = e.pointCount;
                for (let t = 0; t < r; t++) i.push(e.point(t));
                return i
            }
            if (e instanceof n.PolyCurve) {
                const t = e.segmentCount;
                for (let n = 0; n < t; n++) {
                    const t = e.segmentCurve(n),
                        s = o(t, r);
                    i = i.concat(s), t.delete()
                }
                return i
            }
            if (e instanceof n.ArcCurve && (r = Math.floor(e.angleDegrees / 5), r = r < 2 ? 2 : r), e instanceof n.NurbsCurve && 1 === e.degree) {
                const t = e.tryGetPolyline();
                for (let e = 0; e < t.count; e++) i.push(t.get(e));
                return t.delete(), i
            }
            const a = e.domain,
                l = r - 1;
            for (let t = 0; t < r; t++) {
                const n = a[0] + t / l * (a[1] - a[0]);
                if (n === a[0] || n === a[1]) {
                    s.push(n);
                    continue
                }
                const r = e.tangentAt(n),
                    i = e.tangentAt(s.slice(-1)[0]),
                    o = r[0] * r[0] + r[1] * r[1] + r[2] * r[2],
                    c = i[0] * i[0] + i[1] * i[1] + i[2] * i[2],
                    u = Math.sqrt(o * c);
                let p;
                if (0 === u) p = Math.PI / 2;
                else {
                    const e = (r.x * i.x + r.y * i.y + r.z * i.z) / u;
                    p = Math.acos(Math.max(-1, Math.min(1, e)))
                }
                p < .1 || s.push(n)
            }
            return i = s.map((t => e.pointAt(t))), i
        }
        onmessage = function(o) {
            const a = o.data;
            switch (a.type) {
                case "init":
                    t = a.libraryConfig;
                    const o = t.wasmBinary;
                    let l;
                    e = new Promise((function(e) {
                        l = {
                            wasmBinary: o,
                            onRuntimeInitialized: e
                        }, rhino3dm(l)
                    })).then((() => {
                        n = l
                    }));
                    break;
                case "decode":
                    r = a.id;
                    const c = a.buffer;
                    e.then((() => {
                        try {
                            const e = function(e, t) {
                                const n = new Uint8Array(t),
                                    o = e.File3dm.fromByteArray(n),
                                    a = [],
                                    l = [],
                                    c = [],
                                    u = [],
                                    p = [],
                                    h = [],
                                    d = [],
                                    f = o.objects(),
                                    _ = f.count;
                                for (let e = 0; e < _; e++) {
                                    const t = f.get(e),
                                        n = i(t, o);
                                    t.delete(), n && a.push(n)
                                }
                                for (let e = 0; e < o.instanceDefinitions().count(); e++) {
                                    const t = o.instanceDefinitions().get(e),
                                        n = s(t);
                                    n.objectIds = t.getObjectIds(), a.push({
                                        geometry: null,
                                        attributes: n,
                                        objectType: "InstanceDefinition"
                                    })
                                }
                                const m = [e.TextureType.Diffuse, e.TextureType.Bump, e.TextureType.Transparency, e.TextureType.Opacity, e.TextureType.Emap],
                                    g = [e.TextureType.PBR_BaseColor, e.TextureType.PBR_Subsurface, e.TextureType.PBR_SubsurfaceScattering, e.TextureType.PBR_SubsurfaceScatteringRadius, e.TextureType.PBR_Metallic, e.TextureType.PBR_Specular, e.TextureType.PBR_SpecularTint, e.TextureType.PBR_Roughness, e.TextureType.PBR_Anisotropic, e.TextureType.PBR_Anisotropic_Rotation, e.TextureType.PBR_Sheen, e.TextureType.PBR_SheenTint, e.TextureType.PBR_Clearcoat, e.TextureType.PBR_ClearcoatBump, e.TextureType.PBR_ClearcoatRoughness, e.TextureType.PBR_OpacityIor, e.TextureType.PBR_OpacityRoughness, e.TextureType.PBR_Emission, e.TextureType.PBR_AmbientOcclusion, e.TextureType.PBR_Displacement];
                                for (let e = 0; e < o.materials().count(); e++) {
                                    const t = o.materials().get(e),
                                        n = t.physicallyBased();
                                    let i = s(t);
                                    const a = [];
                                    for (let e = 0; e < m.length; e++) {
                                        const n = t.getTexture(m[e]);
                                        if (n) {
                                            let t = m[e].constructor.name;
                                            t = t.substring(12, t.length);
                                            const i = {
                                                    type: t
                                                },
                                                s = o.getEmbeddedFileAsBase64(n.fileName);
                                            i.wrapU = n.wrapU, i.wrapV = n.wrapV, i.wrapW = n.wrapW;
                                            const l = n.uvwTransform.toFloatArray(!0);
                                            i.repeat = [l[0], l[5]], s ? i.image = "data:image/png;base64," + s : (self.postMessage({
                                                type: "warning",
                                                id: r,
                                                data: {
                                                    message: `THREE.3DMLoader: Image for ${t} texture not embedded in file.`,
                                                    type: "missing resource"
                                                }
                                            }), i.image = null), a.push(i), n.delete()
                                        }
                                    }
                                    if (i.textures = a, n.supported) {
                                        for (let e = 0; e < g.length; e++) {
                                            const n = t.getTexture(g[e]);
                                            if (n) {
                                                const t = o.getEmbeddedFileAsBase64(n.fileName);
                                                let r = g[e].constructor.name;
                                                r = r.substring(12, r.length);
                                                const i = {
                                                    type: r,
                                                    image: "data:image/png;base64," + t
                                                };
                                                a.push(i), n.delete()
                                            }
                                        }
                                        const e = s(t.physicallyBased());
                                        i = Object.assign(e, i)
                                    }
                                    l.push(i), t.delete(), n.delete()
                                }
                                for (let e = 0; e < o.layers().count(); e++) {
                                    const t = o.layers().get(e),
                                        n = s(t);
                                    c.push(n), t.delete()
                                }
                                for (let e = 0; e < o.views().count(); e++) {
                                    const t = o.views().get(e),
                                        n = s(t);
                                    u.push(n), t.delete()
                                }
                                for (let e = 0; e < o.namedViews().count(); e++) {
                                    const t = o.namedViews().get(e),
                                        n = s(t);
                                    p.push(n), t.delete()
                                }
                                for (let e = 0; e < o.groups().count(); e++) {
                                    const t = o.groups().get(e),
                                        n = s(t);
                                    h.push(n), t.delete()
                                }
                                const v = s(o.settings()),
                                    b = o.strings().count();
                                for (let e = 0; e < b; e++) d.push(o.strings().get(e));
                                return o.delete(), {
                                    objects: a,
                                    materials: l,
                                    layers: c,
                                    views: u,
                                    namedViews: p,
                                    groups: h,
                                    strings: d,
                                    settings: v
                                }
                            }(n, c);
                            self.postMessage({
                                type: "decode",
                                id: a.id,
                                data: e
                            })
                        } catch (e) {
                            self.postMessage({
                                type: "error",
                                id: a.id,
                                error: e
                            })
                        }
                    }))
            }
        }
    }
    class Nb extends Ib {
        constructor(e) {
            super(e), this.setLibraryPath("https://cdn.jsdelivr.net/npm/rhino3dm@7.11.1/")
        }
        async loadAsync(e, t) {
            return await super.loadAsync(e, t)
        }
    }
    class Ub extends r {
        constructor() {
            super(...arguments), this.dependencies = [Vs], this._importer = new $t(Nb, ["3dm"], !0)
        }
        async onAdded(e) {
            Us.Importers.push(this._importer)
        }
        async onDispose(e) {}
        async onRemove(e) {
            Us.Importers.splice(Us.Importers.indexOf(this._importer), 1)
        }
    }
    Ub.PluginType = "Rhino3dmLoadPlugin";
    class Bb extends r {
        constructor() {
            super(...arguments), this.dependencies = [Vs]
        }
        async onAdded(e) {
            const t = document.createElement("script");
            t.type = "module", t.innerHTML = "\nimport { MeshoptDecoder } from 'https://cdn.jsdelivr.net/gh/zeux/meshoptimizer@master/js/meshopt_decoder.module.js'\nwindow.MeshoptDecoder = MeshoptDecoder\n", document.head.appendChild(t), this._script = t
        }
        async onDispose(e) {}
        async onRemove(e) {
            this._script && (document.head.removeChild(this._script), this._script = void 0)
        }
    }
    Bb.PluginType = "GLTFMeshOptPlugin";
    class jb extends i.aNw {
        constructor(e) {
            super(e)
        }
        load(e, t, n, r) {
            const s = this,
                o = new i.hH6(this.manager);
            o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(n) {
                try {
                    t(s.parse(n))
                } catch (t) {
                    r ? r(t) : console.error(t), s.manager.itemError(e)
                }
            }), n, r)
        }
        parse(e) {
            function t(e, t, n) {
                for (let r = 0, i = e.length; r < i; r++)
                    if (e[r] !== t.getUint8(n + r)) return !1;
                return !0
            }
            const n = function(e) {
                if ("string" == typeof e) {
                    const t = new Uint8Array(e.length);
                    for (let n = 0; n < e.length; n++) t[n] = 255 & e.charCodeAt(n);
                    return t.buffer || t
                }
                return e
            }(e);
            return function(e) {
                const n = new DataView(e);
                if (84 + 50 * n.getUint32(80, !0) === n.byteLength) return !0;
                const r = [115, 111, 108, 105, 100];
                for (let e = 0; e < 5; e++)
                    if (t(r, n, e)) return !1;
                return !0
            }(n) ? function(e) {
                const t = new DataView(e),
                    n = t.getUint32(80, !0);
                let r, s, o, a, l, c, u, p, h = !1;
                for (let e = 0; e < 70; e++) 1129270351 == t.getUint32(e, !1) && 82 == t.getUint8(e + 4) && 61 == t.getUint8(e + 5) && (h = !0, a = new Float32Array(3 * n * 3), l = t.getUint8(e + 6) / 255, c = t.getUint8(e + 7) / 255, u = t.getUint8(e + 8) / 255, p = t.getUint8(e + 9) / 255);
                const d = new i.u9r,
                    f = new Float32Array(3 * n * 3),
                    _ = new Float32Array(3 * n * 3);
                for (let e = 0; e < n; e++) {
                    const n = 84 + 50 * e,
                        i = t.getFloat32(n, !0),
                        p = t.getFloat32(n + 4, !0),
                        d = t.getFloat32(n + 8, !0);
                    if (h) {
                        const e = t.getUint16(n + 48, !0);
                        0 == (32768 & e) ? (r = (31 & e) / 31, s = (e >> 5 & 31) / 31, o = (e >> 10 & 31) / 31) : (r = l, s = c, o = u)
                    }
                    for (let l = 1; l <= 3; l++) {
                        const c = n + 12 * l,
                            u = 3 * e * 3 + 3 * (l - 1);
                        f[u] = t.getFloat32(c, !0), f[u + 1] = t.getFloat32(c + 4, !0), f[u + 2] = t.getFloat32(c + 8, !0), _[u] = i, _[u + 1] = p, _[u + 2] = d, h && (a[u] = r, a[u + 1] = s, a[u + 2] = o)
                    }
                }
                return d.setAttribute("position", new i.TlE(f, 3)), d.setAttribute("normal", new i.TlE(_, 3)), h && (d.setAttribute("color", new i.TlE(a, 3)), d.hasColors = !0, d.alpha = p), d
            }(n) : function(e) {
                const t = new i.u9r,
                    n = /solid([\s\S]*?)endsolid/g,
                    r = /facet([\s\S]*?)endfacet/g;
                let s = 0;
                const o = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,
                    a = new RegExp("vertex" + o + o + o, "g"),
                    l = new RegExp("normal" + o + o + o, "g"),
                    c = [],
                    u = [],
                    p = new i.Pa4;
                let h, d = 0,
                    f = 0,
                    _ = 0;
                for (; null !== (h = n.exec(e));) {
                    f = _;
                    const e = h[0];
                    for (; null !== (h = r.exec(e));) {
                        let e = 0,
                            t = 0;
                        const n = h[0];
                        for (; null !== (h = l.exec(n));) p.x = parseFloat(h[1]), p.y = parseFloat(h[2]), p.z = parseFloat(h[3]), t++;
                        for (; null !== (h = a.exec(n));) c.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3])), u.push(p.x, p.y, p.z), e++, _++;
                        1 !== t && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + s), 3 !== e && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + s), s++
                    }
                    const n = f,
                        i = _ - f;
                    t.addGroup(n, i, d), d++
                }
                return t.setAttribute("position", new i.a$l(c, 3)), t.setAttribute("normal", new i.a$l(u, 3)), t
            }("string" != typeof(r = e) ? i.Zp0.decodeText(new Uint8Array(r)) : r);
            var r
        }
    }
    class zb extends r {
        constructor() {
            super(...arguments), this.dependencies = [Vs]
        }
        async onAdded(e) {
            this._importer || (this._importer = new $t(jb, ["stl"], !0)), Us.Importers.push(this._importer)
        }
        async onDispose(e) {
            this._importer = void 0
        }
        async onRemove(e) {
            this._importer && Us.Importers.splice(Us.Importers.indexOf(this._importer), 1), this._importer = void 0
        }
    }
    zb.PluginType = "STLLoadPlugin";
    class Vb extends i.aNw {
        constructor(e) {
            super(e)
        }
        load(e, t, n, r) {
            const s = this,
                o = "" === this.path ? i.Zp0.extractUrlBase(e) : this.path,
                a = new i.hH6(this.manager);
            a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function(n) {
                try {
                    t(s.parse(n, o))
                } catch (t) {
                    r ? r(t) : console.error(t), s.manager.itemError(e)
                }
            }), n, r)
        }
        setMaterialOptions(e) {
            return this.materialOptions = e, this
        }
        parse(e, t) {
            const n = e.split("\n");
            let r = {};
            const i = /\s+/,
                s = {};
            for (let e = 0; e < n.length; e++) {
                let t = n[e];
                if (t = t.trim(), 0 === t.length || "#" === t.charAt(0)) continue;
                const o = t.indexOf(" ");
                let a = o >= 0 ? t.substring(0, o) : t;
                a = a.toLowerCase();
                let l = o >= 0 ? t.substring(o + 1) : "";
                if (l = l.trim(), "newmtl" === a) r = {
                    name: l
                }, s[l] = r;
                else if ("ka" === a || "kd" === a || "ks" === a || "ke" === a) {
                    const e = l.split(i, 3);
                    r[a] = [parseFloat(e[0]), parseFloat(e[1]), parseFloat(e[2])]
                } else r[a] = l
            }
            const o = new Gb(this.resourcePath || t, this.materialOptions);
            return o.setCrossOrigin(this.crossOrigin), o.setManager(this.manager), o.setMaterials(s), o
        }
    }
    class Gb {
        constructor(e = "", t = {}) {
            this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.crossOrigin = "anonymous", this.side = void 0 !== this.options.side ? this.options.side : i.Wl3, this.wrap = void 0 !== this.options.wrap ? this.options.wrap : i.rpg
        }
        setCrossOrigin(e) {
            return this.crossOrigin = e, this
        }
        setManager(e) {
            this.manager = e
        }
        setMaterials(e) {
            this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {}
        }
        convert(e) {
            if (!this.options) return e;
            const t = {};
            for (const n in e) {
                const r = e[n],
                    i = {};
                t[n] = i;
                for (const e in r) {
                    let t = !0,
                        n = r[e];
                    const s = e.toLowerCase();
                    switch (s) {
                        case "kd":
                        case "ka":
                        case "ks":
                            this.options && this.options.normalizeRGB && (n = [n[0] / 255, n[1] / 255, n[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === n[0] && 0 === n[1] && 0 === n[2] && (t = !1)
                    }
                    t && (i[s] = n)
                }
            }
            return t
        }
        async preload() {
            for (const e in this.materialsInfo) await this.create(e)
        }
        getIndex(e) {
            return this.nameLookup[e]
        }
        async getAsArray() {
            let e = 0;
            for (const t in this.materialsInfo) this.materialsArray[e] = await this.create(t), this.nameLookup[t] = e, e++;
            return this.materialsArray
        }
        async create(e) {
            return void 0 === this.materials[e] && await this.createMaterial_(e), this.materials[e]
        }
        async createMaterial_(e) {
            const t = this,
                n = this.materialsInfo[e],
                r = {
                    name: e,
                    side: this.side
                };
            async function s(e, n) {
                if (r[e]) return;
                const i = t.getTextureParams(n, r);
                return new Promise(((n, s) => {
                    let o = !1,
                        a = () => !o && (o = !0) && n();
                    const l = t.loadTexture((c = t.baseUrl, "string" != typeof(u = i.url) || "" === u ? "" : /^https?:\/\//i.test(u) ? u : c + u), void 0, (t => {
                        r[e] = t, a()
                    }), void 0, a);
                    var c, u;
                    setTimeout(a, 50), l.repeat.copy(i.scale), l.offset.copy(i.offset), l.wrapS = t.wrap, l.wrapT = t.wrap
                }))
            }
            const o = Array.from(Object.keys(n || {}));
            let a = o.includes("d") || o.includes("D");
            for (const e of o) {
                const t = n[e];
                let o;
                if ("" !== t) switch (e.toLowerCase()) {
                    case "kd":
                        r.color = (new i.Ilk).fromArray(t);
                        break;
                    case "ks":
                        r.specular = (new i.Ilk).fromArray(t);
                        break;
                    case "ke":
                        r.emissive = (new i.Ilk).fromArray(t);
                        break;
                    case "map_kd":
                        await s("map", t);
                        break;
                    case "map_ks":
                        await s("specularMap", t);
                        break;
                    case "map_ke":
                        await s("emissiveMap", t);
                        break;
                    case "norm":
                        await s("normalMap", t);
                        break;
                    case "map_bump":
                    case "bump":
                        await s("bumpMap", t);
                        break;
                    case "map_d":
                        await s("alphaMap", t), r.transparent = !0;
                        break;
                    case "ns":
                        r.shininess = parseFloat(t);
                        break;
                    case "d":
                        o = parseFloat(t), o < 1 && (r.opacity = o, r.transparent = !0);
                        break;
                    case "tr":
                        if (a) break;
                        o = parseFloat(t), this.options && this.options.invertTrProperty && (o = 1 - o), o > 0 && (r.opacity = 1 - o, r.transparent = !0)
                }
            }
            return this.materials[e] = new i.xoR(r), this.materials[e]
        }
        getTextureParams(e, t) {
            const n = {
                    scale: new i.FM8(1, 1),
                    offset: new i.FM8(0, 0)
                },
                r = e.split(/\s+/);
            let s;
            return s = r.indexOf("-bm"), s >= 0 && (t.bumpScale = parseFloat(r[s + 1]), r.splice(s, 2)), s = r.indexOf("-s"), s >= 0 && (n.scale.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), s = r.indexOf("-o"), s >= 0 && (n.offset.set(parseFloat(r[s + 1]), parseFloat(r[s + 2])), r.splice(s, 4)), n.url = r.join(" ").trim(), n
        }
        loadTexture(e, t, n, r, s) {
            const o = void 0 !== this.manager ? this.manager : i.tEQ;
            let a = o.getHandler(e);
            null === a && (a = new i.dpR(o)), a.setCrossOrigin && a.setCrossOrigin(this.crossOrigin);
            const l = a.load(e, n, r, s);
            return void 0 !== t && (l.mapping = t), l
        }
    }
    const Hb = /^[og]\s*(.+)?/,
        Wb = /^mtllib /,
        Kb = /^usemtl /,
        Xb = /^usemap /,
        qb = new i.Pa4,
        Yb = new i.Pa4,
        Zb = new i.Pa4,
        Jb = new i.Pa4,
        $b = new i.Pa4;

    function Qb() {
        const e = {
            objects: [],
            object: {},
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            materials: {},
            materialLibraries: [],
            startObject: function(e, t) {
                if (this.object && !1 === this.object.fromDeclaration) return this.object.name = e, void(this.object.fromDeclaration = !1 !== t);
                const n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
                        name: e || "",
                        fromDeclaration: !1 !== t,
                        geometry: {
                            vertices: [],
                            normals: [],
                            colors: [],
                            uvs: [],
                            hasUVIndices: !1
                        },
                        materials: [],
                        smooth: !0,
                        startMaterial: function(e, t) {
                            const n = this._finalize(!1);
                            n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                            const r = {
                                index: this.materials.length,
                                name: e || "",
                                mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                                smooth: void 0 !== n ? n.smooth : this.smooth,
                                groupStart: void 0 !== n ? n.groupEnd : 0,
                                groupEnd: -1,
                                groupCount: -1,
                                inherited: !1,
                                clone: function(e) {
                                    const t = {
                                        index: "number" == typeof e ? e : this.index,
                                        name: this.name,
                                        mtllib: this.mtllib,
                                        smooth: this.smooth,
                                        groupStart: 0,
                                        groupEnd: -1,
                                        groupCount: -1,
                                        inherited: !1
                                    };
                                    return t.clone = this.clone.bind(t), t
                                }
                            };
                            return this.materials.push(r), r
                        },
                        currentMaterial: function() {
                            if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                        },
                        _finalize: function(e) {
                            const t = this.currentMaterial();
                            if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3, t.groupCount = t.groupEnd - t.groupStart, t.inherited = !1), e && this.materials.length > 1)
                                for (let e = this.materials.length - 1; e >= 0; e--) this.materials[e].groupCount <= 0 && this.materials.splice(e, 1);
                            return e && 0 === this.materials.length && this.materials.push({
                                name: "",
                                smooth: this.smooth
                            }), t
                        }
                    }, n && n.name && "function" == typeof n.clone) {
                    const e = n.clone(0);
                    e.inherited = !0, this.object.materials.push(e)
                }
                this.objects.push(this.object)
            },
            finalize: function() {
                this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
            },
            parseVertexIndex: function(e, t) {
                const n = parseInt(e, 10);
                return 3 * (n >= 0 ? n - 1 : n + t / 3)
            },
            parseNormalIndex: function(e, t) {
                const n = parseInt(e, 10);
                return 3 * (n >= 0 ? n - 1 : n + t / 3)
            },
            parseUVIndex: function(e, t) {
                const n = parseInt(e, 10);
                return 2 * (n >= 0 ? n - 1 : n + t / 2)
            },
            addVertex: function(e, t, n) {
                const r = this.vertices,
                    i = this.object.geometry.vertices;
                i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[n + 0], r[n + 1], r[n + 2])
            },
            addVertexPoint: function(e) {
                const t = this.vertices;
                this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
            },
            addVertexLine: function(e) {
                const t = this.vertices;
                this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
            },
            addNormal: function(e, t, n) {
                const r = this.normals,
                    i = this.object.geometry.normals;
                i.push(r[e + 0], r[e + 1], r[e + 2]), i.push(r[t + 0], r[t + 1], r[t + 2]), i.push(r[n + 0], r[n + 1], r[n + 2])
            },
            addFaceNormal: function(e, t, n) {
                const r = this.vertices,
                    i = this.object.geometry.normals;
                qb.fromArray(r, e), Yb.fromArray(r, t), Zb.fromArray(r, n), $b.subVectors(Zb, Yb), Jb.subVectors(qb, Yb), $b.cross(Jb), $b.normalize(), i.push($b.x, $b.y, $b.z), i.push($b.x, $b.y, $b.z), i.push($b.x, $b.y, $b.z)
            },
            addColor: function(e, t, n) {
                const r = this.colors,
                    i = this.object.geometry.colors;
                void 0 !== r[e] && i.push(r[e + 0], r[e + 1], r[e + 2]), void 0 !== r[t] && i.push(r[t + 0], r[t + 1], r[t + 2]), void 0 !== r[n] && i.push(r[n + 0], r[n + 1], r[n + 2])
            },
            addUV: function(e, t, n) {
                const r = this.uvs,
                    i = this.object.geometry.uvs;
                i.push(r[e + 0], r[e + 1]), i.push(r[t + 0], r[t + 1]), i.push(r[n + 0], r[n + 1])
            },
            addDefaultUV: function() {
                const e = this.object.geometry.uvs;
                e.push(0, 0), e.push(0, 0), e.push(0, 0)
            },
            addUVLine: function(e) {
                const t = this.uvs;
                this.object.geometry.uvs.push(t[e + 0], t[e + 1])
            },
            addFace: function(e, t, n, r, i, s, o, a, l) {
                const c = this.vertices.length;
                let u = this.parseVertexIndex(e, c),
                    p = this.parseVertexIndex(t, c),
                    h = this.parseVertexIndex(n, c);
                if (this.addVertex(u, p, h), this.addColor(u, p, h), void 0 !== o && "" !== o) {
                    const e = this.normals.length;
                    u = this.parseNormalIndex(o, e), p = this.parseNormalIndex(a, e), h = this.parseNormalIndex(l, e), this.addNormal(u, p, h)
                } else this.addFaceNormal(u, p, h);
                if (void 0 !== r && "" !== r) {
                    const e = this.uvs.length;
                    u = this.parseUVIndex(r, e), p = this.parseUVIndex(i, e), h = this.parseUVIndex(s, e), this.addUV(u, p, h), this.object.geometry.hasUVIndices = !0
                } else this.addDefaultUV()
            },
            addPointGeometry: function(e) {
                this.object.geometry.type = "Points";
                const t = this.vertices.length;
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = this.parseVertexIndex(e[n], t);
                    this.addVertexPoint(r), this.addColor(r)
                }
            },
            addLineGeometry: function(e, t) {
                this.object.geometry.type = "Line";
                const n = this.vertices.length,
                    r = this.uvs.length;
                for (let t = 0, r = e.length; t < r; t++) this.addVertexLine(this.parseVertexIndex(e[t], n));
                for (let e = 0, n = t.length; e < n; e++) this.addUVLine(this.parseUVIndex(t[e], r))
            }
        };
        return e.startObject("", !1), e
    }
    class ex extends i.aNw {
        constructor(e) {
            super(e), this.materials = null
        }
        load(e, t, n, r) {
            const s = this,
                o = new i.hH6(this.manager);
            o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (async function(n) {
                try {
                    t(await s.parse(n))
                } catch (t) {
                    r ? r(t) : console.error(t), s.manager.itemError(e)
                }
            }), n, r)
        }
        setMaterials(e) {
            return this.materials = e, this
        }
        async parse(e) {
            const t = new Qb; - 1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")), -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
            const n = e.split("\n");
            let r = "",
                s = "",
                o = 0,
                a = [];
            const l = "function" == typeof "".trimLeft;
            for (let e = 0, i = n.length; e < i; e++)
                if (r = n[e], r = l ? r.trimLeft() : r.trim(), o = r.length, 0 !== o && (s = r.charAt(0), "#" !== s))
                    if ("v" === s) {
                        const e = r.split(/\s+/);
                        switch (e[0]) {
                            case "v":
                                t.vertices.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])), e.length >= 7 ? t.colors.push(parseFloat(e[4]), parseFloat(e[5]), parseFloat(e[6])) : t.colors.push(void 0, void 0, void 0);
                                break;
                            case "vn":
                                t.normals.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]));
                                break;
                            case "vt":
                                t.uvs.push(parseFloat(e[1]), parseFloat(e[2]))
                        }
                    } else if ("f" === s) {
                const e = r.substr(1).trim().split(/\s+/),
                    n = [];
                for (let t = 0, r = e.length; t < r; t++) {
                    const r = e[t];
                    if (r.length > 0) {
                        const e = r.split("/");
                        n.push(e)
                    }
                }
                const i = n[0];
                for (let e = 1, r = n.length - 1; e < r; e++) {
                    const r = n[e],
                        s = n[e + 1];
                    t.addFace(i[0], r[0], s[0], i[1], r[1], s[1], i[2], r[2], s[2])
                }
            } else if ("l" === s) {
                const e = r.substring(1).trim().split(" ");
                let n = [];
                const i = [];
                if (-1 === r.indexOf("/")) n = e;
                else
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = e[t].split("/");
                        "" !== r[0] && n.push(r[0]), "" !== r[1] && i.push(r[1])
                    }
                t.addLineGeometry(n, i)
            } else if ("p" === s) {
                const e = r.substr(1).trim().split(" ");
                t.addPointGeometry(e)
            } else if (null !== (a = Hb.exec(r))) {
                const e = (" " + a[0].substr(1).trim()).substr(1);
                t.startObject(e)
            } else if (Kb.test(r)) t.object.startMaterial(r.substring(7).trim(), t.materialLibraries);
            else if (Wb.test(r)) {
                t.materialLibraries.push(r.substring(7).trim());
                const e = r.substring(7).trim(),
                    n = this.manager.getHandler(e);
                if (n) {
                    const t = await n.loadAsync(e).catch((e => {
                        console.warn(e)
                    }));
                    t && this.setMaterials(t)
                } else console.warn("OBJLoader2: Set MTLLoader to loading manager to load materials.")
            } else if (Xb.test(r)) console.warn('OBJLoader2: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
            else if ("s" === s) {
                if (a = r.split(" "), a.length > 1) {
                    const e = a[1].trim().toLowerCase();
                    t.object.smooth = "0" !== e && "off" !== e
                } else t.object.smooth = !0;
                const e = t.object.currentMaterial();
                e && (e.smooth = t.object.smooth)
            } else {
                if ("\0" === r) continue;
                console.warn('THREE.OBJLoader: Unexpected line: "' + r + '"')
            }
            t.finalize();
            const c = new i.ZAu;
            if (c.materialLibraries = [].concat(t.materialLibraries), !0 == !(1 === t.objects.length && 0 === t.objects[0].geometry.vertices.length))
                for (let e = 0, n = t.objects.length; e < n; e++) {
                    const n = t.objects[e],
                        r = n.geometry,
                        s = n.materials,
                        o = "Line" === r.type,
                        a = "Points" === r.type;
                    let l = !1;
                    if (0 === r.vertices.length) continue;
                    const u = new i.u9r;
                    u.setAttribute("position", new i.a$l(r.vertices, 3)), r.normals.length > 0 && u.setAttribute("normal", new i.a$l(r.normals, 3)), r.colors.length > 0 && (l = !0, u.setAttribute("color", new i.a$l(r.colors, 3))), !0 === r.hasUVIndices && u.setAttribute("uv", new i.a$l(r.uvs, 2));
                    const p = [];
                    for (let e = 0, n = s.length; e < n; e++) {
                        const n = s[e],
                            r = n.name + "_" + n.smooth + "_" + l;
                        let c = t.materials[r];
                        if (null !== this.materials)
                            if (c = await this.materials.create(n.name), !o || !c || c instanceof i.nls) {
                                if (a && c && !(c instanceof i.UY4)) {
                                    const e = new i.UY4({
                                        size: 10,
                                        sizeAttenuation: !1
                                    });
                                    i.F5T.prototype.copy.call(e, c), e.color.copy(c.color), e.map = c.map, c = e
                                }
                            } else {
                                const e = new i.nls;
                                i.F5T.prototype.copy.call(e, c), e.color.copy(c.color), c = e
                            }
                        void 0 === c && (c = o ? new i.nls : a ? new i.UY4({
                            size: 1,
                            sizeAttenuation: !1
                        }) : new i.xoR, c.name = n.name, c.flatShading = !n.smooth, c.vertexColors = l, t.materials[r] = c), p.push(c)
                    }
                    let h;
                    if (p.length > 1) {
                        for (let e = 0, t = s.length; e < t; e++) {
                            const t = s[e];
                            u.addGroup(t.groupStart, t.groupCount, e)
                        }
                        h = o ? new i.ejS(u, p) : a ? new i.woe(u, p) : new i.Kj0(u, p)
                    } else h = o ? new i.ejS(u, p[0]) : a ? new i.woe(u, p[0]) : new i.Kj0(u, p[0]);
                    h.name = n.name, c.add(h)
                } else if (t.vertices.length > 0) {
                    const e = new i.UY4({
                            size: 1,
                            sizeAttenuation: !1
                        }),
                        n = new i.u9r;
                    n.setAttribute("position", new i.a$l(t.vertices, 3)), t.colors.length > 0 && void 0 !== t.colors[0] && (n.setAttribute("color", new i.a$l(t.colors, 3)), e.vertexColors = !0);
                    const r = new i.woe(n, e);
                    c.add(r)
                }
            return c
        }
    }
    class tx extends r {
        constructor() {
            super(...arguments), this.dependencies = [Vs], this._importer1 = new $t(ex, ["obj"], !0), this._importer2 = new $t(Vb, ["mtl"], !1)
        }
        async onAdded(e) {
            Us.Importers.push(this._importer1), Us.Importers.push(this._importer2)
        }
        async onDispose(e) {}
        async onRemove(e) {
            Us.Importers.splice(Us.Importers.indexOf(this._importer1), 1), Us.Importers.splice(Us.Importers.indexOf(this._importer2), 1)
        }
    }
    tx.PluginType = "ObjMtlLoadPlugin";
    class nx extends i.DqL {
        constructor(e) {
            super(e)
        }
        parse(e, t) {
            const n = new rx(e, 1);
            return {
                mipmaps: n.mipmaps(t),
                width: n.pixelWidth,
                height: n.pixelHeight,
                format: n.glInternalFormat,
                isCubemap: 6 === n.numberOfFaces,
                mipmapCount: n.numberOfMipmapLevels
            }
        }
    }
    class rx {
        constructor(e, t) {
            this.arrayBuffer = e;
            const n = new Uint8Array(this.arrayBuffer, 0, 12);
            if (171 !== n[0] || 75 !== n[1] || 84 !== n[2] || 88 !== n[3] || 32 !== n[4] || 49 !== n[5] || 49 !== n[6] || 187 !== n[7] || 13 !== n[8] || 10 !== n[9] || 26 !== n[10] || 10 !== n[11]) return void console.error("texture missing KTX identifier");
            const r = Uint32Array.BYTES_PER_ELEMENT,
                i = new DataView(this.arrayBuffer, 12, 13 * r),
                s = 67305985 === i.getUint32(0, !0);
            this.glType = i.getUint32(1 * r, s), this.glTypeSize = i.getUint32(2 * r, s), this.glFormat = i.getUint32(3 * r, s), this.glInternalFormat = i.getUint32(4 * r, s), this.glBaseInternalFormat = i.getUint32(5 * r, s), this.pixelWidth = i.getUint32(6 * r, s), this.pixelHeight = i.getUint32(7 * r, s), this.pixelDepth = i.getUint32(8 * r, s), this.numberOfArrayElements = i.getUint32(9 * r, s), this.numberOfFaces = i.getUint32(10 * r, s), this.numberOfMipmapLevels = i.getUint32(11 * r, s), this.bytesOfKeyValueData = i.getUint32(12 * r, s), 0 === this.glType ? (this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels), 0 !== this.pixelHeight && 0 === this.pixelDepth ? 0 === this.numberOfArrayElements ? this.numberOfFaces === t ? this.loadType = 0 : console.warn("number of faces expected" + t + ", but found " + this.numberOfFaces) : console.warn("texture arrays not currently supported") : console.warn("only 2D textures currently supported")) : console.warn("only compressed formats currently supported")
        }
        mipmaps(e) {
            const t = [];
            let n = 64 + this.bytesOfKeyValueData,
                r = this.pixelWidth,
                i = this.pixelHeight;
            const s = e ? this.numberOfMipmapLevels : 1;
            for (let e = 0; e < s; e++) {
                const e = new Int32Array(this.arrayBuffer, n, 1)[0];
                n += 4;
                for (let s = 0; s < this.numberOfFaces; s++) {
                    const s = new Uint8Array(this.arrayBuffer, n, e);
                    t.push({
                        data: s,
                        width: r,
                        height: i
                    }), n += e, n += 3 - (e + 3) % 4
                }
                r = Math.max(1, .5 * r), i = Math.max(1, .5 * i)
            }
            return t
        }
    }
    class ix extends r {
        constructor() {
            super(...arguments), this.dependencies = [Vs]
        }
        async onAdded(e) {
            this._importer || (this._importer = new $t(nx, ["ktx"], !1)), Us.Importers.push(this._importer)
        }
        async onDispose(e) {
            this._importer = void 0
        }
        async onRemove(e) {
            this._importer && Us.Importers.splice(Us.Importers.indexOf(this._importer), 1), this._importer = void 0
        }
    }
    ix.PluginType = "KTXLoadPlugin";
    class sx extends i.hH6 {
        constructor(e) {
            super(e), this.responseType = "blob"
        }
    }
    class ox extends i.hH6 {
        constructor(e) {
            super(e), this.responseType = "blob"
        }
        load(e, t, n, r) {
            return super.load(e, (e => {
                try {
                    null == t || t(bt(e))
                } catch (e) {
                    null == r || r(e)
                }
            }), n, r)
        }
    }
    class ax {
        async parseAsync(e, t) {
            var n;
            return new Blob([JSON.stringify(e, null, null !== (n = t.jsonSpaces) && void 0 !== n ? n : 2)], {
                type: "application/json"
            })
        }
    }
    class lx {
        async parseAsync(e, t) {
            return new Blob([e], {
                type: "text/plain"
            })
        }
    }

    function cx(e, t) {
        const n = e.getPlugin(Vs).exportViewerConfig(),
            r = [];
        Object.values(n.resources).forEach((e => {
            Object.values(e).forEach((e => {
                e.url && ("Uint16Array" === e.url.type && e.url.data && (e.url.data = new Uint16Array(e.url.data), r.push(e.url)), "Uint8Array" === e.url.type && e.url.data && (e.url.data = new Uint8Array(e.url.data), r.push(e.url)))
            }))
        }));
        for (const e of r) {
            let n = "application/octet-stream";
            if ("Uint16Array" === e.type) {
                const t = ux(e.data, 4),
                    r = new ImageData(t, e.width, e.height),
                    s = i.PpQ.getDataURL(r).split(",")[1];
                n = "image/png", e.data = atob(s), e.encoding = "rgbe"
            }
            const r = new Blob([e.data], {
                type: n
            });
            t.json.images || (t.json.images = []);
            const s = {
                    mimeType: n
                },
                o = t.json.images.push(s) - 1;
            e.data = {
                image: o
            }, t.pending.push(t.processBufferViewImage(r).then((e => {
                s.bufferView = e
            })))
        }
        return n
    }

    function ux(e, t = 3, n) {
        let r, i, s, o, a;
        const l = e.byteLength / (2 * t) | 0;
        n = n || new Uint8ClampedArray(4 * l);
        for (let c = 0; c < l; c++) {
            r = e[c * t], i = e[c * t + 1], s = e[c * t + 2], o = Math.max(Math.max(r, i), s);
            const l = Math.ceil(Math.log2(o));
            a = Math.pow(2, l - 8), n[4 * c] = r / a | 0, n[4 * c + 1] = i / a | 0, n[4 * c + 2] = s / a | 0, n[4 * c + 3] = l + 128
        }
        return n
    }
    class px {
        constructor() {
            this.pluginCallbacks = [], this.register((function(e) {
                return new yx(e)
            })), this.register((function(e) {
                return new wx(e)
            })), this.register((function(e) {
                return new Sx(e)
            })), this.register((function(e) {
                return new Ex(e)
            })), this.register((function(e) {
                return new Ax(e)
            })), this.register((function(e) {
                return new Mx(e)
            })), this.register((function(e) {
                return new Cx(e)
            })), this.register((function(e) {
                return new Tx(e)
            })), this.register((function(e) {
                return new Rx(e)
            }))
        }
        register(e) {
            return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
        }
        unregister(e) {
            return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
        }
        parse(e, t, n, r, i) {
            "object" == typeof n && (console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."), r = n);
            const s = i || new xx,
                o = [];
            for (let e = 0, t = this.pluginCallbacks.length; e < t; e++) o.push(this.pluginCallbacks[e](s));
            s.setPlugins(o), s.write(e, t, r).catch(n)
        }
        parseAsync(e, t) {
            const n = this;
            return new Promise((function(r, i) {
                n.parse(e, r, i, t)
            }))
        }
    }
    const hx = 5121,
        dx = 5123,
        fx = {};
    fx[i.TyD] = 9728, fx[i.YLQ] = 9984, fx[i.aH4] = 9986, fx[i.wem] = 9729, fx[i.qyh] = 9985, fx[i.D1R] = 9987, fx[i.uWy] = 33071, fx[i.rpg] = 10497, fx[i.OoA] = 33648;
    const _x = {
        scale: "scale",
        position: "translation",
        quaternion: "rotation",
        morphTargetInfluences: "weights"
    };

    function mx(e, t) {
        return e.length === t.length && e.every((function(e, n) {
            return e === t[n]
        }))
    }

    function gx(e) {
        return 4 * Math.ceil(e / 4)
    }

    function vx(e, t = 0) {
        const n = gx(e.byteLength);
        if (n !== e.byteLength) {
            const r = new Uint8Array(n);
            if (r.set(new Uint8Array(e)), 0 !== t)
                for (let i = e.byteLength; i < n; i++) r[i] = t;
            return r.buffer
        }
        return e
    }

    function bx(e, t) {
        if (void 0 !== e.toBlob) return new Promise((n => e.toBlob(n, t)));
        let n;
        return "image/jpeg" === t ? n = .92 : "image/webp" === t && (n = .8), e.convertToBlob({
            type: t,
            quality: n
        })
    }
    class xx {
        constructor() {
            this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map, this.skins = [], this.extensionsUsed = {}, this.uids = new Map, this.uid = 0, this.json = {
                asset: {
                    version: "2.0",
                    generator: "THREE.GLTFExporter"
                }
            }, this.cache = {
                meshes: new Map,
                attributes: new Map,
                attributesNormalized: new Map,
                materials: new Map,
                textures: new Map,
                images: new Map
            }
        }
        setPlugins(e) {
            this.plugins = e
        }
        async write(e, t, n) {
            this.options = Object.assign({}, {
                binary: !1,
                trs: !1,
                onlyVisible: !0,
                truncateDrawRange: !0,
                maxTextureSize: 1 / 0,
                animations: [],
                includeCustomExtensions: !1
            }, n), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
            const r = this,
                i = r.buffers,
                s = r.json;
            n = r.options;
            const o = r.extensionsUsed,
                a = new Blob(i, {
                    type: "application/octet-stream"
                }),
                l = Object.keys(o);
            if (l.length > 0 && (s.extensionsUsed = l), s.buffers && s.buffers.length > 0 && (s.buffers[0].byteLength = a.size), !0 === n.binary) {
                const e = new FileReader;
                e.readAsArrayBuffer(a), e.onloadend = function() {
                    const n = vx(e.result),
                        r = new DataView(new ArrayBuffer(8));
                    r.setUint32(0, n.byteLength, !0), r.setUint32(4, 5130562, !0);
                    const i = vx((o = JSON.stringify(s), (new TextEncoder).encode(o).buffer), 32);
                    var o;
                    const a = new DataView(new ArrayBuffer(8));
                    a.setUint32(0, i.byteLength, !0), a.setUint32(4, 1313821514, !0);
                    const l = new ArrayBuffer(12),
                        c = new DataView(l);
                    c.setUint32(0, 1179937895, !0), c.setUint32(4, 2, !0);
                    const u = 12 + a.byteLength + i.byteLength + r.byteLength + n.byteLength;
                    c.setUint32(8, u, !0);
                    const p = new Blob([l, a, i, r, n], {
                            type: "application/octet-stream"
                        }),
                        h = new FileReader;
                    h.readAsArrayBuffer(p), h.onloadend = function() {
                        t(h.result)
                    }
                }
            } else if (s.buffers && s.buffers.length > 0) {
                const e = new FileReader;
                e.readAsDataURL(a), e.onloadend = function() {
                    const n = e.result;
                    s.buffers[0].uri = n, t(s)
                }
            } else t(s)
        }
        serializeUserData(e, t) {
            if (0 === Object.keys(e.userData).length) return;
            const n = this.options,
                r = this.extensionsUsed;
            try {
                const i = JSON.parse(JSON.stringify(e.userData));
                if (n.includeCustomExtensions && i.gltfExtensions) {
                    void 0 === t.extensions && (t.extensions = {});
                    for (const e in i.gltfExtensions) t.extensions[e] = i.gltfExtensions[e], r[e] = !0;
                    delete i.gltfExtensions
                }
                Object.keys(i).length > 0 && (t.extras = i)
            } catch (t) {
                console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t.message), console.warn({ ...e.userData
                })
            }
        }
        getUID(e, t = !1) {
            if (!1 === this.uids.has(e)) {
                const t = new Map;
                t.set(!0, this.uid++), t.set(!1, this.uid++), this.uids.set(e, t)
            }
            return this.uids.get(e).get(t)
        }
        isNormalizedNormalAttribute(e) {
            if (this.cache.attributesNormalized.has(e)) return !1;
            const t = new i.Pa4;
            for (let n = 0, r = e.count; n < r; n++)
                if (Math.abs(t.fromBufferAttribute(e, n).length() - 1) > 5e-4) return !1;
            return !0
        }
        createNormalizedNormalAttribute(e) {
            const t = this.cache;
            if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e);
            const n = e.clone(),
                r = new i.Pa4;
            for (let e = 0, t = n.count; e < t; e++) r.fromBufferAttribute(n, e), 0 === r.x && 0 === r.y && 0 === r.z ? r.setX(1) : r.normalize(), n.setXYZ(e, r.x, r.y, r.z);
            return t.attributesNormalized.set(e, n), n
        }
        applyTextureTransform(e, t) {
            let n = !1;
            const r = {};
            0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(), n = !0), 0 !== t.rotation && (r.rotation = t.rotation, n = !0), 1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0)
        }
        buildMetalRoughTexture(e, t) {
            if (e === t) return e;

            function n(e) {
                return e.encoding === i.knz ? function(e) {
                    return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
                } : function(e) {
                    return e
                }
            }
            console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
            const r = e ? e.image : void 0,
                s = t ? t.image : void 0,
                o = Math.max(r ? r.width : 0, s ? s.width : 0),
                a = Math.max(r ? r.height : 0, s ? s.height : 0),
                l = document.createElement("canvas");
            l.width = o, l.height = a;
            const c = l.getContext("2d");
            c.fillStyle = "#00ffff", c.fillRect(0, 0, o, a);
            const u = c.getImageData(0, 0, o, a);
            if (r) {
                c.drawImage(r, 0, 0, o, a);
                const t = n(e),
                    i = c.getImageData(0, 0, o, a).data;
                for (let e = 2; e < i.length; e += 4) u.data[e] = 256 * t(i[e] / 256)
            }
            if (s) {
                c.drawImage(s, 0, 0, o, a);
                const e = n(t),
                    r = c.getImageData(0, 0, o, a).data;
                for (let t = 1; t < r.length; t += 4) u.data[t] = 256 * e(r[t] / 256)
            }
            c.putImageData(u, 0, 0);
            const p = (e || t).clone();
            return p.source = new i.Hw6(l), p.encoding = i.rnI, p
        }
        processBuffer(e) {
            const t = this.json,
                n = this.buffers;
            return t.buffers || (t.buffers = [{
                byteLength: 0
            }]), n.push(e), 0
        }
        processBufferView(e, t, n, r, i) {
            const s = this.json;
            let o;
            s.bufferViews || (s.bufferViews = []), o = t === hx ? 1 : t === dx ? 2 : 4;
            const a = gx(r * e.itemSize * o),
                l = new DataView(new ArrayBuffer(a));
            let c = 0;
            for (let i = n; i < n + r; i++)
                for (let n = 0; n < e.itemSize; n++) {
                    let r;
                    e.itemSize > 4 ? r = e.array[i * e.itemSize + n] : 0 === n ? r = e.getX(i) : 1 === n ? r = e.getY(i) : 2 === n ? r = e.getZ(i) : 3 === n && (r = e.getW(i)), 5126 === t ? l.setFloat32(c, r, !0) : 5125 === t ? l.setUint32(c, r, !0) : t === dx ? l.setUint16(c, r, !0) : t === hx && l.setUint8(c, r), c += o
                }
            const u = {
                buffer: this.processBuffer(l.buffer),
                byteOffset: this.byteOffset,
                byteLength: a
            };
            return void 0 !== i && (u.target = i), 34962 === i && (u.byteStride = e.itemSize * o), this.byteOffset += a, s.bufferViews.push(u), {
                id: s.bufferViews.length - 1,
                byteLength: 0
            }
        }
        processBufferViewImage(e) {
            const t = this,
                n = t.json;
            return n.bufferViews || (n.bufferViews = []), new Promise((function(r) {
                const i = new FileReader;
                i.readAsArrayBuffer(e), i.onloadend = function() {
                    const e = vx(i.result),
                        s = {
                            buffer: t.processBuffer(e),
                            byteOffset: t.byteOffset,
                            byteLength: e.byteLength
                        };
                    t.byteOffset += e.byteLength, r(n.bufferViews.push(s) - 1)
                }
            }))
        }
        processAccessor(e, t, n, r) {
            const i = this.options,
                s = this.json;
            let o;
            if (e.array.constructor === Float32Array) o = 5126;
            else if (e.array.constructor === Uint32Array) o = 5125;
            else if (e.array.constructor === Uint16Array) o = dx;
            else {
                if (e.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
                o = hx
            }
            if (void 0 === n && (n = 0), void 0 === r && (r = e.count), i.truncateDrawRange && void 0 !== t && null === t.index) {
                const i = n + r,
                    s = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count;
                n = Math.max(n, t.drawRange.start), (r = Math.min(i, s) - n) < 0 && (r = 0)
            }
            if (0 === r) return null;
            const a = function(e, t, n) {
                const r = {
                    min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),
                    max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)
                };
                for (let i = t; i < t + n; i++)
                    for (let t = 0; t < e.itemSize; t++) {
                        let n;
                        e.itemSize > 4 ? n = e.array[i * e.itemSize + t] : 0 === t ? n = e.getX(i) : 1 === t ? n = e.getY(i) : 2 === t ? n = e.getZ(i) : 3 === t && (n = e.getW(i)), r.min[t] = Math.min(r.min[t], n), r.max[t] = Math.max(r.max[t], n)
                    }
                return r
            }(e, n, r);
            let l;
            void 0 !== t && (l = e === t.index ? 34963 : 34962);
            const c = this.processBufferView(e, o, n, r, l),
                u = {
                    bufferView: c.id,
                    byteOffset: c.byteOffset,
                    componentType: o,
                    count: r,
                    max: a.max,
                    min: a.min,
                    type: {
                        1: "SCALAR",
                        2: "VEC2",
                        3: "VEC3",
                        4: "VEC4",
                        16: "MAT4"
                    }[e.itemSize]
                };
            return !0 === e.normalized && (u.normalized = !0), s.accessors || (s.accessors = []), s.accessors.push(u) - 1
        }
        processImage(e, t, n, r = "image/png") {
            const s = this,
                o = s.cache,
                a = s.json,
                l = s.options,
                c = s.pending;
            o.images.has(e) || o.images.set(e, {});
            const u = o.images.get(e),
                p = r + ":flipY/" + n.toString();
            if (void 0 !== u[p]) return u[p];
            a.images || (a.images = []);
            const h = {
                    mimeType: r
                },
                d = "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
            d.width = Math.min(e.width, l.maxTextureSize), d.height = Math.min(e.height, l.maxTextureSize);
            const f = d.getContext("2d");
            if (!0 === n && (f.translate(0, d.height), f.scale(1, -1)), void 0 !== e.data) {
                t !== i.wk1 && console.error("GLTFExporter: Only RGBAFormat is supported."), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
                const n = new Uint8ClampedArray(e.height * e.width * 4);
                for (let t = 0; t < n.length; t += 4) n[t + 0] = e.data[t + 0], n[t + 1] = e.data[t + 1], n[t + 2] = e.data[t + 2], n[t + 3] = e.data[t + 3];
                f.putImageData(new ImageData(n, e.width, e.height), 0, 0)
            } else f.drawImage(e, 0, 0, d.width, d.height);
            !0 === l.binary ? c.push(bx(d, r).then((e => s.processBufferViewImage(e))).then((e => {
                h.bufferView = e
            }))) : void 0 !== d.toDataURL ? h.uri = d.toDataURL(r) : c.push(bx(d, r).then((e => (new FileReader).readAsDataURL(e))).then((e => {
                h.uri = e
            })));
            const _ = a.images.push(h) - 1;
            return u[p] = _, _
        }
        processSampler(e) {
            const t = this.json;
            t.samplers || (t.samplers = []);
            const n = {
                magFilter: fx[e.magFilter],
                minFilter: fx[e.minFilter],
                wrapS: fx[e.wrapS],
                wrapT: fx[e.wrapT]
            };
            return t.samplers.push(n) - 1
        }
        processTexture(e) {
            const t = this.cache,
                n = this.json;
            if (t.textures.has(e)) return t.textures.get(e);
            n.textures || (n.textures = []);
            let r = e.userData.mimeType;
            "image/webp" === r && (r = "image/png"), "image/jpg" === r && (r = "image/jpeg");
            const i = ["image/jpeg", "image/png"];
            r && !i.includes(r) && console.error("GLTFExporter: Unsupported mime type: " + r + ". Cannot export texture.", e);
            const s = {
                sampler: this.processSampler(e),
                source: !r || i.includes(r) ? this.processImage(e.image, e.format, e.flipY, r) : null
            };
            e.name && (s.name = e.name), this._invokeAll((function(t) {
                t.writeTexture && t.writeTexture(e, s)
            }));
            const o = n.textures.push(s) - 1;
            return t.textures.set(e, o), o
        }
        processMaterial(e) {
            const t = this.cache,
                n = this.json;
            if (t.materials.has(e)) return t.materials.get(e);
            if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
            n.materials || (n.materials = []);
            const r = {
                pbrMetallicRoughness: {}
            };
            !0 !== e.isMeshStandardMaterial && !0 !== e.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
            const s = e.color.toArray().concat([e.opacity]);
            if (mx(s, [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = s), e.isMeshStandardMaterial ? (r.pbrMetallicRoughness.metallicFactor = e.metalness, r.pbrMetallicRoughness.roughnessFactor = e.roughness) : (r.pbrMetallicRoughness.metallicFactor = .5, r.pbrMetallicRoughness.roughnessFactor = .5), e.metalnessMap || e.roughnessMap) {
                const t = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap),
                    n = {
                        index: this.processTexture(t)
                    };
                this.applyTextureTransform(n, t), r.pbrMetallicRoughness.metallicRoughnessTexture = n
            }
            if (e.map) {
                const t = {
                    index: this.processTexture(e.map)
                };
                this.applyTextureTransform(t, e.map), r.pbrMetallicRoughness.baseColorTexture = t
            }
            if (e.emissive) {
                const t = e.emissive.clone().multiplyScalar(e.emissiveIntensity),
                    n = Math.max(t.r, t.g, t.b);
                if (n > 1 && (t.multiplyScalar(1 / n), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), n > 0 && (r.emissiveFactor = t.toArray()), e.emissiveMap) {
                    const t = {
                        index: this.processTexture(e.emissiveMap)
                    };
                    this.applyTextureTransform(t, e.emissiveMap), r.emissiveTexture = t
                }
            }
            if (e.normalMap) {
                const t = {
                    index: this.processTexture(e.normalMap)
                };
                e.normalScale && 1 !== e.normalScale.x && (t.scale = e.normalScale.x), this.applyTextureTransform(t, e.normalMap), r.normalTexture = t
            }
            if (e.aoMap) {
                const t = {
                    index: this.processTexture(e.aoMap),
                    texCoord: 1
                };
                1 !== e.aoMapIntensity && (t.strength = e.aoMapIntensity), this.applyTextureTransform(t, e.aoMap), r.occlusionTexture = t
            }
            e.transparent ? r.alphaMode = "BLEND" : e.alphaTest > 0 && (r.alphaMode = "MASK", r.alphaCutoff = e.alphaTest), e.side === i.ehD && (r.doubleSided = !0), "" !== e.name && (r.name = e.name), this.serializeUserData(e, r), this._invokeAll((function(t) {
                t.writeMaterial && t.writeMaterial(e, r)
            }));
            const o = n.materials.push(r) - 1;
            return t.materials.set(e, o), o
        }
        processMesh(e) {
            const t = this.cache,
                n = this.json,
                r = [e.geometry.uuid];
            if (Array.isArray(e.material))
                for (let t = 0, n = e.material.length; t < n; t++) r.push(e.material[t].uuid);
            else r.push(e.material.uuid);
            const s = r.join(":");
            if (t.meshes.has(s)) return t.meshes.get(s);
            const o = e.geometry;
            let a;
            if (a = e.isLineSegments ? 1 : e.isLineLoop ? 2 : e.isLine ? 3 : e.isPoints ? 0 : e.material.wireframe ? 1 : 4, !0 !== o.isBufferGeometry) throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
            const l = {},
                c = {},
                u = [],
                p = [],
                h = {
                    uv: "TEXCOORD_0",
                    uv2: "TEXCOORD_1",
                    color: "COLOR_0",
                    skinWeight: "WEIGHTS_0",
                    skinIndex: "JOINTS_0"
                },
                d = o.getAttribute("normal");
            void 0 === d || this.isNormalizedNormalAttribute(d) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o.setAttribute("normal", this.createNormalizedNormalAttribute(d)));
            let f = null;
            for (let e in o.attributes) {
                if ("morph" === e.slice(0, 5)) continue;
                const n = o.attributes[e];
                if (e = h[e] || e.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e) || (e = "_" + e), t.attributes.has(this.getUID(n))) {
                    c[e] = t.attributes.get(this.getUID(n));
                    continue
                }
                f = null;
                const r = n.array;
                "JOINTS_0" !== e || r instanceof Uint16Array || r instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), f = new i.TlE(new Uint16Array(r), n.itemSize, n.normalized));
                const s = this.processAccessor(f || n, o);
                null !== s && (c[e] = s, t.attributes.set(this.getUID(n), s))
            }
            if (void 0 !== d && o.setAttribute("normal", d), 0 === Object.keys(c).length) return null;
            if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) {
                const n = [],
                    r = [],
                    i = {};
                if (void 0 !== e.morphTargetDictionary)
                    for (const t in e.morphTargetDictionary) i[e.morphTargetDictionary[t]] = t;
                for (let s = 0; s < e.morphTargetInfluences.length; ++s) {
                    const a = {};
                    let l = !1;
                    for (const e in o.morphAttributes) {
                        if ("position" !== e && "normal" !== e) {
                            l || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l = !0);
                            continue
                        }
                        const n = o.morphAttributes[e][s],
                            r = e.toUpperCase(),
                            i = o.attributes[e];
                        if (t.attributes.has(this.getUID(n, !0))) {
                            a[r] = t.attributes.get(this.getUID(n, !0));
                            continue
                        }
                        const c = n.clone();
                        if (!o.morphTargetsRelative)
                            for (let e = 0, t = n.count; e < t; e++) c.setXYZ(e, n.getX(e) - i.getX(e), n.getY(e) - i.getY(e), n.getZ(e) - i.getZ(e));
                        a[r] = this.processAccessor(c, o), t.attributes.set(this.getUID(i, !0), a[r])
                    }
                    p.push(a), n.push(e.morphTargetInfluences[s]), void 0 !== e.morphTargetDictionary && r.push(i[s])
                }
                l.weights = n, r.length > 0 && (l.extras = {}, l.extras.targetNames = r)
            }
            const _ = Array.isArray(e.material);
            if (_ && 0 === o.groups.length) return null;
            const m = _ ? e.material : [e.material],
                g = _ ? o.groups : [{
                    materialIndex: 0,
                    start: void 0,
                    count: void 0
                }];
            for (let e = 0, n = g.length; e < n; e++) {
                const n = {
                    mode: a,
                    attributes: c
                };
                if (this.serializeUserData(o, n), p.length > 0 && (n.targets = p), null !== o.index) {
                    let r = this.getUID(o.index);
                    void 0 === g[e].start && void 0 === g[e].count || (r += ":" + g[e].start + ":" + g[e].count), t.attributes.has(r) ? n.indices = t.attributes.get(r) : (n.indices = this.processAccessor(o.index, o, g[e].start, g[e].count), t.attributes.set(r, n.indices)), null === n.indices && delete n.indices
                }
                const r = this.processMaterial(m[g[e].materialIndex]);
                null !== r && (n.material = r), u.push(n)
            }
            l.primitives = u, n.meshes || (n.meshes = []), this._invokeAll((function(t) {
                t.writeMesh && t.writeMesh(e, l)
            }));
            const v = n.meshes.push(l) - 1;
            return t.meshes.set(s, v), v
        }
        processCamera(e) {
            const t = this.json;
            t.cameras || (t.cameras = []);
            const n = e.isOrthographicCamera,
                r = {
                    type: n ? "orthographic" : "perspective"
                };
            return n ? r.orthographic = {
                xmag: 2 * e.right,
                ymag: 2 * e.top,
                zfar: e.far <= 0 ? .001 : e.far,
                znear: e.near < 0 ? 0 : e.near
            } : r.perspective = {
                aspectRatio: e.aspect,
                yfov: i.M8C.degToRad(e.fov),
                zfar: e.far <= 0 ? .001 : e.far,
                znear: e.near < 0 ? 0 : e.near
            }, "" !== e.name && (r.name = e.type), t.cameras.push(r) - 1
        }
        processAnimation(e, t) {
            const n = this.json,
                r = this.nodeMap;
            n.animations || (n.animations = []);
            const s = (e = px.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks,
                o = [],
                a = [];
            for (let e = 0; e < s.length; ++e) {
                const n = s[e],
                    l = i.iUV.parseTrackName(n.name);
                let c = i.iUV.findNode(t, l.nodeName);
                const u = _x[l.propertyName];
                if ("bones" === l.objectName && (c = !0 === c.isSkinnedMesh ? c.skeleton.getBoneByName(l.objectIndex) : void 0), !c || !u) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', n.name), null;
                const p = 1;
                let h, d = n.values.length / n.times.length;
                u === _x.morphTargetInfluences && (d /= c.morphTargetInfluences.length), !0 === n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (h = "CUBICSPLINE", d /= 3) : h = n.getInterpolation() === i.Syv ? "STEP" : "LINEAR", a.push({
                    input: this.processAccessor(new i.TlE(n.times, p)),
                    output: this.processAccessor(new i.TlE(n.values, d)),
                    interpolation: h
                }), o.push({
                    sampler: a.length - 1,
                    target: {
                        node: r.get(c),
                        path: u
                    }
                })
            }
            return n.animations.push({
                name: e.name || "clip_" + n.animations.length,
                samplers: a,
                channels: o
            }), n.animations.length - 1
        }
        processSkin(e) {
            const t = this.json,
                n = this.nodeMap,
                r = t.nodes[n.get(e)],
                s = e.skeleton;
            if (void 0 === s) return null;
            const o = e.skeleton.bones[0];
            if (void 0 === o) return null;
            const a = [],
                l = new Float32Array(16 * s.bones.length),
                c = new i.yGw;
            for (let t = 0; t < s.bones.length; ++t) a.push(n.get(s.bones[t])), c.copy(s.boneInverses[t]), c.multiply(e.bindMatrix).toArray(l, 16 * t);
            return void 0 === t.skins && (t.skins = []), t.skins.push({
                inverseBindMatrices: this.processAccessor(new i.TlE(l, 16)),
                joints: a,
                skeleton: n.get(o)
            }), r.skin = t.skins.length - 1
        }
        processNode(e) {
            const t = this.json,
                n = this.options,
                r = this.nodeMap;
            t.nodes || (t.nodes = []);
            const i = {};
            if (n.trs) {
                const t = e.quaternion.toArray(),
                    n = e.position.toArray(),
                    r = e.scale.toArray();
                mx(t, [0, 0, 0, 1]) || (i.rotation = t), mx(n, [0, 0, 0]) || (i.translation = n), mx(r, [1, 1, 1]) || (i.scale = r)
            } else e.matrixAutoUpdate && e.updateMatrix(), !1 === mx(e.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (i.matrix = e.matrix.elements);
            if ("" !== e.name && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
                const t = this.processMesh(e);
                null !== t && (i.mesh = t)
            } else e.isCamera && (i.camera = this.processCamera(e));
            if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
                const t = [];
                for (let r = 0, i = e.children.length; r < i; r++) {
                    const i = e.children[r];
                    if (i.visible || !1 === n.onlyVisible) {
                        const e = this.processNode(i);
                        null !== e && t.push(e)
                    }
                }
                t.length > 0 && (i.children = t)
            }
            this._invokeAll((function(t) {
                t.writeNode && t.writeNode(e, i)
            }));
            const s = t.nodes.push(i) - 1;
            return r.set(e, s), s
        }
        processScene(e) {
            const t = this.json,
                n = this.options;
            t.scenes || (t.scenes = [], t.scene = 0);
            const r = {};
            "" !== e.name && (r.name = e.name), t.scenes.push(r);
            const i = [];
            for (let t = 0, r = e.children.length; t < r; t++) {
                const r = e.children[t];
                if (r.visible || !1 === n.onlyVisible) {
                    const e = this.processNode(r);
                    null !== e && i.push(e)
                }
            }
            i.length > 0 && (r.nodes = i), this.serializeUserData(e, r)
        }
        processObjects(e) {
            const t = new i.xsS;
            t.name = "AuxScene";
            for (let n = 0; n < e.length; n++) t.children.push(e[n]);
            this.processScene(t)
        }
        processInput(e) {
            const t = this.options;
            e = e instanceof Array ? e : [e], this._invokeAll((function(t) {
                t.beforeParse && t.beforeParse(e)
            }));
            const n = [];
            for (let t = 0; t < e.length; t++) e[t] instanceof i.xsS ? this.processScene(e[t]) : n.push(e[t]);
            n.length > 0 && this.processObjects(n);
            for (let e = 0; e < this.skins.length; ++e) this.processSkin(this.skins[e]);
            for (let n = 0; n < t.animations.length; ++n) this.processAnimation(t.animations[n], e[0]);
            this._invokeAll((function(t) {
                t.afterParse && t.afterParse(e)
            }))
        }
        _invokeAll(e) {
            for (let t = 0, n = this.plugins.length; t < n; t++) e(this.plugins[t])
        }
    }
    class yx {
        constructor(e) {
            this.writer = e, this.name = "KHR_lights_punctual"
        }
        writeNode(e, t) {
            if (!e.isLight) return;
            if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
            const n = this.writer,
                r = n.json,
                i = n.extensionsUsed,
                s = {};
            e.name && (s.name = e.name), s.color = e.color.toArray(), s.intensity = e.intensity, e.isDirectionalLight ? s.type = "directional" : e.isPointLight ? (s.type = "point", e.distance > 0 && (s.range = e.distance)) : e.isSpotLight && (s.type = "spot", e.distance > 0 && (s.range = e.distance), s.spot = {}, s.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, s.spot.outerConeAngle = e.angle), void 0 !== e.decay && 2 !== e.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e.target || e.target.parent === e && 0 === e.target.position.x && 0 === e.target.position.y && -1 === e.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), i[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = {
                lights: []
            }, i[this.name] = !0);
            const o = r.extensions[this.name].lights;
            o.push(s), t.extensions = t.extensions || {}, t.extensions[this.name] = {
                light: o.length - 1
            }
        }
    }
    class wx {
        constructor(e) {
            this.writer = e, this.name = "KHR_materials_unlit"
        }
        writeMaterial(e, t) {
            if (!e.isMeshBasicMaterial) return;
            const n = this.writer.extensionsUsed;
            t.extensions = t.extensions || {}, t.extensions[this.name] = {}, n[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9
        }
    }
    class Sx {
        constructor(e) {
            this.writer = e, this.name = "KHR_materials_pbrSpecularGlossiness"
        }
        writeMaterial(e, t) {
            if (!e.isGLTFSpecularGlossinessMaterial) return;
            const n = this.writer,
                r = n.extensionsUsed,
                i = {};
            t.pbrMetallicRoughness.baseColorFactor && (i.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor);
            const s = [1, 1, 1];
            if (e.specular.toArray(s, 0), i.specularFactor = s, i.glossinessFactor = e.glossiness, t.pbrMetallicRoughness.baseColorTexture && (i.diffuseTexture = t.pbrMetallicRoughness.baseColorTexture), e.specularMap) {
                const t = {
                    index: n.processTexture(e.specularMap)
                };
                n.applyTextureTransform(t, e.specularMap), i.specularGlossinessTexture = t
            }
            t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
        }
    }
    class Mx {
        constructor(e) {
            this.writer = e, this.name = "KHR_materials_clearcoat"
        }
        writeMaterial(e, t) {
            if (!e.isMeshPhysicalMaterial) return;
            const n = this.writer,
                r = n.extensionsUsed,
                i = {};
            if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
                const t = {
                    index: n.processTexture(e.clearcoatMap)
                };
                n.applyTextureTransform(t, e.clearcoatMap), i.clearcoatTexture = t
            }
            if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
                const t = {
                    index: n.processTexture(e.clearcoatRoughnessMap)
                };
                n.applyTextureTransform(t, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = t
            }
            if (e.clearcoatNormalMap) {
                const t = {
                    index: n.processTexture(e.clearcoatNormalMap)
                };
                n.applyTextureTransform(t, e.clearcoatNormalMap), i.clearcoatNormalTexture = t
            }
            t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
        }
    }
    class Tx {
        constructor(e) {
            this.writer = e, this.name = "KHR_materials_iridescence"
        }
        writeMaterial(e, t) {
            if (!e.isMeshPhysicalMaterial) return;
            const n = this.writer,
                r = n.extensionsUsed,
                i = {};
            if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
                const t = {
                    index: n.processTexture(e.iridescenceMap)
                };
                n.applyTextureTransform(t, e.iridescenceMap), i.iridescenceTexture = t
            }
            if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
                const t = {
                    index: n.processTexture(e.iridescenceThicknessMap)
                };
                n.applyTextureTransform(t, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = t
            }
            t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
        }
    }
    class Ex {
        constructor(e) {
            this.writer = e, this.name = "KHR_materials_transmission"
        }
        writeMaterial(e, t) {
            if (!e.isMeshPhysicalMaterial || 0 === e.transmission) return;
            const n = this.writer,
                r = n.extensionsUsed,
                i = {};
            if (i.transmissionFactor = e.transmission, e.transmissionMap) {
                const t = {
                    index: n.processTexture(e.transmissionMap)
                };
                n.applyTextureTransform(t, e.transmissionMap), i.transmissionTexture = t
            }
            t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
        }
    }
    class Ax {
        constructor(e) {
            this.writer = e, this.name = "KHR_materials_volume"
        }
        writeMaterial(e, t) {
            if (!e.isMeshPhysicalMaterial || 0 === e.transmission) return;
            const n = this.writer,
                r = n.extensionsUsed,
                i = {};
            if (i.thicknessFactor = e.thickness, e.thicknessMap) {
                const t = {
                    index: n.processTexture(e.thicknessMap)
                };
                n.applyTextureTransform(t, e.thicknessMap), i.thicknessTexture = t
            }
            i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
        }
    }
    class Cx {
        constructor(e) {
            this.writer = e, this.name = "KHR_materials_sheen"
        }
        writeMaterial(e, t) {
            if (!e.isMeshPhysicalMaterial || e.sheen < .01) return;
            const n = this.writer,
                r = n.extensionsUsed,
                i = {};
            if (i.sheenColorFactor = e.sheenColor.toArray(), e.sheenColorMap) {
                const t = {
                    index: n.processTexture(e.sheenColorMap)
                };
                n.applyTextureTransform(t, e.sheenColorMap), i.sheenColorTexture = t
            }
            if (i.sheenRoughnessFactor = e.sheenRoughness, e.sheenRoughnessMap) {
                const t = {
                    index: n.processTexture(e.sheenRoughnessMap)
                };
                n.applyTextureTransform(t, e.sheenRoughnessMap), i.sheenRoughnessTexture = t
            }
            t.extensions = t.extensions || {}, t.extensions[this.name] = i, t.extras = t.extras || {}, t.extras.sheenFactor = e.sheen, r[this.name] = !0
        }
    }
    class Rx {
        constructor(e) {
            this.writer = e, this.name = "KHR_materials_ior"
        }
        writeMaterial(e, t) {
            if (!e.isMeshPhysicalMaterial) return;
            const n = this.writer.extensionsUsed,
                r = {};
            r.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = r, n[this.name] = !0
        }
    }
    px.Utils = {
        GLTFWriter: xx,
        insertKeyframe: function(e, t) {
            const n = .001,
                r = e.getValueSize(),
                i = new e.TimeBufferType(e.times.length + 1),
                s = new e.ValueBufferType(e.values.length + r),
                o = e.createInterpolant(new e.ValueBufferType(r));
            let a;
            if (0 === e.times.length) {
                i[0] = t;
                for (let e = 0; e < r; e++) s[e] = 0;
                a = 0
            } else if (t < e.times[0]) {
                if (Math.abs(e.times[0] - t) < n) return 0;
                i[0] = t, i.set(e.times, 1), s.set(o.evaluate(t), 0), s.set(e.values, r), a = 0
            } else if (t > e.times[e.times.length - 1]) {
                if (Math.abs(e.times[e.times.length - 1] - t) < n) return e.times.length - 1;
                i[i.length - 1] = t, i.set(e.times, 0), s.set(e.values, 0), s.set(o.evaluate(t), e.values.length), a = i.length - 1
            } else
                for (let l = 0; l < e.times.length; l++) {
                    if (Math.abs(e.times[l] - t) < n) return l;
                    if (e.times[l] < t && e.times[l + 1] > t) {
                        i.set(e.times.slice(0, l + 1), 0), i[l + 1] = t, i.set(e.times.slice(l + 1), l + 2), s.set(e.values.slice(0, (l + 1) * r), 0), s.set(o.evaluate(t), (l + 1) * r), s.set(e.values.slice((l + 1) * r), (l + 2) * r), a = l + 1;
                        break
                    }
                }
            return e.times = i, e.values = s, a
        },
        mergeMorphTargetTracks: function(e, t) {
            const n = [],
                r = {},
                s = e.tracks;
            for (let e = 0; e < s.length; ++e) {
                let o = s[e];
                const a = i.iUV.parseTrackName(o.name),
                    l = i.iUV.findNode(t, a.nodeName);
                if ("morphTargetInfluences" !== a.propertyName || void 0 === a.propertyIndex) {
                    n.push(o);
                    continue
                }
                if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
                    if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                    console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(i.NMF)
                }
                const c = l.morphTargetInfluences.length,
                    u = l.morphTargetDictionary[a.propertyIndex];
                if (void 0 === u) throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
                let p;
                if (void 0 === r[l.uuid]) {
                    p = o.clone();
                    const e = new p.ValueBufferType(c * p.times.length);
                    for (let t = 0; t < p.times.length; t++) e[t * c + u] = p.values[t];
                    p.name = (a.nodeName || "") + ".morphTargetInfluences", p.values = e, r[l.uuid] = p, n.push(p);
                    continue
                }
                const h = o.createInterpolant(new o.ValueBufferType(1));
                p = r[l.uuid];
                for (let e = 0; e < p.times.length; e++) p.values[e * c + u] = h.evaluate(p.times[e]);
                for (let e = 0; e < o.times.length; e++) {
                    const t = this.insertKeyframe(p, o.times[e]);
                    p.values[t * c + u] = o.values[e]
                }
            }
            return e.tracks = n, e
        }
    };
    class kx extends px.Utils.GLTFWriter {
        constructor() {
            super(...arguments), this._defaultMaterial = new i.Wid
        }
        serializeUserData(e, t) {
            const n = e.userData,
                r = {};
            n.__disposed && console.error("Serializing a disposed object", e), Object.entries(n).forEach((([e, t]) => {
                (!t || "function" == typeof t || t.isObject3D || t.isTexture || t.isMaterial || null != t.assetType || e.startsWith("_") || "uuid" !== e && (ct.includes(e) || ut.includes(e) || Xt.includes(e))) && (r[e] = t, delete n[e])
            })), super.serializeUserData(e, t), Object.entries(r).forEach((([e, t]) => {
                n[e] = t, delete r[e]
            }))
        }
        processObjects(e) {
            var t;
            1 === e.length && (null === (t = e[0]) || void 0 === t ? void 0 : t.userData.rootSceneModelRoot) ? this.processScene(e[0]) : super.processObjects(e)
        }
        processMaterial(e) {
            if (this.cache.materials.has(e)) return this.cache.materials.get(e);
            let t = e;
            t.isShaderMaterial && (t = this._defaultMaterial);
            const n = super.processMaterial(t),
                r = JSON.stringify(this.json.materials[n]),
                i = JSON.parse(r);
            if (this.serializeUserData(e, i), this._invokeAll((t => {
                    t.writeMaterial && t.writeMaterial(e, i)
                })), JSON.stringify(i) === r) return n;
            const s = this.json.materials.push(i) - 1;
            return this.cache.materials.set(e, s), s
        }
        processImageBlob(e, t) {
            const n = this.cache,
                r = this.options,
                i = this.pending,
                s = this.json,
                o = t.image;
            n.images.has(o) || n.images.set(o, {});
            const a = n.images.get(o),
                l = e.type + ":flipY/" + t.flipY.toString();
            if (void 0 !== a[l]) return a[l];
            s.images || (s.images = []);
            const c = {
                mimeType: e.type
            };
            !0 === r.binary ? i.push(new Promise((t => {
                this.processBufferViewImage(e).then((e => {
                    c.bufferView = e, t()
                }))
            }))) : i.push(bt(e).then((e => {
                c.uri = e
            })));
            const u = s.images.push(c) - 1;
            return a[l] = u, u
        }
    }
    class Px extends px {
        register(e) {
            return super.register(e)
        }
        async parseAsync(e, t) {
            var n;
            if (!e) throw new Error("No object to export");
            const r = e.__isGLTFOutput || !Array.isArray(e) && !e.isObject3D ? e : await new Promise(((n, r) => this.parse(e, n, r, t)));
            if (r && "object" == typeof r && !r.byteLength) return new Blob([JSON.stringify(r, ((e, t) => e.startsWith("__") ? void 0 : t), null !== (n = t.jsonSpaces) && void 0 !== n ? n : 2)], {
                type: "model/gltf+json"
            });
            if (r) return new Blob([r], {
                type: "model/gltf+binary"
            });
            throw new Error("GLTFExporter2.parse() failed")
        }
        parse(e, t, n, r) {
            const i = {
                binary: !1,
                trs: !1,
                onlyVisible: !0,
                truncateDrawRange: !0,
                embedImages: !0,
                maxTextureSize: 1 / 0,
                animations: [],
                includeCustomExtensions: !0
            };
            return "glb" === r.exportExt && (i.binary = !0), !1 !== r.preserveUUIDs && (Array.isArray(e) ? e : [e]).forEach((e => e.traverse((e => {
                e.uuid && (e.userData.gltfUUID = e.uuid)
            })))), (Array.isArray(e) ? e : [e]).forEach((e => e.traverse((e => {
                if (e.animations)
                    for (const t of e.animations) !1 === t.__gltfExport || i.animations.includes(t) || i.animations.push(...e.animations)
            })))), super.parse(e, (n => {
                !1 !== r.preserveUUIDs && (Array.isArray(e) ? e : [e]).forEach((e => e.traverse((e => {
                    delete e.userData.gltfUUID
                })))), t(Object.assign(n, {
                    __isGLTFOutput: !0
                }))
            }), n, i, new kx)
        }
    }
    class Dx extends r {
        constructor(e, t = {}) {
            super(), this._processors = new rt, this._cachedParsers = [], Ox(e)
        }
        get processors() {
            return this._processors
        }
        getExporter(...e) {
            return Dx.Exporters.find((t => t.ext.some((t => e.includes(t)))))
        }
        async exportObject(e, t = {}) {
            var n, r, i, s;
            if (!(null == e ? void 0 : e.assetType)) return void console.error("Object has no asset type");
            (null === (r = null === (n = e) || void 0 === n ? void 0 : n.userData) || void 0 === r ? void 0 : r.rootSceneModelRoot) && !1 === t.viewerConfig && (e.userData.__exportViewerConfig = !1);
            const o = await this._exportFile(e, t);
            return (null === (s = null === (i = e) || void 0 === i ? void 0 : i.userData) || void 0 === s ? void 0 : s.rootSceneModelRoot) && !1 === t.viewerConfig && delete e.userData.__exportViewerConfig, o
        }
        async _exportFile(e, t = {}) {
            var n, r, i;
            let s;
            this.dispatchEvent({
                type: "exportFile",
                obj: e,
                state: "processing"
            });
            try {
                const o = await this.processBeforeExport(e, t),
                    a = null !== (r = null !== (n = t.exportExt) && void 0 !== n ? n : null == o ? void 0 : o.typeExt) && void 0 !== r ? r : null == o ? void 0 : o.ext;
                if (!o || !a) throw new Error(`Unable to preprocess before export ${a}`);
                const l = this._getParser(a);
                this.dispatchEvent({
                    type: "exportFile",
                    obj: e,
                    state: "exporting"
                });
                const c = await l.parseAsync(o.obj, {
                    exportExt: null !== (i = o.ext) && void 0 !== i ? i : a,
                    ...t
                });
                c.ext = o.ext, s = c
            } catch (t) {
                return console.error("AssetExporter: Unable to Export file", e), console.error(t), void this.dispatchEvent({
                    type: "exportFile",
                    obj: e,
                    state: "error",
                    error: t
                })
            }
            return this.dispatchEvent({
                type: "exportFile",
                obj: e,
                state: "done"
            }), s
        }
        _createParser(e) {
            const t = Dx.Exporters.find((t => t.ext.includes(e)));
            if (!t) throw new Error(`No exporter found for extension ${e}`);
            const n = null == t ? void 0 : t.ctor(this);
            if (!n) throw new Error(`Unable to create parser for extension ${e}`);
            return this._cachedParsers.push({
                ext: t.ext,
                parser: n
            }), this.dispatchEvent({
                type: "exporterCreate",
                exporter: t,
                parser: n
            }), n
        }
        _getParser(e) {
            var t, n;
            return null !== (n = null === (t = this._cachedParsers.find((t => t.ext.includes(e)))) || void 0 === t ? void 0 : t.parser) && void 0 !== n ? n : this._createParser(e)
        }
        async processBeforeExport(e, t = {}) {
            switch (null != e.assetType && (e = await this._processors.process(e.assetType, e, t)), e.assetType) {
                case "light":
                    return void console.error("AssetExporter: light export not implemented");
                case "model":
                    return {
                        obj: e,
                        ext: "glb"
                    };
                case "material":
                    return {
                        obj: e.toJSON(),
                        ext: e.typeSlug || "json",
                        typeExt: "json"
                    };
                case "texture":
                    return {
                        obj: e.toJSON(),
                        ext: "json"
                    };
                default:
                    console.error("AssetExporter: unknown asset type", e.assetType)
            }
        }
        dispose() {
            var e;
            null === (e = this._processors) || void 0 === e || e.dispose()
        }
    }

    function Ox(e, t = Px, n) {
        var r;
        if (!e) return;
        const i = Dx.Exporters.findIndex((e => e.ext.includes("gltf") || e.ext.includes("glb"))),
            s = [];
        if (i >= 0) s.push(...null !== (r = Dx.Exporters[i].extensions) && void 0 !== r ? r : []), Dx.Exporters.splice(i, 1);
        else {
            const t = t => ({
                afterParse: n => {
                    var r, i;
                    if (!(null === (r = null == (n = Array.isArray(n) ? n[0] : n) ? void 0 : n.userData) || void 0 === r ? void 0 : r.rootSceneModelRoot) || !1 === (null === (i = null == n ? void 0 : n.userData) || void 0 === i ? void 0 : i.__exportViewerConfig)) return;
                    const s = t.json.scenes[t.json.scene || 0];
                    s.extensions || (s.extensions = {}), s.extensions[Jn] = cx(e, t), t.extensionsUsed[Jn] = !0
                }
            });
            s.push(Fx), s.push(Ix), s.push(Lx), s.push(t), s.push((e => new Nx(e))), s.push((e => new Ux(e))), s.push((e => new Bx(e)))
        }
        Dx.Exporters.push({
            ctor: () => {
                const e = new t;
                return s.forEach((t => e.register(t))), null == n || n(e), e
            },
            ext: ["gltf", "glb"],
            extensions: s
        })
    }
    Dx.Exporters = [{
        ctor: () => new ax,
        ext: ["json"]
    }, {
        ctor: () => new lx,
        ext: ["txt", "text"]
    }];
    const Lx = e => ({
            writeNode: (t, n) => {
                if (!(null == t ? void 0 : t.isLight)) return;
                n.extensions || (n.extensions = {});
                const r = {};
                t.shadow && (r.shadow = t.shadow.toJSON()), Object.keys(r).length > 0 && (n.extensions[Qn] = r, e.extensionsUsed[Qn] = !0)
            }
        }),
        Ix = e => ({
            writeNode: (t, n) => {
                if (!(null == t ? void 0 : t.isObject3D)) return;
                n.extensions || (n.extensions = {});
                const r = {};
                void 0 !== t.castShadow && (r.castShadow = t.castShadow), void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow), !1 === t.visible && (r.visible = !1), !1 === t.frustumCulled && (r.frustumCulled = !1), 0 !== t.renderOrder && (r.renderOrder = t.renderOrder), 1 !== t.layers.mask && (r.layers = t.layers.mask), !1 === t.matrixAutoUpdate && (r.matrixAutoUpdate = !1), Object.keys(r).length > 0 && (n.extensions[er] = r, e.extensionsUsed[er] = !0)
            }
        }),
        Fx = e => ({
            writeMaterial: (t, n) => {
                var r;
                if (!(null == t ? void 0 : t.isMaterial)) return;
                n.extensions || (n.extensions = {});
                const i = {};
                if (void 0 !== t.emissiveIntensity && (null === (r = t.emissive) || void 0 === r ? void 0 : r.isColor)) {
                    const e = t.emissive.clone().multiplyScalar(t.emissiveIntensity),
                        n = Math.max(e.r, e.g, e.b);
                    n > 1 && (i.emissiveIntensity = n)
                }
                void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.alphaToCoverage && (i.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (i.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), Object.keys(i).length > 0 && (n.extensions[tr] = i, e.extensionsUsed[tr] = !0)
            }
        });
    class Nx {
        constructor(e) {
            this.writer = e, this.name = or
        }
        writeMaterial(e, t) {
            if (!e.isMeshStandardMaterial || 0 === e.bumpScale) return;
            const n = this.writer,
                r = n.extensionsUsed,
                i = {};
            if (i.bumpScale = e.bumpScale, e.bumpMap) {
                const t = {
                    index: n.processTexture(e.bumpMap)
                };
                n.applyTextureTransform(t, e.bumpMap), i.bumpTexture = t
            }
            t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
        }
    }
    class Ux {
        constructor(e) {
            this.writer = e, this.name = lr
        }
        writeMaterial(e, t) {
            if (!e.isMeshStandardMaterial || 0 === e.lightMapIntensity) return;
            const n = this.writer,
                r = n.extensionsUsed,
                i = {};
            if (i.lightMapIntensity = e.lightMapIntensity, e.bumpMap) {
                const t = {
                    index: n.processTexture(e.bumpMap)
                };
                n.applyTextureTransform(t, e.bumpMap), i.lightMapTexture = t
            }
            t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
        }
    }
    class Bx {
        constructor(e) {
            this.writer = e, this.name = ar
        }
        writeMaterial(e, t) {
            if (!e.isMeshStandardMaterial || !e.alphaMap) return;
            const n = this.writer,
                r = n.extensionsUsed,
                i = {};
            if (e.alphaMap) {
                const t = {
                    index: n.processTexture(e.alphaMap)
                };
                n.applyTextureTransform(t, e.alphaMap), i.alphaTexture = t
            }
            t.extensions = t.extensions || {}, t.extensions[this.name] = i, r[this.name] = !0
        }
    }
    class jx extends Gs {
        constructor(e) {
            super(), this.enabled = !0, this.exportOptions = {
                compress: !1,
                name: "scene",
                viewerConfig: !0,
                convertMeshToIndexed: !1
            }, this.exporter = e, this.exportScene = this.exportScene.bind(this)
        }
        async onAdded(e) {
            await super.onAdded(e), this.exporter || (this.exporter = new Dx(e)), this.exporter.processors.add("model", {
                forAssetType: "model",
                processAsync: async (e, t) => {
                    var n;
                    return t.convertMeshToIndexed && (null === (n = e.modelObject) || void 0 === n || n.traverse((e => {
                        e.geometry && (e.geometry.attributes.index || e.userData.setGeometry(q(e.geometry)))
                    }))), e
                }
            })
        }
        async onRemove(e) {
            return super.onRemove(e)
        }
        async exportScene(e) {
            var t, n;
            return null === (t = this.exporter) || void 0 === t ? void 0 : t.exportObject(null === (n = this._viewer) || void 0 === n ? void 0 : n.scene.modelRoot, e || { ...this.exportOptions
            })
        }
        get uiConfig() {
            if (this._uiConfig) return this._uiConfig;
            const e = this._viewer;
            e.addEventListener("addPlugin", (e => {
                var t;
                "function" == typeof(null === (t = e.plugin) || void 0 === t ? void 0 : t.toJSON) && console.error("Add all plugins before setting up the export UI, or use `toJSON: any = null` in the plugin ")
            }));
            const t = Object.entries(e.plugins).filter((([e, t]) => "function" == typeof(null == t ? void 0 : t.toJSON))).map((([e, t]) => ({
                label: e,
                type: "checkbox",
                value: !0
            })));
            return this._uiConfig = {
                type: "folder",
                label: "Asset Exporter",
                limitedUi: !0,
                children: [{
                    type: "input",
                    property: [this.exportOptions, "name"],
                    limitedUi: !0
                }, {
                    type: "folder",
                    label: "GLB Export",
                    limitedUi: !0,
                    children: [{
                        type: "checkbox",
                        label: "DRACO Compress",
                        property: [this.exportOptions, "compress"],
                        limitedUi: !0
                    }, {
                        type: "checkbox",
                        label: "Scene Settings",
                        property: [this.exportOptions, "viewerConfig"],
                        limitedUi: !0
                    }, {
                        type: "checkbox",
                        label: "Indexed meshes only",
                        property: [this.exportOptions, "convertMeshToIndexed"]
                    }, {
                        type: "button",
                        label: "Export GLB",
                        limitedUi: !0,
                        value: async () => {
                            const e = await this.exportScene(this.exportOptions);
                            e && vt(e, this.exportOptions.name + "." + e.ext)
                        }
                    }]
                }, {
                    type: "folder",
                    label: "Preset/Config export",
                    children: [{
                        type: "folder",
                        label: "Plugins",
                        children: t
                    }, {
                        type: "button",
                        label: "Select none",
                        value: () => {
                            t.forEach((e => {
                                var t;
                                e.value = !1, null === (t = e.uiRefresh) || void 0 === t || t.call(e)
                            }))
                        }
                    }, {
                        type: "button",
                        label: "Select all",
                        value: () => {
                            t.forEach((e => {
                                var t;
                                e.value = !0, null === (t = e.uiRefresh) || void 0 === t || t.call(e)
                            }))
                        }
                    }, {
                        type: "button",
                        label: "Export Plugins",
                        limitedUi: !0,
                        value: async () => {
                            const n = new Blob([JSON.stringify(e.getPlugin(Vs).exportPluginPresets(t.filter((e => !!e.value)).map((e => x(e.label) || ""))), null, 2)], {
                                type: "application/json"
                            });
                            n && vt(n, this.exportOptions.name + "." + Vs.ViewerTypeSlug)
                        }
                    }, {
                        type: "button",
                        label: "Export All Viewer Config",
                        limitedUi: !0,
                        value: async () => {
                            const t = new Blob([JSON.stringify(e.getPlugin(Vs).exportViewerConfig(), null, 2)], {
                                type: "application/json"
                            });
                            t && vt(t, this.exportOptions.name + "." + Vs.ViewerTypeSlug)
                        }
                    }]
                }]
            }
        }
    }
    jx.PluginType = "AssetExporterPlugin";
    class zx {
        constructor() {
            this._listeners = {}
        }
        addEventListener(e, t) {
            const n = this._listeners;
            return void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t), this
        }
        removeEventListener(e, t) {
            if (void 0 === this._listeners) return this;
            const n = this._listeners[e];
            if (void 0 !== n) {
                const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
            }
            return this
        }
        dispatchEvent(e) {
            if (void 0 === this._listeners) return this;
            const t = this._listeners[e.type];
            if (void 0 !== t) {
                const n = t.slice(0);
                for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e)
            }
            return this
        }
        dispose() {
            for (const e in this._listeners) delete this._listeners[e]
        }
    }
    class Vx extends zx {
        constructor(e, t, n, r = {}) {
            if (super(), this._name = void 0, this._parent = void 0, this._child = void 0, this._attributes = void 0, this._disposed = !1, this._name = e, this._parent = t, this._child = n, this._attributes = r, !t.isOnGraph(n)) throw new Error("Cannot connect disconnected graphs.")
        }
        getName() {
            return this._name
        }
        getParent() {
            return this._parent
        }
        getChild() {
            return this._child
        }
        setChild(e) {
            return this._child = e, this
        }
        getAttributes() {
            return this._attributes
        }
        dispose() {
            this._disposed || (this._disposed = !0, this.dispatchEvent({
                type: "dispose",
                target: this
            }), super.dispose())
        }
        isDisposed() {
            return this._disposed
        }
    }
    class Gx extends zx {
        constructor(...e) {
            super(...e), this._emptySet = new Set, this._edges = new Set, this._parentEdges = new Map, this._childEdges = new Map
        }
        listEdges() {
            return Array.from(this._edges)
        }
        listParentEdges(e) {
            return Array.from(this._childEdges.get(e) || this._emptySet)
        }
        listParents(e) {
            return this.listParentEdges(e).map((e => e.getParent()))
        }
        listChildEdges(e) {
            return Array.from(this._parentEdges.get(e) || this._emptySet)
        }
        listChildren(e) {
            return this.listChildEdges(e).map((e => e.getChild()))
        }
        disconnectParents(e, t) {
            let n = this.listParentEdges(e);
            return t && (n = n.filter((e => t(e.getParent())))), n.forEach((e => e.dispose())), this
        }
        createEdge(e, t, n, r) {
            return this._registerEdge(new Vx(e, t, n, r))
        }
        _registerEdge(e) {
            this._edges.add(e);
            const t = e.getParent();
            this._parentEdges.has(t) || this._parentEdges.set(t, new Set), this._parentEdges.get(t).add(e);
            const n = e.getChild();
            return this._childEdges.has(n) || this._childEdges.set(n, new Set), this._childEdges.get(n).add(e), e.addEventListener("dispose", (() => this._removeEdge(e))), e
        }
        _removeEdge(e) {
            return this._edges.delete(e), this._parentEdges.get(e.getParent()).delete(e), this._childEdges.get(e.getChild()).delete(e), this
        }
    }

    function Hx() {
        return (Hx = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }).apply(this, arguments)
    }

    function Wx(e) {
        return e instanceof Vx
    }

    function Kx(e) {
        return Array.isArray(e) && e[0] instanceof Vx
    }

    function Xx(e) {
        return !!(e && "object" == typeof e && Object.values(e)[0] instanceof Vx)
    }
    const qx = Symbol("attributes"),
        Yx = Symbol("immutableKeys");
    class Zx extends zx {
        constructor(e) {
            super(), this._disposed = !1, this.graph = void 0, this[qx] = void 0, this[Yx] = void 0, this.graph = e, this[Yx] = new Set, this[qx] = this._createAttributes()
        }
        getDefaults() {
            return {}
        }
        _createAttributes() {
            const e = this.getDefaults(),
                t = {};
            for (const n in e) {
                const r = e[n];
                if (r instanceof Zx) {
                    const e = this.graph.createEdge(n, this, r);
                    e.addEventListener("dispose", (() => r.dispose())), this[Yx].add(n), t[n] = e
                } else t[n] = r
            }
            return t
        }
        isOnGraph(e) {
            return this.graph === e.graph
        }
        isDisposed() {
            return this._disposed
        }
        dispose() {
            this._disposed || (this.graph.listChildEdges(this).forEach((e => e.dispose())), this.graph.disconnectParents(this), this._disposed = !0, this.dispatchEvent({
                type: "dispose"
            }))
        }
        detach() {
            return this.graph.disconnectParents(this), this
        }
        swap(e, t) {
            for (const n in this[qx]) {
                const r = this[qx][n];
                if (Wx(r)) {
                    const i = r;
                    i.getChild() === e && this.setRef(n, t, i.getAttributes())
                } else if (Kx(r)) {
                    const i = r.find((t => t.getChild() === e));
                    if (i) {
                        const r = i.getAttributes();
                        this.removeRef(n, e).addRef(n, t, r)
                    }
                } else if (Xx(r)) {
                    const i = r;
                    for (const r in i) {
                        const s = i[r];
                        s.getChild() === e && this.setRefMap(n, r, t, s.getAttributes())
                    }
                }
            }
            return this
        }
        get(e) {
            return this[qx][e]
        }
        set(e, t) {
            return this[qx][e] = t, this.dispatchEvent({
                type: "change",
                attribute: e
            })
        }
        getRef(e) {
            const t = this[qx][e];
            return t ? t.getChild() : null
        }
        setRef(e, t, n) {
            if (this[Yx].has(e)) throw new Error(`Cannot overwrite immutable attribute, "${e}".`);
            const r = this[qx][e];
            if (r && r.dispose(), !t) return this;
            const i = this.graph.createEdge(e, this, t, n);
            return i.addEventListener("dispose", (() => {
                delete this[qx][e], this.dispatchEvent({
                    type: "change",
                    attribute: e
                })
            })), this[qx][e] = i, this.dispatchEvent({
                type: "change",
                attribute: e
            })
        }
        listRefs(e) {
            return this[qx][e].map((e => e.getChild()))
        }
        addRef(e, t, n) {
            const r = this.graph.createEdge(e, this, t, n),
                i = this[qx][e];
            return i.push(r), r.addEventListener("dispose", (() => {
                const t = i.filter((e => e !== r));
                i.length = 0;
                for (const e of t) i.push(e);
                this.dispatchEvent({
                    type: "change",
                    attribute: e
                })
            })), this.dispatchEvent({
                type: "change",
                attribute: e
            })
        }
        removeRef(e, t) {
            return this[qx][e].filter((e => e.getChild() === t)).forEach((e => e.dispose())), this
        }
        listRefMapKeys(e) {
            return Object.keys(this[qx][e])
        }
        listRefMapValues(e) {
            return Object.values(this[qx][e]).map((e => e.getChild()))
        }
        getRefMap(e, t) {
            const n = this[qx][e];
            return n[t] ? n[t].getChild() : null
        }
        setRefMap(e, t, n, r) {
            const i = this[qx][e],
                s = i[t];
            if (s && s.dispose(), !n) return this;
            r = Object.assign(r || {}, {
                key: t
            });
            const o = this.graph.createEdge(e, this, n, Hx({}, r, {
                key: t
            }));
            return o.addEventListener("dispose", (() => {
                delete i[t], this.dispatchEvent({
                    type: "change",
                    attribute: e,
                    key: t
                })
            })), i[t] = o, this.dispatchEvent({
                type: "change",
                attribute: e,
                key: t
            })
        }
        dispatchEvent(e) {
            return super.dispatchEvent(Hx({}, e, {
                target: this
            })), this.graph.dispatchEvent(Hx({}, e, {
                target: this,
                type: `node:${e.type}`
            })), this
        }
    }
    var Jx, $x, Qx, ey, ty, ny, ry = "undefined" != typeof Float32Array ? Float32Array : Array;

    function iy(e) {
        var t = e[0],
            n = e[1],
            r = e[2];
        return Math.hypot(t, n, r)
    }

    function sy(e, t, n) {
        var r = t[0],
            i = t[1],
            s = t[2],
            o = n[3] * r + n[7] * i + n[11] * s + n[15];
        return o = o || 1, e[0] = (n[0] * r + n[4] * i + n[8] * s + n[12]) / o, e[1] = (n[1] * r + n[5] * i + n[9] * s + n[13]) / o, e[2] = (n[2] * r + n[6] * i + n[10] * s + n[14]) / o, e
    }

    function oy(e, t, n) {
        var r = t[0],
            i = t[1],
            s = t[2],
            o = t[3],
            a = t[4],
            l = t[5],
            c = t[6],
            u = t[7],
            p = t[8],
            h = t[9],
            d = t[10],
            f = t[11],
            _ = t[12],
            m = t[13],
            g = t[14],
            v = t[15],
            b = n[0],
            x = n[1],
            y = n[2],
            w = n[3];
        return e[0] = b * r + x * a + y * p + w * _, e[1] = b * i + x * l + y * h + w * m, e[2] = b * s + x * c + y * d + w * g, e[3] = b * o + x * u + y * f + w * v, b = n[4], x = n[5], y = n[6], w = n[7], e[4] = b * r + x * a + y * p + w * _, e[5] = b * i + x * l + y * h + w * m, e[6] = b * s + x * c + y * d + w * g, e[7] = b * o + x * u + y * f + w * v, b = n[8], x = n[9], y = n[10], w = n[11], e[8] = b * r + x * a + y * p + w * _, e[9] = b * i + x * l + y * h + w * m, e[10] = b * s + x * c + y * d + w * g, e[11] = b * o + x * u + y * f + w * v, b = n[12], x = n[13], y = n[14], w = n[15], e[12] = b * r + x * a + y * p + w * _, e[13] = b * i + x * l + y * h + w * m, e[14] = b * s + x * c + y * d + w * g, e[15] = b * o + x * u + y * f + w * v, e
    }

    function ay(e, t) {
        const n = {
            min: [1 / 0, 1 / 0, 1 / 0],
            max: [-1 / 0, -1 / 0, -1 / 0]
        };
        for (const r of e.listPrimitives()) {
            const e = r.getAttribute("POSITION");
            if (!e) continue;
            let i = [0, 0, 0],
                s = [0, 0, 0];
            for (let r = 0; r < e.getCount(); r++) i = e.getElement(r, i), s = sy(s, i, t), ly(s, n)
        }
        return n
    }

    function ly(e, t) {
        for (let n = 0; n < 3; n++) t.min[n] = Math.min(e[n], t.min[n]), t.max[n] = Math.max(e[n], t.max[n])
    }
    Math.random, Math.PI, Math.hypot || (Math.hypot = function() {
            for (var e = 0, t = arguments.length; t--;) e += arguments[t] * arguments[t];
            return Math.sqrt(e)
        }), Jx = new ry(3), ry != Float32Array && (Jx[0] = 0, Jx[1] = 0, Jx[2] = 0),
        function(e) {
            e.ACCESSOR = "Accessor", e.ANIMATION = "Animation", e.ANIMATION_CHANNEL = "AnimationChannel", e.ANIMATION_SAMPLER = "AnimationSampler", e.BUFFER = "Buffer", e.CAMERA = "Camera", e.MATERIAL = "Material", e.MESH = "Mesh", e.PRIMITIVE = "Primitive", e.PRIMITIVE_TARGET = "PrimitiveTarget", e.NODE = "Node", e.ROOT = "Root", e.SCENE = "Scene", e.SKIN = "Skin", e.TEXTURE = "Texture", e.TEXTURE_INFO = "TextureInfo"
        }($x || ($x = {})),
        function(e) {
            e.INTERLEAVED = "interleaved", e.SEPARATE = "separate"
        }(Qx || (Qx = {})),
        function(e) {
            e.ARRAY_BUFFER = "ARRAY_BUFFER", e.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER", e.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES", e.OTHER = "OTHER"
        }(ey || (ey = {})),
        function(e) {
            e[e.R = 4096] = "R", e[e.G = 256] = "G", e[e.B = 16] = "B", e[e.A = 1] = "A"
        }(ty || (ty = {})),
        function(e) {
            e.GLTF = "GLTF", e.GLB = "GLB"
        }(ny || (ny = {}));
    class cy {
        static createBufferFromDataURI(e) {
            if ("undefined" == typeof Buffer) {
                const t = atob(e.split(",")[1]),
                    n = new Uint8Array(t.length);
                for (let e = 0; e < t.length; e++) n[e] = t.charCodeAt(e);
                return n
            } {
                const t = e.split(",")[1],
                    n = e.indexOf("base64") >= 0;
                return Buffer.from(t, n ? "base64" : "utf8")
            }
        }
        static encodeText(e) {
            return "undefined" != typeof TextEncoder ? (new TextEncoder).encode(e) : Buffer.from(e)
        }
        static decodeText(e) {
            return "undefined" != typeof TextDecoder ? (new TextDecoder).decode(e) : Buffer.from(e).toString("utf8")
        }
        static concat(e) {
            let t = 0;
            for (const n of e) t += n.byteLength;
            const n = new Uint8Array(t);
            let r = 0;
            for (const t of e) n.set(t, r), r += t.byteLength;
            return n
        }
        static pad(e, t = 0) {
            const n = this.padNumber(e.byteLength);
            if (n === e.byteLength) return e;
            const r = new Uint8Array(n);
            if (r.set(e), 0 !== t)
                for (let i = e.byteLength; i < n; i++) r[i] = t;
            return r
        }
        static padNumber(e) {
            return 4 * Math.ceil(e / 4)
        }
        static equals(e, t) {
            if (e === t) return !0;
            if (e.byteLength !== t.byteLength) return !1;
            let n = e.byteLength;
            for (; n--;)
                if (e[n] !== t[n]) return !1;
            return !0
        }
        static toView(e, t = 0, n = 1 / 0) {
            return new Uint8Array(e.buffer, e.byteOffset + t, Math.min(e.byteLength, n))
        }
        static assertView(e) {
            if (e && !ArrayBuffer.isView(e)) throw new Error(`Method requires Uint8Array parameter; received "${typeof e}".`);
            return e
        }
    }
    class uy {
        static hexToFactor(e, t) {
            e = Math.floor(e);
            const n = t;
            return n[0] = (e >> 16 & 255) / 255, n[1] = (e >> 8 & 255) / 255, n[2] = (255 & e) / 255, this.convertSRGBToLinear(t, t)
        }
        static factorToHex(e) {
            const t = [...e],
                [n, r, i] = this.convertLinearToSRGB(e, t);
            return 255 * n << 16 ^ 255 * r << 8 ^ 255 * i << 0
        }
        static convertSRGBToLinear(e, t) {
            const n = e,
                r = t;
            for (let e = 0; e < 3; e++) r[e] = n[e] < .04045 ? .0773993808 * n[e] : Math.pow(.9478672986 * n[e] + .0521327014, 2.4);
            return t
        }
        static convertLinearToSRGB(e, t) {
            const n = e,
                r = t;
            for (let e = 0; e < 3; e++) r[e] = n[e] < .0031308 ? 12.92 * n[e] : 1.055 * Math.pow(n[e], .41666) - .055;
            return t
        }
    }
    class py {
        match(e) {
            return e.length >= 8 && 137 === e[0] && 80 === e[1] && 78 === e[2] && 71 === e[3] && 13 === e[4] && 10 === e[5] && 26 === e[6] && 10 === e[7]
        }
        getSize(e) {
            const t = new DataView(e.buffer, e.byteOffset);
            return cy.decodeText(e.slice(12, 16)) === py.PNG_FRIED_CHUNK_NAME ? [t.getUint32(32, !1), t.getUint32(36, !1)] : [t.getUint32(16, !1), t.getUint32(20, !1)]
        }
        getChannels(e) {
            return 4
        }
    }
    py.PNG_FRIED_CHUNK_NAME = "CgBI";
    class hy {
        static registerFormat(e, t) {
            this.impls[e] = t
        }
        static getMimeType(e) {
            for (const t in this.impls)
                if (this.impls[t].match(e)) return t;
            return null
        }
        static getSize(e, t) {
            return this.impls[t] ? this.impls[t].getSize(e) : null
        }
        static getChannels(e, t) {
            return this.impls[t] ? this.impls[t].getChannels(e) : null
        }
        static getMemSize(e, t) {
            if (!this.impls[t]) return null;
            if (this.impls[t].getGPUByteLength) return this.impls[t].getGPUByteLength(e);
            let n = 0;
            const r = this.getSize(e, t);
            if (!r) return null;
            for (; r[0] > 1 || r[1] > 1;) n += r[0] * r[1] * 4, r[0] = Math.max(Math.floor(r[0] / 2), 1), r[1] = Math.max(Math.floor(r[1] / 2), 1);
            return n += 4, n
        }
        static mimeTypeToExtension(e) {
            return "image/jpeg" === e ? "jpg" : e.split("/").pop()
        }
        static extensionToMimeType(e) {
            return "jpg" === e ? "image/jpeg" : `image/${e}`
        }
    }

    function dy(e, t) {
        if (t > e.byteLength) throw new TypeError("Corrupt JPG, exceeded buffer limits");
        if (255 !== e.getUint8(t)) throw new TypeError("Invalid JPG, marker table corrupted");
        return e
    }
    hy.impls = {
        "image/jpeg": new class {
            match(e) {
                return e.length >= 3 && 255 === e[0] && 216 === e[1] && 255 === e[2]
            }
            getSize(e) {
                let t, n, r = new DataView(e.buffer, e.byteOffset + 4);
                for (; r.byteLength;) {
                    if (t = r.getUint16(0, !1), dy(r, t), n = r.getUint8(t + 1), 192 === n || 193 === n || 194 === n) return [r.getUint16(t + 7, !1), r.getUint16(t + 5, !1)];
                    r = new DataView(e.buffer, r.byteOffset + t + 2)
                }
                throw new TypeError("Invalid JPG, no size found")
            }
            getChannels(e) {
                return 3
            }
        },
        "image/png": new py
    };
    class fy {
        static basename(e) {
            const t = e.split(/[\\/]/).pop();
            return t.substring(0, t.lastIndexOf("."))
        }
        static extension(e) {
            if (e.startsWith("data:image/")) {
                const t = e.match(/data:(image\/\w+)/)[1];
                return hy.mimeTypeToExtension(t)
            }
            return e.startsWith("data:model/gltf+json") ? "gltf" : e.startsWith("data:model/gltf-binary") ? "glb" : e.startsWith("data:application/") ? "bin" : e.split(/[\\/]/).pop().split(/[.]/).pop()
        }
    }

    function _y(e) {
        return "[object Object]" === Object.prototype.toString.call(e)
    }

    function my(e) {
        if (!1 === _y(e)) return !1;
        const t = e.constructor;
        if (void 0 === t) return !0;
        const n = t.prototype;
        return !1 !== _y(n) && !1 !== Object.prototype.hasOwnProperty.call(n, "isPrototypeOf")
    }
    class gy {
        constructor(e) {
            this.verbosity = void 0, this.verbosity = e
        }
        debug(e) {
            this.verbosity <= gy.Verbosity.DEBUG && console.debug(e)
        }
        info(e) {
            this.verbosity <= gy.Verbosity.INFO && console.info(e)
        }
        warn(e) {
            this.verbosity <= gy.Verbosity.WARN && console.warn(e)
        }
        error(e) {
            this.verbosity <= gy.Verbosity.ERROR && console.error(e)
        }
    }
    gy.Verbosity = {
        SILENT: 4,
        ERROR: 3,
        WARN: 2,
        INFO: 1,
        DEBUG: 0
    }, gy.DEFAULT_INSTANCE = new gy(gy.Verbosity.INFO);
    class vy {
        static identity(e) {
            return e
        }
        static eq(e, t) {
            if (e.length !== t.length) return !1;
            for (let n = 0; n < e.length; n++)
                if (Math.abs(e[n] - t[n]) > 1e-5) return !1;
            return !0
        }
        static denormalize(e, t) {
            switch (t) {
                case 5126:
                    return e;
                case 5123:
                    return e / 65535;
                case 5121:
                    return e / 255;
                case 5122:
                    return Math.max(e / 32767, -1);
                case 5120:
                    return Math.max(e / 127, -1);
                default:
                    throw new Error("Invalid component type.")
            }
        }
        static normalize(e, t) {
            switch (t) {
                case 5126:
                    return e;
                case 5123:
                    return Math.round(65535 * e);
                case 5121:
                    return Math.round(255 * e);
                case 5122:
                    return Math.round(32767 * e);
                case 5120:
                    return Math.round(127 * e);
                default:
                    throw new Error("Invalid component type.")
            }
        }
        static decompose(e, t, n, r) {
            let i = iy([e[0], e[1], e[2]]);
            const s = iy([e[4], e[5], e[6]]),
                o = iy([e[8], e[9], e[10]]);
            (function(e) {
                var t = e[0],
                    n = e[1],
                    r = e[2],
                    i = e[3],
                    s = e[4],
                    o = e[5],
                    a = e[6],
                    l = e[7],
                    c = e[8],
                    u = e[9],
                    p = e[10],
                    h = e[11],
                    d = e[12],
                    f = e[13],
                    _ = e[14],
                    m = e[15];
                return (t * o - n * s) * (p * m - h * _) - (t * a - r * s) * (u * m - h * f) + (t * l - i * s) * (u * _ - p * f) + (n * a - r * o) * (c * m - h * d) - (n * l - i * o) * (c * _ - p * d) + (r * l - i * a) * (c * f - u * d)
            })(e) < 0 && (i = -i), t[0] = e[12], t[1] = e[13], t[2] = e[14];
            const a = e.slice(),
                l = 1 / i,
                c = 1 / s,
                u = 1 / o;
            a[0] *= l, a[1] *= l, a[2] *= l, a[4] *= c, a[5] *= c, a[6] *= c, a[8] *= u, a[9] *= u, a[10] *= u,
                function(e, t) {
                    var n = new ry(3);
                    ! function(e, t) {
                        var n = t[0],
                            r = t[1],
                            i = t[2],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            l = t[8],
                            c = t[9],
                            u = t[10];
                        e[0] = Math.hypot(n, r, i), e[1] = Math.hypot(s, o, a), e[2] = Math.hypot(l, c, u)
                    }(n, t);
                    var r = 1 / n[0],
                        i = 1 / n[1],
                        s = 1 / n[2],
                        o = t[0] * r,
                        a = t[1] * i,
                        l = t[2] * s,
                        c = t[4] * r,
                        u = t[5] * i,
                        p = t[6] * s,
                        h = t[8] * r,
                        d = t[9] * i,
                        f = t[10] * s,
                        _ = o + u + f,
                        m = 0;
                    _ > 0 ? (m = 2 * Math.sqrt(_ + 1), e[3] = .25 * m, e[0] = (p - d) / m, e[1] = (h - l) / m, e[2] = (a - c) / m) : o > u && o > f ? (m = 2 * Math.sqrt(1 + o - u - f), e[3] = (p - d) / m, e[0] = .25 * m, e[1] = (a + c) / m, e[2] = (h + l) / m) : u > f ? (m = 2 * Math.sqrt(1 + u - o - f), e[3] = (h - l) / m, e[0] = (a + c) / m, e[1] = .25 * m, e[2] = (p + d) / m) : (m = 2 * Math.sqrt(1 + f - o - u), e[3] = (a - c) / m, e[0] = (h + l) / m, e[1] = (p + d) / m, e[2] = .25 * m)
                }(n, a), r[0] = i, r[1] = s, r[2] = o
        }
        static compose(e, t, n, r) {
            const i = r,
                s = t[0],
                o = t[1],
                a = t[2],
                l = t[3],
                c = s + s,
                u = o + o,
                p = a + a,
                h = s * c,
                d = s * u,
                f = s * p,
                _ = o * u,
                m = o * p,
                g = a * p,
                v = l * c,
                b = l * u,
                x = l * p,
                y = n[0],
                w = n[1],
                S = n[2];
            return i[0] = (1 - (_ + g)) * y, i[1] = (d + x) * y, i[2] = (f - b) * y, i[3] = 0, i[4] = (d - x) * w, i[5] = (1 - (h + g)) * w, i[6] = (m + v) * w, i[7] = 0, i[8] = (f + b) * S, i[9] = (m - v) * S, i[10] = (1 - (h + _)) * S, i[11] = 0, i[12] = e[0], i[13] = e[1], i[14] = e[2], i[15] = 1, i
        }
    }

    function by(e, t) {
        if (!!e != !!t) return !1;
        const n = e.getChild(),
            r = t.getChild();
        return n === r || n.equals(r)
    }

    function xy(e, t) {
        if (!!e != !!t) return !1;
        if (e.length !== t.length) return !1;
        for (let n = 0; n < e.length; n++) {
            const r = e[n],
                i = t[n];
            if (r.getChild() !== i.getChild() && !r.getChild().equals(i.getChild())) return !1
        }
        return !0
    }

    function yy(e, t) {
        if (!!e != !!t) return !1;
        const n = Object.keys(e),
            r = Object.keys(t);
        if (n.length !== r.length) return !1;
        for (const n in e) {
            const r = e[n],
                i = t[n];
            if (!!r != !!i) return !1;
            const s = r.getChild(),
                o = i.getChild();
            if (s !== o && !s.equals(o)) return !1
        }
        return !0
    }

    function wy(e, t) {
        if (e === t) return !0;
        if (!!e != !!t || !e || !t) return !1;
        if (e.length !== t.length) return !1;
        for (let n = 0; n < e.length; n++)
            if (e[n] !== t[n]) return !1;
        return !0
    }

    function Sy(e, t) {
        if (e === t) return !0;
        if (!!e != !!t) return !1;
        if (!my(e) || !my(t)) return e === t;
        const n = e,
            r = t;
        let i, s = 0,
            o = 0;
        for (i in n) s++;
        for (i in r) o++;
        if (s !== o) return !1;
        for (i in n) {
            const e = n[i],
                t = r[i];
            if (My(e) && My(t)) {
                if (!wy(e, t)) return !1
            } else if (my(e) && my(t)) {
                if (!Sy(e, t)) return !1
            } else if (e !== t) return !1
        }
        return !0
    }

    function My(e) {
        return Array.isArray(e) || ArrayBuffer.isView(e)
    }
    const Ty = "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ",
        Ey = new Set,
        Ay = function() {
            let e = "";
            for (let t = 0; t < 6; t++) e += Ty.charAt(Math.floor(Math.random() * Ty.length));
            return e
        };
    class Cy {
        static dirname(e) {
            const t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substring(0, t + 1)
        }
        static basename(e) {
            return fy.basename(new URL(e, "https://null.example").pathname)
        }
        static extension(e) {
            return fy.extension(new URL(e, "https://null.example").pathname)
        }
        static resolve(e, t) {
            if (!this.isRelativePath(t)) return t;
            const n = e.split("/"),
                r = t.split("/");
            n.pop();
            for (let e = 0; e < r.length; e++) "." !== r[e] && (".." === r[e] ? n.pop() : n.push(r[e]));
            return n.join("/")
        }
        static isAbsoluteURL(e) {
            return this.PROTOCOL_REGEXP.test(e)
        }
        static isRelativePath(e) {
            return !/^(?:[a-zA-Z]+:)?\//.test(e)
        }
    }
    Cy.DEFAULT_INIT = {}, Cy.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;
    const Ry = e => e;
    class ky extends Zx {
        constructor(e, t = "") {
            super(e), this[qx].name = t, this.init(), this.dispatchEvent({
                type: "create"
            })
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                name: "",
                extras: {}
            })
        }
        getName() {
            return this.get("name")
        }
        setName(e) {
            return this.set("name", e)
        }
        getExtras() {
            return this.get("extras")
        }
        setExtras(e) {
            return this.set("extras", e)
        }
        clone() {
            return new(0, this.constructor)(this.graph).copy(this, Ry)
        }
        copy(e, t = Ry) {
            for (const e in this[qx]) {
                const t = this[qx][e];
                if (t instanceof Vx) this[Yx].has(e) || t.dispose();
                else if (Array.isArray(t) && t[0] instanceof Vx)
                    for (const e of t) e.dispose();
                else if (my(t) && Object.values(t)[0] instanceof Vx)
                    for (const e in t) t[e].dispose()
            }
            for (const n in e[qx]) {
                const r = this[qx][n],
                    i = e[qx][n];
                if (i instanceof Vx) this[Yx].has(n) ? r.getChild().copy(t(i.getChild()), t) : this.setRef(n, t(i.getChild()), i.getAttributes());
                else if (Array.isArray(i) && i[0] instanceof Vx)
                    for (const e of i) this.addRef(n, t(e.getChild()), e.getAttributes());
                else if (my(i) && Object.values(i)[0] instanceof Vx)
                    for (const e in i) {
                        const r = i[e];
                        this.setRefMap(n, e, t(r.getChild()), r.getAttributes())
                    } else this[qx][n] = my(i) ? JSON.parse(JSON.stringify(i)) : Array.isArray(i) || i instanceof ArrayBuffer || ArrayBuffer.isView(i) ? i.slice() : i
            }
            return this
        }
        equals(e) {
            if (this === e) return !0;
            if (this.propertyType !== e.propertyType) return !1;
            for (const t in this[qx]) {
                const n = this[qx][t],
                    r = e[qx][t];
                if (Wx(n) || Wx(r)) {
                    if (!by(n, r)) return !1
                } else if (Kx(n) || Kx(r)) {
                    if (!xy(n, r)) return !1
                } else if (Xx(n) || Xx(r)) {
                    if (!yy(n, r)) return !1
                } else if (my(n) || my(r)) {
                    if (!Sy(n, r)) return !1
                } else if (My(n) || My(r)) {
                    if (!wy(n, r)) return !1
                } else if (n !== r) return !1
            }
            return !0
        }
        detach() {
            return this.graph.disconnectParents(this, (e => "Root" !== e.propertyType)), this
        }
        listParents() {
            return this.graph.listParents(this)
        }
    }
    class Py extends ky {
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                extensions: {}
            })
        }
        getExtension(e) {
            return this.getRefMap("extensions", e)
        }
        setExtension(e, t) {
            return t && t.t(this), this.setRefMap("extensions", e, t)
        }
        listExtensions() {
            return this.listRefMapValues("extensions")
        }
    }
    class Dy extends Py {
        constructor(...e) {
            super(...e), this.i = vy.identity, this.o = vy.identity
        }
        init() {
            this.propertyType = $x.ACCESSOR
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                array: null,
                type: Dy.Type.SCALAR,
                componentType: Dy.ComponentType.FLOAT,
                normalized: !1,
                buffer: null
            })
        }
        copy(e, t = Ry) {
            return super.copy(e, t), this.i = e.i, this.o = e.o, this
        }
        static getElementSize(e) {
            switch (e) {
                case Dy.Type.SCALAR:
                    return 1;
                case Dy.Type.VEC2:
                    return 2;
                case Dy.Type.VEC3:
                    return 3;
                case Dy.Type.VEC4:
                case Dy.Type.MAT2:
                    return 4;
                case Dy.Type.MAT3:
                    return 9;
                case Dy.Type.MAT4:
                    return 16;
                default:
                    throw new Error("Unexpected type: " + e)
            }
        }
        static getComponentSize(e) {
            switch (e) {
                case Dy.ComponentType.BYTE:
                case Dy.ComponentType.UNSIGNED_BYTE:
                    return 1;
                case Dy.ComponentType.SHORT:
                case Dy.ComponentType.UNSIGNED_SHORT:
                    return 2;
                case Dy.ComponentType.UNSIGNED_INT:
                case Dy.ComponentType.FLOAT:
                    return 4;
                default:
                    throw new Error("Unexpected component type: " + e)
            }
        }
        getMinNormalized(e) {
            const t = this.getElementSize();
            this.getMin(e);
            for (let n = 0; n < t; n++) e[n] = this.o(e[n]);
            return e
        }
        getMin(e) {
            const t = this.get("array"),
                n = this.getCount(),
                r = this.getElementSize();
            for (let t = 0; t < r; t++) e[t] = 1 / 0;
            for (let i = 0; i < n * r; i += r)
                for (let n = 0; n < r; n++) {
                    const r = t[i + n];
                    Number.isFinite(r) && (e[n] = Math.min(e[n], r))
                }
            return e
        }
        getMaxNormalized(e) {
            const t = this.getElementSize();
            this.getMax(e);
            for (let n = 0; n < t; n++) e[n] = this.o(e[n]);
            return e
        }
        getMax(e) {
            const t = this.get("array"),
                n = this.getCount(),
                r = this.getElementSize();
            for (let t = 0; t < r; t++) e[t] = -1 / 0;
            for (let i = 0; i < n * r; i += r)
                for (let n = 0; n < r; n++) {
                    const r = t[i + n];
                    Number.isFinite(r) && (e[n] = Math.max(e[n], r))
                }
            return e
        }
        getCount() {
            const e = this.get("array");
            return e ? e.length / this.getElementSize() : 0
        }
        getType() {
            return this.get("type")
        }
        setType(e) {
            return this.set("type", e)
        }
        getElementSize() {
            return Dy.getElementSize(this.get("type"))
        }
        getComponentSize() {
            return this.get("array").BYTES_PER_ELEMENT
        }
        getComponentType() {
            return this.get("componentType")
        }
        getNormalized() {
            return this.get("normalized")
        }
        setNormalized(e) {
            return this.set("normalized", e), e ? (this.o = e => vy.denormalize(e, this.get("componentType")), this.i = e => vy.normalize(e, this.get("componentType"))) : (this.o = vy.identity, this.i = vy.identity), this
        }
        getScalar(e) {
            const t = this.getElementSize();
            return this.o(this.get("array")[e * t])
        }
        setScalar(e, t) {
            return this.get("array")[e * this.getElementSize()] = this.i(t), this
        }
        getElement(e, t) {
            const n = this.getElementSize(),
                r = this.get("array");
            for (let i = 0; i < n; i++) t[i] = this.o(r[e * n + i]);
            return t
        }
        setElement(e, t) {
            const n = this.getElementSize(),
                r = this.get("array");
            for (let i = 0; i < n; i++) r[e * n + i] = this.i(t[i]);
            return this
        }
        getBuffer() {
            return this.getRef("buffer")
        }
        setBuffer(e) {
            return this.setRef("buffer", e)
        }
        getArray() {
            return this.get("array")
        }
        setArray(e) {
            return this.set("componentType", e ? function(e) {
                switch (e.constructor) {
                    case Float32Array:
                        return Dy.ComponentType.FLOAT;
                    case Uint32Array:
                        return Dy.ComponentType.UNSIGNED_INT;
                    case Uint16Array:
                        return Dy.ComponentType.UNSIGNED_SHORT;
                    case Uint8Array:
                        return Dy.ComponentType.UNSIGNED_BYTE;
                    case Int16Array:
                        return Dy.ComponentType.SHORT;
                    case Int8Array:
                        return Dy.ComponentType.BYTE;
                    default:
                        throw new Error("Unknown accessor componentType.")
                }
            }(e) : Dy.ComponentType.FLOAT), this.set("array", e), this
        }
        getByteLength() {
            const e = this.get("array");
            return e ? e.byteLength : 0
        }
    }
    Dy.Type = {
        SCALAR: "SCALAR",
        VEC2: "VEC2",
        VEC3: "VEC3",
        VEC4: "VEC4",
        MAT2: "MAT2",
        MAT3: "MAT3",
        MAT4: "MAT4"
    }, Dy.ComponentType = {
        BYTE: 5120,
        UNSIGNED_BYTE: 5121,
        SHORT: 5122,
        UNSIGNED_SHORT: 5123,
        UNSIGNED_INT: 5125,
        FLOAT: 5126
    };
    class Oy extends Py {
        init() {
            this.propertyType = $x.ANIMATION
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                channels: [],
                samplers: []
            })
        }
        addChannel(e) {
            return this.addRef("channels", e)
        }
        removeChannel(e) {
            return this.removeRef("channels", e)
        }
        listChannels() {
            return this.listRefs("channels")
        }
        addSampler(e) {
            return this.addRef("samplers", e)
        }
        removeSampler(e) {
            return this.removeRef("samplers", e)
        }
        listSamplers() {
            return this.listRefs("samplers")
        }
    }
    class Ly extends Py {
        init() {
            this.propertyType = $x.ANIMATION_CHANNEL
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                targetPath: null,
                targetNode: null,
                sampler: null
            })
        }
        getTargetPath() {
            return this.get("targetPath")
        }
        setTargetPath(e) {
            return this.set("targetPath", e)
        }
        getTargetNode() {
            return this.getRef("targetNode")
        }
        setTargetNode(e) {
            return this.setRef("targetNode", e)
        }
        getSampler() {
            return this.getRef("sampler")
        }
        setSampler(e) {
            return this.setRef("sampler", e)
        }
    }
    Ly.TargetPath = {
        TRANSLATION: "translation",
        ROTATION: "rotation",
        SCALE: "scale",
        WEIGHTS: "weights"
    };
    class Iy extends Py {
        init() {
            this.propertyType = $x.ANIMATION_SAMPLER
        }
        getDefaultAttributes() {
            return Object.assign(super.getDefaults(), {
                interpolation: Iy.Interpolation.LINEAR,
                input: null,
                output: null
            })
        }
        getInterpolation() {
            return this.get("interpolation")
        }
        setInterpolation(e) {
            return this.set("interpolation", e)
        }
        getInput() {
            return this.getRef("input")
        }
        setInput(e) {
            return this.setRef("input", e, {
                usage: ey.OTHER
            })
        }
        getOutput() {
            return this.getRef("output")
        }
        setOutput(e) {
            return this.setRef("output", e, {
                usage: ey.OTHER
            })
        }
    }
    Iy.Interpolation = {
        LINEAR: "LINEAR",
        STEP: "STEP",
        CUBICSPLINE: "CUBICSPLINE"
    };
    class Fy extends Py {
        init() {
            this.propertyType = $x.BUFFER
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                uri: ""
            })
        }
        getURI() {
            return this.get("uri")
        }
        setURI(e) {
            return this.set("uri", e)
        }
    }
    class Ny extends Py {
        init() {
            this.propertyType = $x.CAMERA
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                type: Ny.Type.PERSPECTIVE,
                znear: .1,
                zfar: 100,
                aspectRatio: null,
                yfov: 2 * Math.PI * 50 / 360,
                xmag: 1,
                ymag: 1
            })
        }
        getType() {
            return this.get("type")
        }
        setType(e) {
            return this.set("type", e)
        }
        getZNear() {
            return this.get("znear")
        }
        setZNear(e) {
            return this.set("znear", e)
        }
        getZFar() {
            return this.get("zfar")
        }
        setZFar(e) {
            return this.set("zfar", e)
        }
        getAspectRatio() {
            return this.get("aspectRatio")
        }
        setAspectRatio(e) {
            return this.set("aspectRatio", e)
        }
        getYFov() {
            return this.get("yfov")
        }
        setYFov(e) {
            return this.set("yfov", e)
        }
        getXMag() {
            return this.get("xmag")
        }
        setXMag(e) {
            return this.set("xmag", e)
        }
        getYMag() {
            return this.get("ymag")
        }
        setYMag(e) {
            return this.set("ymag", e)
        }
    }
    Ny.Type = {
        PERSPECTIVE: "perspective",
        ORTHOGRAPHIC: "orthographic"
    };
    class Uy extends ky {
        t(e) {
            if (!this.parentTypes.includes(e.propertyType)) throw new Error(`Parent "${e.propertyType}" invalid for child "${this.propertyType}".`)
        }
    }
    Uy.EXTENSION_NAME = void 0;
    class By extends Py {
        init() {
            this.propertyType = $x.TEXTURE_INFO
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                texCoord: 0,
                magFilter: null,
                minFilter: null,
                wrapS: By.WrapMode.REPEAT,
                wrapT: By.WrapMode.REPEAT
            })
        }
        getTexCoord() {
            return this.get("texCoord")
        }
        setTexCoord(e) {
            return this.set("texCoord", e)
        }
        getMagFilter() {
            return this.get("magFilter")
        }
        setMagFilter(e) {
            return this.set("magFilter", e)
        }
        getMinFilter() {
            return this.get("minFilter")
        }
        setMinFilter(e) {
            return this.set("minFilter", e)
        }
        getWrapS() {
            return this.get("wrapS")
        }
        setWrapS(e) {
            return this.set("wrapS", e)
        }
        getWrapT() {
            return this.get("wrapT")
        }
        setWrapT(e) {
            return this.set("wrapT", e)
        }
    }
    By.WrapMode = {
        CLAMP_TO_EDGE: 33071,
        MIRRORED_REPEAT: 33648,
        REPEAT: 10497
    }, By.MagFilter = {
        NEAREST: 9728,
        LINEAR: 9729
    }, By.MinFilter = {
        NEAREST: 9728,
        LINEAR: 9729,
        NEAREST_MIPMAP_NEAREST: 9984,
        LINEAR_MIPMAP_NEAREST: 9985,
        NEAREST_MIPMAP_LINEAR: 9986,
        LINEAR_MIPMAP_LINEAR: 9987
    };
    const {
        R: jy,
        G: zy,
        B: Vy,
        A: Gy
    } = ty;
    class Hy extends Py {
        init() {
            this.propertyType = $x.MATERIAL
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                alphaMode: Hy.AlphaMode.OPAQUE,
                alphaCutoff: .5,
                doubleSided: !1,
                baseColorFactor: [1, 1, 1, 1],
                baseColorTexture: null,
                baseColorTextureInfo: new By(this.graph, "baseColorTextureInfo"),
                emissiveFactor: [0, 0, 0],
                emissiveTexture: null,
                emissiveTextureInfo: new By(this.graph, "emissiveTextureInfo"),
                normalScale: 1,
                normalTexture: null,
                normalTextureInfo: new By(this.graph, "normalTextureInfo"),
                occlusionStrength: 1,
                occlusionTexture: null,
                occlusionTextureInfo: new By(this.graph, "occlusionTextureInfo"),
                roughnessFactor: 1,
                metallicFactor: 1,
                metallicRoughnessTexture: null,
                metallicRoughnessTextureInfo: new By(this.graph, "metallicRoughnessTextureInfo")
            })
        }
        getDoubleSided() {
            return this.get("doubleSided")
        }
        setDoubleSided(e) {
            return this.set("doubleSided", e)
        }
        getAlpha() {
            return this.get("baseColorFactor")[3]
        }
        setAlpha(e) {
            const t = this.get("baseColorFactor").slice();
            return t[3] = e, this.set("baseColorFactor", t)
        }
        getAlphaMode() {
            return this.get("alphaMode")
        }
        setAlphaMode(e) {
            return this.set("alphaMode", e)
        }
        getAlphaCutoff() {
            return this.get("alphaCutoff")
        }
        setAlphaCutoff(e) {
            return this.set("alphaCutoff", e)
        }
        getBaseColorFactor() {
            return this.get("baseColorFactor")
        }
        setBaseColorFactor(e) {
            return this.set("baseColorFactor", e)
        }
        getBaseColorHex() {
            return uy.factorToHex(this.get("baseColorFactor"))
        }
        setBaseColorHex(e) {
            const t = this.get("baseColorFactor").slice();
            return this.set("baseColorFactor", uy.hexToFactor(e, t))
        }
        getBaseColorTexture() {
            return this.getRef("baseColorTexture")
        }
        getBaseColorTextureInfo() {
            return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null
        }
        setBaseColorTexture(e) {
            return this.setRef("baseColorTexture", e, {
                channels: jy | zy | Vy | Gy
            })
        }
        getEmissiveFactor() {
            return this.get("emissiveFactor")
        }
        setEmissiveFactor(e) {
            return this.set("emissiveFactor", e)
        }
        getEmissiveHex() {
            return uy.factorToHex(this.get("emissiveFactor"))
        }
        setEmissiveHex(e) {
            const t = this.get("emissiveFactor").slice();
            return this.set("emissiveFactor", uy.hexToFactor(e, t))
        }
        getEmissiveTexture() {
            return this.getRef("emissiveTexture")
        }
        getEmissiveTextureInfo() {
            return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null
        }
        setEmissiveTexture(e) {
            return this.setRef("emissiveTexture", e, {
                channels: jy | zy | Vy
            })
        }
        getNormalScale() {
            return this.get("normalScale")
        }
        setNormalScale(e) {
            return this.set("normalScale", e)
        }
        getNormalTexture() {
            return this.getRef("normalTexture")
        }
        getNormalTextureInfo() {
            return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null
        }
        setNormalTexture(e) {
            return this.setRef("normalTexture", e, {
                channels: jy | zy | Vy
            })
        }
        getOcclusionStrength() {
            return this.get("occlusionStrength")
        }
        setOcclusionStrength(e) {
            return this.set("occlusionStrength", e)
        }
        getOcclusionTexture() {
            return this.getRef("occlusionTexture")
        }
        getOcclusionTextureInfo() {
            return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null
        }
        setOcclusionTexture(e) {
            return this.setRef("occlusionTexture", e, {
                channels: jy
            })
        }
        getRoughnessFactor() {
            return this.get("roughnessFactor")
        }
        setRoughnessFactor(e) {
            return this.set("roughnessFactor", e)
        }
        getMetallicFactor() {
            return this.get("metallicFactor")
        }
        setMetallicFactor(e) {
            return this.set("metallicFactor", e)
        }
        getMetallicRoughnessTexture() {
            return this.getRef("metallicRoughnessTexture")
        }
        getMetallicRoughnessTextureInfo() {
            return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null
        }
        setMetallicRoughnessTexture(e) {
            return this.setRef("metallicRoughnessTexture", e, {
                channels: zy | Vy
            })
        }
    }
    Hy.AlphaMode = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };
    class Wy extends Py {
        init() {
            this.propertyType = $x.MESH
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                weights: [],
                primitives: []
            })
        }
        addPrimitive(e) {
            return this.addRef("primitives", e)
        }
        removePrimitive(e) {
            return this.removeRef("primitives", e)
        }
        listPrimitives() {
            return this.listRefs("primitives")
        }
        getWeights() {
            return this.get("weights")
        }
        setWeights(e) {
            return this.set("weights", e)
        }
    }
    class Ky extends Py {
        constructor(...e) {
            super(...e), this.u = null
        }
        init() {
            this.propertyType = $x.NODE
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                translation: [0, 0, 0],
                rotation: [0, 0, 0, 1],
                scale: [1, 1, 1],
                weights: [],
                camera: null,
                mesh: null,
                skin: null,
                children: []
            })
        }
        copy(e, t = Ry) {
            if (t === Ry) throw new Error("Node cannot be copied.");
            return super.copy(e, t)
        }
        getTranslation() {
            return this.get("translation")
        }
        getRotation() {
            return this.get("rotation")
        }
        getScale() {
            return this.get("scale")
        }
        setTranslation(e) {
            return this.set("translation", e)
        }
        setRotation(e) {
            return this.set("rotation", e)
        }
        setScale(e) {
            return this.set("scale", e)
        }
        getMatrix() {
            return vy.compose(this.get("translation"), this.get("rotation"), this.get("scale"), [])
        }
        setMatrix(e) {
            const t = this.get("translation").slice(),
                n = this.get("rotation").slice(),
                r = this.get("scale").slice();
            return vy.decompose(e, t, n, r), this.set("translation", t).set("rotation", n).set("scale", r)
        }
        getWorldTranslation() {
            const e = [0, 0, 0];
            return vy.decompose(this.getWorldMatrix(), e, [0, 0, 0, 1], [1, 1, 1]), e
        }
        getWorldRotation() {
            const e = [0, 0, 0, 1];
            return vy.decompose(this.getWorldMatrix(), [0, 0, 0], e, [1, 1, 1]), e
        }
        getWorldScale() {
            const e = [1, 1, 1];
            return vy.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], e), e
        }
        getWorldMatrix() {
            const e = [];
            for (let t = this; t instanceof Ky; t = t.u) e.push(t);
            let t;
            const n = e.pop().getMatrix();
            for (; t = e.pop();) oy(n, n, t.getMatrix());
            return n
        }
        addChild(e) {
            e.u && e.u.removeChild(e), this.addRef("children", e), e.u = this;
            const t = this[qx].children;
            return t[t.length - 1].addEventListener("dispose", (() => e.u = null)), this
        }
        removeChild(e) {
            return this.removeRef("children", e)
        }
        listChildren() {
            return this.listRefs("children")
        }
        getParent() {
            return this.u
        }
        getMesh() {
            return this.getRef("mesh")
        }
        setMesh(e) {
            return this.setRef("mesh", e)
        }
        getCamera() {
            return this.getRef("camera")
        }
        setCamera(e) {
            return this.setRef("camera", e)
        }
        getSkin() {
            return this.getRef("skin")
        }
        setSkin(e) {
            return this.setRef("skin", e)
        }
        getWeights() {
            return this.get("weights")
        }
        setWeights(e) {
            return this.set("weights", e)
        }
        traverse(e) {
            e(this);
            for (const t of this.listChildren()) t.traverse(e);
            return this
        }
    }
    class Xy extends Py {
        init() {
            this.propertyType = $x.PRIMITIVE
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                mode: Xy.Mode.TRIANGLES,
                material: null,
                indices: null,
                attributes: {},
                targets: []
            })
        }
        getIndices() {
            return this.getRef("indices")
        }
        setIndices(e) {
            return this.setRef("indices", e, {
                usage: ey.ELEMENT_ARRAY_BUFFER
            })
        }
        getAttribute(e) {
            return this.getRefMap("attributes", e)
        }
        setAttribute(e, t) {
            return this.setRefMap("attributes", e, t, {
                usage: ey.ARRAY_BUFFER
            })
        }
        listAttributes() {
            return this.listRefMapValues("attributes")
        }
        listSemantics() {
            return this.listRefMapKeys("attributes")
        }
        getMaterial() {
            return this.getRef("material")
        }
        setMaterial(e) {
            return this.setRef("material", e)
        }
        getMode() {
            return this.get("mode")
        }
        setMode(e) {
            return this.set("mode", e)
        }
        listTargets() {
            return this.listRefs("targets")
        }
        addTarget(e) {
            return this.addRef("targets", e)
        }
        removeTarget(e) {
            return this.removeRef("targets", e)
        }
    }
    Xy.Mode = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
    };
    class qy extends ky {
        init() {
            this.propertyType = $x.PRIMITIVE_TARGET
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                attributes: {}
            })
        }
        getAttribute(e) {
            return this.getRefMap("attributes", e)
        }
        setAttribute(e, t) {
            return this.setRefMap("attributes", e, t, {
                usage: ey.ARRAY_BUFFER
            })
        }
        listAttributes() {
            return this.listRefMapValues("attributes")
        }
        listSemantics() {
            return this.listRefMapKeys("attributes")
        }
    }

    function Yy() {
        return (Yy = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }).apply(this, arguments)
    }
    class Zy extends Py {
        init() {
            this.propertyType = $x.SCENE
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                children: []
            })
        }
        copy(e, t = Ry) {
            if (t === Ry) throw new Error("Scene cannot be copied.");
            return super.copy(e, t)
        }
        addChild(e) {
            e.u && e.u.removeChild(e), this.addRef("children", e), e.u = this;
            const t = this[qx].children;
            return t[t.length - 1].addEventListener("dispose", (() => e.u = null)), this
        }
        removeChild(e) {
            return this.removeRef("children", e)
        }
        listChildren() {
            return this.listRefs("children")
        }
        traverse(e) {
            for (const t of this.listChildren()) t.traverse(e);
            return this
        }
    }
    class Jy extends Py {
        init() {
            this.propertyType = $x.SKIN
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                skeleton: null,
                inverseBindMatrices: null,
                joints: []
            })
        }
        getSkeleton() {
            return this.getRef("skeleton")
        }
        setSkeleton(e) {
            return this.setRef("skeleton", e)
        }
        getInverseBindMatrices() {
            return this.getRef("inverseBindMatrices")
        }
        setInverseBindMatrices(e) {
            return this.setRef("inverseBindMatrices", e, {
                usage: ey.INVERSE_BIND_MATRICES
            })
        }
        addJoint(e) {
            return this.addRef("joints", e)
        }
        removeJoint(e) {
            return this.removeRef("joints", e)
        }
        listJoints() {
            return this.listRefs("joints")
        }
    }
    class $y extends Py {
        init() {
            this.propertyType = $x.TEXTURE
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                image: null,
                mimeType: "",
                uri: ""
            })
        }
        getMimeType() {
            return this.get("mimeType") || hy.extensionToMimeType(fy.extension(this.get("uri")))
        }
        setMimeType(e) {
            return this.set("mimeType", e)
        }
        getURI() {
            return this.get("uri")
        }
        setURI(e) {
            return this.set("uri", e), this.set("mimeType", hy.extensionToMimeType(fy.extension(e))), this
        }
        getImage() {
            return this.get("image")
        }
        setImage(e) {
            return this.set("image", cy.assertView(e))
        }
        getSize() {
            const e = this.get("image");
            return e ? hy.getSize(e, this.getMimeType()) : null
        }
    }
    class Qy extends Py {
        init() {
            this.propertyType = $x.ROOT
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                asset: {
                    generator: "glTF-Transform v2.2.0",
                    version: "2.0"
                },
                defaultScene: null,
                accessors: [],
                animations: [],
                buffers: [],
                cameras: [],
                materials: [],
                meshes: [],
                nodes: [],
                scenes: [],
                skins: [],
                textures: []
            })
        }
        constructor(e) {
            super(e), this.h = new Set, e.addEventListener("node:create", (e => {
                this.l(e.target)
            }))
        }
        clone() {
            throw new Error("Root cannot be cloned.")
        }
        copy(e, t = Ry) {
            if (t === Ry) throw new Error("Root cannot be copied.");
            this.set("asset", Yy({}, e.get("asset"))), this.setName(e.getName()), this.setExtras(Yy({}, e.getExtras())), this.setDefaultScene(e.getDefaultScene() ? t(e.getDefaultScene()) : null);
            for (const n of e.listRefMapKeys("extensions")) {
                const r = e.getExtension(n);
                this.setExtension(n, t(r))
            }
            return this
        }
        l(e) {
            return e instanceof Zy ? this.addRef("scenes", e) : e instanceof Ky ? this.addRef("nodes", e) : e instanceof Ny ? this.addRef("cameras", e) : e instanceof Jy ? this.addRef("skins", e) : e instanceof Wy ? this.addRef("meshes", e) : e instanceof Hy ? this.addRef("materials", e) : e instanceof $y ? this.addRef("textures", e) : e instanceof Oy ? this.addRef("animations", e) : e instanceof Dy ? this.addRef("accessors", e) : e instanceof Fy && this.addRef("buffers", e), this
        }
        getAsset() {
            return this.get("asset")
        }
        listExtensionsUsed() {
            return Array.from(this.h)
        }
        listExtensionsRequired() {
            return this.listExtensionsUsed().filter((e => e.isRequired()))
        }
        g(e) {
            return this.h.add(e), this
        }
        p(e) {
            return this.h.delete(e), this
        }
        listScenes() {
            return this.listRefs("scenes")
        }
        setDefaultScene(e) {
            return this.setRef("defaultScene", e)
        }
        getDefaultScene() {
            return this.getRef("defaultScene")
        }
        listNodes() {
            return this.listRefs("nodes")
        }
        listCameras() {
            return this.listRefs("cameras")
        }
        listSkins() {
            return this.listRefs("skins")
        }
        listMeshes() {
            return this.listRefs("meshes")
        }
        listMaterials() {
            return this.listRefs("materials")
        }
        listTextures() {
            return this.listRefs("textures")
        }
        listAnimations() {
            return this.listRefs("animations")
        }
        listAccessors() {
            return this.listRefs("accessors")
        }
        listBuffers() {
            return this.listRefs("buffers")
        }
    }
    class ew {
        constructor() {
            this.m = new Gx, this.T = new Qy(this.m), this.v = gy.DEFAULT_INSTANCE
        }
        getRoot() {
            return this.T
        }
        getGraph() {
            return this.m
        }
        getLogger() {
            return this.v
        }
        setLogger(e) {
            return this.v = e, this
        }
        clone() {
            return (new ew).setLogger(this.v).merge(this)
        }
        merge(e) {
            for (const t of e.getRoot().listExtensionsUsed()) {
                const e = this.createExtension(t.constructor);
                t.isRequired() && e.setRequired(!0)
            }
            const t = new Set,
                n = new Map;
            t.add(e.T), n.set(e.T, this.T);
            for (const r of e.m.listEdges())
                for (const e of [r.getParent(), r.getChild()]) {
                    if (t.has(e)) continue;
                    let r;
                    r = e.propertyType === $x.TEXTURE_INFO ? e : new(0, e.constructor)(this.m), n.set(e, r), t.add(e)
                }
            const r = e => {
                const t = n.get(e);
                if (!t) throw new Error("Could resolve property.");
                return t
            };
            for (const e of t) {
                const t = n.get(e);
                if (!t) throw new Error("Could resolve property.");
                t.propertyType !== $x.TEXTURE_INFO && t.copy(e, r)
            }
            return this
        }
        async transform(...e) {
            const t = e.map((e => e.name));
            for (const n of e) await n(this, {
                stack: t
            });
            return this
        }
        createExtension(e) {
            const t = e.EXTENSION_NAME;
            return this.getRoot().listExtensionsUsed().find((e => e.extensionName === t)) || new e(this)
        }
        createScene(e = "") {
            return new Zy(this.m, e)
        }
        createNode(e = "") {
            return new Ky(this.m, e)
        }
        createCamera(e = "") {
            return new Ny(this.m, e)
        }
        createSkin(e = "") {
            return new Jy(this.m, e)
        }
        createMesh(e = "") {
            return new Wy(this.m, e)
        }
        createPrimitive() {
            return new Xy(this.m)
        }
        createPrimitiveTarget(e = "") {
            return new qy(this.m, e)
        }
        createMaterial(e = "") {
            return new Hy(this.m, e)
        }
        createTexture(e = "") {
            return new $y(this.m, e)
        }
        createAnimation(e = "") {
            return new Oy(this.m, e)
        }
        createAnimationChannel(e = "") {
            return new Ly(this.m, e)
        }
        createAnimationSampler(e = "") {
            return new Iy(this.m, e)
        }
        createAccessor(e = "", t = null) {
            return t || (t = this.getRoot().listBuffers()[0]), new Dy(this.m, e).setBuffer(t)
        }
        createBuffer(e = "") {
            return new Fy(this.m, e)
        }
    }
    class tw {
        constructor(e) {
            this.extensionName = "", this.prereadTypes = [], this.prewriteTypes = [], this.readDependencies = [], this.writeDependencies = [], this.document = void 0, this.required = !1, this.properties = new Set, this.S = void 0, this.document = e, e.getRoot().g(this), this.S = e => {
                const t = e,
                    n = t.target;
                n instanceof Uy && n.extensionName === this.extensionName && ("node:create" === t.type && this.M(n), "node:dispose" === t.type && this.I(n))
            };
            const t = e.getGraph();
            t.addEventListener("node:create", this.S), t.addEventListener("node:dispose", this.S)
        }
        dispose() {
            this.document.getRoot().p(this);
            const e = this.document.getGraph();
            e.removeEventListener("node:create", this.S), e.removeEventListener("node:dispose", this.S);
            for (const e of this.properties) e.dispose()
        }
        static register() {}
        isRequired() {
            return this.required
        }
        setRequired(e) {
            return this.required = e, this
        }
        M(e) {
            return this.properties.add(e), this
        }
        I(e) {
            return this.properties.delete(e), this
        }
        install(e, t) {
            return this
        }
        preread(e, t) {
            return this
        }
        prewrite(e, t) {
            return this
        }
    }
    tw.EXTENSION_NAME = void 0;
    class nw {
        constructor(e) {
            this.jsonDoc = void 0, this.buffers = [], this.bufferViews = [], this.bufferViewBuffers = [], this.accessors = [], this.textures = [], this.textureInfos = new Map, this.materials = [], this.meshes = [], this.cameras = [], this.nodes = [], this.skins = [], this.animations = [], this.scenes = [], this.jsonDoc = e
        }
        setTextureInfo(e, t) {
            this.textureInfos.set(e, t), void 0 !== t.texCoord && e.setTexCoord(t.texCoord);
            const n = this.jsonDoc.json.textures[t.index];
            if (void 0 === n.sampler) return;
            const r = this.jsonDoc.json.samplers[n.sampler];
            void 0 !== r.magFilter && e.setMagFilter(r.magFilter), void 0 !== r.minFilter && e.setMinFilter(r.minFilter), void 0 !== r.wrapS && e.setWrapS(r.wrapS), void 0 !== r.wrapT && e.setWrapT(r.wrapT)
        }
    }
    const rw = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        },
        iw = {
            logger: gy.DEFAULT_INSTANCE,
            extensions: [],
            dependencies: {}
        };

    function sw(e, t) {
        const n = t.bufferViews[e.bufferView],
            r = t.jsonDoc.json.bufferViews[e.bufferView],
            i = rw[e.componentType],
            s = Dy.getElementSize(e.type),
            o = i.BYTES_PER_ELEMENT;
        if (void 0 !== r.byteStride && r.byteStride !== s * o) return function(e, t) {
            const n = t.bufferViews[e.bufferView],
                r = t.jsonDoc.json.bufferViews[e.bufferView],
                i = rw[e.componentType],
                s = Dy.getElementSize(e.type),
                o = i.BYTES_PER_ELEMENT,
                a = e.byteOffset || 0,
                l = new i(e.count * s),
                c = new DataView(n.buffer, n.byteOffset, n.byteLength),
                u = r.byteStride;
            for (let t = 0; t < e.count; t++)
                for (let n = 0; n < s; n++) {
                    const r = a + t * u + n * o;
                    let i;
                    switch (e.componentType) {
                        case Dy.ComponentType.FLOAT:
                            i = c.getFloat32(r, !0);
                            break;
                        case Dy.ComponentType.UNSIGNED_INT:
                            i = c.getUint32(r, !0);
                            break;
                        case Dy.ComponentType.UNSIGNED_SHORT:
                            i = c.getUint16(r, !0);
                            break;
                        case Dy.ComponentType.UNSIGNED_BYTE:
                            i = c.getUint8(r);
                            break;
                        case Dy.ComponentType.SHORT:
                            i = c.getInt16(r, !0);
                            break;
                        case Dy.ComponentType.BYTE:
                            i = c.getInt8(r);
                            break;
                        default:
                            throw new Error(`Unexpected componentType "${e.componentType}".`)
                    }
                    l[t * s + n] = i
                }
            return l
        }(e, t);
        const a = n.byteOffset + (e.byteOffset || 0);
        return new i(n.buffer.slice(a, a + e.count * s * o))
    }
    var ow;
    ! function(e) {
        e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER"
    }(ow || (ow = {}));
    class aw {
        constructor(e, t, n) {
            this.N = void 0, this.jsonDoc = void 0, this.options = void 0, this.accessorIndexMap = new Map, this.animationIndexMap = new Map, this.bufferIndexMap = new Map, this.cameraIndexMap = new Map, this.skinIndexMap = new Map, this.materialIndexMap = new Map, this.meshIndexMap = new Map, this.nodeIndexMap = new Map, this.imageIndexMap = new Map, this.textureDefIndexMap = new Map, this.textureInfoDefMap = new Map, this.samplerDefIndexMap = new Map, this.sceneIndexMap = new Map, this.imageBufferViews = [], this.otherBufferViews = new Map, this.otherBufferViewsIndexMap = new Map, this.extensionData = {}, this.bufferURIGenerator = void 0, this.imageURIGenerator = void 0, this.logger = void 0, this.O = new Map, this.accessorUsageGroupedByParent = new Set(["ARRAY_BUFFER"]), this.accessorParents = new Map, this.N = e, this.jsonDoc = t, this.options = n;
            const r = e.getRoot(),
                i = r.listBuffers().length,
                s = r.listTextures().length;
            this.bufferURIGenerator = new lw(i > 1, n.basename), this.imageURIGenerator = new lw(s > 1, n.basename), this.logger = e.getLogger()
        }
        createTextureInfoDef(e, t) {
            const n = {
                    magFilter: t.getMagFilter() || void 0,
                    minFilter: t.getMinFilter() || void 0,
                    wrapS: t.getWrapS(),
                    wrapT: t.getWrapT()
                },
                r = JSON.stringify(n);
            this.samplerDefIndexMap.has(r) || (this.samplerDefIndexMap.set(r, this.jsonDoc.json.samplers.length), this.jsonDoc.json.samplers.push(n));
            const i = {
                    source: this.imageIndexMap.get(e),
                    sampler: this.samplerDefIndexMap.get(r)
                },
                s = JSON.stringify(i);
            this.textureDefIndexMap.has(s) || (this.textureDefIndexMap.set(s, this.jsonDoc.json.textures.length), this.jsonDoc.json.textures.push(i));
            const o = {
                index: this.textureDefIndexMap.get(s)
            };
            return 0 !== t.getTexCoord() && (o.texCoord = t.getTexCoord()), this.textureInfoDefMap.set(t, o), o
        }
        createPropertyDef(e) {
            const t = {};
            return e.getName() && (t.name = e.getName()), Object.keys(e.getExtras()).length > 0 && (t.extras = e.getExtras()), t
        }
        createAccessorDef(e) {
            const t = this.createPropertyDef(e);
            return t.type = e.getType(), t.componentType = e.getComponentType(), t.count = e.getCount(), this.N.getGraph().listParentEdges(e).some((e => "attributes" === e.getName() && "POSITION" === e.getAttributes().key || "input" === e.getName())) && (t.max = e.getMax([]).map(Math.fround), t.min = e.getMin([]).map(Math.fround)), e.getNormalized() && (t.normalized = e.getNormalized()), t
        }
        createImageData(e, t, n) {
            if (this.options.format === ny.GLB) this.imageBufferViews.push(t), e.bufferView = this.jsonDoc.json.bufferViews.length, this.jsonDoc.json.bufferViews.push({
                buffer: 0,
                byteOffset: -1,
                byteLength: t.byteLength
            });
            else {
                const r = hy.mimeTypeToExtension(n.getMimeType());
                e.uri = this.imageURIGenerator.createURI(n, r), this.jsonDoc.resources[e.uri] = t
            }
        }
        getAccessorUsage(e) {
            const t = this.O.get(e);
            if (t) return t;
            for (const t of this.N.getGraph().listParentEdges(e)) {
                const {
                    usage: e
                } = t.getAttributes();
                if (e) return e;
                t.getParent().propertyType !== $x.ROOT && this.N.getLogger().warn(`Missing attribute ".usage" on edge, "${t.getName()}".`)
            }
            return aw.BufferViewUsage.OTHER
        }
        addAccessorToUsageGroup(e, t) {
            const n = this.O.get(e);
            if (n && n !== t) throw new Error(`Accessor with usage "${n}" cannot be reused as "${t}".`);
            return this.O.set(e, t), this
        }
        listAccessorUsageGroups() {
            const e = {};
            for (const [t, n] of Array.from(this.O.entries())) e[n] = e[n] || [], e[n].push(t);
            return e
        }
    }
    aw.BufferViewTarget = ow, aw.BufferViewUsage = ey, aw.USAGE_TO_TARGET = {
        [ey.ARRAY_BUFFER]: ow.ARRAY_BUFFER,
        [ey.ELEMENT_ARRAY_BUFFER]: ow.ELEMENT_ARRAY_BUFFER
    };
    class lw {
        constructor(e, t) {
            this.multiple = void 0, this.basename = void 0, this.counter = 1, this.multiple = e, this.basename = t
        }
        createURI(e, t) {
            return e.getURI() ? e.getURI() : this.multiple ? `${this.basename}_${this.counter++}.${t}` : `${this.basename}.${t}`
        }
    }
    const {
        BufferViewUsage: cw
    } = aw;
    var uw;
    ! function(e) {
        e[e.JSON = 1313821514] = "JSON", e[e.BIN = 5130562] = "BIN"
    }(uw || (uw = {}));
    class pw extends class {
        constructor() {
            this.v = gy.DEFAULT_INSTANCE, this.h = new Set, this.C = {}, this.F = Qx.INTERLEAVED, this.lastReadBytes = 0, this.lastWriteBytes = 0
        }
        setLogger(e) {
            return this.v = e, this
        }
        registerExtensions(e) {
            for (const t of e) this.h.add(t), t.register();
            return this
        }
        registerDependencies(e) {
            return Object.assign(this.C, e), this
        }
        setVertexLayout(e) {
            return this.F = e, this
        }
        async read(e) {
            return await this.readJSON(await this.readAsJSON(e))
        }
        async readAsJSON(e) {
            return e.match(/^data:application\/octet-stream;/) || this.detectFormat(e) === ny.GLB ? this.U(e) : this.P(e)
        }
        async readJSON(e) {
            return e = this.j(e), this.L(e), class {
                static read(e, t = iw) {
                    const n = Yy({}, iw, t),
                        {
                            json: r
                        } = e,
                        i = new ew;
                    this.validate(e, n);
                    const s = new nw(e),
                        o = r.asset,
                        a = i.getRoot().getAsset();
                    o.copyright && (a.copyright = o.copyright), o.extras && (a.extras = o.extras), void 0 !== r.extras && i.getRoot().setExtras(Yy({}, r.extras));
                    const l = r.extensionsUsed || [],
                        c = r.extensionsRequired || [];
                    for (const e of n.extensions)
                        if (l.includes(e.EXTENSION_NAME)) {
                            const t = i.createExtension(e).setRequired(c.includes(e.EXTENSION_NAME));
                            for (const e of t.readDependencies) t.install(e, n.dependencies[e])
                        }
                    const u = r.buffers || [];
                    i.getRoot().listExtensionsUsed().filter((e => e.prereadTypes.includes($x.BUFFER))).forEach((e => e.preread(s, $x.BUFFER))), s.buffers = u.map((e => {
                        const t = i.createBuffer(e.name);
                        return e.extras && t.setExtras(e.extras), e.uri && 0 !== e.uri.indexOf("__") && t.setURI(e.uri), t
                    })), s.bufferViewBuffers = (r.bufferViews || []).map(((t, n) => {
                        if (!s.bufferViews[n]) {
                            const r = e.json.buffers[t.buffer];
                            s.bufferViews[n] = cy.toView(r.uri ? e.resources[r.uri] : e.resources["@glb.bin"], t.byteOffset || 0, t.byteLength)
                        }
                        return s.buffers[t.buffer]
                    })), s.accessors = (r.accessors || []).map((e => {
                        const t = i.createAccessor(e.name, s.bufferViewBuffers[e.bufferView]).setType(e.type);
                        if (e.extras && t.setExtras(e.extras), void 0 !== e.normalized && t.setNormalized(e.normalized), void 0 === e.bufferView && !e.sparse) return t;
                        let n;
                        return n = void 0 !== e.sparse ? function(e, t) {
                            const n = rw[e.componentType],
                                r = Dy.getElementSize(e.type);
                            let i;
                            i = void 0 !== e.bufferView ? sw(e, t) : new n(e.count * r);
                            const s = e.sparse,
                                o = s.count,
                                a = Yy({}, e, s.indices, {
                                    count: o,
                                    type: "SCALAR"
                                }),
                                l = Yy({}, e, s.values, {
                                    count: o
                                }),
                                c = sw(a, t),
                                u = sw(l, t);
                            for (let e = 0; e < a.count; e++)
                                for (let t = 0; t < r; t++) i[c[e] * r + t] = u[e * r + t];
                            return i
                        }(e, s) : sw(e, s), t.setArray(n), t
                    }));
                    const p = r.images || [],
                        h = r.textures || [];
                    i.getRoot().listExtensionsUsed().filter((e => e.prereadTypes.includes($x.TEXTURE))).forEach((e => e.preread(s, $x.TEXTURE))), s.textures = p.map((t => {
                        const n = i.createTexture(t.name);
                        if (t.extras && n.setExtras(t.extras), void 0 !== t.bufferView) {
                            const i = r.bufferViews[t.bufferView],
                                s = e.json.buffers[i.buffer],
                                o = i.byteOffset || 0,
                                a = (s.uri ? e.resources[s.uri] : e.resources["@glb.bin"]).slice(o, o + i.byteLength);
                            n.setImage(a)
                        } else void 0 !== t.uri && (n.setImage(e.resources[t.uri]), 0 !== t.uri.indexOf("__") && n.setURI(t.uri));
                        if (void 0 !== t.mimeType) n.setMimeType(t.mimeType);
                        else if (t.uri) {
                            const e = fy.extension(t.uri);
                            n.setMimeType(hy.extensionToMimeType(e))
                        }
                        return n
                    })), s.materials = (r.materials || []).map((e => {
                        const t = i.createMaterial(e.name);
                        e.extras && t.setExtras(e.extras), void 0 !== e.alphaMode && t.setAlphaMode(e.alphaMode), void 0 !== e.alphaCutoff && t.setAlphaCutoff(e.alphaCutoff), void 0 !== e.doubleSided && t.setDoubleSided(e.doubleSided);
                        const n = e.pbrMetallicRoughness || {};
                        if (void 0 !== n.baseColorFactor && t.setBaseColorFactor(n.baseColorFactor), void 0 !== e.emissiveFactor && t.setEmissiveFactor(e.emissiveFactor), void 0 !== n.metallicFactor && t.setMetallicFactor(n.metallicFactor), void 0 !== n.roughnessFactor && t.setRoughnessFactor(n.roughnessFactor), void 0 !== n.baseColorTexture) {
                            const e = n.baseColorTexture;
                            t.setBaseColorTexture(s.textures[h[e.index].source]), s.setTextureInfo(t.getBaseColorTextureInfo(), e)
                        }
                        if (void 0 !== e.emissiveTexture) {
                            const n = e.emissiveTexture;
                            t.setEmissiveTexture(s.textures[h[n.index].source]), s.setTextureInfo(t.getEmissiveTextureInfo(), n)
                        }
                        if (void 0 !== e.normalTexture) {
                            const n = e.normalTexture;
                            t.setNormalTexture(s.textures[h[n.index].source]), s.setTextureInfo(t.getNormalTextureInfo(), n), void 0 !== e.normalTexture.scale && t.setNormalScale(e.normalTexture.scale)
                        }
                        if (void 0 !== e.occlusionTexture) {
                            const n = e.occlusionTexture;
                            t.setOcclusionTexture(s.textures[h[n.index].source]), s.setTextureInfo(t.getOcclusionTextureInfo(), n), void 0 !== e.occlusionTexture.strength && t.setOcclusionStrength(e.occlusionTexture.strength)
                        }
                        if (void 0 !== n.metallicRoughnessTexture) {
                            const e = n.metallicRoughnessTexture;
                            t.setMetallicRoughnessTexture(s.textures[h[e.index].source]), s.setTextureInfo(t.getMetallicRoughnessTextureInfo(), e)
                        }
                        return t
                    }));
                    const d = r.meshes || [];
                    i.getRoot().listExtensionsUsed().filter((e => e.prereadTypes.includes($x.PRIMITIVE))).forEach((e => e.preread(s, $x.PRIMITIVE))), s.meshes = d.map((e => {
                        const t = i.createMesh(e.name);
                        return e.extras && t.setExtras(e.extras), void 0 !== e.weights && t.setWeights(e.weights), (e.primitives || []).forEach((n => {
                            const r = i.createPrimitive();
                            n.extras && r.setExtras(n.extras), void 0 !== n.material && r.setMaterial(s.materials[n.material]), void 0 !== n.mode && r.setMode(n.mode);
                            for (const [e, t] of Object.entries(n.attributes || {})) r.setAttribute(e, s.accessors[t]);
                            void 0 !== n.indices && r.setIndices(s.accessors[n.indices]);
                            const o = e.extras && e.extras.targetNames || [];
                            (n.targets || []).forEach(((e, t) => {
                                const n = o[t] || t.toString(),
                                    a = i.createPrimitiveTarget(n);
                                for (const [t, n] of Object.entries(e)) a.setAttribute(t, s.accessors[n]);
                                r.addTarget(a)
                            })), t.addPrimitive(r)
                        })), t
                    })), s.cameras = (r.cameras || []).map((e => {
                        const t = i.createCamera(e.name).setType(e.type);
                        if (e.extras && t.setExtras(e.extras), e.type === Ny.Type.PERSPECTIVE) {
                            const n = e.perspective;
                            t.setYFov(n.yfov), t.setZNear(n.znear), void 0 !== n.zfar && t.setZFar(n.zfar), void 0 !== n.aspectRatio && t.setAspectRatio(n.aspectRatio)
                        } else {
                            const n = e.orthographic;
                            t.setZNear(n.znear).setZFar(n.zfar).setXMag(n.xmag).setYMag(n.ymag)
                        }
                        return t
                    }));
                    const f = r.nodes || [];
                    i.getRoot().listExtensionsUsed().filter((e => e.prereadTypes.includes($x.NODE))).forEach((e => e.preread(s, $x.NODE))), s.nodes = f.map((e => {
                        const t = i.createNode(e.name);
                        if (e.extras && t.setExtras(e.extras), void 0 !== e.translation && t.setTranslation(e.translation), void 0 !== e.rotation && t.setRotation(e.rotation), void 0 !== e.scale && t.setScale(e.scale), void 0 !== e.matrix) {
                            const n = [0, 0, 0],
                                r = [0, 0, 0, 1],
                                i = [1, 1, 1];
                            vy.decompose(e.matrix, n, r, i), t.setTranslation(n), t.setRotation(r), t.setScale(i)
                        }
                        return void 0 !== e.weights && t.setWeights(e.weights), t
                    })), s.skins = (r.skins || []).map((e => {
                        const t = i.createSkin(e.name);
                        e.extras && t.setExtras(e.extras), void 0 !== e.inverseBindMatrices && t.setInverseBindMatrices(s.accessors[e.inverseBindMatrices]), void 0 !== e.skeleton && t.setSkeleton(s.nodes[e.skeleton]);
                        for (const n of e.joints) t.addJoint(s.nodes[n]);
                        return t
                    })), f.map(((e, t) => {
                        const n = s.nodes[t];
                        (e.children || []).forEach((e => n.addChild(s.nodes[e]))), void 0 !== e.mesh && n.setMesh(s.meshes[e.mesh]), void 0 !== e.camera && n.setCamera(s.cameras[e.camera]), void 0 !== e.skin && n.setSkin(s.skins[e.skin])
                    })), s.animations = (r.animations || []).map((e => {
                        const t = i.createAnimation(e.name);
                        e.extras && t.setExtras(e.extras);
                        const n = (e.samplers || []).map((e => {
                            const n = i.createAnimationSampler().setInput(s.accessors[e.input]).setOutput(s.accessors[e.output]).setInterpolation(e.interpolation || Iy.Interpolation.LINEAR);
                            return e.extras && n.setExtras(e.extras), t.addSampler(n), n
                        }));
                        return (e.channels || []).forEach((e => {
                            const r = i.createAnimationChannel().setSampler(n[e.sampler]).setTargetPath(e.target.path);
                            void 0 !== e.target.node && r.setTargetNode(s.nodes[e.target.node]), e.extras && r.setExtras(e.extras), t.addChannel(r)
                        })), t
                    }));
                    const _ = r.scenes || [];
                    return i.getRoot().listExtensionsUsed().filter((e => e.prereadTypes.includes($x.SCENE))).forEach((e => e.preread(s, $x.SCENE))), s.scenes = _.map((e => {
                        const t = i.createScene(e.name);
                        return e.extras && t.setExtras(e.extras), (e.nodes || []).map((e => s.nodes[e])).forEach((e => t.addChild(e))), t
                    })), void 0 !== r.scene && i.getRoot().setDefaultScene(s.scenes[r.scene]), i.getRoot().listExtensionsUsed().forEach((e => e.read(s))), i
                }
                static validate(e, t) {
                    const n = e.json;
                    if ("2.0" !== n.asset.version) throw new Error(`Unsupported glTF version, "${n.asset.version}".`);
                    if (n.extensionsRequired)
                        for (const e of n.extensionsRequired)
                            if (!t.extensions.find((t => t.EXTENSION_NAME === e))) throw new Error(`Missing required extension, "${e}".`);
                    if (n.extensionsUsed)
                        for (const e of n.extensionsUsed) t.extensions.find((t => t.EXTENSION_NAME === e)) || t.logger.warn(`Missing optional extension, "${e}".`)
                }
            }.read(e, {
                extensions: Array.from(this.h),
                dependencies: this.C,
                logger: this.v
            })
        }
        async binaryToJSON(e) {
            const t = this._(cy.assertView(e));
            this.L(t);
            const n = t.json;
            if (n.buffers && n.buffers.some((e => function(e, t) {
                    return void 0 !== t.uri && !(t.uri in e.resources)
                }(t, e)))) throw new Error("Cannot resolve external buffers with binaryToJSON().");
            if (n.images && n.images.some((e => function(e, t) {
                    return void 0 !== t.uri && !(t.uri in e.resources) && void 0 === t.bufferView
                }(t, e)))) throw new Error("Cannot resolve external images with binaryToJSON().");
            return t
        }
        async readBinary(e) {
            return this.readJSON(await this.binaryToJSON(cy.assertView(e)))
        }
        async writeJSON(e, t = {}) {
            if (t.format === ny.GLB && e.getRoot().listBuffers().length > 1) throw new Error("GLB must have 0–1 buffers.");
            return class {
                static write(e, t) {
                    const n = e.getRoot(),
                        r = {
                            asset: Yy({
                                generator: "glTF-Transform v2.2.0"
                            }, n.getAsset()),
                            extras: Yy({}, n.getExtras())
                        },
                        i = {
                            json: r,
                            resources: {}
                        },
                        s = new aw(e, i, t),
                        o = t.logger || gy.DEFAULT_INSTANCE,
                        a = new Set(t.extensions.map((e => e.EXTENSION_NAME))),
                        l = e.getRoot().listExtensionsUsed().filter((e => a.has(e.extensionName))),
                        c = e.getRoot().listExtensionsRequired().filter((e => a.has(e.extensionName)));
                    l.length < e.getRoot().listExtensionsUsed().length && o.debug("Some extensions were not registered for I/O, and will not be written.");
                    for (const e of l)
                        for (const n of e.writeDependencies) e.install(n, t.dependencies[n]);

                    function u(e, t, n, i) {
                        const o = [];
                        let a = 0;
                        for (const t of e) {
                            const e = s.createAccessorDef(t);
                            e.bufferView = r.bufferViews.length;
                            const n = t.getArray(),
                                i = cy.pad(cy.toView(n));
                            e.byteOffset = a, a += i.byteLength, o.push(i), s.accessorIndexMap.set(t, r.accessors.length), r.accessors.push(e)
                        }
                        const l = {
                            buffer: t,
                            byteOffset: n,
                            byteLength: cy.concat(o).byteLength
                        };
                        return i && (l.target = i), r.bufferViews.push(l), {
                            buffers: o,
                            byteLength: a
                        }
                    }

                    function p(e, t, n) {
                        const i = e[0].getCount();
                        let o = 0;
                        for (const t of e) {
                            const e = s.createAccessorDef(t);
                            e.bufferView = r.bufferViews.length, e.byteOffset = o;
                            const n = t.getElementSize(),
                                i = t.getComponentSize();
                            o += cy.padNumber(n * i), s.accessorIndexMap.set(t, r.accessors.length), r.accessors.push(e)
                        }
                        const a = i * o,
                            l = new ArrayBuffer(a),
                            c = new DataView(l);
                        for (let t = 0; t < i; t++) {
                            let n = 0;
                            for (const r of e) {
                                const e = r.getElementSize(),
                                    i = r.getComponentSize(),
                                    s = r.getComponentType(),
                                    a = r.getArray();
                                for (let r = 0; r < e; r++) {
                                    const l = t * o + n + r * i,
                                        u = a[t * e + r];
                                    switch (s) {
                                        case Dy.ComponentType.FLOAT:
                                            c.setFloat32(l, u, !0);
                                            break;
                                        case Dy.ComponentType.BYTE:
                                            c.setInt8(l, u);
                                            break;
                                        case Dy.ComponentType.SHORT:
                                            c.setInt16(l, u, !0);
                                            break;
                                        case Dy.ComponentType.UNSIGNED_BYTE:
                                            c.setUint8(l, u);
                                            break;
                                        case Dy.ComponentType.UNSIGNED_SHORT:
                                            c.setUint16(l, u, !0);
                                            break;
                                        case Dy.ComponentType.UNSIGNED_INT:
                                            c.setUint32(l, u, !0);
                                            break;
                                        default:
                                            throw new Error("Unexpected component type: " + s)
                                    }
                                }
                                n += cy.padNumber(e * i)
                            }
                        }
                        return r.bufferViews.push({
                            buffer: t,
                            byteOffset: n,
                            byteLength: a,
                            byteStride: o,
                            target: aw.BufferViewTarget.ARRAY_BUFFER
                        }), {
                            byteLength: a,
                            buffers: [new Uint8Array(l)]
                        }
                    }
                    const h = new Map;
                    for (const t of e.getGraph().listEdges()) {
                        if (t.getParent() === n) continue;
                        const e = t.getChild();
                        if (e instanceof Dy) {
                            const n = h.get(e) || [];
                            n.push(t), h.set(e, n)
                        }
                    }
                    if (r.accessors = [], r.bufferViews = [], r.samplers = [], r.textures = [], r.images = n.listTextures().map(((e, t) => {
                            const n = s.createPropertyDef(e);
                            e.getMimeType() && (n.mimeType = e.getMimeType());
                            const r = e.getImage();
                            return r && s.createImageData(n, r, e), s.imageIndexMap.set(e, t), n
                        })), l.filter((e => e.prewriteTypes.includes($x.ACCESSOR))).forEach((e => e.prewrite(s, $x.ACCESSOR))), n.listAccessors().forEach((e => {
                            const t = s.accessorUsageGroupedByParent,
                                n = s.accessorParents;
                            if (s.accessorIndexMap.has(e)) return;
                            const r = h.get(e) || [],
                                i = s.getAccessorUsage(e);
                            if (s.addAccessorToUsageGroup(e, i), t.has(i)) {
                                const t = r[0].getParent(),
                                    i = n.get(t) || new Set;
                                i.add(e), n.set(t, i)
                            }
                        })), l.filter((e => e.prewriteTypes.includes($x.BUFFER))).forEach((e => e.prewrite(s, $x.BUFFER))), (n.listAccessors().length > 0 || n.listTextures().length > 0 || s.otherBufferViews.size > 0) && 0 === n.listBuffers().length) throw new Error("Buffer required for Document resources, but none was found.");
                    r.buffers = [], n.listBuffers().forEach(((e, n) => {
                        const o = s.createPropertyDef(e),
                            a = s.accessorUsageGroupedByParent,
                            l = s.accessorParents,
                            c = e.listParents().filter((e => e instanceof Dy)),
                            h = new Set(c),
                            d = [],
                            f = r.buffers.length;
                        let _ = 0;
                        const m = s.listAccessorUsageGroups();
                        for (const e in m)
                            if (a.has(e))
                                for (const n of Array.from(l.values())) {
                                    const r = Array.from(n).filter((e => h.has(e))).filter((t => s.getAccessorUsage(t) === e));
                                    if (r.length)
                                        if (e !== cw.ARRAY_BUFFER || t.vertexLayout === Qx.INTERLEAVED) {
                                            const t = e === cw.ARRAY_BUFFER ? p(r, f, _) : u(r, f, _);
                                            _ += t.byteLength, d.push(...t.buffers)
                                        } else
                                            for (const e of r) {
                                                const t = p([e], f, _);
                                                _ += t.byteLength, d.push(...t.buffers)
                                            }
                                } else {
                                    const t = m[e].filter((e => h.has(e)));
                                    if (!t.length) continue;
                                    const n = u(t, f, _, e === cw.ELEMENT_ARRAY_BUFFER ? aw.BufferViewTarget.ELEMENT_ARRAY_BUFFER : void 0);
                                    _ += n.byteLength, d.push(...n.buffers)
                                }
                        if (s.imageBufferViews.length && 0 === n)
                            for (let e = 0; e < s.imageBufferViews.length; e++)
                                if (r.bufferViews[r.images[e].bufferView].byteOffset = _, _ += s.imageBufferViews[e].byteLength, d.push(s.imageBufferViews[e]), _ % 8) {
                                    const e = 8 - _ % 8;
                                    _ += e, d.push(new Uint8Array(e))
                                }
                        if (s.otherBufferViews.has(e))
                            for (const t of s.otherBufferViews.get(e)) r.bufferViews.push({
                                buffer: f,
                                byteOffset: _,
                                byteLength: t.byteLength
                            }), s.otherBufferViewsIndexMap.set(t, r.bufferViews.length - 1), _ += t.byteLength, d.push(t);
                        if (_) {
                            let n;
                            t.format === ny.GLB ? n = "@glb.bin" : (n = s.bufferURIGenerator.createURI(e, "bin"), o.uri = n), o.byteLength = _, i.resources[n] = cy.concat(d)
                        }
                        r.buffers.push(o), s.bufferIndexMap.set(e, n)
                    })), n.listAccessors().find((e => !e.getBuffer())) && o.warn("Skipped writing one or more Accessors: no Buffer assigned."), r.materials = n.listMaterials().map(((e, t) => {
                        const n = s.createPropertyDef(e);
                        if (e.getAlphaMode() !== Hy.AlphaMode.OPAQUE && (n.alphaMode = e.getAlphaMode()), e.getAlphaMode() === Hy.AlphaMode.MASK && (n.alphaCutoff = e.getAlphaCutoff()), e.getDoubleSided() && (n.doubleSided = !0), n.pbrMetallicRoughness = {}, vy.eq(e.getBaseColorFactor(), [1, 1, 1, 1]) || (n.pbrMetallicRoughness.baseColorFactor = e.getBaseColorFactor()), vy.eq(e.getEmissiveFactor(), [0, 0, 0]) || (n.emissiveFactor = e.getEmissiveFactor()), 1 !== e.getRoughnessFactor() && (n.pbrMetallicRoughness.roughnessFactor = e.getRoughnessFactor()), 1 !== e.getMetallicFactor() && (n.pbrMetallicRoughness.metallicFactor = e.getMetallicFactor()), e.getBaseColorTexture()) {
                            const t = e.getBaseColorTexture(),
                                r = e.getBaseColorTextureInfo();
                            n.pbrMetallicRoughness.baseColorTexture = s.createTextureInfoDef(t, r)
                        }
                        if (e.getEmissiveTexture()) {
                            const t = e.getEmissiveTexture(),
                                r = e.getEmissiveTextureInfo();
                            n.emissiveTexture = s.createTextureInfoDef(t, r)
                        }
                        if (e.getNormalTexture()) {
                            const t = e.getNormalTexture(),
                                r = e.getNormalTextureInfo(),
                                i = s.createTextureInfoDef(t, r);
                            1 !== e.getNormalScale() && (i.scale = e.getNormalScale()), n.normalTexture = i
                        }
                        if (e.getOcclusionTexture()) {
                            const t = e.getOcclusionTexture(),
                                r = e.getOcclusionTextureInfo(),
                                i = s.createTextureInfoDef(t, r);
                            1 !== e.getOcclusionStrength() && (i.strength = e.getOcclusionStrength()), n.occlusionTexture = i
                        }
                        if (e.getMetallicRoughnessTexture()) {
                            const t = e.getMetallicRoughnessTexture(),
                                r = e.getMetallicRoughnessTextureInfo();
                            n.pbrMetallicRoughness.metallicRoughnessTexture = s.createTextureInfoDef(t, r)
                        }
                        return s.materialIndexMap.set(e, t), n
                    })), r.meshes = n.listMeshes().map(((e, t) => {
                        const n = s.createPropertyDef(e);
                        let r = null;
                        return n.primitives = e.listPrimitives().map((e => {
                            const t = {
                                attributes: {}
                            };
                            t.mode = e.getMode();
                            const n = e.getMaterial();
                            n && (t.material = s.materialIndexMap.get(n)), Object.keys(e.getExtras()).length && (t.extras = e.getExtras());
                            const i = e.getIndices();
                            i && (t.indices = s.accessorIndexMap.get(i));
                            for (const n of e.listSemantics()) t.attributes[n] = s.accessorIndexMap.get(e.getAttribute(n));
                            for (const n of e.listTargets()) {
                                const e = {};
                                for (const t of n.listSemantics()) e[t] = s.accessorIndexMap.get(n.getAttribute(t));
                                t.targets = t.targets || [], t.targets.push(e)
                            }
                            return e.listTargets().length && !r && (r = e.listTargets().map((e => e.getName()))), t
                        })), e.getWeights().length && (n.weights = e.getWeights()), r && (n.extras = n.extras || {}, n.extras.targetNames = r), s.meshIndexMap.set(e, t), n
                    })), r.cameras = n.listCameras().map(((e, t) => {
                        const n = s.createPropertyDef(e);
                        if (n.type = e.getType(), n.type === Ny.Type.PERSPECTIVE) {
                            n.perspective = {
                                znear: e.getZNear(),
                                zfar: e.getZFar(),
                                yfov: e.getYFov()
                            };
                            const t = e.getAspectRatio();
                            null !== t && (n.perspective.aspectRatio = t)
                        } else n.orthographic = {
                            znear: e.getZNear(),
                            zfar: e.getZFar(),
                            xmag: e.getXMag(),
                            ymag: e.getYMag()
                        };
                        return s.cameraIndexMap.set(e, t), n
                    })), r.nodes = n.listNodes().map(((e, t) => {
                        const n = s.createPropertyDef(e);
                        return vy.eq(e.getTranslation(), [0, 0, 0]) || (n.translation = e.getTranslation()), vy.eq(e.getRotation(), [0, 0, 0, 1]) || (n.rotation = e.getRotation()), vy.eq(e.getScale(), [1, 1, 1]) || (n.scale = e.getScale()), e.getWeights().length && (n.weights = e.getWeights()), s.nodeIndexMap.set(e, t), n
                    })), r.skins = n.listSkins().map(((e, t) => {
                        const n = s.createPropertyDef(e),
                            r = e.getInverseBindMatrices();
                        r && (n.inverseBindMatrices = s.accessorIndexMap.get(r));
                        const i = e.getSkeleton();
                        return i && (n.skeleton = s.nodeIndexMap.get(i)), n.joints = e.listJoints().map((e => s.nodeIndexMap.get(e))), s.skinIndexMap.set(e, t), n
                    })), n.listNodes().forEach(((e, t) => {
                        const n = r.nodes[t],
                            i = e.getMesh();
                        i && (n.mesh = s.meshIndexMap.get(i));
                        const o = e.getCamera();
                        o && (n.camera = s.cameraIndexMap.get(o));
                        const a = e.getSkin();
                        a && (n.skin = s.skinIndexMap.get(a)), e.listChildren().length > 0 && (n.children = e.listChildren().map((e => s.nodeIndexMap.get(e))))
                    })), r.animations = n.listAnimations().map(((e, t) => {
                        const n = s.createPropertyDef(e),
                            r = new Map;
                        return n.samplers = e.listSamplers().map(((e, t) => {
                            const n = s.createPropertyDef(e);
                            return n.input = s.accessorIndexMap.get(e.getInput()), n.output = s.accessorIndexMap.get(e.getOutput()), n.interpolation = e.getInterpolation(), r.set(e, t), n
                        })), n.channels = e.listChannels().map((e => {
                            const t = s.createPropertyDef(e);
                            return t.sampler = r.get(e.getSampler()), t.target = {
                                node: s.nodeIndexMap.get(e.getTargetNode()),
                                path: e.getTargetPath()
                            }, t
                        })), s.animationIndexMap.set(e, t), n
                    })), r.scenes = n.listScenes().map(((e, t) => {
                        const n = s.createPropertyDef(e);
                        return n.nodes = e.listChildren().map((e => s.nodeIndexMap.get(e))), s.sceneIndexMap.set(e, t), n
                    }));
                    const d = n.getDefaultScene();
                    return d && (r.scene = n.listScenes().indexOf(d)), r.extensionsUsed = l.map((e => e.extensionName)), r.extensionsRequired = c.map((e => e.extensionName)), l.forEach((e => e.write(s))),
                        function(e) {
                            const t = [];
                            for (const n in e) {
                                const r = e[n];
                                (Array.isArray(r) && 0 === r.length || null === r || "" === r || r && "object" == typeof r && 0 === Object.keys(r).length) && t.push(n)
                            }
                            for (const n of t) delete e[n]
                        }(r), i
                }
            }.write(e, {
                format: t.format || ny.GLTF,
                basename: t.basename || "",
                logger: this.v,
                vertexLayout: this.F,
                dependencies: Yy({}, this.C),
                extensions: Array.from(this.h)
            })
        }
        async writeBinary(e) {
            const {
                json: t,
                resources: n
            } = await this.writeJSON(e, {
                format: ny.GLB
            }), r = new Uint32Array([1179937895, 2, 12]), i = JSON.stringify(t), s = cy.pad(cy.encodeText(i), 32), o = cy.toView(new Uint32Array([s.byteLength, 1313821514])), a = cy.concat([o, s]);
            r[r.length - 1] += a.byteLength;
            const l = Object.values(n)[0];
            if (!l || !l.byteLength) return cy.concat([cy.toView(r), a]);
            const c = cy.pad(l, 0),
                u = cy.toView(new Uint32Array([c.byteLength, 5130562])),
                p = cy.concat([u, c]);
            return r[r.length - 1] += p.byteLength, cy.concat([cy.toView(r), a, p])
        }
        detectFormat(e) {
            return "glb" === (Cy.isAbsoluteURL(e) ? Cy.extension(e) : fy.extension(e)) ? ny.GLB : ny.GLTF
        }
        async P(e) {
            this.lastReadBytes = 0;
            const t = await this.readURI(e, "text");
            this.lastReadBytes += t.length;
            const n = {
                json: JSON.parse(t),
                resources: {}
            };
            return await this.D(n, this.dirname(e)), this.L(n), n
        }
        async U(e) {
            const t = await this.readURI(e, "view");
            this.lastReadBytes = t.byteLength;
            const n = this._(t);
            return await this.D(n, this.dirname(e)), this.L(n), n
        }
        async D(e, t) {
            var n = this;
            const r = [...e.json.images || [], ...e.json.buffers || []].map((async function(r) {
                const i = r.uri;
                if (!i || i.match(/data:/)) return Promise.resolve();
                e.resources[i] = await n.readURI(n.resolve(t, i), "view"), n.lastReadBytes += e.resources[i].byteLength
            }));
            await Promise.all(r)
        }
        L(e) {
            function t(t) {
                if (t.uri)
                    if (t.uri in e.resources) cy.assertView(e.resources[t.uri]);
                    else if (t.uri.match(/data:/)) {
                    const n = `__${function(){for(let e=0;e<999;e++){const e=Ay();if(!Ey.has(e))return Ey.add(e),e}return""}()}.${fy.extension(t.uri)}`;
                    e.resources[n] = cy.createBufferFromDataURI(t.uri), t.uri = n
                }
            }(e.json.images || []).forEach((e => {
                if (void 0 === e.bufferView && void 0 === e.uri) throw new Error("Missing resource URI or buffer view.");
                t(e)
            })), (e.json.buffers || []).forEach(t)
        }
        j(e) {
            const {
                images: t,
                buffers: n
            } = e.json;
            return e = {
                json: Yy({}, e.json),
                resources: Yy({}, e.resources)
            }, t && (e.json.images = t.map((e => Yy({}, e)))), n && (e.json.buffers = n.map((e => Yy({}, e)))), e
        }
        _(e) {
            const t = new Uint32Array(e.buffer, e.byteOffset, 3);
            if (1179937895 !== t[0]) throw new Error("Invalid glTF asset.");
            if (2 !== t[1]) throw new Error(`Unsupported glTF binary version, "${t[1]}".`);
            const n = new Uint32Array(e.buffer, e.byteOffset + 12, 2);
            if (n[1] !== uw.JSON) throw new Error("Missing required GLB JSON chunk.");
            const r = n[0],
                i = cy.decodeText(cy.toView(e, 20, r)),
                s = JSON.parse(i),
                o = 20 + r;
            if (e.byteLength <= o) return {
                json: s,
                resources: {}
            };
            const a = new Uint32Array(e.buffer, e.byteOffset + o, 2);
            if (a[1] !== uw.BIN) throw new Error("Expected GLB BIN in second chunk.");
            return {
                json: s,
                resources: {
                    "@glb.bin": cy.toView(e, o + 8, a[0])
                }
            }
        }
    } {
        constructor(e = Cy.DEFAULT_INIT) {
            super(), this.V = void 0, this.V = e
        }
        async readURI(e, t) {
            const n = await fetch(e, this.V);
            switch (t) {
                case "view":
                    return new Uint8Array(await n.arrayBuffer());
                case "text":
                    return n.text()
            }
        }
        resolve(e, t) {
            return Cy.resolve(e, t)
        }
        dirname(e) {
            return Cy.dirname(e)
        }
        detectFormat(e) {
            return "glb" === Cy.extension(e) ? ny.GLB : ny.GLTF
        }
    }
    class hw {
        constructor() {
            this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
                vendorId: 0,
                descriptorType: 0,
                descriptorBlockSize: 0,
                versionNumber: 2,
                colorModel: 0,
                colorPrimaries: 1,
                transferFunction: 2,
                flags: 0,
                texelBlockDimension: [0, 0, 0, 0],
                bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                samples: []
            }], this.keyValue = {}, this.globalData = null
        }
    }
    class dw {
        constructor(e, t, n, r) {
            this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = r, this._offset = 0
        }
        _nextUint8() {
            const e = this._dataView.getUint8(this._offset);
            return this._offset += 1, e
        }
        _nextUint16() {
            const e = this._dataView.getUint16(this._offset, this._littleEndian);
            return this._offset += 2, e
        }
        _nextUint32() {
            const e = this._dataView.getUint32(this._offset, this._littleEndian);
            return this._offset += 4, e
        }
        _nextUint64() {
            const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
            return this._offset += 8, e
        }
        _nextInt32() {
            const e = this._dataView.getInt32(this._offset, this._littleEndian);
            return this._offset += 4, e
        }
        _skip(e) {
            return this._offset += e, this
        }
        _scan(e, t = 0) {
            const n = this._offset;
            let r = 0;
            for (; this._dataView.getUint8(this._offset) !== t && r < e;) r++, this._offset++;
            return r < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, r)
        }
    }
    new Uint8Array([0]);
    const fw = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

    function _w(e) {
        return "undefined" != typeof TextDecoder ? (new TextDecoder).decode(e) : Buffer.from(e).toString("utf8")
    }

    function mw(e) {
        const t = new Uint8Array(e.buffer, e.byteOffset, fw.length);
        if (t[0] !== fw[0] || t[1] !== fw[1] || t[2] !== fw[2] || t[3] !== fw[3] || t[4] !== fw[4] || t[5] !== fw[5] || t[6] !== fw[6] || t[7] !== fw[7] || t[8] !== fw[8] || t[9] !== fw[9] || t[10] !== fw[10] || t[11] !== fw[11]) throw new Error("Missing KTX 2.0 identifier.");
        const n = new hw,
            r = 17 * Uint32Array.BYTES_PER_ELEMENT,
            i = new dw(e, fw.length, r, !0);
        n.vkFormat = i._nextUint32(), n.typeSize = i._nextUint32(), n.pixelWidth = i._nextUint32(), n.pixelHeight = i._nextUint32(), n.pixelDepth = i._nextUint32(), n.layerCount = i._nextUint32(), n.faceCount = i._nextUint32();
        const s = i._nextUint32();
        n.supercompressionScheme = i._nextUint32();
        const o = i._nextUint32(),
            a = i._nextUint32(),
            l = i._nextUint32(),
            c = i._nextUint32(),
            u = i._nextUint64(),
            p = i._nextUint64(),
            h = new dw(e, fw.length + r, 3 * s * 8, !0);
        for (let t = 0; t < s; t++) n.levels.push({
            levelData: new Uint8Array(e.buffer, e.byteOffset + h._nextUint64(), h._nextUint64()),
            uncompressedByteLength: h._nextUint64()
        });
        const d = new dw(e, o, a, !0),
            f = {
                vendorId: d._skip(4)._nextUint16(),
                descriptorType: d._nextUint16(),
                versionNumber: d._nextUint16(),
                descriptorBlockSize: d._nextUint16(),
                colorModel: d._nextUint8(),
                colorPrimaries: d._nextUint8(),
                transferFunction: d._nextUint8(),
                flags: d._nextUint8(),
                texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
                bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
                samples: []
            },
            _ = (f.descriptorBlockSize / 4 - 6) / 4;
        for (let e = 0; e < _; e++) {
            const t = {
                bitOffset: d._nextUint16(),
                bitLength: d._nextUint8(),
                channelType: d._nextUint8(),
                samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
                sampleLower: -1 / 0,
                sampleUpper: 1 / 0
            };
            64 & t.channelType ? (t.sampleLower = d._nextInt32(), t.sampleUpper = d._nextInt32()) : (t.sampleLower = d._nextUint32(), t.sampleUpper = d._nextUint32()), f.samples[e] = t
        }
        n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(f);
        const m = new dw(e, l, c, !0);
        for (; m._offset < c;) {
            const e = m._nextUint32(),
                t = m._scan(e),
                r = _w(t),
                i = m._scan(e - t.byteLength);
            n.keyValue[r] = r.match(/^ktx/i) ? _w(i) : i, m._offset % 4 && m._skip(4 - m._offset % 4)
        }
        if (p <= 0) return n;
        const g = new dw(e, u, p, !0),
            v = g._nextUint16(),
            b = g._nextUint16(),
            x = g._nextUint32(),
            y = g._nextUint32(),
            w = g._nextUint32(),
            S = g._nextUint32(),
            M = [];
        for (let e = 0; e < s; e++) M.push({
            imageFlags: g._nextUint32(),
            rgbSliceByteOffset: g._nextUint32(),
            rgbSliceByteLength: g._nextUint32(),
            alphaSliceByteOffset: g._nextUint32(),
            alphaSliceByteLength: g._nextUint32()
        });
        const T = u + g._offset,
            E = T + x,
            A = E + y,
            C = A + w,
            R = new Uint8Array(e.buffer, e.byteOffset + T, x),
            k = new Uint8Array(e.buffer, e.byteOffset + E, y),
            P = new Uint8Array(e.buffer, e.byteOffset + A, w),
            D = new Uint8Array(e.buffer, e.byteOffset + C, S);
        return n.globalData = {
            endpointCount: v,
            selectorCount: b,
            imageDescs: M,
            endpointsData: R,
            selectorsData: k,
            tablesData: P,
            extendedData: D
        }, n
    }
    class gw extends Uy {
        init() {
            this.extensionName = "EXT_mesh_gpu_instancing", this.propertyType = "InstancedMesh", this.parentTypes = [$x.NODE]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                attributes: {}
            })
        }
        getAttribute(e) {
            return this.getRefMap("attributes", e)
        }
        setAttribute(e, t) {
            return this.setRefMap("attributes", e, t, {
                usage: "INSTANCE_ATTRIBUTE"
            })
        }
        listAttributes() {
            return this.listRefMapValues("attributes")
        }
        listSemantics() {
            return this.listRefMapKeys("attributes")
        }
    }
    gw.EXTENSION_NAME = "EXT_mesh_gpu_instancing";
    const vw = "EXT_mesh_gpu_instancing";

    function bw() {
        return (bw = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }).apply(this, arguments)
    }
    var xw, yw, ww;
    (class extends tw {
        constructor(...e) {
            super(...e), this.extensionName = vw, this.provideTypes = [$x.NODE], this.prewriteTypes = [$x.ACCESSOR]
        }
        createInstancedMesh() {
            return new gw(this.document.getGraph())
        }
        read(e) {
            return (e.jsonDoc.json.nodes || []).forEach(((t, n) => {
                if (!t.extensions || !t.extensions[vw]) return;
                const r = t.extensions[vw],
                    i = this.createInstancedMesh();
                for (const t in r.attributes) i.setAttribute(t, e.accessors[r.attributes[t]]);
                e.nodes[n].setExtension(vw, i)
            })), this
        }
        prewrite(e) {
            e.accessorUsageGroupedByParent.add("INSTANCE_ATTRIBUTE");
            for (const t of this.properties)
                for (const n of t.listAttributes()) e.addAccessorToUsageGroup(n, "INSTANCE_ATTRIBUTE");
            return this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listNodes().forEach((n => {
                const r = n.getExtension(vw);
                if (r) {
                    const i = e.nodeIndexMap.get(n),
                        s = t.json.nodes[i],
                        o = {
                            attributes: {}
                        };
                    r.listSemantics().forEach((t => {
                        const n = r.getAttribute(t);
                        o.attributes[t] = e.accessorIndexMap.get(n)
                    })), s.extensions = s.extensions || {}, s.extensions[vw] = o
                }
            })), this
        }
    }).EXTENSION_NAME = vw,
        function(e) {
            e.QUANTIZE = "quantize", e.FILTER = "filter"
        }(xw || (xw = {})),
        function(e) {
            e.ATTRIBUTES = "ATTRIBUTES", e.TRIANGLES = "TRIANGLES", e.INDICES = "INDICES"
        }(yw || (yw = {})),
        function(e) {
            e.NONE = "NONE", e.OCTAHEDRAL = "OCTAHEDRAL", e.QUATERNION = "QUATERNION", e.EXPONENTIAL = "EXPONENTIAL"
        }(ww || (ww = {}));
    const {
        BYTE: Sw,
        SHORT: Mw,
        FLOAT: Tw
    } = Dy.ComponentType, {
        normalize: Ew,
        denormalize: Aw
    } = vy;

    function Cw(e, t, n, r) {
        const {
            filter: i,
            bits: s
        } = r, o = {
            array: e.getArray(),
            byteStride: e.getElementSize() * e.getComponentSize(),
            componentType: e.getComponentType(),
            normalized: e.getNormalized()
        };
        if (n !== yw.ATTRIBUTES) return o;
        if (i !== ww.NONE) {
            let n = e.getNormalized() ? function(e) {
                const t = e.getComponentType(),
                    n = e.getArray(),
                    r = new Float32Array(n.length);
                for (let e = 0; e < n.length; e++) r[e] = Aw(n[e], t);
                return r
            }(e) : new Float32Array(o.array);
            switch (i) {
                case ww.EXPONENTIAL:
                    o.byteStride = 4 * e.getElementSize(), o.componentType = Tw, o.normalized = !1, o.array = t.encodeFilterExp(n, e.getCount(), o.byteStride, s);
                    break;
                case ww.OCTAHEDRAL:
                    o.byteStride = s > 8 ? 8 : 4, o.componentType = s > 8 ? Mw : Sw, o.normalized = !0, n = 3 === e.getElementSize() ? function(e) {
                        const t = new Float32Array(4 * e.length / 3);
                        for (let n = 0, r = e.length / 3; n < r; n++) t[4 * n] = e[3 * n], t[4 * n + 1] = e[3 * n + 1], t[4 * n + 2] = e[3 * n + 2];
                        return t
                    }(n) : n, o.array = t.encodeFilterOct(n, e.getCount(), o.byteStride, s);
                    break;
                case ww.QUATERNION:
                    o.byteStride = 8, o.componentType = Mw, o.normalized = !0, o.array = t.encodeFilterQuat(n, e.getCount(), o.byteStride, s);
                    break;
                default:
                    throw new Error("Invalid filter.")
            }
            o.min = e.getMin([]), o.max = e.getMax([]), e.getNormalized() && (o.min = o.min.map((t => Aw(t, e.getComponentType()))), o.max = o.max.map((t => Aw(t, e.getComponentType())))), o.normalized && (o.min = o.min.map((e => Ew(e, o.componentType))), o.max = o.max.map((e => Ew(e, o.componentType))))
        } else o.byteStride % 4 && (o.array = function(e, t) {
            const n = cy.padNumber(e.BYTES_PER_ELEMENT * t) / e.BYTES_PER_ELEMENT,
                r = new e.constructor(e.length / t * n);
            for (let i = 0; i * t < e.length; i++)
                for (let s = 0; s < t; s++) r[i * n + s] = e[i * t + s];
            return r
        }(o.array, e.getElementSize()), o.byteStride = o.array.byteLength / e.getCount());
        return o
    }

    function Rw(e, t) {
        return t === aw.BufferViewUsage.ELEMENT_ARRAY_BUFFER ? e.listParents().some((e => e instanceof Xy && e.getMode() === Xy.Mode.TRIANGLES)) ? yw.TRIANGLES : yw.INDICES : yw.ATTRIBUTES
    }

    function kw(e, t) {
        const n = t.getGraph().listParentEdges(e).filter((e => !(e.getParent() instanceof Qy)));
        for (const t of n) {
            const n = t.getName(),
                r = t.getAttributes().key || "";
            if ("indices" === n) return {
                filter: ww.NONE
            };
            if ("attributes" === n) {
                if ("POSITION" === r) return {
                    filter: ww.NONE
                };
                if ("TEXCOORD_0" === r) return {
                    filter: ww.NONE
                };
                if ("NORMAL" === r) return {
                    filter: ww.OCTAHEDRAL,
                    bits: 8
                };
                if ("TANGENT" === r) return {
                    filter: ww.OCTAHEDRAL,
                    bits: 8
                };
                if (r.startsWith("JOINTS_")) return {
                    filter: ww.NONE
                };
                if (r.startsWith("WEIGHTS_")) return {
                    filter: ww.NONE
                }
            }
            if ("output" === n) {
                const t = Pw(e);
                return "rotation" === t ? {
                    filter: ww.QUATERNION,
                    bits: 16
                } : "translation" === t || "scale" === t ? {
                    filter: ww.EXPONENTIAL,
                    bits: 12
                } : {
                    filter: ww.NONE
                }
            }
            if ("input" === n) return {
                filter: ww.NONE
            };
            if ("inverseBindMatrices" === n) return {
                filter: ww.NONE
            }
        }
        return {
            filter: ww.NONE
        }
    }

    function Pw(e) {
        for (const t of e.listParents())
            if (t instanceof Iy)
                for (const e of t.listParents())
                    if (e instanceof Ly) return e.getTargetPath();
        return null
    }
    const Dw = "EXT_meshopt_compression",
        Ow = {
            method: xw.QUANTIZE
        };
    class Lw extends tw {
        constructor(...e) {
            super(...e), this.extensionName = Dw, this.prereadTypes = [$x.BUFFER, $x.PRIMITIVE], this.prewriteTypes = [$x.BUFFER, $x.ACCESSOR], this.readDependencies = ["meshopt.decoder"], this.writeDependencies = ["meshopt.encoder"], this._decoder = null, this._decoderFallbackBufferMap = new Map, this._encoder = null, this._encoderOptions = Ow, this._encoderFallbackBuffer = null, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {}
        }
        install(e, t) {
            return "meshopt.decoder" === e && (this._decoder = t), "meshopt.encoder" === e && (this._encoder = t), this
        }
        setEncoderOptions(e) {
            return this._encoderOptions = bw({}, Ow, e), this
        }
        preread(e, t) {
            if (!this._decoder) {
                if (!this.isRequired()) return this;
                throw new Error(`[${Dw}] Please install extension dependency, "meshopt.decoder".`)
            }
            if (!this._decoder.supported) {
                if (!this.isRequired()) return this;
                throw new Error(`[${Dw}]: Missing WASM support.`)
            }
            return t === $x.BUFFER ? this._prereadBuffers(e) : t === $x.PRIMITIVE && this._prereadPrimitives(e), this
        }
        _prereadBuffers(e) {
            const t = e.jsonDoc;
            (t.json.bufferViews || []).forEach(((n, r) => {
                if (!n.extensions || !n.extensions[Dw]) return;
                const i = n.extensions[Dw],
                    s = i.byteOffset || 0,
                    o = i.byteLength || 0,
                    a = i.count,
                    l = i.byteStride,
                    c = new Uint8Array(a * l),
                    u = t.json.buffers[n.buffer],
                    p = cy.toView(u.uri ? t.resources[u.uri] : t.resources["@glb.bin"], s, o);
                this._decoder.decodeGltfBuffer(c, a, l, p, i.mode, i.filter), e.bufferViews[r] = c
            }))
        }
        _prereadPrimitives(e) {
            const t = e.jsonDoc;
            (t.json.bufferViews || []).forEach((n => {
                var r;
                n.extensions && n.extensions[Dw] && (r = t.json.buffers[n.buffer]).extensions && r.extensions.EXT_meshopt_compression && r.extensions.EXT_meshopt_compression.fallback && this._decoderFallbackBufferMap.set(e.buffers[n.buffer], e.buffers[n.extensions[Dw].buffer])
            }))
        }
        read(e) {
            if (!this.isRequired()) return this;
            for (const [e, t] of this._decoderFallbackBufferMap) {
                for (const n of e.listParents()) n instanceof Dy && n.swap(e, t);
                e.dispose()
            }
            return this
        }
        prewrite(e, t) {
            return t === $x.ACCESSOR ? this._prewriteAccessors(e) : t === $x.BUFFER && this._prewriteBuffers(e), this
        }
        _prewriteAccessors(e) {
            const t = e.jsonDoc.json,
                n = this._encoder,
                r = this._encoderOptions,
                i = this.document.createBuffer(),
                s = this.document.getRoot().listBuffers().indexOf(i);
            this._encoderFallbackBuffer = i, this._encoderBufferViews = {}, this._encoderBufferViewData = {}, this._encoderBufferViewAccessors = {};
            for (const i of this.document.getRoot().listAccessors()) {
                if ("weights" === Pw(i)) continue;
                const o = e.getAccessorUsage(i),
                    a = Rw(i, o),
                    l = r.method === xw.FILTER ? kw(i, this.document) : {
                        filter: ww.NONE
                    },
                    c = Cw(i, n, a, l),
                    {
                        array: u,
                        byteStride: p
                    } = c,
                    h = i.getBuffer();
                if (!h) throw new Error(`${Dw}: Missing buffer for accessor.`);
                const d = this.document.getRoot().listBuffers().indexOf(h),
                    f = [o, a, l.filter, p, d].join(":");
                let _ = this._encoderBufferViews[f],
                    m = this._encoderBufferViewData[f],
                    g = this._encoderBufferViewAccessors[f];
                _ && m || (g = this._encoderBufferViewAccessors[f] = [], m = this._encoderBufferViewData[f] = [], _ = this._encoderBufferViews[f] = {
                    buffer: s,
                    target: aw.USAGE_TO_TARGET[o],
                    byteOffset: 0,
                    byteLength: 0,
                    byteStride: o === aw.BufferViewUsage.ARRAY_BUFFER ? p : void 0,
                    extensions: {
                        [Dw]: {
                            buffer: d,
                            byteOffset: 0,
                            byteLength: 0,
                            mode: a,
                            filter: l.filter !== ww.NONE ? l.filter : void 0,
                            byteStride: p,
                            count: 0
                        }
                    }
                });
                const v = e.createAccessorDef(i);
                v.componentType = c.componentType, v.normalized = c.normalized, v.byteOffset = _.byteLength, v.min && c.min && (v.min = c.min), v.max && c.max && (v.max = c.max), e.accessorIndexMap.set(i, t.accessors.length), t.accessors.push(v), g.push(v), m.push(new Uint8Array(u.buffer, u.byteOffset, u.byteLength)), _.byteLength += u.byteLength, _.extensions.EXT_meshopt_compression.count += i.getCount()
            }
        }
        _prewriteBuffers(e) {
            const t = this._encoder;
            for (const n in this._encoderBufferViews) {
                const r = this._encoderBufferViews[n],
                    i = this._encoderBufferViewData[n],
                    s = this.document.getRoot().listBuffers()[r.extensions[Dw].buffer],
                    o = e.otherBufferViews.get(s) || [],
                    {
                        count: a,
                        byteStride: l,
                        mode: c
                    } = r.extensions[Dw],
                    u = cy.concat(i),
                    p = t.encodeGltfBuffer(u, a, l, c),
                    h = cy.pad(p);
                r.extensions[Dw].byteLength = p.byteLength, i.length = 0, i.push(h), o.push(h), e.otherBufferViews.set(s, o)
            }
        }
        write(e) {
            let t = 0;
            for (const n in this._encoderBufferViews) {
                const r = this._encoderBufferViews[n],
                    i = e.otherBufferViewsIndexMap.get(this._encoderBufferViewData[n][0]),
                    s = this._encoderBufferViewAccessors[n];
                for (const e of s) e.bufferView = i;
                const o = e.jsonDoc.json.bufferViews[i],
                    a = o.byteOffset || 0;
                Object.assign(o, r), o.byteOffset = t, o.extensions[Dw].byteOffset = a, t += cy.padNumber(r.byteLength)
            }
            const n = this._encoderFallbackBuffer,
                r = e.bufferIndexMap.get(n),
                i = e.jsonDoc.json.buffers[r];
            return i.byteLength = t, i.extensions = {
                [Dw]: {
                    fallback: !0
                }
            }, n.dispose(), this
        }
    }
    Lw.EXTENSION_NAME = Dw, Lw.EncoderMethod = xw;
    const Iw = "EXT_texture_webp";
    class Fw {
        match(e) {
            return e.length >= 12 && 87 === e[8] && 69 === e[9] && 66 === e[10] && 80 === e[11]
        }
        getSize(e) {
            const t = cy.decodeText(e.slice(0, 4)),
                n = cy.decodeText(e.slice(8, 12));
            if ("RIFF" !== t || "WEBP" !== n) return null;
            const r = new DataView(e.buffer, e.byteOffset);
            let i = 12;
            for (; i < r.byteLength;) {
                const e = cy.decodeText(new Uint8Array([r.getUint8(i), r.getUint8(i + 1), r.getUint8(i + 2), r.getUint8(i + 3)])),
                    t = r.getUint32(i + 4, !0);
                if ("VP8 " === e) return [16383 & r.getInt16(i + 14, !0), 16383 & r.getInt16(i + 16, !0)];
                if ("VP8L" === e) {
                    const e = r.getUint8(i + 9),
                        t = r.getUint8(i + 10),
                        n = r.getUint8(i + 11);
                    return [1 + ((63 & t) << 8 | e), 1 + ((15 & r.getUint8(i + 12)) << 10 | n << 2 | (192 & t) >> 6)]
                }
                i += 8 + t + t % 2
            }
            return null
        }
        getChannels(e) {
            return 4
        }
    }(class extends tw {
        constructor(...e) {
            super(...e), this.extensionName = Iw, this.prereadTypes = [$x.TEXTURE]
        }
        static register() {
            hy.registerFormat("image/webp", new Fw)
        }
        preread(e) {
            return (e.jsonDoc.json.textures || []).forEach((e => {
                e.extensions && e.extensions.EXT_texture_webp && (e.source = e.extensions.EXT_texture_webp.source)
            })), this
        }
        read(e) {
            return this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listTextures().forEach((n => {
                if ("image/webp" === n.getMimeType()) {
                    const r = e.imageIndexMap.get(n);
                    (t.json.textures || []).forEach((e => {
                        e.source === r && (e.extensions = e.extensions || {}, e.extensions.EXT_texture_webp = {
                            source: e.source
                        }, delete e.source)
                    }))
                }
            })), this
        }
    }).EXTENSION_NAME = Iw;
    const Nw = "KHR_draco_mesh_compression";
    let Uw, Bw, jw, zw;

    function Vw(e, t) {
        const n = new Uw.DecoderBuffer;
        try {
            if (n.Init(t, t.length), e.GetEncodedGeometryType(n) !== Uw.TRIANGULAR_MESH) throw new Error(`[${Nw}] Unknown geometry type.`);
            const r = new Uw.Mesh;
            if (!e.DecodeBufferToMesh(n, r).ok() || 0 === r.ptr) throw new Error(`[${Nw}] Decoding failure.`);
            return r
        } finally {
            Uw.destroy(n)
        }
    }

    function Gw(e, t) {
        const n = 3 * t.num_faces();
        let r, i;
        if (t.num_points() <= 65534) {
            const s = n * Uint16Array.BYTES_PER_ELEMENT;
            r = Uw._malloc(s), e.GetTrianglesUInt16Array(t, s, r), i = new Uint16Array(Uw.HEAPU16.buffer, r, n).slice()
        } else {
            const s = n * Uint32Array.BYTES_PER_ELEMENT;
            r = Uw._malloc(s), e.GetTrianglesUInt32Array(t, s, r), i = new Uint32Array(Uw.HEAPU32.buffer, r, n).slice()
        }
        return Uw._free(r), i
    }

    function Hw(e, t, n, r) {
        const i = jw[r.componentType],
            s = Bw[r.componentType],
            o = n.num_components(),
            a = t.num_points() * o,
            l = a * s.BYTES_PER_ELEMENT,
            c = Uw._malloc(l);
        e.GetAttributeDataArrayForAllPoints(t, n, i, l, c);
        const u = new s(Uw.HEAPF32.buffer, c, a).slice();
        return Uw._free(c), u
    }
    var Ww, Kw;
    ! function(e) {
        e[e.EDGEBREAKER = 1] = "EDGEBREAKER", e[e.SEQUENTIAL = 0] = "SEQUENTIAL"
    }(Ww || (Ww = {})),
    function(e) {
        e.POSITION = "POSITION", e.NORMAL = "NORMAL", e.COLOR = "COLOR", e.TEX_COORD = "TEX_COORD", e.GENERIC = "GENERIC"
    }(Kw || (Kw = {}));
    const Xw = {
            [Kw.POSITION]: 14,
            [Kw.NORMAL]: 10,
            [Kw.COLOR]: 8,
            [Kw.TEX_COORD]: 12,
            [Kw.GENERIC]: 12
        },
        qw = {
            decodeSpeed: 5,
            encodeSpeed: 5,
            method: Ww.EDGEBREAKER,
            quantizationBits: Xw,
            quantizationVolume: "mesh"
        };

    function Yw(e, t = qw) {
        const n = bw({}, qw, t);
        n.quantizationBits = bw({}, Xw, t.quantizationBits);
        const r = new zw.Encoder,
            i = new zw.MeshBuilder,
            s = new zw.Mesh,
            o = {},
            a = new zw.DracoInt8Array;
        for (const t of e.listSemantics()) {
            const a = e.getAttribute(t),
                l = Zw(t),
                c = Jw(i, a.getComponentType(), s, zw[l], a.getCount(), a.getElementSize(), a.getArray());
            if (-1 === c) throw new Error(`Error compressing "${t}" attribute.`);
            if (o[t] = c, "mesh" === n.quantizationVolume || "POSITION" !== t) r.SetAttributeQuantization(zw[l], n.quantizationBits[l]);
            else {
                if ("object" != typeof n.quantizationVolume) throw new Error("Invalid quantization volume state."); {
                    const {
                        quantizationVolume: e
                    } = n, t = Math.max(e.max[0] - e.min[0], e.max[1] - e.min[1], e.max[2] - e.min[2]);
                    r.SetAttributeExplicitQuantization(zw[l], n.quantizationBits[l], a.getElementSize(), e.min, t)
                }
            }
        }
        const l = e.getIndices();
        if (!l) throw new Error("Primitive must have indices.");
        i.AddFacesToMesh(s, l.getCount() / 3, l.getArray()), r.SetSpeedOptions(n.encodeSpeed, n.decodeSpeed), r.SetTrackEncodedProperties(!0), n.method === Ww.SEQUENTIAL || e.listTargets().length > 0 ? r.SetEncodingMethod(zw.MESH_SEQUENTIAL_ENCODING) : r.SetEncodingMethod(zw.MESH_EDGEBREAKER_ENCODING);
        const c = r.EncodeMeshToDracoBuffer(s, a);
        if (c <= 0) throw new Error("Error applying Draco compression.");
        const u = new Uint8Array(c);
        for (let e = 0; e < c; ++e) u[e] = a.GetValue(e);
        const p = e.getAttribute("POSITION").getCount(),
            h = r.GetNumberOfEncodedPoints(),
            d = 3 * r.GetNumberOfEncodedFaces();
        if (e.listTargets().length > 0 && h !== p) throw new Error('Compression reduced vertex count unexpectedly, corrupting morph targets. Applying the "weld" function before compression may resolve the issue.');
        return zw.destroy(a), zw.destroy(s), zw.destroy(i), zw.destroy(r), {
            numVertices: h,
            numIndices: d,
            data: u,
            attributeIDs: o
        }
    }

    function Zw(e) {
        return "POSITION" === e ? Kw.POSITION : "NORMAL" === e ? Kw.NORMAL : e.startsWith("COLOR_") ? Kw.COLOR : e.startsWith("TEXCOORD_") ? Kw.TEX_COORD : Kw.GENERIC
    }

    function Jw(e, t, n, r, i, s, o) {
        switch (t) {
            case Dy.ComponentType.UNSIGNED_BYTE:
                return e.AddUInt8Attribute(n, r, i, s, o);
            case Dy.ComponentType.BYTE:
                return e.AddInt8Attribute(n, r, i, s, o);
            case Dy.ComponentType.UNSIGNED_SHORT:
                return e.AddUInt16Attribute(n, r, i, s, o);
            case Dy.ComponentType.SHORT:
                return e.AddInt16Attribute(n, r, i, s, o);
            case Dy.ComponentType.UNSIGNED_INT:
                return e.AddUInt32Attribute(n, r, i, s, o);
            case Dy.ComponentType.FLOAT:
                return e.AddFloatAttribute(n, r, i, s, o);
            default:
                throw new Error(`Unexpected component type, "${t}".`)
        }
    }
    const $w = "KHR_draco_mesh_compression";
    class Qw extends tw {
        constructor(...e) {
            super(...e), this.extensionName = $w, this.prereadTypes = [$x.PRIMITIVE], this.prewriteTypes = [$x.ACCESSOR], this.readDependencies = ["draco3d.decoder"], this.writeDependencies = ["draco3d.encoder"], this._decoderModule = null, this._encoderModule = null, this._encoderOptions = {}
        }
        install(e, t) {
            return "draco3d.decoder" === e && (this._decoderModule = t, Uw = this._decoderModule, Bw = {
                [Dy.ComponentType.FLOAT]: Float32Array,
                [Dy.ComponentType.UNSIGNED_INT]: Uint32Array,
                [Dy.ComponentType.UNSIGNED_SHORT]: Uint16Array,
                [Dy.ComponentType.UNSIGNED_BYTE]: Uint8Array,
                [Dy.ComponentType.SHORT]: Int16Array,
                [Dy.ComponentType.BYTE]: Int8Array
            }, jw = {
                [Dy.ComponentType.FLOAT]: Uw.DT_FLOAT32,
                [Dy.ComponentType.UNSIGNED_INT]: Uw.DT_UINT32,
                [Dy.ComponentType.UNSIGNED_SHORT]: Uw.DT_UINT16,
                [Dy.ComponentType.UNSIGNED_BYTE]: Uw.DT_UINT8,
                [Dy.ComponentType.SHORT]: Uw.DT_INT16,
                [Dy.ComponentType.BYTE]: Uw.DT_INT8
            }), "draco3d.encoder" === e && (this._encoderModule = t, zw = this._encoderModule), this
        }
        setEncoderOptions(e) {
            return this._encoderOptions = e, this
        }
        preread(e) {
            if (!this._decoderModule) throw new Error(`[${$w}] Please install extension dependency, "draco3d.decoder".`);
            const t = this.document.getLogger(),
                n = e.jsonDoc,
                r = new Map;
            try {
                const i = n.json.meshes || [];
                for (const s of i)
                    for (const i of s.primitives) {
                        if (!i.extensions || !i.extensions[$w]) continue;
                        const s = i.extensions[$w];
                        let [o, a] = r.get(s.bufferView) || [];
                        if (!a || !o) {
                            const e = n.json.bufferViews[s.bufferView],
                                i = n.json.buffers[e.buffer],
                                l = cy.toView(i.uri ? n.resources[i.uri] : n.resources["@glb.bin"], e.byteOffset || 0, e.byteLength);
                            o = new this._decoderModule.Decoder, a = Vw(o, l), r.set(s.bufferView, [o, a]), t.debug(`[${$w}] Decompressed ${l.byteLength} bytes.`)
                        }
                        for (const t in i.attributes) {
                            const n = e.jsonDoc.json.accessors[i.attributes[t]],
                                r = o.GetAttributeByUniqueId(a, s.attributes[t]),
                                l = Hw(o, a, r, n);
                            e.accessors[i.attributes[t]].setArray(l)
                        }
                        void 0 !== i.indices && e.accessors[i.indices].setArray(Gw(o, a))
                    }
            } finally {
                for (const [e, t] of Array.from(r.values())) this._decoderModule.destroy(e), this._decoderModule.destroy(t)
            }
            return this
        }
        read(e) {
            return this
        }
        prewrite(e, t) {
            if (!this._encoderModule) throw new Error(`[${$w}] Please install extension dependency, "draco3d.encoder".`);
            const n = this.document.getLogger();
            n.debug(`[${$w}] Compression options: ${JSON.stringify(this._encoderOptions)}`);
            const r = function(e) {
                    const t = e.getLogger(),
                        n = new Set,
                        r = new Set;
                    for (const i of e.getRoot().listMeshes())
                        for (const e of i.listPrimitives()) e.getIndices() ? e.getMode() !== Xy.Mode.TRIANGLES ? (r.add(e), t.warn(`[${$w}] Skipping Draco compression on non-TRIANGLES primitive.`)) : n.add(e) : (r.add(e), t.warn(`[${$w}] Skipping Draco compression on non-indexed primitive.`));
                    const i = e.getRoot().listAccessors(),
                        s = new Map;
                    for (let e = 0; e < i.length; e++) s.set(i[e], e);
                    const o = new Map,
                        a = new Set,
                        l = new Map;
                    for (const t of Array.from(n)) {
                        let n = eS(t, s);
                        if (a.has(n)) l.set(t, n);
                        else {
                            if (o.has(t.getIndices())) {
                                const n = t.getIndices(),
                                    r = n.clone();
                                s.set(r, e.getRoot().listAccessors().length - 1), t.swap(n, r)
                            }
                            for (const n of t.listAttributes())
                                if (o.has(n)) {
                                    const r = n.clone();
                                    s.set(r, e.getRoot().listAccessors().length - 1), t.swap(n, r)
                                }
                            n = eS(t, s), a.add(n), l.set(t, n), o.set(t.getIndices(), n);
                            for (const e of t.listAttributes()) o.set(e, n)
                        }
                    }
                    for (const e of Array.from(o.keys())) {
                        const t = new Set(e.listParents().map((e => e.propertyType)));
                        if (2 !== t.size || !t.has($x.PRIMITIVE) || !t.has($x.ROOT)) throw new Error(`[${$w}] Compressed accessors must only be used as indices or vertex attributes.`)
                    }
                    for (const e of Array.from(n)) {
                        const t = l.get(e),
                            n = e.getIndices();
                        if (o.get(n) !== t || e.listAttributes().some((e => o.get(e) !== t))) throw new Error(`[${$w}] Draco primitives must share all, or no, accessors.`)
                    }
                    for (const e of Array.from(r)) {
                        const t = e.getIndices();
                        if (o.has(t) || e.listAttributes().some((e => o.has(e)))) throw new Error(`[${$w}] Accessor cannot be shared by compressed and uncompressed primitives.`)
                    }
                    return l
                }(this.document),
                i = new Map;
            let s = "mesh";
            "scene" === this._encoderOptions.quantizationVolume && (1 !== this.document.getRoot().listScenes().length ? n.warn(`[${$w}]: quantizationVolume=scene requires exactly 1 scene.`) : s = function(e) {
                const t = {
                        min: [1 / 0, 1 / 0, 1 / 0],
                        max: [-1 / 0, -1 / 0, -1 / 0]
                    },
                    n = e.propertyType === $x.NODE ? [e] : e.listChildren();
                for (const e of n) e.traverse((e => {
                    const n = e.getMesh();
                    if (!n) return;
                    const r = ay(n, e.getWorldMatrix());
                    ly(r.min, t), ly(r.max, t)
                }));
                return t
            }(this.document.getRoot().listScenes().pop()));
            for (const t of Array.from(r.keys())) {
                const n = r.get(t);
                if (!n) throw new Error("Unexpected primitive.");
                if (i.has(n)) {
                    i.set(n, i.get(n));
                    continue
                }
                const o = t.getIndices(),
                    a = e.jsonDoc.json.accessors,
                    l = Yw(t, bw({}, this._encoderOptions, {
                        quantizationVolume: s
                    }));
                i.set(n, l);
                const c = e.createAccessorDef(o);
                c.count = l.numIndices, e.accessorIndexMap.set(o, a.length), a.push(c);
                for (const n of t.listSemantics()) {
                    const r = t.getAttribute(n),
                        i = e.createAccessorDef(r);
                    i.count = l.numVertices, e.accessorIndexMap.set(r, a.length), a.push(i)
                }
                const u = t.getAttribute("POSITION").getBuffer() || this.document.getRoot().listBuffers()[0];
                e.otherBufferViews.has(u) || e.otherBufferViews.set(u, []), e.otherBufferViews.get(u).push(l.data)
            }
            return n.debug(`[${$w}] Compressed ${r.size} primitives.`), e.extensionData[$w] = {
                primitiveHashMap: r,
                primitiveEncodingMap: i
            }, this
        }
        write(e) {
            const t = e.extensionData[$w];
            for (const n of this.document.getRoot().listMeshes()) {
                const r = e.jsonDoc.json.meshes[e.meshIndexMap.get(n)];
                for (let i = 0; i < n.listPrimitives().length; i++) {
                    const s = n.listPrimitives()[i],
                        o = r.primitives[i],
                        a = t.primitiveHashMap.get(s);
                    if (!a) continue;
                    const l = t.primitiveEncodingMap.get(a);
                    o.extensions = o.extensions || {}, o.extensions[$w] = {
                        bufferView: e.otherBufferViewsIndexMap.get(l.data),
                        attributes: l.attributeIDs
                    }
                }
            }
            if (!t.primitiveHashMap.size) {
                const t = e.jsonDoc.json;
                t.extensionsUsed = (t.extensionsUsed || []).filter((e => e !== $w)), t.extensionsRequired = (t.extensionsRequired || []).filter((e => e !== $w))
            }
            return this
        }
    }

    function eS(e, t) {
        const n = [],
            r = e.getIndices();
        n.push(t.get(r));
        for (const r of e.listAttributes()) n.push(t.get(r));
        return n.sort().join("|")
    }
    Qw.EXTENSION_NAME = $w, Qw.EncoderMethod = Ww;
    class tS extends Uy {
        init() {
            this.extensionName = "KHR_lights_punctual", this.propertyType = "Light", this.parentTypes = [$x.NODE]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                color: [1, 1, 1],
                intensity: 1,
                type: tS.Type.POINT,
                range: null,
                innerConeAngle: 0,
                outerConeAngle: Math.PI / 4
            })
        }
        getColor() {
            return this.get("color")
        }
        setColor(e) {
            return this.set("color", e)
        }
        getColorHex() {
            return uy.factorToHex(this.getColor())
        }
        setColorHex(e) {
            const t = this.getColor().slice();
            return uy.hexToFactor(e, t), this.setColor(t)
        }
        getIntensity() {
            return this.get("intensity")
        }
        setIntensity(e) {
            return this.set("intensity", e)
        }
        getType() {
            return this.get("type")
        }
        setType(e) {
            return this.set("type", e)
        }
        getRange() {
            return this.get("range")
        }
        setRange(e) {
            return this.set("range", e)
        }
        getInnerConeAngle() {
            return this.get("innerConeAngle")
        }
        setInnerConeAngle(e) {
            return this.set("innerConeAngle", e)
        }
        getOuterConeAngle() {
            return this.get("outerConeAngle")
        }
        setOuterConeAngle(e) {
            return this.set("outerConeAngle", e)
        }
    }
    tS.EXTENSION_NAME = "KHR_lights_punctual", tS.Type = {
        POINT: "point",
        SPOT: "spot",
        DIRECTIONAL: "directional"
    };
    const nS = "KHR_lights_punctual";
    class rS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = nS
        }
        createLight(e = "") {
            return new tS(this.document.getGraph(), e)
        }
        read(e) {
            const t = e.jsonDoc;
            if (!t.json.extensions || !t.json.extensions.KHR_lights_punctual) return this;
            const n = (t.json.extensions.KHR_lights_punctual.lights || []).map((e => {
                var t, n;
                const r = this.createLight().setName(e.name || "").setType(e.type);
                return void 0 !== e.color && r.setColor(e.color), void 0 !== e.intensity && r.setIntensity(e.intensity), void 0 !== e.range && r.setRange(e.range), void 0 !== (null == (t = e.spot) ? void 0 : t.innerConeAngle) && r.setInnerConeAngle(e.spot.innerConeAngle), void 0 !== (null == (n = e.spot) ? void 0 : n.outerConeAngle) && r.setOuterConeAngle(e.spot.outerConeAngle), r
            }));
            return t.json.nodes.forEach(((t, r) => {
                t.extensions && t.extensions.KHR_lights_punctual && e.nodes[r].setExtension(nS, n[t.extensions.KHR_lights_punctual.light])
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            if (0 === this.properties.size) return this;
            const n = [],
                r = new Map;
            for (const e of this.properties) {
                const t = e,
                    i = {
                        type: t.getType()
                    };
                vy.eq(t.getColor(), [1, 1, 1]) || (i.color = t.getColor()), 1 !== t.getIntensity() && (i.intensity = t.getIntensity()), null != t.getRange() && (i.range = t.getRange()), t.getName() && (i.name = t.getName()), t.getType() === tS.Type.SPOT && (i.spot = {
                    innerConeAngle: t.getInnerConeAngle(),
                    outerConeAngle: t.getOuterConeAngle()
                }), n.push(i), r.set(t, n.length - 1)
            }
            return this.document.getRoot().listNodes().forEach((n => {
                const i = n.getExtension(nS);
                if (i) {
                    const s = e.nodeIndexMap.get(n),
                        o = t.json.nodes[s];
                    o.extensions = o.extensions || {}, o.extensions.KHR_lights_punctual = {
                        light: r.get(i)
                    }
                }
            })), t.json.extensions = t.json.extensions || {}, t.json.extensions.KHR_lights_punctual = {
                lights: n
            }, this
        }
    }
    rS.EXTENSION_NAME = nS;
    const {
        R: iS,
        G: sS,
        B: oS
    } = ty;
    class aS extends Uy {
        init() {
            this.extensionName = "KHR_materials_clearcoat", this.propertyType = "Clearcoat", this.parentTypes = [$x.MATERIAL]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                clearcoatFactor: 0,
                clearcoatTexture: null,
                clearcoatTextureInfo: new By(this.graph, "clearcoatTextureInfo"),
                clearcoatRoughnessFactor: 0,
                clearcoatRoughnessTexture: null,
                clearcoatRoughnessTextureInfo: new By(this.graph, "clearcoatRoughnessTextureInfo"),
                clearcoatNormalScale: 1,
                clearcoatNormalTexture: null,
                clearcoatNormalTextureInfo: new By(this.graph, "clearcoatNormalTextureInfo")
            })
        }
        getClearcoatFactor() {
            return this.get("clearcoatFactor")
        }
        setClearcoatFactor(e) {
            return this.set("clearcoatFactor", e)
        }
        getClearcoatTexture() {
            return this.getRef("clearcoatTexture")
        }
        getClearcoatTextureInfo() {
            return this.getRef("clearcoatTexture") ? this.getRef("clearcoatTextureInfo") : null
        }
        setClearcoatTexture(e) {
            return this.setRef("clearcoatTexture", e, {
                channels: iS
            })
        }
        getClearcoatRoughnessFactor() {
            return this.get("clearcoatRoughnessFactor")
        }
        setClearcoatRoughnessFactor(e) {
            return this.set("clearcoatRoughnessFactor", e)
        }
        getClearcoatRoughnessTexture() {
            return this.getRef("clearcoatRoughnessTexture")
        }
        getClearcoatRoughnessTextureInfo() {
            return this.getRef("clearcoatRoughnessTexture") ? this.getRef("clearcoatRoughnessTextureInfo") : null
        }
        setClearcoatRoughnessTexture(e) {
            return this.setRef("clearcoatRoughnessTexture", e, {
                channels: sS
            })
        }
        getClearcoatNormalScale() {
            return this.get("clearcoatNormalScale")
        }
        setClearcoatNormalScale(e) {
            return this.set("clearcoatNormalScale", e)
        }
        getClearcoatNormalTexture() {
            return this.getRef("clearcoatNormalTexture")
        }
        getClearcoatNormalTextureInfo() {
            return this.getRef("clearcoatNormalTexture") ? this.getRef("clearcoatNormalTextureInfo") : null
        }
        setClearcoatNormalTexture(e) {
            return this.setRef("clearcoatNormalTexture", e, {
                channels: iS | sS | oS
            })
        }
    }
    aS.EXTENSION_NAME = "KHR_materials_clearcoat";
    const lS = "KHR_materials_clearcoat";
    class cS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = lS
        }
        createClearcoat() {
            return new aS(this.document.getGraph())
        }
        read(e) {
            const t = e.jsonDoc,
                n = t.json.textures || [];
            return (t.json.materials || []).forEach(((t, r) => {
                if (t.extensions && t.extensions[lS]) {
                    const i = this.createClearcoat();
                    e.materials[r].setExtension(lS, i);
                    const s = t.extensions[lS];
                    if (void 0 !== s.clearcoatFactor && i.setClearcoatFactor(s.clearcoatFactor), void 0 !== s.clearcoatRoughnessFactor && i.setClearcoatRoughnessFactor(s.clearcoatRoughnessFactor), void 0 !== s.clearcoatTexture) {
                        const t = s.clearcoatTexture;
                        i.setClearcoatTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getClearcoatTextureInfo(), t)
                    }
                    if (void 0 !== s.clearcoatRoughnessTexture) {
                        const t = s.clearcoatRoughnessTexture;
                        i.setClearcoatRoughnessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getClearcoatRoughnessTextureInfo(), t)
                    }
                    if (void 0 !== s.clearcoatNormalTexture) {
                        const t = s.clearcoatNormalTexture;
                        i.setClearcoatNormalTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getClearcoatNormalTextureInfo(), t), void 0 !== t.scale && i.setClearcoatNormalScale(t.scale)
                    }
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(lS);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {};
                    const o = s.extensions[lS] = {
                        clearcoatFactor: r.getClearcoatFactor(),
                        clearcoatRoughnessFactor: r.getClearcoatRoughnessFactor()
                    };
                    if (r.getClearcoatTexture()) {
                        const t = r.getClearcoatTexture(),
                            n = r.getClearcoatTextureInfo();
                        o.clearcoatTexture = e.createTextureInfoDef(t, n)
                    }
                    if (r.getClearcoatRoughnessTexture()) {
                        const t = r.getClearcoatRoughnessTexture(),
                            n = r.getClearcoatRoughnessTextureInfo();
                        o.clearcoatRoughnessTexture = e.createTextureInfoDef(t, n)
                    }
                    if (r.getClearcoatNormalTexture()) {
                        const t = r.getClearcoatNormalTexture(),
                            n = r.getClearcoatNormalTextureInfo();
                        o.clearcoatNormalTexture = e.createTextureInfoDef(t, n), 1 !== r.getClearcoatNormalScale() && (o.clearcoatNormalTexture.scale = r.getClearcoatNormalScale())
                    }
                }
            })), this
        }
    }
    cS.EXTENSION_NAME = lS;
    class uS extends Uy {
        init() {
            this.extensionName = "KHR_materials_emissive_strength", this.propertyType = "EmissiveStrength", this.parentTypes = [$x.MATERIAL]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                emissiveStrength: 1
            })
        }
        getEmissiveStrength() {
            return this.get("emissiveStrength")
        }
        setEmissiveStrength(e) {
            return this.set("emissiveStrength", e)
        }
    }
    uS.EXTENSION_NAME = "KHR_materials_emissive_strength";
    const pS = "KHR_materials_emissive_strength";
    class hS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = pS
        }
        createEmissiveStrength() {
            return new uS(this.document.getGraph())
        }
        read(e) {
            return (e.jsonDoc.json.materials || []).forEach(((t, n) => {
                if (t.extensions && t.extensions[pS]) {
                    const r = this.createEmissiveStrength();
                    e.materials[n].setExtension(pS, r);
                    const i = t.extensions[pS];
                    void 0 !== i.emissiveStrength && r.setEmissiveStrength(i.emissiveStrength)
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(pS);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {}, s.extensions[pS] = {
                        emissiveStrength: r.getEmissiveStrength()
                    }
                }
            })), this
        }
    }
    hS.EXTENSION_NAME = pS;
    class dS extends Uy {
        init() {
            this.extensionName = "KHR_materials_ior", this.propertyType = "IOR", this.parentTypes = [$x.MATERIAL]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                ior: 0
            })
        }
        getIOR() {
            return this.get("ior")
        }
        setIOR(e) {
            return this.set("ior", e)
        }
    }
    dS.EXTENSION_NAME = "KHR_materials_ior";
    const fS = "KHR_materials_ior";
    class _S extends tw {
        constructor(...e) {
            super(...e), this.extensionName = fS
        }
        createIOR() {
            return new dS(this.document.getGraph())
        }
        read(e) {
            return (e.jsonDoc.json.materials || []).forEach(((t, n) => {
                if (t.extensions && t.extensions.KHR_materials_ior) {
                    const r = this.createIOR();
                    e.materials[n].setExtension(fS, r);
                    const i = t.extensions.KHR_materials_ior;
                    void 0 !== i.ior && r.setIOR(i.ior)
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(fS);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {}, s.extensions.KHR_materials_ior = {
                        ior: r.getIOR()
                    }
                }
            })), this
        }
    }
    _S.EXTENSION_NAME = fS;
    const {
        R: mS,
        G: gS
    } = ty;
    class vS extends Uy {
        init() {
            this.extensionName = "KHR_materials_iridescence", this.propertyType = "Iridescence", this.parentTypes = [$x.MATERIAL]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                iridescenceFactor: 0,
                iridescenceTexture: null,
                iridescenceTextureInfo: new By(this.graph, "iridescenceTextureInfo"),
                iridescenceIOR: 1.3,
                iridescenceThicknessMinimum: 100,
                iridescenceThicknessMaximum: 400,
                iridescenceThicknessTexture: null,
                iridescenceThicknessTextureInfo: new By(this.graph, "iridescenceThicknessTextureInfo")
            })
        }
        getIridescenceFactor() {
            return this.get("iridescenceFactor")
        }
        setIridescenceFactor(e) {
            return this.set("iridescenceFactor", e)
        }
        getIridescenceTexture() {
            return this.getRef("iridescenceTexture")
        }
        getIridescenceTextureInfo() {
            return this.getRef("iridescenceTexture") ? this.getRef("iridescenceTextureInfo") : null
        }
        setIridescenceTexture(e) {
            return this.setRef("iridescenceTexture", e, {
                channels: mS
            })
        }
        getIridescenceIOR() {
            return this.get("iridescenceIOR")
        }
        setIridescenceIOR(e) {
            return this.set("iridescenceIOR", e)
        }
        getIridescenceThicknessMinimum() {
            return this.get("iridescenceThicknessMinimum")
        }
        setIridescenceThicknessMinimum(e) {
            return this.set("iridescenceThicknessMinimum", e)
        }
        getIridescenceThicknessMaximum() {
            return this.get("iridescenceThicknessMaximum")
        }
        setIridescenceThicknessMaximum(e) {
            return this.set("iridescenceThicknessMaximum", e)
        }
        getIridescenceThicknessTexture() {
            return this.getRef("iridescenceThicknessTexture")
        }
        getIridescenceThicknessTextureInfo() {
            return this.getRef("iridescenceThicknessTexture") ? this.getRef("iridescenceThicknessTextureInfo") : null
        }
        setIridescenceThicknessTexture(e) {
            return this.setRef("iridescenceThicknessTexture", e, {
                channels: gS
            })
        }
    }
    vS.EXTENSION_NAME = "KHR_materials_iridescence";
    const bS = "KHR_materials_iridescence";
    class xS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = bS
        }
        createIridescence() {
            return new vS(this.document.getGraph())
        }
        read(e) {
            const t = e.jsonDoc,
                n = t.json.textures || [];
            return (t.json.materials || []).forEach(((t, r) => {
                if (t.extensions && t.extensions[bS]) {
                    const i = this.createIridescence();
                    e.materials[r].setExtension(bS, i);
                    const s = t.extensions[bS];
                    if (void 0 !== s.iridescenceFactor && i.setIridescenceFactor(s.iridescenceFactor), void 0 !== s.iridescenceIor && i.setIridescenceIOR(s.iridescenceIor), void 0 !== s.iridescenceThicknessMinimum && i.setIridescenceThicknessMinimum(s.iridescenceThicknessMinimum), void 0 !== s.iridescenceThicknessMaximum && i.setIridescenceThicknessMaximum(s.iridescenceThicknessMaximum), void 0 !== s.iridescenceTexture) {
                        const t = s.iridescenceTexture;
                        i.setIridescenceTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getIridescenceTextureInfo(), t)
                    }
                    if (void 0 !== s.iridescenceThicknessTexture) {
                        const t = s.iridescenceThicknessTexture;
                        i.setIridescenceThicknessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getIridescenceThicknessTextureInfo(), t)
                    }
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(bS);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {};
                    const o = s.extensions[bS] = {};
                    if (r.getIridescenceFactor() > 0 && (o.iridescenceFactor = r.getIridescenceFactor()), 1.3 !== r.getIridescenceIOR() && (o.iridescenceIor = r.getIridescenceIOR()), 100 !== r.getIridescenceThicknessMinimum() && (o.iridescenceThicknessMinimum = r.getIridescenceThicknessMinimum()), 400 !== r.getIridescenceThicknessMaximum() && (o.iridescenceThicknessMaximum = r.getIridescenceThicknessMaximum()), r.getIridescenceTexture()) {
                        const t = r.getIridescenceTexture(),
                            n = r.getIridescenceTextureInfo();
                        o.iridescenceTexture = e.createTextureInfoDef(t, n)
                    }
                    if (r.getIridescenceThicknessTexture()) {
                        const t = r.getIridescenceThicknessTexture(),
                            n = r.getIridescenceThicknessTextureInfo();
                        o.iridescenceThicknessTexture = e.createTextureInfoDef(t, n)
                    }
                }
            })), this
        }
    }
    xS.EXTENSION_NAME = bS;
    const {
        R: yS,
        G: wS,
        B: SS,
        A: MS
    } = ty;
    class TS extends Uy {
        init() {
            this.extensionName = "KHR_materials_pbrSpecularGlossiness", this.propertyType = "PBRSpecularGlossiness", this.parentTypes = [$x.MATERIAL]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                diffuseFactor: [1, 1, 1, 1],
                diffuseTexture: null,
                diffuseTextureInfo: new By(this.graph, "diffuseTextureInfo"),
                specularFactor: [1, 1, 1],
                glossinessFactor: 1,
                specularGlossinessTexture: null,
                specularGlossinessTextureInfo: new By(this.graph, "specularGlossinessTextureInfo")
            })
        }
        getDiffuseFactor() {
            return this.get("diffuseFactor")
        }
        setDiffuseFactor(e) {
            return this.set("diffuseFactor", e)
        }
        getDiffuseHex() {
            return uy.factorToHex(this.getDiffuseFactor())
        }
        setDiffuseHex(e) {
            const t = this.getDiffuseFactor().slice();
            return this.setDiffuseFactor(uy.hexToFactor(e, t))
        }
        getDiffuseTexture() {
            return this.getRef("diffuseTexture")
        }
        getDiffuseTextureInfo() {
            return this.getRef("diffuseTexture") ? this.getRef("diffuseTextureInfo") : null
        }
        setDiffuseTexture(e) {
            return this.setRef("diffuseTexture", e, {
                channels: yS | wS | SS | MS
            })
        }
        getSpecularFactor() {
            return this.get("specularFactor")
        }
        setSpecularFactor(e) {
            return this.set("specularFactor", e)
        }
        getGlossinessFactor() {
            return this.get("glossinessFactor")
        }
        setGlossinessFactor(e) {
            return this.set("glossinessFactor", e)
        }
        getSpecularGlossinessTexture() {
            return this.getRef("specularGlossinessTexture")
        }
        getSpecularGlossinessTextureInfo() {
            return this.getRef("specularGlossinessTexture") ? this.getRef("specularGlossinessTextureInfo") : null
        }
        setSpecularGlossinessTexture(e) {
            return this.setRef("specularGlossinessTexture", e, {
                channels: yS | wS | SS | MS
            })
        }
    }
    TS.EXTENSION_NAME = "KHR_materials_pbrSpecularGlossiness";
    const ES = "KHR_materials_pbrSpecularGlossiness";
    class AS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = ES
        }
        createPBRSpecularGlossiness() {
            return new TS(this.document.getGraph())
        }
        read(e) {
            const t = e.jsonDoc,
                n = t.json.textures || [];
            return (t.json.materials || []).forEach(((t, r) => {
                if (t.extensions && t.extensions[ES]) {
                    const i = this.createPBRSpecularGlossiness();
                    e.materials[r].setExtension(ES, i);
                    const s = t.extensions[ES];
                    if (void 0 !== s.diffuseFactor && i.setDiffuseFactor(s.diffuseFactor), void 0 !== s.specularFactor && i.setSpecularFactor(s.specularFactor), void 0 !== s.glossinessFactor && i.setGlossinessFactor(s.glossinessFactor), void 0 !== s.diffuseTexture) {
                        const t = s.diffuseTexture;
                        i.setDiffuseTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getDiffuseTextureInfo(), t)
                    }
                    if (void 0 !== s.specularGlossinessTexture) {
                        const t = s.specularGlossinessTexture;
                        i.setSpecularGlossinessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSpecularGlossinessTextureInfo(), t)
                    }
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(ES);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {};
                    const o = s.extensions[ES] = {
                        diffuseFactor: r.getDiffuseFactor(),
                        specularFactor: r.getSpecularFactor(),
                        glossinessFactor: r.getGlossinessFactor()
                    };
                    if (r.getDiffuseTexture()) {
                        const t = r.getDiffuseTexture(),
                            n = r.getDiffuseTextureInfo();
                        o.diffuseTexture = e.createTextureInfoDef(t, n)
                    }
                    if (r.getSpecularGlossinessTexture()) {
                        const t = r.getSpecularGlossinessTexture(),
                            n = r.getSpecularGlossinessTextureInfo();
                        o.specularGlossinessTexture = e.createTextureInfoDef(t, n)
                    }
                }
            })), this
        }
    }
    AS.EXTENSION_NAME = ES;
    const {
        R: CS,
        G: RS,
        B: kS,
        A: PS
    } = ty;
    class DS extends Uy {
        init() {
            this.extensionName = "KHR_materials_sheen", this.propertyType = "Sheen", this.parentTypes = [$x.MATERIAL]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                sheenColorFactor: [0, 0, 0],
                sheenColorTexture: null,
                sheenColorTextureInfo: new By(this.graph, "sheenColorTextureInfo"),
                sheenRoughnessFactor: 0,
                sheenRoughnessTexture: null,
                sheenRoughnessTextureInfo: new By(this.graph, "sheenRoughnessTextureInfo")
            })
        }
        getSheenColorFactor() {
            return this.get("sheenColorFactor")
        }
        getSheenColorHex() {
            return uy.factorToHex(this.getSheenColorFactor())
        }
        setSheenColorFactor(e) {
            return this.set("sheenColorFactor", e)
        }
        setSheenColorHex(e) {
            const t = this.getSheenColorFactor().slice();
            return this.set("sheenColorFactor", uy.hexToFactor(e, t))
        }
        getSheenColorTexture() {
            return this.getRef("sheenColorTexture")
        }
        getSheenColorTextureInfo() {
            return this.getRef("sheenColorTexture") ? this.getRef("sheenColorTextureInfo") : null
        }
        setSheenColorTexture(e) {
            return this.setRef("sheenColorTexture", e, {
                channels: CS | RS | kS
            })
        }
        getSheenRoughnessFactor() {
            return this.get("sheenRoughnessFactor")
        }
        setSheenRoughnessFactor(e) {
            return this.set("sheenRoughnessFactor", e)
        }
        getSheenRoughnessTexture() {
            return this.getRef("sheenRoughnessTexture")
        }
        getSheenRoughnessTextureInfo() {
            return this.getRef("sheenRoughnessTexture") ? this.getRef("sheenRoughnessTextureInfo") : null
        }
        setSheenRoughnessTexture(e) {
            return this.setRef("sheenRoughnessTexture", e, {
                channels: PS
            })
        }
    }
    DS.EXTENSION_NAME = "KHR_materials_sheen";
    const OS = "KHR_materials_sheen";
    class LS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = OS
        }
        createSheen() {
            return new DS(this.document.getGraph())
        }
        read(e) {
            const t = e.jsonDoc,
                n = t.json.textures || [];
            return (t.json.materials || []).forEach(((t, r) => {
                if (t.extensions && t.extensions.KHR_materials_sheen) {
                    const i = this.createSheen();
                    e.materials[r].setExtension(OS, i);
                    const s = t.extensions.KHR_materials_sheen;
                    if (void 0 !== s.sheenColorFactor && i.setSheenColorFactor(s.sheenColorFactor), void 0 !== s.sheenRoughnessFactor && i.setSheenRoughnessFactor(s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture) {
                        const t = s.sheenColorTexture;
                        i.setSheenColorTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSheenColorTextureInfo(), t)
                    }
                    if (void 0 !== s.sheenRoughnessTexture) {
                        const t = s.sheenRoughnessTexture;
                        i.setSheenRoughnessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSheenRoughnessTextureInfo(), t)
                    }
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(OS);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {};
                    const o = s.extensions.KHR_materials_sheen = {
                        sheenColorFactor: r.getSheenColorFactor(),
                        sheenRoughnessFactor: r.getSheenRoughnessFactor()
                    };
                    if (r.getSheenColorTexture()) {
                        const t = r.getSheenColorTexture(),
                            n = r.getSheenColorTextureInfo();
                        o.sheenColorTexture = e.createTextureInfoDef(t, n)
                    }
                    if (r.getSheenRoughnessTexture()) {
                        const t = r.getSheenRoughnessTexture(),
                            n = r.getSheenRoughnessTextureInfo();
                        o.sheenRoughnessTexture = e.createTextureInfoDef(t, n)
                    }
                }
            })), this
        }
    }
    LS.EXTENSION_NAME = OS;
    const {
        R: IS,
        G: FS,
        B: NS,
        A: US
    } = ty;
    class BS extends Uy {
        init() {
            this.extensionName = "KHR_materials_specular", this.propertyType = "Specular", this.parentTypes = [$x.MATERIAL]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                specularFactor: 1,
                specularTexture: null,
                specularTextureInfo: new By(this.graph, "specularTextureInfo"),
                specularColorFactor: [1, 1, 1],
                specularColorTexture: null,
                specularColorTextureInfo: new By(this.graph, "specularColorTextureInfo")
            })
        }
        getSpecularFactor() {
            return this.get("specularFactor")
        }
        setSpecularFactor(e) {
            return this.set("specularFactor", e)
        }
        getSpecularColorFactor() {
            return this.get("specularColorFactor")
        }
        setSpecularColorFactor(e) {
            return this.set("specularColorFactor", e)
        }
        getSpecularColorHex() {
            return uy.factorToHex(this.getSpecularColorFactor())
        }
        setSpecularColorHex(e) {
            const t = this.getSpecularColorFactor().slice();
            return this.set("specularColorFactor", uy.hexToFactor(e, t))
        }
        getSpecularTexture() {
            return this.getRef("specularTexture")
        }
        getSpecularTextureInfo() {
            return this.getRef("specularTexture") ? this.getRef("specularTextureInfo") : null
        }
        setSpecularTexture(e) {
            return this.setRef("specularTexture", e, {
                channels: US
            })
        }
        getSpecularColorTexture() {
            return this.getRef("specularColorTexture")
        }
        getSpecularColorTextureInfo() {
            return this.getRef("specularColorTexture") ? this.getRef("specularColorTextureInfo") : null
        }
        setSpecularColorTexture(e) {
            return this.setRef("specularColorTexture", e, {
                channels: IS | FS | NS
            })
        }
    }
    BS.EXTENSION_NAME = "KHR_materials_specular";
    const jS = "KHR_materials_specular";
    class zS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = jS
        }
        createSpecular() {
            return new BS(this.document.getGraph())
        }
        read(e) {
            const t = e.jsonDoc,
                n = t.json.textures || [];
            return (t.json.materials || []).forEach(((t, r) => {
                if (t.extensions && t.extensions[jS]) {
                    const i = this.createSpecular();
                    e.materials[r].setExtension(jS, i);
                    const s = t.extensions[jS];
                    if (void 0 !== s.specularFactor && i.setSpecularFactor(s.specularFactor), void 0 !== s.specularColorFactor && i.setSpecularColorFactor(s.specularColorFactor), void 0 !== s.specularTexture) {
                        const t = s.specularTexture;
                        i.setSpecularTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSpecularTextureInfo(), t)
                    }
                    if (void 0 !== s.specularColorTexture) {
                        const t = s.specularColorTexture;
                        i.setSpecularColorTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getSpecularColorTextureInfo(), t)
                    }
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(jS);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {};
                    const o = s.extensions[jS] = {};
                    if (1 !== r.getSpecularFactor() && (o.specularFactor = r.getSpecularFactor()), vy.eq(r.getSpecularColorFactor(), [1, 1, 1]) || (o.specularColorFactor = r.getSpecularColorFactor()), r.getSpecularTexture()) {
                        const t = r.getSpecularTexture(),
                            n = r.getSpecularTextureInfo();
                        o.specularTexture = e.createTextureInfoDef(t, n)
                    }
                    if (r.getSpecularColorTexture()) {
                        const t = r.getSpecularColorTexture(),
                            n = r.getSpecularColorTextureInfo();
                        o.specularColorTexture = e.createTextureInfoDef(t, n)
                    }
                }
            })), this
        }
    }
    zS.EXTENSION_NAME = jS;
    const {
        R: VS
    } = ty;
    class GS extends Uy {
        init() {
            this.extensionName = "KHR_materials_transmission", this.propertyType = "Transmission", this.parentTypes = [$x.MATERIAL]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                transmissionFactor: 0,
                transmissionTexture: null,
                transmissionTextureInfo: new By(this.graph, "transmissionTextureInfo")
            })
        }
        getTransmissionFactor() {
            return this.get("transmissionFactor")
        }
        setTransmissionFactor(e) {
            return this.set("transmissionFactor", e)
        }
        getTransmissionTexture() {
            return this.getRef("transmissionTexture")
        }
        getTransmissionTextureInfo() {
            return this.getRef("transmissionTexture") ? this.getRef("transmissionTextureInfo") : null
        }
        setTransmissionTexture(e) {
            return this.setRef("transmissionTexture", e, {
                channels: VS
            })
        }
    }
    GS.EXTENSION_NAME = "KHR_materials_transmission";
    const HS = "KHR_materials_transmission";
    class WS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = HS
        }
        createTransmission() {
            return new GS(this.document.getGraph())
        }
        read(e) {
            const t = e.jsonDoc,
                n = t.json.textures || [];
            return (t.json.materials || []).forEach(((t, r) => {
                if (t.extensions && t.extensions[HS]) {
                    const i = this.createTransmission();
                    e.materials[r].setExtension(HS, i);
                    const s = t.extensions[HS];
                    if (void 0 !== s.transmissionFactor && i.setTransmissionFactor(s.transmissionFactor), void 0 !== s.transmissionTexture) {
                        const t = s.transmissionTexture;
                        i.setTransmissionTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getTransmissionTextureInfo(), t)
                    }
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(HS);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {};
                    const o = s.extensions[HS] = {
                        transmissionFactor: r.getTransmissionFactor()
                    };
                    if (r.getTransmissionTexture()) {
                        const t = r.getTransmissionTexture(),
                            n = r.getTransmissionTextureInfo();
                        o.transmissionTexture = e.createTextureInfoDef(t, n)
                    }
                }
            })), this
        }
    }
    WS.EXTENSION_NAME = HS;
    class KS extends Uy {
        init() {
            this.extensionName = "KHR_materials_unlit", this.propertyType = "Unlit", this.parentTypes = [$x.MATERIAL]
        }
    }
    KS.EXTENSION_NAME = "KHR_materials_unlit";
    const XS = "KHR_materials_unlit";
    class qS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = XS
        }
        createUnlit() {
            return new KS(this.document.getGraph())
        }
        read(e) {
            return (e.jsonDoc.json.materials || []).forEach(((t, n) => {
                t.extensions && t.extensions.KHR_materials_unlit && e.materials[n].setExtension(XS, this.createUnlit())
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                if (n.getExtension(XS)) {
                    const r = e.materialIndexMap.get(n),
                        i = t.json.materials[r];
                    i.extensions = i.extensions || {}, i.extensions.KHR_materials_unlit = {}
                }
            })), this
        }
    }
    qS.EXTENSION_NAME = XS;
    class YS extends Uy {
        init() {
            this.extensionName = "KHR_materials_variants", this.propertyType = "Mapping", this.parentTypes = ["MappingList"]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                material: null,
                variants: []
            })
        }
        getMaterial() {
            return this.getRef("material")
        }
        setMaterial(e) {
            return this.setRef("material", e)
        }
        addVariant(e) {
            return this.addRef("variants", e)
        }
        removeVariant(e) {
            return this.removeRef("variants", e)
        }
        listVariants() {
            return this.listRefs("variants")
        }
    }
    YS.EXTENSION_NAME = "KHR_materials_variants";
    class ZS extends Uy {
        init() {
            this.extensionName = "KHR_materials_variants", this.propertyType = "MappingList", this.parentTypes = [$x.PRIMITIVE]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                mappings: []
            })
        }
        addMapping(e) {
            return this.addRef("mappings", e)
        }
        removeMapping(e) {
            return this.removeRef("mappings", e)
        }
        listMappings() {
            return this.listRefs("mappings")
        }
    }
    ZS.EXTENSION_NAME = "KHR_materials_variants";
    class JS extends Uy {
        init() {
            this.extensionName = "KHR_materials_variants", this.propertyType = "Variant", this.parentTypes = ["MappingList"]
        }
    }
    JS.EXTENSION_NAME = "KHR_materials_variants";
    const $S = "KHR_materials_variants";
    class QS extends tw {
        constructor(...e) {
            super(...e), this.extensionName = $S
        }
        createMappingList() {
            return new ZS(this.document.getGraph())
        }
        createVariant(e = "") {
            return new JS(this.document.getGraph(), e)
        }
        createMapping() {
            return new YS(this.document.getGraph())
        }
        listVariants() {
            return Array.from(this.properties).filter((e => e instanceof JS))
        }
        read(e) {
            const t = e.jsonDoc;
            if (!t.json.extensions || !t.json.extensions[$S]) return this;
            const n = (t.json.extensions[$S].variants || []).map((e => this.createVariant().setName(e.name || "")));
            return (t.json.meshes || []).forEach(((t, r) => {
                const i = e.meshes[r];
                (t.primitives || []).forEach(((t, r) => {
                    if (!t.extensions || !t.extensions[$S]) return;
                    const s = this.createMappingList(),
                        o = t.extensions[$S];
                    for (const t of o.mappings) {
                        const r = this.createMapping();
                        void 0 !== t.material && r.setMaterial(e.materials[t.material]);
                        for (const e of t.variants || []) r.addVariant(n[e]);
                        s.addMapping(r)
                    }
                    i.listPrimitives()[r].setExtension($S, s)
                }))
            })), this
        }
        write(e) {
            const t = e.jsonDoc,
                n = this.listVariants();
            if (!n.length) return this;
            const r = [],
                i = new Map;
            for (const t of n) i.set(t, r.length), r.push(e.createPropertyDef(t));
            for (const t of this.document.getRoot().listMeshes()) {
                const n = e.meshIndexMap.get(t);
                t.listPrimitives().forEach(((t, r) => {
                    const s = t.getExtension($S);
                    if (!s) return;
                    const o = e.jsonDoc.json.meshes[n].primitives[r],
                        a = s.listMappings().map((t => {
                            const n = e.createPropertyDef(t),
                                r = t.getMaterial();
                            return r && (n.material = e.materialIndexMap.get(r)), n.variants = t.listVariants().map((e => i.get(e))), n
                        }));
                    o.extensions = o.extensions || {}, o.extensions[$S] = {
                        mappings: a
                    }
                }))
            }
            return t.json.extensions = t.json.extensions || {}, t.json.extensions[$S] = {
                variants: r
            }, this
        }
    }
    QS.EXTENSION_NAME = $S;
    const {
        G: eM
    } = ty;
    class tM extends Uy {
        init() {
            this.extensionName = "KHR_materials_volume", this.propertyType = "Volume", this.parentTypes = [$x.MATERIAL]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                thicknessFactor: 0,
                thicknessTexture: null,
                thicknessTextureInfo: new By(this.graph, "thicknessTexture"),
                attenuationDistance: 1 / 0,
                attenuationColor: [1, 1, 1]
            })
        }
        getThicknessFactor() {
            return this.get("thicknessFactor")
        }
        setThicknessFactor(e) {
            return this.set("thicknessFactor", e)
        }
        getThicknessTexture() {
            return this.getRef("thicknessTexture")
        }
        getThicknessTextureInfo() {
            return this.getRef("thicknessTexture") ? this.getRef("thicknessTextureInfo") : null
        }
        setThicknessTexture(e) {
            return this.setRef("thicknessTexture", e, {
                channels: eM
            })
        }
        getAttenuationDistance() {
            return this.get("attenuationDistance")
        }
        setAttenuationDistance(e) {
            return this.set("attenuationDistance", e)
        }
        getAttenuationColor() {
            return this.get("attenuationColor")
        }
        setAttenuationColor(e) {
            return this.set("attenuationColor", e)
        }
        getAttenuationColorHex() {
            return uy.factorToHex(this.getAttenuationColor())
        }
        setAttenuationColorHex(e) {
            const t = this.getAttenuationColor().slice();
            return this.set("attenuationColor", uy.hexToFactor(e, t))
        }
    }
    tM.EXTENSION_NAME = "KHR_materials_volume";
    const nM = "KHR_materials_volume";
    class rM extends tw {
        constructor(...e) {
            super(...e), this.extensionName = nM
        }
        createVolume() {
            return new tM(this.document.getGraph())
        }
        read(e) {
            const t = e.jsonDoc,
                n = t.json.textures || [];
            return (t.json.materials || []).forEach(((t, r) => {
                if (t.extensions && t.extensions.KHR_materials_volume) {
                    const i = this.createVolume();
                    e.materials[r].setExtension(nM, i);
                    const s = t.extensions.KHR_materials_volume;
                    if (void 0 !== s.thicknessFactor && i.setThicknessFactor(s.thicknessFactor), void 0 !== s.attenuationDistance && i.setAttenuationDistance(s.attenuationDistance), void 0 !== s.attenuationColor && i.setAttenuationColor(s.attenuationColor), void 0 !== s.thicknessTexture) {
                        const t = s.thicknessTexture;
                        i.setThicknessTexture(e.textures[n[t.index].source]), e.setTextureInfo(i.getThicknessTextureInfo(), t)
                    }
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(nM);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {};
                    const o = s.extensions.KHR_materials_volume = {};
                    if (r.getThicknessFactor() > 0 && (o.thicknessFactor = r.getThicknessFactor()), Number.isFinite(r.getAttenuationDistance()) && (o.attenuationDistance = r.getAttenuationDistance()), vy.eq(r.getAttenuationColor(), [1, 1, 1]) || (o.attenuationColor = r.getAttenuationColor()), r.getThicknessTexture()) {
                        const t = r.getThicknessTexture(),
                            n = r.getThicknessTextureInfo();
                        o.thicknessTexture = e.createTextureInfoDef(t, n)
                    }
                }
            })), this
        }
    }
    rM.EXTENSION_NAME = nM;
    const iM = "KHR_mesh_quantization";
    class sM extends tw {
        constructor(...e) {
            super(...e), this.extensionName = iM
        }
        read(e) {
            return this
        }
        write(e) {
            return this
        }
    }
    sM.EXTENSION_NAME = iM;
    const oM = "KHR_texture_basisu";
    class aM {
        match(e) {
            return 171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 50 === e[5] && 48 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11]
        }
        getSize(e) {
            const t = mw(e);
            return [t.pixelWidth, t.pixelHeight]
        }
        getChannels(e) {
            const t = mw(e).dataFormatDescriptor[0];
            if (163 === t.colorModel) return 2 === t.samples.length && 15 == (15 & t.samples[1].channelType) ? 4 : 3;
            if (166 === t.colorModel) return 3 == (15 & t.samples[0].channelType) ? 4 : 3;
            throw new Error(`Unexpected KTX2 colorModel, "${t.colorModel}".`)
        }
        getGPUByteLength(e) {
            const t = mw(e),
                n = this.getChannels(e) > 3;
            let r = 0;
            for (let e = 0; e < t.levels.length; e++) {
                const i = t.levels[e];
                r += i.uncompressedByteLength ? i.uncompressedByteLength : Math.max(1, Math.floor(t.pixelWidth / Math.pow(2, e))) / 4 * (Math.max(1, Math.floor(t.pixelHeight / Math.pow(2, e))) / 4) * (n ? 16 : 8)
            }
            return r
        }
    }
    class lM extends tw {
        constructor(...e) {
            super(...e), this.extensionName = oM, this.prereadTypes = [$x.TEXTURE]
        }
        static register() {
            hy.registerFormat("image/ktx2", new aM)
        }
        preread(e) {
            return e.jsonDoc.json.textures.forEach((e => {
                e.extensions && e.extensions.KHR_texture_basisu && (e.source = e.extensions.KHR_texture_basisu.source)
            })), this
        }
        read(e) {
            return this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listTextures().forEach((n => {
                if ("image/ktx2" === n.getMimeType()) {
                    const r = e.imageIndexMap.get(n);
                    t.json.textures.forEach((e => {
                        e.source === r && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_basisu = {
                            source: e.source
                        }, delete e.source)
                    }))
                }
            })), this
        }
    }
    lM.EXTENSION_NAME = oM;
    class cM extends Uy {
        init() {
            this.extensionName = "KHR_texture_transform", this.propertyType = "Transform", this.parentTypes = [$x.TEXTURE_INFO]
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                offset: [0, 0],
                rotation: 0,
                scale: [1, 1],
                texCoord: null
            })
        }
        getOffset() {
            return this.get("offset")
        }
        setOffset(e) {
            return this.set("offset", e)
        }
        getRotation() {
            return this.get("rotation")
        }
        setRotation(e) {
            return this.set("rotation", e)
        }
        getScale() {
            return this.get("scale")
        }
        setScale(e) {
            return this.set("scale", e)
        }
        getTexCoord() {
            return this.get("texCoord")
        }
        setTexCoord(e) {
            return this.set("texCoord", e)
        }
    }
    cM.EXTENSION_NAME = "KHR_texture_transform";
    const uM = "KHR_texture_transform";
    class pM extends tw {
        constructor(...e) {
            super(...e), this.extensionName = uM
        }
        createTransform() {
            return new cM(this.document.getGraph())
        }
        read(e) {
            for (const [t, n] of Array.from(e.textureInfos.entries())) {
                if (!n.extensions || !n.extensions.KHR_texture_transform) continue;
                const e = this.createTransform(),
                    r = n.extensions.KHR_texture_transform;
                void 0 !== r.offset && e.setOffset(r.offset), void 0 !== r.rotation && e.setRotation(r.rotation), void 0 !== r.scale && e.setScale(r.scale), void 0 !== r.texCoord && e.setTexCoord(r.texCoord), t.setExtension(uM, e)
            }
            return this
        }
        write(e) {
            const t = Array.from(e.textureInfoDefMap.entries());
            for (const [e, n] of t) {
                const t = e.getExtension(uM);
                if (!t) continue;
                n.extensions = n.extensions || {};
                const r = {},
                    i = vy.eq;
                i(t.getOffset(), [0, 0]) || (r.offset = t.getOffset()), 0 !== t.getRotation() && (r.rotation = t.getRotation()), i(t.getScale(), [1, 1]) || (r.scale = t.getScale()), null != t.getTexCoord() && (r.texCoord = t.getTexCoord()), n.extensions.KHR_texture_transform = r
            }
            return this
        }
    }
    pM.EXTENSION_NAME = uM;
    const hM = [$x.ROOT, $x.SCENE, $x.NODE, $x.MESH, $x.MATERIAL, $x.TEXTURE, $x.ANIMATION];
    class dM extends Uy {
        init() {
            this.extensionName = "KHR_xmp_json_ld", this.propertyType = "Packet", this.parentTypes = hM
        }
        getDefaults() {
            return Object.assign(super.getDefaults(), {
                context: {},
                properties: {}
            })
        }
        getContext() {
            return this.get("context")
        }
        setContext(e) {
            return this.set("context", bw({}, e))
        }
        listProperties() {
            return Object.keys(this.get("properties"))
        }
        getProperty(e) {
            const t = this.get("properties");
            return e in t ? t[e] : null
        }
        setProperty(e, t) {
            this._assertContext(e);
            const n = bw({}, this.get("properties"));
            return t ? n[e] = t : delete n[e], this.set("properties", n)
        }
        toJSONLD() {
            return bw({
                "@context": fM(this.get("context"))
            }, fM(this.get("properties")))
        }
        fromJSONLD(e) {
            const t = (e = fM(e))["@context"];
            return t && this.set("context", t), delete e["@context"], this.set("properties", e)
        }
        _assertContext(e) {
            if (!(e.split(":")[0] in this.get("context"))) throw new Error(`KHR_xmp_json_ld: Missing context for term, "${e}".`)
        }
    }

    function fM(e) {
        return JSON.parse(JSON.stringify(e))
    }
    dM.EXTENSION_NAME = "KHR_xmp_json_ld";
    const _M = "KHR_xmp_json_ld";
    class mM extends tw {
        constructor(...e) {
            super(...e), this.extensionName = _M
        }
        createPacket() {
            return new dM(this.document.getGraph())
        }
        listPackets() {
            return Array.from(this.properties)
        }
        read(e) {
            var t;
            const n = null == (t = e.jsonDoc.json.extensions) ? void 0 : t.KHR_xmp_json_ld;
            if (!n || !n.packets) return this;
            const r = e.jsonDoc.json,
                i = this.document.getRoot(),
                s = n.packets.map((e => this.createPacket().fromJSONLD(e))),
                o = [
                    [r.asset], r.scenes, r.nodes, r.meshes, r.materials, r.images, r.animations
                ],
                a = [
                    [i], i.listScenes(), i.listNodes(), i.listMeshes(), i.listMaterials(), i.listTextures(), i.listAnimations()
                ];
            for (let e = 0; e < o.length; e++) {
                const t = o[e] || [];
                for (let n = 0; n < t.length; n++) {
                    const r = t[n];
                    r.extensions && r.extensions.KHR_xmp_json_ld && a[e][n].setExtension(_M, s[r.extensions.KHR_xmp_json_ld.packet])
                }
            }
            return this
        }
        write(e) {
            const {
                json: t
            } = e.jsonDoc, n = [];
            for (const r of this.properties) {
                n.push(r.toJSONLD());
                for (const i of r.listParents()) {
                    let r;
                    switch (i.propertyType) {
                        case $x.ROOT:
                            r = t.asset;
                            break;
                        case $x.SCENE:
                            r = t.scenes[e.sceneIndexMap.get(i)];
                            break;
                        case $x.NODE:
                            r = t.nodes[e.nodeIndexMap.get(i)];
                            break;
                        case $x.MESH:
                            r = t.meshes[e.meshIndexMap.get(i)];
                            break;
                        case $x.MATERIAL:
                            r = t.materials[e.materialIndexMap.get(i)];
                            break;
                        case $x.TEXTURE:
                            r = t.images[e.imageIndexMap.get(i)];
                            break;
                        case $x.ANIMATION:
                            r = t.animations[e.animationIndexMap.get(i)];
                            break;
                        default:
                            r = null, this.document.getLogger().warn(`[KHR_xmp_json_ld]: Unsupported parent property, "${i.propertyType}"`)
                    }
                    r && (r.extensions = r.extensions || {}, r.extensions.KHR_xmp_json_ld = {
                        packet: n.length - 1
                    })
                }
            }
            return n.length > 0 && (t.extensions = t.extensions || {}, t.extensions.KHR_xmp_json_ld = {
                packets: n
            }), this
        }
    }
    mM.EXTENSION_NAME = _M;
    const gM = [Qw, rS, cS, hS, _S, xS, AS, zS, LS, WS, qS, QS, rM, sM, lM, pM, mM];
    class vM extends Px {
        constructor(e) {
            super(), this._loadedLibs = !1, e = e || {
                method: Qw.EncoderMethod.EDGEBREAKER,
                encodeSpeed: 5
            }, this._io = (new pw).registerExtensions(gM).registerExtensions([yM, AM, MM, TM, EM, CM, RM, kM, PM, DM, OM, LM, IM, FM]), this._encoderOptions = e
        }
        preload() {
            return this._loadLibs(), this
        }
        async _loadLibs() {
            if (this._loadedLibs || !this.loader) return;
            const e = await Promise.all([this.loader.initEncoder(), this.loader.initDecoder()]);
            this._io.registerDependencies({
                "draco3d.encoder": e[0],
                "draco3d.decoder": e[1]
            }), this._loadedLibs = !0
        }
        async parseAsync(e, t) {
            if (!this.loader) return console.error("GLTFDracoExporter: No DRACOLoader2 instance provided"), super.parseAsync(e, t);
            await this._loadLibs();
            const n = await new Promise(((n, r) => this.parse(e, n, r, t))),
                r = await super.parseAsync(n, t);
            if (!1 === t.compress) return r;
            if (!n) throw new Error("GLTFDracoExporter: gltf is null");
            let i = n;
            const s = i.byteLength || 1 / 0,
                o = await ("object" != typeof i || i.byteLength ? this._io.readBinary(new Uint8Array(i)) : this._io.readJSON({
                    json: i,
                    resources: {}
                }));
            if (o.createExtension(Qw).setRequired(!0).setEncoderOptions(this._encoderOptions), "glb" === t.exportExt) i = await this._io.writeBinary(o), isFinite(s) && console.log("DRACO Compression ratio: " + (i.byteLength / s).toFixed(5));
            else {
                const e = await this._io.writeJSON(o);
                i = e.json, Object.values(e.resources).filter((e => e)).length > 0 && (console.warn("DRACOExporter: extra resources in resources not supported properly"), i.resources = e.resources)
            }
            i.__isGLTFOutput = !0;
            const a = await super.parseAsync(i, t);
            return a.__uncompressed = r, a
        }
    }
    class bM extends Gs {
        constructor() {
            super(...arguments), this.enabled = !0, this.dependencies = [Vs, jx]
        }
        async onAdded(e) {
            await super.onAdded(e);
            const t = e.getManager().importer;
            if (!t) throw new Error("GLTFDracoExportPlugin: AssetImporter not found");
            ! function(e, t) {
                Ox(e, vM, (e => {
                    const n = Be() + ".drc",
                        r = e;
                    r.loader = t.registerFile(n), r.loader.setDecoderConfig({
                        type: "js"
                    }), r.loader.preload(!0, !0)
                }))
            }(e, t)
        }
    }
    bM.PluginType = "GLTFDracoExportPlugin";
    class xM extends Uy {
        constructor() {
            super(...arguments), this.extensionName = Jn, this.parentTypes = [$x.SCENE], this.propertyType = "ViewerJSON"
        }
        init() {}
    }
    class yM extends tw {
        constructor() {
            super(...arguments), this.extensionName = Jn, this._viewerConfig = {}, this._texturesRef = [], this.required = !0
        }
        read(e) {
            var t;
            return this._viewerConfig = {}, null === (t = e.jsonDoc.json.scenes) || void 0 === t || t.forEach(((t, n) => {
                if (t.extensions && t.extensions[Jn]) {
                    const r = new xM(this.document.getGraph());
                    e.scenes[n].setExtension(Jn, r);
                    const i = t.extensions[Jn];
                    this._viewerConfig = i
                }
            })), this
        }
        write(e) {
            return this.document.getRoot().listScenes().forEach((t => {
                var n;
                if (t.getExtension(Jn)) {
                    const t = null === (n = e.jsonDoc.json.scenes) || void 0 === n ? void 0 : n[e.jsonDoc.json.scene || 0];
                    t && this._viewerConfig !== {} && (t.extensions = t.extensions || {}, t.extensions[Jn] = this._viewerConfig, this._texturesRef = [], this._viewerConfig = {})
                }
            })), this
        }
    }
    yM.EXTENSION_NAME = Jn;
    class wM extends Uy {
        constructor(e, t, n) {
            super(e, t), this.parentTypes = [$x.MATERIAL, $x.MESH, $x.NODE, $x.SCENE], this.propertyType = "GenericExtension", this.textures = {}, this.extensionName = n
        }
        addTexture(e, t, n, r = 4369) {
            this.setRef(e, n, {
                channels: r
            }), this.textures[e] = [t, n]
        }
        copy(e, t = Ry) {
            return super.copy(e, t), this
        }
        dispose() {
            Object.values(this.textures).forEach((([e, t]) => {
                null == e || e.dispose()
            })), super.dispose()
        }
        init() {}
    }
    class SM extends tw {
        constructor() {
            super(...arguments), this.textureChannels = {}
        }
        read(e) {
            const t = e.jsonDoc,
                n = t.json.materials || [],
                r = t.json.textures || [];
            return n.forEach(((t, n) => {
                var i, s;
                if (t.extensions && t.extensions[this.extensionName]) {
                    const o = new wM(this.document.getGraph(), "", this.extensionName);
                    e.materials[n].setExtension(this.extensionName, o);
                    const a = { ...t.extensions[this.extensionName]
                    };
                    for (const [t, n] of Object.entries(a))
                        if ("number" == typeof(null == n ? void 0 : n.index)) {
                            const l = n,
                                c = null === (i = r[l.index]) || void 0 === i ? void 0 : i.source;
                            if ("number" != typeof c) {
                                console.warn("GLTF Pipeline: source texture not found for texture info", l);
                                continue
                            }
                            const u = e.textures[c],
                                p = new By(this.document.getGraph()),
                                h = null !== (s = this.textureChannels[t]) && void 0 !== s ? s : 4369;
                            o.addTexture(t, p, u, h), e.setTextureInfo(p, l), delete a[t]
                        }
                    o.setExtras(a)
                }
            })), (t.json.meshes || []).forEach(((t, n) => {
                if (t.extensions && t.extensions[this.extensionName]) {
                    const r = new wM(this.document.getGraph(), "", this.extensionName);
                    e.meshes[n].setExtension(this.extensionName, r);
                    const i = t.extensions[this.extensionName];
                    r.setExtras(i)
                }
            })), (t.json.nodes || []).forEach(((t, n) => {
                if (t.extensions && t.extensions[this.extensionName]) {
                    const r = new wM(this.document.getGraph(), "", this.extensionName);
                    e.nodes[n].setExtension(this.extensionName, r);
                    const i = t.extensions[this.extensionName];
                    r.setExtras(i)
                }
            })), (t.json.scenes || []).forEach(((t, n) => {
                if (t.extensions && t.extensions[this.extensionName]) {
                    const r = new wM(this.document.getGraph(), "", this.extensionName);
                    e.scenes[n].setExtension(this.extensionName, r);
                    const i = t.extensions[this.extensionName];
                    r.setExtras(i)
                }
            })), this
        }
        write(e) {
            const t = e.jsonDoc;
            return this.document.getRoot().listMaterials().forEach((n => {
                const r = n.getExtension(this.extensionName);
                if (r) {
                    const i = e.materialIndexMap.get(n),
                        s = t.json.materials[i];
                    s.extensions = s.extensions || {};
                    const o = { ...r.getExtras()
                    };
                    for (const [t, n] of Object.entries(r.textures)) {
                        const r = n[0],
                            i = n[1];
                        i && (o[t] = e.createTextureInfoDef(i, r))
                    }
                    s.extensions[this.extensionName] = o
                }
            })), this.document.getRoot().listMeshes().forEach((n => {
                const r = n.getExtension(this.extensionName);
                if (r) {
                    const i = e.meshIndexMap.get(n),
                        s = t.json.meshes[i];
                    s.extensions = s.extensions || {}, s.extensions[this.extensionName] = r.getExtras()
                }
            })), this.document.getRoot().listNodes().forEach((n => {
                const r = n.getExtension(this.extensionName);
                if (r) {
                    const i = e.nodeIndexMap.get(n),
                        s = t.json.nodes[i];
                    s.extensions = s.extensions || {}, s.extensions[this.extensionName] = r.getExtras()
                }
            })), this.document.getRoot().listScenes().forEach((n => {
                const r = n.getExtension(this.extensionName);
                if (r) {
                    const n = e.jsonDoc.json.scene || 0,
                        i = t.json.scenes[n];
                    if (!i) return;
                    i.extensions = i.extensions || {}, i.extensions[this.extensionName] = r.getExtras()
                }
            })), this
        }
    }
    class MM extends SM {
        constructor() {
            super(...arguments), this.extensionName = MM.EXTENSION_NAME, this.textureChannels = {
                bumpTexture: ty.R
            }
        }
    }
    MM.EXTENSION_NAME = or;
    class TM extends SM {
        constructor() {
            super(...arguments), this.extensionName = TM.EXTENSION_NAME, this.textureChannels = {
                lightMapTexture: ty.R | ty.G | ty.B
            }
        }
    }
    TM.EXTENSION_NAME = lr;
    class EM extends SM {
        constructor() {
            super(...arguments), this.extensionName = EM.EXTENSION_NAME, this.textureChannels = {
                alphaTexture: ty.G
            }
        }
    }
    EM.EXTENSION_NAME = ar;
    class AM extends SM {
        constructor() {
            super(...arguments), this.extensionName = AM.EXTENSION_NAME
        }
    }
    AM.EXTENSION_NAME = Pa.DIAMOND_GLTF_EXTENSION;
    class CM extends SM {
        constructor() {
            super(...arguments), this.extensionName = CM.EXTENSION_NAME
        }
    }
    CM.EXTENSION_NAME = wc.AnimationMarkersExtension;
    class RM extends SM {
        constructor() {
            super(...arguments), this.extensionName = RM.EXTENSION_NAME, this.textureChannels = {
                anisotropyDirection: ty.R | ty.G | ty.B
            }
        }
    }
    RM.EXTENSION_NAME = kc.ANISOTROPY_GLTF_EXTENSION;
    class kM extends SM {
        constructor() {
            super(...arguments), this.extensionName = kM.EXTENSION_NAME, this.textureChannels = {
                anisotropyDirection: ty.R | ty.G | ty.B
            }
        }
    }
    kM.EXTENSION_NAME = dm.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
    class PM extends SM {
        constructor() {
            super(...arguments), this.extensionName = PM.EXTENSION_NAME
        }
    }
    PM.EXTENSION_NAME = Qn;
    class DM extends SM {
        constructor() {
            super(...arguments), this.extensionName = DM.EXTENSION_NAME
        }
    }
    DM.EXTENSION_NAME = er;
    class OM extends SM {
        constructor() {
            super(...arguments), this.extensionName = OM.EXTENSION_NAME
        }
    }
    OM.EXTENSION_NAME = tr;
    class LM extends SM {
        constructor() {
            super(...arguments), this.extensionName = LM.EXTENSION_NAME
        }
    }
    LM.EXTENSION_NAME = lu.CLEARCOAT_TINT_GLTF_EXTENSION;
    class IM extends SM {
        constructor() {
            super(...arguments), this.extensionName = IM.EXTENSION_NAME
        }
    }
    IM.EXTENSION_NAME = ru.THIN_FILM_LAYER_GLTF_EXTENSION;
    class FM extends SM {
        constructor() {
            super(...arguments), this.extensionName = FM.EXTENSION_NAME
        }
    }
    FM.EXTENSION_NAME = xu.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
    class NM extends r {
        constructor() {
            super(...arguments), this.processor = {
                forAssetType: "texture",
                process: (e, t) => e
            }
        }
        async onAdded(e) {}
        async onDispose(e) {}
        async onRemove(e) {
            this._pmrem = void 0
        }
    }
    NM.PluginType = "PMREMGenerator";
    const UM = 1e4,
        BM = 50;
    class jM {
        constructor(e = BM) {
            this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(e)
        }
        setDecayTime(e) {
            this.naturalFrequency = 1 / Math.max(.001, e)
        }
        update(e, t, n, r) {
            const i = 2e-4 * this.naturalFrequency;
            if (null == e || 0 === r) return t;
            if (e === t && 0 === this.velocity) return t;
            if (n < 0) return e;
            const s = e - t,
                o = this.velocity + this.naturalFrequency * s,
                a = s + n * o,
                l = Math.exp(-this.naturalFrequency * n),
                c = (o - this.naturalFrequency * a) * l,
                u = -this.naturalFrequency * (c + o * l);
            return Math.abs(c) < i * Math.abs(r) && u * s >= 0 ? (this.velocity = 0, t) : (this.velocity = c, t + a * l)
        }
    }
    const zM = new i.Pa4;
    class VM {
        constructor() {
            this.inputSource = null, this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.lastDragPosition = new i.Pa4, this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new i.Pa4, this.goalYaw = 0, this.goalScale = 1, this.presentedScene = null, this.placementBox = null, this.placeOnWall = !1, this.placementComplete = !1, this.xr = null, this.session = null, this._hitPosition = new i.Pa4, this._hitMatrix = new i.yGw, this.xDamper = new jM, this.yDamper = new jM, this.zDamper = new jM, this.yawDamper = new jM, this.scaleDamper = new jM, this.onSelectStart = e => {
                const t = this.transientHitTestSource;
                if (null == t) return;
                const n = this.frame.getHitTestResultsForTransientInput(t),
                    r = this.presentedScene,
                    i = this.placementBox;
                if (1 === n.length) {
                    this.inputSource = e.inputSource;
                    const {
                        axes: t
                    } = this.inputSource.gamepad || {
                        axes: [0, 0]
                    }, n = i.getHit(r, t[0], t[1]);
                    i.show = !0, null != n ? (this.isTranslating = !0, this.lastDragPosition.copy(n)) : this.placeOnWall || (this.isRotating = !0, this.lastAngle = 1.5 * t[0])
                } else if (2 === n.length) {
                    i.show = !0, this.isTwoFingering = !0;
                    const {
                        separation: e
                    } = this.fingerPolar(n);
                    this.firstRatio = e / r.scale.x
                }
            }, this.onSelectEnd = () => {
                this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = !1
            }
        }
        async setSession(e, t, n, r) {
            var i;
            this.transientHitTestSource = await (null === (i = e.requestHitTestSourceForTransientInput) || void 0 === i ? void 0 : i.call(e, {
                profile: "generic-touchscreen"
            })), this.presentedScene = t, this.placementBox = r, this.xr = n, this.session = e, this.placementComplete = !1, this.goalPosition.copy(t.position), this.goalYaw = t.rotation.y, this.goalScale = t.scale.x, e.addEventListener("selectstart", this.onSelectStart), e.addEventListener("selectend", this.onSelectEnd)
        }
        cancel() {
            this.transientHitTestSource && (this.transientHitTestSource.cancel(), this.transientHitTestSource = void 0), this.presentedScene = null, this.placeOnWall = !1, this.frame = void 0, this.xr = null, this.placementBox && (this.placementBox.show = !1, this.placementBox = null), this.session && (this.session.removeEventListener("selectstart", this.onSelectStart), this.session.removeEventListener("selectend", this.onSelectEnd), this.session = null)
        }
        getHitPoint(e) {
            var t;
            const n = null === (t = this.xr) || void 0 === t ? void 0 : t.getReferenceSpace(),
                r = n ? e.getPose(n) : null;
            return r ? (this._hitMatrix.fromArray(r.transform.matrix), this.placeOnWall && (this.goalYaw = Math.atan2(this._hitMatrix.elements[4], this._hitMatrix.elements[6])), this._hitMatrix.elements[5] > .75 !== this.placeOnWall ? this._hitPosition.setFromMatrixPosition(this._hitMatrix) : null) : null
        }
        moveScene(e) {
            if (!this.session) return;
            const t = this.presentedScene,
                n = t.position,
                r = t.rotation.y,
                i = this.placementBox,
                s = Math.max(i.boundingSize.x, i.boundingSize.y, i.boundingSize.z) / 2,
                o = this.goalPosition,
                a = t.scale.x;
            if (!o.equals(n) || this.goalScale !== a) {
                let {
                    x: r,
                    y: l,
                    z: c
                } = n;
                r = this.xDamper.update(r, o.x, e, s), l = this.yDamper.update(l, o.y, e, s), c = this.zDamper.update(c, o.z, e, s), n.set(r, l, c);
                const u = this.scaleDamper.update(a, this.goalScale, e, 1);
                if (t.scale.set(u, u, u), !this.isTranslating) {
                    const e = o.y - l;
                    this.placementComplete && !this.placeOnWall ? i.offsetHeight = e / u : 0 === e && (this.placementComplete = !0, i.show = !1)
                }
            }
            i.updateOpacity(e), t.rotation.y = this.yawDamper.update(r, this.goalYaw, e, Math.PI)
        }
        processInput(e) {
            var t;
            this.frame = e;
            const n = this.transientHitTestSource;
            if (!n) return;
            if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) return;
            const r = e.getHitTestResultsForTransientInput(n),
                i = this.presentedScene,
                s = i.scale.x;
            if (this.isTwoFingering)
                if (r.length < 2) this.isTwoFingering = !1;
                else {
                    const {
                        separation: e,
                        deltaYaw: t
                    } = this.fingerPolar(r);
                    if (this.placeOnWall || (this.goalYaw += t), !i.userData.__scaleDisabled) {
                        const t = e / this.firstRatio;
                        this.goalScale = t < 1.3 && t > .7692307692307692 ? 1 : t
                    }
                }
            else if (2 !== r.length)
                if (this.isRotating && (null === (t = this.inputSource) || void 0 === t ? void 0 : t.gamepad)) {
                    const e = 1.5 * this.inputSource.gamepad.axes[0];
                    this.goalYaw += e - this.lastAngle, this.lastAngle = e
                } else this.isTranslating && (console.log("translating"), r.forEach((e => {
                    if (e.inputSource !== this.inputSource) return;
                    let t = null;
                    if (e.results.length > 0 && (t = this.getHitPoint(e.results[0])), null == t && (t = this.getTouchLocation()), null != t) {
                        if (this.goalPosition.sub(this.lastDragPosition), !this.placeOnWall) {
                            const e = t.y - this.lastDragPosition.y;
                            if (e < 0) {
                                this.placementBox.offsetHeight = e / s;
                                const n = zM.copy(this.xr.getCamera().position),
                                    r = -e / (n.y - t.y);
                                n.multiplyScalar(r), t.multiplyScalar(1 - r).add(n)
                            }
                        }
                        this.goalPosition.add(t), this.lastDragPosition.copy(t)
                    }
                })));
            else {
                this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !0;
                const {
                    separation: e
                } = this.fingerPolar(r);
                this.firstRatio = e / s
            }
        }
        getTouchLocation() {
            var e, t;
            const {
                axes: n
            } = null !== (e = this.inputSource.gamepad) && void 0 !== e ? e : {
                axes: [0, 0]
            }, r = this.placementBox.getExpandedHit(this.presentedScene, n[0], n[1]);
            return null != r && (zM.copy(r).sub(null === (t = this.xr) || void 0 === t ? void 0 : t.getCamera().position), zM.length() > 10) ? null : r
        }
        fingerPolar(e) {
            var t, n, r, i, s, o;
            const a = null !== (r = null === (n = null === (t = e[0].inputSource) || void 0 === t ? void 0 : t.gamepad) || void 0 === n ? void 0 : n.axes) && void 0 !== r ? r : [0, 0],
                l = null !== (o = null === (s = null === (i = e[1].inputSource) || void 0 === i ? void 0 : i.gamepad) || void 0 === s ? void 0 : s.axes) && void 0 !== o ? o : [0, 0],
                c = l[0] - a[0],
                u = l[1] - a[1],
                p = Math.atan2(u, c);
            let h = this.lastAngle - p;
            return h > Math.PI ? h -= 2 * Math.PI : h < -Math.PI && (h += 2 * Math.PI), this.lastAngle = p, {
                separation: Math.sqrt(c * c + u * u),
                deltaYaw: h
            }
        }
    }
    const GM = .2,
        HM = Math.PI / 24,
        WM = new i.FM8,
        KM = (e, t, n) => {
            let r = t > 0 ? n > 0 ? 0 : -Math.PI / 2 : n > 0 ? Math.PI / 2 : Math.PI;
            for (let i = 0; i <= 12; ++i) e.push(t + .17 * Math.cos(r), n + .17 * Math.sin(r), 0, t + GM * Math.cos(r), n + GM * Math.sin(r), 0), r += HM
        };
    class XM extends i.Kj0 {
        constructor(e, t, n = !1) {
            super(((e, t) => {
                const n = new i.u9r,
                    r = [],
                    s = [],
                    o = e.getSize(new i.Pa4),
                    a = o.x / 2,
                    l = (t ? o.y : o.z) / 2;
                KM(s, a, l), KM(s, -a, l), KM(s, -a, -l), KM(s, a, -l);
                const c = s.length / 3;
                for (let e = 0; e < c - 2; e += 2) r.push(e, e + 1, e + 3, e, e + 3, e + 2);
                const u = c - 2;
                return r.push(u, u + 1, 1, u, 1, 0), n.setAttribute("position", new i.a$l(s, 3)), n.setIndex(r), n
            })(e, n)), this.boundingSize = new i.Pa4, this._raycaster = new i.iMs, this._camera = t, this._placeOnWall = n;
            const r = this.material;
            r.side = i.Wl3, r.color = new ve(16711935), r.opacity = 0, this.userData.bboxVisible = !1;
            const s = e.getSize(this.boundingSize);
            console.log(e, n, s, this);
            const o = s.x / 2,
                a = (n ? s.y : s.z) / 2;
            this.hitPlane = new i.Kj0(new i.BKK(2 * (o + GM), 2 * (a + GM))), this.hitPlane.visible = !1, this.add(this.hitPlane), e.getCenter(this.position), n ? (this.shadowHeight = e.min.z, this.position.z = this.shadowHeight) : (this.rotateX(-Math.PI / 2), this.shadowHeight = e.min.y, this.position.y = this.shadowHeight), this.offsetHeight = 0
        }
        getHit(e, t, n) {
            WM.set(t, -n), this.hitPlane.visible = !0;
            const r = this._positionAndNormalFromPoint(WM, this.hitPlane);
            return this.hitPlane.visible = !1, null == r ? null : r.position
        }
        getExpandedHit(e, t, n) {
            this.hitPlane.scale.set(1e3, 1e3, 1e3);
            const r = this.getHit(e, t, n);
            return this.hitPlane.scale.set(1, 1, 1), r
        }
        set offsetHeight(e) {
            e -= .001, this._placeOnWall ? this.position.z = this.shadowHeight + e : this.position.y = this.shadowHeight + e
        }
        get offsetHeight() {
            return this._placeOnWall ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight
        }
        set show(e) {
            this.material.opacity = e ? .75 : 0
        }
        get show() {
            return this.material.opacity > .01
        }
        updateOpacity(e) {
            const t = this.material;
            this.visible = t.opacity > 0
        }
        dispose() {
            var e;
            const {
                geometry: t,
                material: n
            } = this.hitPlane;
            t.dispose(), n.dispose(), this.geometry.dispose(), this.material.dispose(), null === (e = this.parent) || void 0 === e || e.remove(this)
        }
        _positionAndNormalFromPoint(e, t) {
            if (!this._camera) return null;
            this._raycaster.setFromCamera(e, this._camera);
            const n = this._raycaster.intersectObject(t, !0);
            if (0 === n.length) return null;
            const r = n[0];
            return null == r.face ? null : null == r.uv ? {
                position: r.point,
                normal: r.face.normal,
                uv: null
            } : (r.face.normal.applyNormalMatrix((new i.Vkp).getNormalMatrix(r.object.matrixWorld)), {
                position: r.point,
                normal: r.face.normal,
                uv: r.uv
            })
        }
    }
    class qM extends Gs {
        constructor() {
            super(...arguments), this.enabled = !0, this._touchInputHelper = new VM, this._preRender = () => {
                if (!(this._dirty && this._viewer && this._xrManager && this._xrSession)) return;
                this._viewer.renderer.composer.renderToScreen = !1, this._xrManager.enabled = !1;
                const e = this._xrManager.getCamera(),
                    t = e.cameras[0] || e,
                    n = this._viewer.scene.activeCamera;
                n.cameraObject.projectionMatrix.copy(t.projectionMatrix), n.cameraObject.projectionMatrixInverse.copy(n.cameraObject.projectionMatrix).invert()
            }, this._postRender = () => {
                var e, t;
                if (!this._dirty || !this._viewer || !this._xrSession) return;
                this._viewer.scene.activeCamera.cameraObject.updateProjectionMatrix();
                const n = this._viewer.renderer,
                    r = null === (t = null === (e = this._xrManager) || void 0 === e ? void 0 : e.getCamera()) || void 0 === t ? void 0 : t.cameras[0].viewport;
                r ? n.rendererObject.setViewport(r) : console.warn("no viewport for ar camera"), K(n.rendererObject, {
                    sceneRender: !0,
                    opaqueRender: !0,
                    shadowMapRender: !1,
                    backgroundRender: !1,
                    transparentRender: !1,
                    transmissionRender: !1,
                    screenSpaceRendering: !1
                }, (() => {
                    YM.render(n.rendererObject, null, n.composer.readBuffer, 0, !1)
                })), this._xrManager.enabled = !0, this._viewer.renderer.composer.renderToScreen = !0
            }, this._frameCount = 0, this._lastTime = 0, this._preFrame = ({
                xrFrame: e,
                deltaTime: t
            }) => {
                var n, r;
                if (this.dirty = !!e && (null === (n = this._xrManager) || void 0 === n ? void 0 : n.isPresenting) || !1, this._viewer.scene.activeCamera.interactionsEnabled = !this._dirty, this._viewer.scene.activeCamera.autoLookAtTarget = !this._dirty, !this._dirty || !e) return void(this._xrSession && this._xrSessionEnd());
                if (!this._xrSession && !this._xrManager.getSession()) return console.error("no xr session found, shouldn't happen"), void(this.dirty = !1);
                this._xrSession || console.log("webxr: AR session init"), this._frameCount++;
                const i = this._xrManager.getReferenceSpace(),
                    s = e.getViewerPose(i);
                if (null == s && this._frameCount, null == s || 0 === (null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.modelRoot.children.length)) return this.dirty = !1, void console.log("no pose or no model");
                if (!this._xrSession) {
                    if (this._xrSession = this._xrManager.getSession() || void 0, !this._xrSession) return;
                    this._frameCount = 0, this._cancelHitSources(), this._savePreXRState(), this._preSetupModel(), this._xrSessionStart()
                }
                const o = this._viewer.scene.activeCamera;
                this._xrManager.updateCamera(o.cameraObject), o.setDirty(), this.moveToFloor(e), this._touchInputHelper.processInput(e), this._touchInputHelper.moveScene(t), this._updateShadow()
            }, this.placeOnWall = !1, this._preXRState = {
                viewerBg: null,
                modelScale: new i.Pa4(1, 1, 1),
                modelPosition: new i.Pa4,
                modelRotation: new i._fP,
                cameraPosition: new i.Pa4(0, 0, 5),
                cameraTarget: new i.Pa4,
                cameraUp: new i.Pa4(0, 1, 0),
                cameraAspect: 1,
                cameraFov: 50,
                cameraZoom: 1,
                cameraNear: .01,
                cameraFar: 100,
                groundOffset: new i.Pa4,
                groundScale: 1
            }, this._savePreXRState = () => {
                if (!this._viewer) return;
                this._preXRState.viewerBg = this._viewer.getBackground(!0);
                const e = this._viewer.scene.modelRoot,
                    t = this._viewer.scene.activeCamera;
                e.updateMatrix(), e.updateMatrixWorld(!0), this._preXRState.modelScale.copy(e.scale), this._preXRState.modelPosition.copy(e.position), this._preXRState.modelRotation.copy(e.quaternion), this._preXRState.cameraPosition.copy(t.position), this._preXRState.cameraTarget.copy(t.target), this._preXRState.cameraUp.copy(t.cameraObject.up), t.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov = t.cameraObject.fov, this._preXRState.cameraAspect = t.cameraObject.aspect), this._preXRState.cameraZoom = t.cameraObject.zoom, this._preXRState.cameraNear = t.cameraObject.near, this._preXRState.cameraFar = t.cameraObject.far;
                const n = this._viewer.getPluginByType("Ground");
                (null == n ? void 0 : n.mesh) && (this._preXRState.groundOffset.subVectors(e.position, n.mesh.modelObject.position), this._preXRState.groundScale = n.mesh.modelObject.scale.x, console.log("ground offset", this._preXRState.groundOffset, this._preXRState.groundScale), n.shadowBaker.enabled = !1)
            }, this._xrSessionStart = () => {
                if (!this._xrSession || !this._viewer) return;
                console.log("webxr: AR session start");
                const e = 20 * Math.PI / 180,
                    t = this.placeOnWall ? void 0 : new window.XRRay(new DOMPoint(0, 0, 0), {
                        x: 0,
                        y: -Math.sin(e),
                        z: -Math.cos(e)
                    });
                this._touchInputHelper.placeOnWall = this.placeOnWall, this._viewer.resize(), (async () => {
                    var e, n;
                    if (this._xrSession) {
                        const r = await this._xrSession.requestReferenceSpace("viewer");
                        this._hitTestSource = await (null === (n = (e = this._xrSession).requestHitTestSource) || void 0 === n ? void 0 : n.call(e, {
                            space: r,
                            offsetRay: t
                        }))
                    }
                    this._xrSession && await this._touchInputHelper.setSession(this._xrSession, this._viewer.scene.modelRoot, this._xrManager, this._placementBox)
                })()
            }, this._xrSessionEnd = () => {
                var e;
                console.log("webxr: AR session end"), this._frameCount = 0, null === (e = this._xrSession) || void 0 === e || e.removeEventListener("end", this._xrSessionEnd), this._xrSession = void 0, this._cancelHitSources(), this._viewer && (this._restorePreXRState(), this._viewer.resize())
            }
        }
        async onAdded(e) {
            await super.onAdded(e);
            const t = e.renderer.rendererObject.xr;
            t.enabled = !0, t.cameraAutoUpdate = !1, this._xrManager = t;
            const n = document.getElementById("tweakpaneUiContainer"),
                r = n ? {
                    root: n
                } : void 0;
            document.body.appendChild(class {
                static createButton(e, t = {}) {
                    const n = document.createElement("button");

                    function r() {
                        n.style.display = "", n.style.cursor = "auto", n.style.left = "calc(50% - 75px)", n.style.width = "150px", n.onmouseenter = null, n.onmouseleave = null, n.onclick = null
                    }

                    function i(e) {
                        e.style.position = "absolute", e.style.bottom = "20px", e.style.padding = "12px 6px", e.style.border = "1px solid #fff", e.style.borderRadius = "4px", e.style.background = "rgba(0,0,0,0.1)", e.style.color = "#fff", e.style.font = "normal 13px sans-serif", e.style.textAlign = "center", e.style.opacity = "0.5", e.style.outline = "none", e.style.zIndex = "999"
                    }
                    if ("xr" in navigator) return n.id = "ARButton", n.style.display = "none", i(n), navigator.xr.isSessionSupported("immersive-ar").then((function(i) {
                        i ? function() {
                            if (void 0 === t.domOverlay) {
                                const e = document.createElement("div");
                                e.style.display = "none", document.body.appendChild(e);
                                const n = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                                n.setAttribute("width", 38), n.setAttribute("height", 38), n.style.position = "absolute", n.style.right = "20px", n.style.top = "20px", n.addEventListener("click", (function() {
                                    r.end()
                                })), e.appendChild(n);
                                const i = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                i.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), i.setAttribute("stroke", "#fff"), i.setAttribute("stroke-width", 2), n.appendChild(i), void 0 === t.optionalFeatures && (t.optionalFeatures = []), t.optionalFeatures.push("dom-overlay"), t.domOverlay = {
                                    root: e
                                }
                            }
                            let r = null;
                            async function i(i) {
                                i.addEventListener("end", s), e.xr.setReferenceSpaceType("local"), await e.xr.setSession(i), n.textContent = "STOP AR", t.domOverlay.root.style.display = "", r = i
                            }

                            function s() {
                                r.removeEventListener("end", s), n.textContent = "START AR", t.domOverlay.root.style.display = "none", r = null
                            }
                            n.style.display = "", n.style.cursor = "pointer", n.style.left = "calc(50% - 50px)", n.style.width = "100px", n.textContent = "START AR", n.onmouseenter = function() {
                                n.style.opacity = "1.0"
                            }, n.onmouseleave = function() {
                                n.style.opacity = "0.5"
                            }, n.onclick = function() {
                                null === r ? navigator.xr.requestSession("immersive-ar", t).then(i) : r.end()
                            }
                        }() : (r(), n.textContent = "AR NOT SUPPORTED")
                    })).catch((function(e) {
                        r(), console.warn("Exception when trying to call xr.isSessionSupported", e), n.textContent = "AR NOT ALLOWED"
                    })), n; {
                        const e = document.createElement("a");
                        return !1 === window.isSecureContext ? (e.href = document.location.href.replace(/^http:/, "https:"), e.innerHTML = "WEBXR NEEDS HTTPS") : (e.href = "https://immersiveweb.dev/", e.innerHTML = "WEBXR NOT AVAILABLE"), e.style.left = "calc(50% - 90px)", e.style.width = "180px", e.style.textDecoration = "none", i(e), e
                    }
                }
            }.createButton(e.renderer.rendererObject, {
                requiredFeatures: ["hit-test"],
                optionalFeatures: ["dom-overlay"],
                domOverlay: r
            })), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), e.addEventListener("preFrame", this._preFrame)
        }
        _updateShadow() {
            if (!this._viewer) return;
            const e = this._viewer.scene.modelRoot,
                t = this._viewer.getPluginByType("Ground");
            t && (t.groundReflection = !1, t.mesh.modelObject.position.copy(this._preXRState.groundOffset).multiplyScalar(e.modelObject.scale.x).sub(e.modelObject.position).negate(), t.mesh.modelObject.scale.setScalar(e.modelObject.scale.x * this._preXRState.groundScale))
        }
        moveToFloor(e) {
            if (!this._dirty || !this._hitTestSource || !this._xrManager) return;
            const t = e.getHitTestResults(this._hitTestSource);
            if (!t.length) return;
            const n = t[0],
                r = this._touchInputHelper.getHitPoint(n);
            r && (this._placementBox.show = !0, this._viewer.scene.modelRoot, this.placeOnWall ? this._touchInputHelper.goalPosition.copy(r) : this._touchInputHelper.goalPosition.y = r.y, this._hitTestSource.cancel(), this._hitTestSource = void 0, console.log("move to initial hit point", r))
        }
        _removePlacementBox() {
            this._placementBox && (this._placementBox.dispose(), this._placementBox = void 0)
        }
        _preSetupModel() {
            var e;
            const t = this._viewer.scene.modelRoot,
                n = this._viewer.scene.activeCamera,
                r = null === (e = this._xrManager) || void 0 === e ? void 0 : e.getCamera(),
                s = r.cameras[0] || r;
            this._removePlacementBox();
            const o = this._viewer.scene.getBounds(!0, !0);
            o.getSize(new i.Pa4).length() > .01 && (this._placementBox = new XM(o, r, this.placeOnWall), t.add(this._placementBox), this._placementBox.show = !1);
            const a = r.getWorldDirection(new i.Pa4);
            t.rotation.y = Math.atan2(-a.x, -a.z) - 0, n.cameraObject.zoom = s.zoom, n.cameraObject.near = s.near, n.cameraObject.far = s.far, n.cameraObject.isPerspectiveCamera ? (n.cameraObject.fov = s.fov, n.cameraObject.aspect = s.viewport.width / s.viewport.height) : console.warn("Perspective camera required."), n.cameraObject.updateProjectionMatrix(), t.position.set(0, 0, 0);
            const l = t.userData.arScale || 1;
            t.scale.set(l, l, l), t.position.copy(r.position).add(a.multiplyScalar(5)), t.visible = !0, this._viewer.setBackground(null)
        }
        _restorePreXRState() {
            if (!this._viewer) return;
            this._viewer.setBackground(this._preXRState.viewerBg), this._preXRState.viewerBg = null;
            const e = this._viewer.scene.modelRoot;
            e.scale.copy(this._preXRState.modelScale), e.position.copy(this._preXRState.modelPosition), e.quaternion.copy(this._preXRState.modelRotation), e.updateMatrix(), e.updateMatrixWorld(!0), e.visible = !0;
            const t = this._viewer.scene.activeCamera;
            t.position.copy(this._preXRState.cameraPosition), t.target.copy(this._preXRState.cameraTarget), t.cameraObject.up.copy(this._preXRState.cameraUp), t.cameraObject.near = this._preXRState.cameraNear, t.cameraObject.far = this._preXRState.cameraFar, t.cameraObject.isPerspectiveCamera && (void 0 !== this._preXRState.cameraFov && (t.cameraObject.fov = this._preXRState.cameraFov), void 0 !== this._preXRState.cameraAspect && (t.cameraObject.aspect = this._preXRState.cameraAspect)), t.positionUpdated(!1), t.targetUpdated(!0), t.cameraObject.updateMatrixWorld(!0), t.cameraObject.updateProjectionMatrix()
        }
        _cancelHitSources() {
            this._hitTestSource && (this._hitTestSource.cancel(), this._hitTestSource = void 0), this._touchInputHelper.cancel()
        }
    }
    qM.PluginType = "WEBXR_ARPlugin";
    const YM = new u({
        vertexShader: s.vertexShader,
        fragmentShader: "\n    uniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\t// gl_FragColor = vec4(1,0,1,1);\n\t\t\tgl_FragColor = texel;\n\n\t\t}\n\t\t",
        uniforms: s.uniforms
    });
    async function ZM(e, t) {
        if (e.createWriter) {
            const n = await e.createWriter();
            return await n.write(0, t), void await n.close()
        }
        const n = await e.createWritable();
        await n.write(t), await n.close()
    }
    async function JM(e, t) {
        const n = {};
        return t && (n.writable = !0, n.mode = "readwrite"), "granted" === await e.queryPermission(n) || "granted" === await e.requestPermission(n)
    }
    YM.renderToScreen = !1, YM.useExistingRenderTarget = !0, YM.clear = !1;
    class $M extends r {
        constructor(e, t) {
            super(), this._state = "stopped", this._console = console, this._currentRecording = [], this._currentImages = [], this.stepMode = !1, this._resumeSyncTime = 0, this._frameCount = 0, this._onstop = e => {
                var t;
                if (this._state = "stopped", this._recorder && this._currentRecording.length > 0) {
                    const e = new Blob(this._currentRecording, {
                        type: this._options.mimeType
                    });
                    null === (t = this._recordingCallback) || void 0 === t || t.call(this, e)
                } else this._currentImages.length > 0 && (this._writeImages([...this._currentImages]), this._currentImages = []);
                this._recorder = void 0, this.dispatchEvent({
                    type: "stop"
                })
            }, this._onstart = e => {
                var t;
                this._state = "recording", this._frameCount = 0, this.dispatchEvent({
                    type: "start"
                }), this.stepMode && (null === (t = this._recorder) || void 0 === t || t.pause())
            }, this._onresume = e => {
                if (!this.stepMode) return;
                const t = () => {
                        var e;
                        "recording" === this._state && (null === (e = this._recorder) || void 0 === e || e.pause())
                    },
                    n = Math.min(this._resumeSyncTime - Ct(), 0) + 1e3 / this._options.frameRate;
                n > 0 ? _c(n).then(t) : t()
            }, this._onpause = e => {}, this._ondataavailable = e => {
                e.data && e.data.size > 0 && this._currentRecording.push(e.data)
            }, this._onerror = e => {
                this._state = "error", this._console.error(e), this.dispatchEvent({
                    type: "error",
                    error: e
                }), this._recorder = void 0
            }, this._canvas = e;
            const n = null == t ? void 0 : t.mimeType;
            this._options = {
                mimeType: n || "auto",
                frameRate: 30
            }, this._setOptions(t || this._options)
        }
        _setOptions(e) {
            var t, n;
            Object.assign(this._options, e), this._options.mimeType && "auto" !== this._options.mimeType || (this._options.mimeType = null !== (t = $M.GetSupportedMimeTypes([], ["h264"], !0)) && void 0 !== t ? t : $M.GetSupportedMimeTypes(void 0, void 0, !0)), this._options.mimeType && !(null === (n = this._options.mimeType) || void 0 === n ? void 0 : n.startsWith("video/")) || window.MediaRecorder || (this._console.warn("MediaRecorder is not supported, switching to png"), this._options.mimeType = "image/png"), this._options.mimeType || console.warn(new Error("No supported mimetype found"))
        }
        setOptions(e) {
            this._setOptions(e)
        }
        isRecording() {
            return "recording" === this._state
        }
        start() {
            var e, t, n;
            if ("recording" === this._state) return void this._console.log("Already recording canvas");
            if ("error" === this._state && (this._recorder = void 0, this._console.warn("Resetting from error state.")), this._recorder) return "paused" === this._state ? (this.dispatchEvent({
                type: "starting"
            }), void this._recorder.resume()) : void this._console.warn("Canvas recorder unknown state", this._state);
            if ("paused" === this._state) return this.dispatchEvent({
                type: "starting"
            }), void(this._state = "recording");
            const r = {
                mimeType: this._options.mimeType,
                videoBitsPerSecond: this._options.videoBitsPerSecond
            };
            if (this._currentRecording = [], this._currentImages = [], this._frameCount = 0, null === (e = r.mimeType) || void 0 === e ? void 0 : e.startsWith("video")) {
                if (!window.MediaRecorder) return this._console.error("MediaRecorder not supported, use image sequence"), void(this._state = "error"); {
                    const e = this._canvas.captureStream(this.stepMode ? 0 : this._options.frameRate),
                        n = null === (t = e.getVideoTracks()) || void 0 === t ? void 0 : t[0];
                    this._track = n, this._recorder = new window.MediaRecorder(e, r), this._recorder.onstop = this._onstop, this._recorder.ondataavailable = this._ondataavailable, this._recorder.onerror = this._onerror, this._recorder.onresume = this._onresume, this._recorder.onstart = this._onstart
                }
            }
            this.dispatchEvent({
                type: "starting"
            }), this._recorder ? (this._state = "recording", null === (n = this._recorder) || void 0 === n || n.start()) : window.showDirectoryPicker && window.showDirectoryPicker().then((async e => {
                const t = await (null == e ? void 0 : e.getDirectoryHandle("i-" + Math.floor(Date.now()), {
                    create: !0
                }));
                this._imgDirectory = t, this._state = "recording", this._onstart({})
            })).catch((e => {
                this._onerror({
                    detail: e
                })
            }))
        }
        async requestFrame() {
            if ("recording" !== this._state) return;
            this._frameCount++;
            const e = this._options.mimeType;
            if (!this._recorder && e.startsWith("image/")) {
                const t = this._canvas.toDataURL(e, 90);
                this._currentImages.push(["frame_" + String(this._frameCount).padStart(5, "0") + (e.includes("png") ? ".png" : ".jpg"), t]), this._currentImages.length > 60 && (this._writeImages([...this._currentImages]), this._currentImages = [])
            }
            this._recorder && this._track && this.stepMode && (this._resumeSyncTime = Ct(), this._track.requestFrame(), this._recorder.resume())
        }
        pause() {
            "paused" !== this._state && "stopped" !== this._state && (this._recorder ? this._recorder.pause() : this._state = "paused")
        }
        stop(e) {
            "stopped" !== this._state && ("error" !== this._state ? (this._recordingCallback = e, this.dispatchEvent({
                type: "stopping"
            }), this._recorder ? this._recorder.stop() : this._onstop({})) : this._console.error("Recorder in error state, cannot stop, call start again."))
        }
        get state() {
            return this._state
        }
        dispose() {
            this._recorder && "error" !== this._state ? this.stop((e => {
                this._console.warn("disposed with blob", e), this.dispose()
            })) : this._recorder = void 0
        }
        async _writeImages(e) {
            if (!this._imgDirectory) return;
            const t = await Promise.all(e.map((async ([e, t]) => await (await fetch(t)).blob()))),
                n = [];
            for (let r = 0; r < e.length; r++) {
                const i = await this._imgDirectory.getFileHandle(e[r][0], {
                    create: !0
                });
                n.push(ZM(i, t[r]))
            }
            await Promise.all(n)
        }
        static GetSupportedMimeTypes(e, t, n = !1) {
            if (!window.MediaRecorder) return n ? void 0 : [];
            const r = ["webm", "ogg", "mp4", "x-matroska"].filter((t => !e || e.length < 1 || e.includes(t))),
                i = ["vp9", "vp9.0", "vp8", "vp8.0", "avc1", "av1", "h265", "h.265", "h264", "h.264", "opus"].filter((e => !t || t.length < 1 || t.includes(e))),
                s = [];
            return r.forEach((e => {
                const t = `video/${e}`;
                i.forEach((e => {
                    [`${t};codecs=${e}`, `${t};codecs:${e}`, `${t};codecs=${e.toUpperCase()}`, `${t};codecs:${e.toUpperCase()}`, `${t}`].forEach((e => {
                        MediaRecorder.isTypeSupported(e) && s.push(e)
                    }))
                }))
            })), n ? s.length > 0 ? s[0] : void 0 : s
        }
    }
    var QM = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class eT extends Gs {
        constructor() {
            super(...arguments), this.enabled = !0, this.convergeMode = !1, this.mimeType = "auto", this.videoFrameRate = 30, this._renderToScreenDisabled = !1, this._preRender = () => {
                var e, t, n;
                if (this.convergeMode && (null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording())) {
                    const e = this._viewer.renderer.composer.renderToScreen;
                    this._viewer.renderer.composer.renderToScreen = (null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(co)) || void 0 === n ? void 0 : n.isConverged()) || !1, e && !this._viewer.renderer.composer.renderToScreen && (this._renderToScreenDisabled = !0)
                }
            }, this._postRender = () => {
                var e, t, n;
                if ((null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording()) && (!this.convergeMode || (null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(co)) || void 0 === n ? void 0 : n.isConverged(!0)))) {
                    const e = () => {
                        var e;
                        return null === (e = this._recorder) || void 0 === e ? void 0 : e.requestFrame()
                    };
                    this.convergeMode ? _c(1).then(e) : e()
                }
                this._renderToScreenDisabled && (this._viewer.renderer.composer.renderToScreen = !0)
            }
        }
        get recorder() {
            return this._recorder
        }
        isRecording() {
            var e, t;
            return null !== (t = null === (e = this._recorder) || void 0 === e ? void 0 : e.isRecording()) && void 0 !== t && t
        }
        refreshRecorderOptions() {
            this._recorder && (this._recorder.setOptions({
                frameRate: this.videoFrameRate,
                mimeType: this.mimeType
            }), this._recorder.stepMode = this.convergeMode)
        }
        async onAdded(e) {
            await super.onAdded(e), this._recorder = new $M(e.canvas, {
                frameRate: this.videoFrameRate,
                mimeType: this.mimeType
            }), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), this._recorder.addEventListener("starting", (() => this._stateChange(!1))), this._recorder.addEventListener("start", (() => {
                this.dispatchEvent({
                    type: "start"
                }), this._stateChange(!this.convergeMode)
            })), this._recorder.addEventListener("error", (() => {
                this.dispatchEvent({
                    type: "error"
                })
            })), this._recorder.addEventListener("pause", (() => this._stateChange(!1))), this._recorder.addEventListener("resume", (() => this._stateChange(!this.convergeMode))), this._recorder.addEventListener("stop", (() => {
                this.dispatchEvent({
                    type: "stop"
                }), this._stateChange(!1)
            }))
        }
        _stateChange(e) {
            var t, n, r;
            this.dirty = e, null === (t = this._viewer) || void 0 === t || t.setDirty(), null === (r = null === (n = this._uiConfig) || void 0 === n ? void 0 : n.children) || void 0 === r || r.map((e => x(e))).flat(2).forEach((e => {
                var t;
                return null === (t = null == e ? void 0 : e.uiRefresh) || void 0 === t ? void 0 : t.call(e)
            }))
        }
        async onRemove(e) {
            var t;
            return e.removeEventListener("preRender", this._preRender), e.removeEventListener("preRender", this._postRender), null === (t = this._recorder) || void 0 === t || t.dispose(), super.onRemove(e)
        }
        startRecording() {
            var e;
            return !!this.enabled && !1 === (null === (e = this.recorder) || void 0 === e ? void 0 : e.isRecording()) && (this.recorder.stepMode = this.convergeMode, this.recorder.start(), !0)
        }
        async stopRecording() {
            var e;
            if (null === (e = this.recorder) || void 0 === e ? void 0 : e.isRecording()) return new Promise(((e, t) => {
                var n;
                return null === (n = this.recorder) || void 0 === n ? void 0 : n.stop(e)
            }))
        }
        get uiConfig() {
            var e;
            if (this._uiConfig) return this._uiConfig;
            const t = this;
            return this._uiConfig = {
                type: "folder",
                label: "Recorder",
                children: [{
                    label: "Quality",
                    type: "slider",
                    bounds: [.1, 4],
                    stepSize: .5,
                    limitedUi: !0,
                    property: [null === (e = this._viewer) || void 0 === e ? void 0 : e.renderer, "displayCanvasScaling"]
                }, {
                    type: "slider",
                    label: "Frame Rate",
                    bounds: [1, 60],
                    stepSize: 1,
                    property: [this, "videoFrameRate"]
                }, {
                    type: "checkbox",
                    limitedUi: !0,
                    property: [this, "convergeMode"]
                }, {
                    type: "dropdown",
                    label: "Mime type",
                    limitedUi: !0,
                    property: [this, "mimeType"],
                    children: [
                        ["Auto Video (x264)", "auto"],
                        ["PNG sequence", "image/png"],
                        ["JPEG sequence", "image/jpeg"]
                    ].map((e => ({
                        label: e[0],
                        value: e[1]
                    })))
                }, {
                    type: "input",
                    disabled: !0,
                    label: "State",
                    limitedUi: !0,
                    get value() {
                        var e, n;
                        return null !== (n = null === (e = t.recorder) || void 0 === e ? void 0 : e.state) && void 0 !== n ? n : "not initialized"
                    },
                    set value(e) {}
                }, {
                    type: "button",
                    get label() {
                        var e;
                        return (null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) ? "Stop" : "Start"
                    },
                    value: () => {
                        var e;
                        (null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) ? this.stopRecording().then((e => {
                            if (e) {
                                console.log(e);
                                const t = e.type.split(";")[0].split("/").pop() || "mp4";
                                vt(e, "test." + t)
                            }
                        })): this.startRecording()
                    }
                }, {
                    type: "button",
                    limitedUi: !0,
                    label: "Record Camera Views",
                    hidden: () => {
                        var e, n;
                        return !!(null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) || !(null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("CameraViews"))
                    },
                    value: () => {
                        var e, t;
                        null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("CameraViews")) || void 0 === t || t.recordAllViews()
                    }
                }, {
                    type: "button",
                    limitedUi: !0,
                    label: "Record Camera Views + GLTF Anim",
                    hidden: () => {
                        var e, n, r, i;
                        return !!(null === (e = t.recorder) || void 0 === e ? void 0 : e.isRecording()) || !(null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("CameraViews")) || !(null === (i = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("GLTFAnimation")) || void 0 === i ? void 0 : i.animations.length)
                    },
                    value: () => {
                        var e, t, n, r;
                        const i = "playing" === (null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t ? void 0 : t.animationState);
                        null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getPluginByType("CameraViews")) || void 0 === r || r.recordAllViews((() => {
                            var e, t;
                            null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t || t.playAnimation()
                        })).then((() => {
                            var e, t;
                            i || null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("GLTFAnimation")) || void 0 === t || t.stopAnimation()
                        }))
                    }
                }]
            }
        }
    }
    eT.PluginType = "CanvasRecorder", QM([C(eT.prototype.refreshRecorderOptions)], eT.prototype, "convergeMode", void 0), QM([C(eT.prototype.refreshRecorderOptions)], eT.prototype, "mimeType", void 0), QM([C(eT.prototype.refreshRecorderOptions)], eT.prototype, "videoFrameRate", void 0);
    var tT = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    const nT = new i.jyz({
        uniforms: {
            tDiffuse: {
                value: null
            },
            h: {
                value: 1 / 512
            }
        },
        vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float h;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
    });
    nT.depthTest = !1;
    const rT = new i.jyz({
        uniforms: {
            tDiffuse: {
                value: null
            },
            v: {
                value: 1 / 512
            }
        },
        vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float v;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
    });
    rT.depthTest = !1;
    class iT extends q_ {
        constructor(e = {}, t = !1) {
            super(e), this.contactShadows = !0, this.blurAmount = 1, this.shadowScale = 1, this.shadowHeight = 5, this.shadowCamera = new i.iKG(-1, 1, 1, -1, .001, this.shadowHeight), this._refreshShadowCameraFrustum = this._refreshShadowCameraFrustum.bind(this), this.refreshOptions = this.refreshOptions.bind(this), this._showDebug = t, t && this.dependencies.push(j_)
        }
        async onAdded(e) {
            const t = e.renderer.createTarget({
                type: i.ywz,
                format: i.wk1,
                encoding: i.rnI,
                size: {
                    width: 512,
                    height: 512
                },
                generateMipmaps: !1,
                depthBuffer: !0,
                minFilter: i.wem,
                magFilter: i.wem,
                isAntialiased: !1
            });
            t.texture.name = "groundContactDepthTexture";
            const n = new i.lRF({
                depthPacking: i.z81
            });
            n.onBeforeCompile = function(e) {
                e.uniforms.opacity.value = 1, e.fragmentShader = `\n\t\t\t\t\t\t${e.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );","gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), 1.0 );")}\n\t\t\t\t\t`
            };
            const r = new qs(t, n, new ve(0, 0, 0), 0);
            this._depthPass = r, await super.onAdded(e)
        }
        _postFrame() {
            super._postFrame(), this._viewer
        }
        _preRender() {
            if (super._preRender(), !this._viewer) return;
            if (!this._depthPass) return;
            this._depthPass.scene = this._viewer.scene.modelObject, this._depthPass.camera = this.shadowCamera, this._depthPass.render(this._viewer.renderer.rendererObject);
            const e = this._viewer.renderer.getTempTarget({
                type: i.ywz,
                format: i.wk1,
                encoding: i.rnI,
                size: {
                    width: 1024,
                    height: 1024
                },
                generateMipmaps: !1,
                depthBuffer: !1,
                minFilter: i.wem,
                magFilter: i.wem,
                isAntialiased: !1
            });
            this._blurShadow(e), this._blurShadow(e, .4), this._viewer.renderer.releaseTempTarget(e)
        }
        _blurShadow(e, t = 1) {
            this._viewer && this._depthPass && (nT.uniforms.h.value = t * this.blurAmount / 256, rT.uniforms.v.value = t * this.blurAmount / 256, this._viewer.renderer.blit(this._depthPass.target.texture, e, {
                material: nT,
                clear: !0
            }), this._viewer.renderer.blit(e.texture, this._depthPass.target, {
                material: rT,
                clear: !0
            }))
        }
        async onDispose(e) {
            return super.onDispose(e)
        }
        async onRemove(e) {
            return super.onRemove(e)
        }
        _refreshTransform() {
            super._refreshTransform(), this._mesh && this._viewer && (this.shadowCamera.position.copy(this._mesh.getWorldPosition(new i.Pa4)), this.shadowCamera.setRotationFromEuler(new i.USm(Math.PI / 2, 0, 0)), this.shadowCamera.updateMatrixWorld(), this._refreshShadowCameraFrustum(), this._mesh.scale.y = -this.size)
        }
        _refreshShadowCameraFrustum() {
            this.shadowCamera && (this.shadowCamera.left = -this.size / (2 * this.shadowScale), this.shadowCamera.right = this.size / (2 * this.shadowScale), this.shadowCamera.top = this.size / (2 * this.shadowScale), this.shadowCamera.bottom = -this.size / (2 * this.shadowScale), this.shadowCamera.far = this.shadowHeight, this.shadowCamera.updateProjectionMatrix(), this._setDirty())
        }
        _setDirty() {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setDirty()
        }
        _removeMaterial() {
            this._material && super._removeMaterial()
        }
        refreshOptions() {
            this._viewer && super.refreshOptions()
        }
        _refreshMaterial() {
            var e;
            if (!this._viewer) return !1;
            const t = super._refreshMaterial();
            return this._material ? (this._material.alphaMap = (null === (e = this._depthPass) || void 0 === e ? void 0 : e.target.texture) || null, t && (this._material.roughness = 1, this._material.metalness = 0, this._material.color.set(1118481), this._material.transparent = !0, this._material.materialObject.userData.ssreflDisabled = !0, this._material.materialObject.userData.ssreflNonPhysical = !1), t) : t
        }
        _extraUiConfig() {
            return [{
                label: "Contact Shadows",
                type: "checkbox",
                property: [this, "contactShadows"]
            }, {
                label: "Shadow Scale",
                type: "slider",
                bounds: [0, 2],
                property: [this, "shadowScale"]
            }, {
                label: "Shadow Height",
                type: "slider",
                bounds: [0, 20],
                property: [this, "shadowHeight"]
            }, {
                label: "Blur Amount",
                type: "slider",
                bounds: [0, 10],
                property: [this, "blurAmount"]
            }, ...super._extraUiConfig()]
        }
    }
    iT.PluginType = "ContactShadowGroundPlugin", tT([C(iT.prototype.refreshOptions), xe()], iT.prototype, "contactShadows", void 0), tT([xe(), C(iT.prototype._setDirty)], iT.prototype, "blurAmount", void 0), tT([xe(), C(iT.prototype._refreshShadowCameraFrustum)], iT.prototype, "shadowScale", void 0), tT([xe(), C(iT.prototype._refreshShadowCameraFrustum)], iT.prototype, "shadowHeight", void 0);
    const sT = new i.cPb(45, 1, .1, 1e3);

    function oT(e, t, n, r = 7, s = new i.Pa4(0, 0, 1.5)) {
        n = null != n ? n : e.scene;
        const o = (new P).expandByObject(null != n ? n : t, !0, !0),
            a = o.getCenter(new i.Pa4),
            l = o.getSize(new i.Pa4);
        sT.position.copy(a).add(s.clone().multiplyScalar(Math.max(l.x, l.y, l.z))), sT.lookAt(a), t && t.traverseVisible((e => {
            e.layers.enable(r)
        })), r > 0 ? sT.layers.set(r) : sT.layers.enableAll();
        const c = null == t ? void 0 : t.visible;
        t && (t.visible = !0), e.renderer.rendererObject.setRenderTarget(null), e.renderer.rendererObject.render(n, sT);
        const u = e.renderer.rendererObject.domElement.toDataURL("image/png");
        return t && (t.visible = c, t.traverseVisible((e => {
            e.layers.disable(r)
        })), sT.layers.enableAll()), e.setDirty(), u
    }
    class aT {
        constructor(e) {
            this.viewer = e, this._lights = [], this.shapes = {
                sphere: new i.Kj0(new i.xo$(1)),
                cube: new i.Kj0(new i.DvJ(1, 1, 1)),
                cylinder: new i.Kj0(new i.fHI(.5, .5, 1))
            };
            const t = new i.xsS;
            this._channel = 7;
            const n = new i.vmT(16777215, 4473924, 1);
            n.position.set(0, 10, 0), n.layers.set(this._channel), t.add(n), this._lights.push(n), this._scene = t
        }
        dispose() {
            this._lights.forEach((e => e.dispose())), Object.values(this.shapes).forEach((e => {
                e.geometry && e.geometry.dispose()
            }))
        }
        generate(e, t = "sphere") {
            const n = this.shapes[t] || new i.Kj0(new i.xo$(1));
            n.material = e.materialObject, this._scene.add(n), this._scene.environment = this.viewer.scene.getEnvironment();
            const r = n.material.envMapIntensity;
            "number" == typeof r && (n.material.envMapIntensity = Math.max(r, 2));
            const s = oT(this.viewer, n, this._scene, this._channel, new i.Pa4(0, 0, 1.5));
            return "number" == typeof r && (n.material.envMapIntensity = r), this._scene.remove(n), n.material = void 0, s
        }
    }
    class lT extends Gs {
        constructor() {
            super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this._refreshUiConfig = () => {
                var e, t;
                this.enabled && (null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e))
            }, this.dependencies = [Vs], this.variations = [], this._selectedMaterial = () => {
                var e, t;
                return (null === (t = null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject()) || void 0 === t ? void 0 : t.material) || void 0
            }, this.uiConfig = {
                label: "Material Configurator",
                type: "folder",
                children: [() => {
                    var e;
                    return [{
                        type: "input",
                        label: "uuid",
                        property: [this._selectedMaterial(), "uuid"],
                        hidden: () => !this._selectedMaterial(),
                        disabled: !0
                    }, {
                        type: "input",
                        label: "title",
                        hidden: () => !this._selectedMaterial(),
                        property: () => [this.getSelectedVariation(), "title"],
                        onChange: async () => this.refreshUi()
                    }, {
                        type: "dropdown",
                        label: "Preview Type",
                        hidden: () => !this._selectedMaterial(),
                        property: () => [this.getSelectedVariation(), "preview"],
                        onChange: async () => this.refreshUi(),
                        children: ["generate:sphere", "generate:cube", "color", "map", "emissive", ...Object.keys(Ht).filter((e => e.endsWith("Map")))].map((e => ({
                            label: e,
                            value: e
                        })))
                    }, ...(null === (e = this.getSelectedVariation()) || void 0 === e ? void 0 : e.materials.map((e => Object.assign(e.uiConfig, {
                        expanded: !1
                    })))) || [], {
                        type: "button",
                        label: "Remove All",
                        hidden: () => !this._selectedMaterial(),
                        value: () => {
                            const e = this.getSelectedVariation();
                            e && confirm("Remove all for this material?") && (e.materials = []), this.refreshUi()
                        }
                    }, {
                        type: "button",
                        label: "Remove Variation",
                        hidden: () => !this._selectedMaterial(),
                        value: () => {
                            const e = this.getSelectedVariation();
                            e && confirm("Remove this variation?") && this.removeVariation(e)
                        }
                    }, {
                        type: "button",
                        label: "Add Variation",
                        hidden: () => !this._selectedMaterial(),
                        value: () => this.addVariation(this._selectedMaterial())
                    }, {
                        type: "button",
                        label: "Refresh Ui",
                        value: () => this.refreshUi()
                    }]
                }]
            }
        }
        async onAdded(e) {
            var t, n;
            await super.onAdded(e), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), this._previewGenerator = new aT(this._viewer), null === (n = this._picking) || void 0 === n || n.addEventListener("selectedObjectChanged", this._refreshUiConfig), e.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi)
        }
        async onRemove(e) {
            var t, n;
            return null === (t = this._previewGenerator) || void 0 === t || t.dispose(), this._previewGenerator = void 0, null === (n = this._picking) || void 0 === n || n.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e)
        }
        findVariation(e) {
            return e ? this.variations.find((t => t.uuid === e)) : void 0
        }
        getSelectedVariation() {
            var e, t;
            return this.findVariation(null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.uuid) || this.findVariation(null === (t = this._selectedMaterial()) || void 0 === t ? void 0 : t.name)
        }
        applyVariation(e, t) {
            var n, r;
            const i = e.materials.find((e => e.uuid === t));
            if (i) {
                const t = null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.getManager()) || void 0 === r ? void 0 : r.materials;
                let s = null == t ? void 0 : t.findMaterialsByName(e.uuid);
                (!s || s.length < 1) && (s = [null == t ? void 0 : t.findMaterial(e.uuid)]), s.forEach((e => {
                    if (!e) return;
                    const t = e.name;
                    e.copyProps(i), e.name = t
                }))
            }
        }
        refreshUi() {
            this.enabled && (this._uiNeedRefresh = !0)
        }
        async _refreshUi() {
            return !(!this.enabled || !this._viewer || !this._uiNeedRefresh || (this._uiNeedRefresh = !1, this._refreshUiConfig(), 0))
        }
        removeVariationForMaterial(e) {
            let t = this.findVariation(e.uuid);
            !t && e.name.length > 0 && (t = this.findVariation(e.name)), t && this.removeVariation(t)
        }
        removeVariation(e) {
            e && (this.variations.splice(this.variations.indexOf(e), 1), this.refreshUi())
        }
        addVariation(e) {
            var t;
            const n = null === (t = null == e ? void 0 : e.clone) || void 0 === t ? void 0 : t.call(e);
            if (e && n) {
                let t = this.findVariation(e.uuid);
                !t && e.name.length > 0 && (t = this.findVariation(e.name)), t || this.variations.push(t = {
                    uuid: e.name.length > 0 ? e.name : e.uuid,
                    title: "Name",
                    preview: "generate:sphere",
                    materials: []
                }), t.materials.push(n), this.refreshUi()
            }
        }
    }
    lT.PluginType = "MaterialConfiguratorBasePlugin",
        function(e, t, n, r) {
            var i, s = arguments.length,
                o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
            else
                for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
            s > 3 && o && Object.defineProperty(t, n, o)
        }([xe()], lT.prototype, "variations", void 0);
    const cT = (e, t = !0) => {
            const n = (new ve).set(e);
            return t && n.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${n.getHexString()}'/%3E%3C/svg%3E%0A`
        },
        uT = (e, t = !0) => {
            const n = (new ve).set(e);
            return t && n.convertLinearToSRGB(), `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${n.getHexString()}'/%3E%3C/svg%3E%0A`
        },
        pT = e => `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${e}%3C/text%3E%3C/svg%3E%0A`,
        hT = async (e, t) => Ot(await St(e), t),
        dT = async (e, t) => await hT(e, t).then((e => e.toDataURL("image/png")));
    class fT {
        static _initialize() {
            this._inited = !0, Mt(T `
  .customContextGrid {
    background: #28223C;
    //backdrop-filter: blur(8px);
    border: 0.5px solid rgba(220, 220, 220, 0.3);
    width: auto;
    height: auto;
    position: absolute;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    z-index: 200;
    padding: 0.35rem 0.35rem;
    border-radius: 0.375rem;
    min-width: 5rem;
    pointer-events: auto;
    box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);

    color: white;
    font-size: 0.65rem;
    font-family: Inter, "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
  }
  .customContextGridItems {
    background-color: transparent;
    cursor: pointer;
    border-radius: 0.25rem;
    line-height: 1rem;
    font-weight: 500;
    overflow: hidden;
    margin: 0.12rem;
  }
  .customContextGridItems:hover {
    color: white;
    background-color: #017AFF;
  }
  .customContextGridItemImage{
    width: 100%;
    height: 100%;
  }
  .customContextGridHeading{
    width: 100%;
    padding: 0.12rem;
    font-size: 0.85rem;
  }

        `)
        }
        static Create(e, t, n, r, i, s, o) {
            var a;
            this._inited || this._initialize();
            const l = Rt(),
                c = l ? .15 : .25,
                u = l ? 1.5 : 2.5,
                p = wt({
                    classList: ["customContextGrid"],
                    addToBody: !1,
                    innerHTML: `\n            <div class="customContextGridHeading"> ${t} </div>\n            `
                });
            p.style.top = i + "px", p.style.left = r + "px", p.style.gap = c + "rem", p.style.width = (u + c) * n - c + "rem", p.dataset.tag = e;
            for (const e of s) {
                const t = wt({
                    classList: ["customContextGridItems"],
                    addToBody: !1,
                    innerHTML: `\n            <img src="${e.image}" class="customContextGridItemImage">\n            `
                });
                t.style.width = u + "rem", t.style.height = u + "rem", p.appendChild(t), t.onclick = () => {
                    var t;
                    return null === (t = e.onClick) || void 0 === t ? void 0 : t.call(e, e.id)
                }, o(t, e)
            }
            return null === (a = this.Elements) || void 0 === a || a.push(p), p
        }
        static RemoveAll(e) {
            if (e) {
                const t = this.Elements.filter((t => t.dataset.tag === e));
                for (const e of t) e.remove();
                this.Elements = this.Elements.filter((t => t.dataset.tag !== e))
            } else {
                for (const e of this.Elements) e.remove();
                this.Elements = []
            }
        }
        static RebuildUi(e) {
            if (0 === this.Elements.length) return;
            e || (e = document.body);
            for (const e of this.Elements) e.remove();
            let t = 20;
            for (const n of this.Elements) n.style.top = t + "px", e.appendChild(n), t += n.clientHeight + 20
        }
    }

    function _T(e) {
        if (null == e) return window;
        if ("[object Window]" !== e.toString()) {
            var t = e.ownerDocument;
            return t && t.defaultView || window
        }
        return e
    }

    function mT(e) {
        return e instanceof _T(e).Element || e instanceof Element
    }

    function gT(e) {
        return e instanceof _T(e).HTMLElement || e instanceof HTMLElement
    }

    function vT(e) {
        return "undefined" != typeof ShadowRoot && (e instanceof _T(e).ShadowRoot || e instanceof ShadowRoot)
    }
    fT.Elements = [], fT._inited = !1;
    var bT = Math.max,
        xT = Math.min,
        yT = Math.round;

    function wT(e, t) {
        void 0 === t && (t = !1);
        var n = e.getBoundingClientRect(),
            r = 1,
            i = 1;
        if (gT(e) && t) {
            var s = e.offsetHeight,
                o = e.offsetWidth;
            o > 0 && (r = yT(n.width) / o || 1), s > 0 && (i = yT(n.height) / s || 1)
        }
        return {
            width: n.width / r,
            height: n.height / i,
            top: n.top / i,
            right: n.right / r,
            bottom: n.bottom / i,
            left: n.left / r,
            x: n.left / r,
            y: n.top / i
        }
    }

    function ST(e) {
        var t = _T(e);
        return {
            scrollLeft: t.pageXOffset,
            scrollTop: t.pageYOffset
        }
    }

    function MT(e) {
        return e ? (e.nodeName || "").toLowerCase() : null
    }

    function TT(e) {
        return ((mT(e) ? e.ownerDocument : e.document) || window.document).documentElement
    }

    function ET(e) {
        return wT(TT(e)).left + ST(e).scrollLeft
    }

    function AT(e) {
        return _T(e).getComputedStyle(e)
    }

    function CT(e) {
        var t = AT(e),
            n = t.overflow,
            r = t.overflowX,
            i = t.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + i + r)
    }

    function RT(e, t, n) {
        void 0 === n && (n = !1);
        var r, i, s = gT(t),
            o = gT(t) && function(e) {
                var t = e.getBoundingClientRect(),
                    n = yT(t.width) / e.offsetWidth || 1,
                    r = yT(t.height) / e.offsetHeight || 1;
                return 1 !== n || 1 !== r
            }(t),
            a = TT(t),
            l = wT(e, o),
            c = {
                scrollLeft: 0,
                scrollTop: 0
            },
            u = {
                x: 0,
                y: 0
            };
        return (s || !s && !n) && (("body" !== MT(t) || CT(a)) && (c = (r = t) !== _T(r) && gT(r) ? {
            scrollLeft: (i = r).scrollLeft,
            scrollTop: i.scrollTop
        } : ST(r)), gT(t) ? ((u = wT(t, !0)).x += t.clientLeft, u.y += t.clientTop) : a && (u.x = ET(a))), {
            x: l.left + c.scrollLeft - u.x,
            y: l.top + c.scrollTop - u.y,
            width: l.width,
            height: l.height
        }
    }

    function kT(e) {
        var t = wT(e),
            n = e.offsetWidth,
            r = e.offsetHeight;
        return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {
            x: e.offsetLeft,
            y: e.offsetTop,
            width: n,
            height: r
        }
    }

    function PT(e) {
        return "html" === MT(e) ? e : e.assignedSlot || e.parentNode || (vT(e) ? e.host : null) || TT(e)
    }

    function DT(e) {
        return ["html", "body", "#document"].indexOf(MT(e)) >= 0 ? e.ownerDocument.body : gT(e) && CT(e) ? e : DT(PT(e))
    }

    function OT(e, t) {
        var n;
        void 0 === t && (t = []);
        var r = DT(e),
            i = r === (null == (n = e.ownerDocument) ? void 0 : n.body),
            s = _T(r),
            o = i ? [s].concat(s.visualViewport || [], CT(r) ? r : []) : r,
            a = t.concat(o);
        return i ? a : a.concat(OT(PT(o)))
    }

    function LT(e) {
        return ["table", "td", "th"].indexOf(MT(e)) >= 0
    }

    function IT(e) {
        return gT(e) && "fixed" !== AT(e).position ? e.offsetParent : null
    }

    function FT(e) {
        for (var t = _T(e), n = IT(e); n && LT(n) && "static" === AT(n).position;) n = IT(n);
        return n && ("html" === MT(n) || "body" === MT(n) && "static" === AT(n).position) ? t : n || function(e) {
            var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
            if (-1 !== navigator.userAgent.indexOf("Trident") && gT(e) && "fixed" === AT(e).position) return null;
            var n = PT(e);
            for (vT(n) && (n = n.host); gT(n) && ["html", "body"].indexOf(MT(n)) < 0;) {
                var r = AT(n);
                if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter) return n;
                n = n.parentNode
            }
            return null
        }(e) || t
    }
    var NT = "top",
        UT = "bottom",
        BT = "right",
        jT = "left",
        zT = "auto",
        VT = [NT, UT, BT, jT],
        GT = "start",
        HT = "end",
        WT = "clippingParents",
        KT = "viewport",
        XT = "popper",
        qT = "reference",
        YT = VT.reduce((function(e, t) {
            return e.concat([t + "-" + GT, t + "-" + HT])
        }), []),
        ZT = [].concat(VT, [zT]).reduce((function(e, t) {
            return e.concat([t, t + "-" + GT, t + "-" + HT])
        }), []),
        JT = "beforeRead",
        $T = "read",
        QT = "afterRead",
        eE = "beforeMain",
        tE = "main",
        nE = "afterMain",
        rE = "beforeWrite",
        iE = "write",
        sE = "afterWrite",
        oE = [JT, $T, QT, eE, tE, nE, rE, iE, sE];

    function aE(e) {
        var t = new Map,
            n = new Set,
            r = [];

        function i(e) {
            n.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach((function(e) {
                if (!n.has(e)) {
                    var r = t.get(e);
                    r && i(r)
                }
            })), r.push(e)
        }
        return e.forEach((function(e) {
            t.set(e.name, e)
        })), e.forEach((function(e) {
            n.has(e.name) || i(e)
        })), r
    }

    function lE(e) {
        var t;
        return function() {
            return t || (t = new Promise((function(n) {
                Promise.resolve().then((function() {
                    t = void 0, n(e())
                }))
            }))), t
        }
    }
    var cE = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };

    function uE() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
        return !t.some((function(e) {
            return !(e && "function" == typeof e.getBoundingClientRect)
        }))
    }

    function pE(e) {
        void 0 === e && (e = {});
        var t = e,
            n = t.defaultModifiers,
            r = void 0 === n ? [] : n,
            i = t.defaultOptions,
            s = void 0 === i ? cE : i;
        return function(e, t, n) {
            void 0 === n && (n = s);
            var i = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign({}, cE, s),
                    modifiersData: {},
                    elements: {
                        reference: e,
                        popper: t
                    },
                    attributes: {},
                    styles: {}
                },
                o = [],
                a = !1,
                l = {
                    state: i,
                    setOptions: function(n) {
                        var a = "function" == typeof n ? n(i.options) : n;
                        c(), i.options = Object.assign({}, s, i.options, a), i.scrollParents = {
                            reference: mT(e) ? OT(e) : e.contextElement ? OT(e.contextElement) : [],
                            popper: OT(t)
                        };
                        var u, p, h = function(e) {
                            var t = aE(e);
                            return oE.reduce((function(e, n) {
                                return e.concat(t.filter((function(e) {
                                    return e.phase === n
                                })))
                            }), [])
                        }((u = [].concat(r, i.options.modifiers), p = u.reduce((function(e, t) {
                            var n = e[t.name];
                            return e[t.name] = n ? Object.assign({}, n, t, {
                                options: Object.assign({}, n.options, t.options),
                                data: Object.assign({}, n.data, t.data)
                            }) : t, e
                        }), {}), Object.keys(p).map((function(e) {
                            return p[e]
                        }))));
                        return i.orderedModifiers = h.filter((function(e) {
                            return e.enabled
                        })), i.orderedModifiers.forEach((function(e) {
                            var t = e.name,
                                n = e.options,
                                r = void 0 === n ? {} : n,
                                s = e.effect;
                            if ("function" == typeof s) {
                                var a = s({
                                    state: i,
                                    name: t,
                                    instance: l,
                                    options: r
                                });
                                o.push(a || function() {})
                            }
                        })), l.update()
                    },
                    forceUpdate: function() {
                        if (!a) {
                            var e = i.elements,
                                t = e.reference,
                                n = e.popper;
                            if (uE(t, n)) {
                                i.rects = {
                                    reference: RT(t, FT(n), "fixed" === i.options.strategy),
                                    popper: kT(n)
                                }, i.reset = !1, i.placement = i.options.placement, i.orderedModifiers.forEach((function(e) {
                                    return i.modifiersData[e.name] = Object.assign({}, e.data)
                                }));
                                for (var r = 0; r < i.orderedModifiers.length; r++)
                                    if (!0 !== i.reset) {
                                        var s = i.orderedModifiers[r],
                                            o = s.fn,
                                            c = s.options,
                                            u = void 0 === c ? {} : c,
                                            p = s.name;
                                        "function" == typeof o && (i = o({
                                            state: i,
                                            options: u,
                                            name: p,
                                            instance: l
                                        }) || i)
                                    } else i.reset = !1, r = -1
                            }
                        }
                    },
                    update: lE((function() {
                        return new Promise((function(e) {
                            l.forceUpdate(), e(i)
                        }))
                    })),
                    destroy: function() {
                        c(), a = !0
                    }
                };
            if (!uE(e, t)) return l;

            function c() {
                o.forEach((function(e) {
                    return e()
                })), o = []
            }
            return l.setOptions(n).then((function(e) {
                !a && n.onFirstUpdate && n.onFirstUpdate(e)
            })), l
        }
    }
    var hE = pE(),
        dE = {
            passive: !0
        },
        fE = {
            name: "eventListeners",
            enabled: !0,
            phase: "write",
            fn: function() {},
            effect: function(e) {
                var t = e.state,
                    n = e.instance,
                    r = e.options,
                    i = r.scroll,
                    s = void 0 === i || i,
                    o = r.resize,
                    a = void 0 === o || o,
                    l = _T(t.elements.popper),
                    c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
                return s && c.forEach((function(e) {
                        e.addEventListener("scroll", n.update, dE)
                    })), a && l.addEventListener("resize", n.update, dE),
                    function() {
                        s && c.forEach((function(e) {
                            e.removeEventListener("scroll", n.update, dE)
                        })), a && l.removeEventListener("resize", n.update, dE)
                    }
            },
            data: {}
        };

    function _E(e) {
        return e.split("-")[0]
    }

    function mE(e) {
        return e.split("-")[1]
    }

    function gE(e) {
        return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
    }

    function vE(e) {
        var t, n = e.reference,
            r = e.element,
            i = e.placement,
            s = i ? _E(i) : null,
            o = i ? mE(i) : null,
            a = n.x + n.width / 2 - r.width / 2,
            l = n.y + n.height / 2 - r.height / 2;
        switch (s) {
            case NT:
                t = {
                    x: a,
                    y: n.y - r.height
                };
                break;
            case UT:
                t = {
                    x: a,
                    y: n.y + n.height
                };
                break;
            case BT:
                t = {
                    x: n.x + n.width,
                    y: l
                };
                break;
            case jT:
                t = {
                    x: n.x - r.width,
                    y: l
                };
                break;
            default:
                t = {
                    x: n.x,
                    y: n.y
                }
        }
        var c = s ? gE(s) : null;
        if (null != c) {
            var u = "y" === c ? "height" : "width";
            switch (o) {
                case GT:
                    t[c] = t[c] - (n[u] / 2 - r[u] / 2);
                    break;
                case HT:
                    t[c] = t[c] + (n[u] / 2 - r[u] / 2)
            }
        }
        return t
    }
    var bE = {
            name: "popperOffsets",
            enabled: !0,
            phase: "read",
            fn: function(e) {
                var t = e.state,
                    n = e.name;
                t.modifiersData[n] = vE({
                    reference: t.rects.reference,
                    element: t.rects.popper,
                    strategy: "absolute",
                    placement: t.placement
                })
            },
            data: {}
        },
        xE = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };

    function yE(e) {
        var t, n = e.popper,
            r = e.popperRect,
            i = e.placement,
            s = e.variation,
            o = e.offsets,
            a = e.position,
            l = e.gpuAcceleration,
            c = e.adaptive,
            u = e.roundOffsets,
            p = e.isFixed,
            h = o.x,
            d = void 0 === h ? 0 : h,
            f = o.y,
            _ = void 0 === f ? 0 : f,
            m = "function" == typeof u ? u({
                x: d,
                y: _
            }) : {
                x: d,
                y: _
            };
        d = m.x, _ = m.y;
        var g = o.hasOwnProperty("x"),
            v = o.hasOwnProperty("y"),
            b = jT,
            x = NT,
            y = window;
        if (c) {
            var w = FT(n),
                S = "clientHeight",
                M = "clientWidth";
            w === _T(n) && "static" !== AT(w = TT(n)).position && "absolute" === a && (S = "scrollHeight", M = "scrollWidth"), w = w, (i === NT || (i === jT || i === BT) && s === HT) && (x = UT, _ -= (p && w === y && y.visualViewport ? y.visualViewport.height : w[S]) - r.height, _ *= l ? 1 : -1), i !== jT && (i !== NT && i !== UT || s !== HT) || (b = BT, d -= (p && w === y && y.visualViewport ? y.visualViewport.width : w[M]) - r.width, d *= l ? 1 : -1)
        }
        var T, E = Object.assign({
                position: a
            }, c && xE),
            A = !0 === u ? function(e) {
                var t = e.x,
                    n = e.y,
                    r = window.devicePixelRatio || 1;
                return {
                    x: yT(t * r) / r || 0,
                    y: yT(n * r) / r || 0
                }
            }({
                x: d,
                y: _
            }) : {
                x: d,
                y: _
            };
        return d = A.x, _ = A.y, l ? Object.assign({}, E, ((T = {})[x] = v ? "0" : "", T[b] = g ? "0" : "", T.transform = (y.devicePixelRatio || 1) <= 1 ? "translate(" + d + "px, " + _ + "px)" : "translate3d(" + d + "px, " + _ + "px, 0)", T)) : Object.assign({}, E, ((t = {})[x] = v ? _ + "px" : "", t[b] = g ? d + "px" : "", t.transform = "", t))
    }
    var wE = {
            name: "computeStyles",
            enabled: !0,
            phase: "beforeWrite",
            fn: function(e) {
                var t = e.state,
                    n = e.options,
                    r = n.gpuAcceleration,
                    i = void 0 === r || r,
                    s = n.adaptive,
                    o = void 0 === s || s,
                    a = n.roundOffsets,
                    l = void 0 === a || a,
                    c = {
                        placement: _E(t.placement),
                        variation: mE(t.placement),
                        popper: t.elements.popper,
                        popperRect: t.rects.popper,
                        gpuAcceleration: i,
                        isFixed: "fixed" === t.options.strategy
                    };
                null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, yE(Object.assign({}, c, {
                    offsets: t.modifiersData.popperOffsets,
                    position: t.options.strategy,
                    adaptive: o,
                    roundOffsets: l
                })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, yE(Object.assign({}, c, {
                    offsets: t.modifiersData.arrow,
                    position: "absolute",
                    adaptive: !1,
                    roundOffsets: l
                })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
                    "data-popper-placement": t.placement
                })
            },
            data: {}
        },
        SE = {
            name: "applyStyles",
            enabled: !0,
            phase: "write",
            fn: function(e) {
                var t = e.state;
                Object.keys(t.elements).forEach((function(e) {
                    var n = t.styles[e] || {},
                        r = t.attributes[e] || {},
                        i = t.elements[e];
                    gT(i) && MT(i) && (Object.assign(i.style, n), Object.keys(r).forEach((function(e) {
                        var t = r[e];
                        !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t)
                    })))
                }))
            },
            effect: function(e) {
                var t = e.state,
                    n = {
                        popper: {
                            position: t.options.strategy,
                            left: "0",
                            top: "0",
                            margin: "0"
                        },
                        arrow: {
                            position: "absolute"
                        },
                        reference: {}
                    };
                return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow),
                    function() {
                        Object.keys(t.elements).forEach((function(e) {
                            var r = t.elements[e],
                                i = t.attributes[e] || {},
                                s = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce((function(e, t) {
                                    return e[t] = "", e
                                }), {});
                            gT(r) && MT(r) && (Object.assign(r.style, s), Object.keys(i).forEach((function(e) {
                                r.removeAttribute(e)
                            })))
                        }))
                    }
            },
            requires: ["computeStyles"]
        },
        ME = {
            name: "offset",
            enabled: !0,
            phase: "main",
            requires: ["popperOffsets"],
            fn: function(e) {
                var t = e.state,
                    n = e.options,
                    r = e.name,
                    i = n.offset,
                    s = void 0 === i ? [0, 0] : i,
                    o = ZT.reduce((function(e, n) {
                        return e[n] = function(e, t, n) {
                            var r = _E(e),
                                i = [jT, NT].indexOf(r) >= 0 ? -1 : 1,
                                s = "function" == typeof n ? n(Object.assign({}, t, {
                                    placement: e
                                })) : n,
                                o = s[0],
                                a = s[1];
                            return o = o || 0, a = (a || 0) * i, [jT, BT].indexOf(r) >= 0 ? {
                                x: a,
                                y: o
                            } : {
                                x: o,
                                y: a
                            }
                        }(n, t.rects, s), e
                    }), {}),
                    a = o[t.placement],
                    l = a.x,
                    c = a.y;
                null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = o
            }
        },
        TE = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };

    function EE(e) {
        return e.replace(/left|right|bottom|top/g, (function(e) {
            return TE[e]
        }))
    }
    var AE = {
        start: "end",
        end: "start"
    };

    function CE(e) {
        return e.replace(/start|end/g, (function(e) {
            return AE[e]
        }))
    }

    function RE(e, t) {
        var n = t.getRootNode && t.getRootNode();
        if (e.contains(t)) return !0;
        if (n && vT(n)) {
            var r = t;
            do {
                if (r && e.isSameNode(r)) return !0;
                r = r.parentNode || r.host
            } while (r)
        }
        return !1
    }

    function kE(e) {
        return Object.assign({}, e, {
            left: e.x,
            top: e.y,
            right: e.x + e.width,
            bottom: e.y + e.height
        })
    }

    function PE(e, t) {
        return t === KT ? kE(function(e) {
            var t = _T(e),
                n = TT(e),
                r = t.visualViewport,
                i = n.clientWidth,
                s = n.clientHeight,
                o = 0,
                a = 0;
            return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), {
                width: i,
                height: s,
                x: o + ET(e),
                y: a
            }
        }(e)) : mT(t) ? function(e) {
            var t = wT(e);
            return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t
        }(t) : kE(function(e) {
            var t, n = TT(e),
                r = ST(e),
                i = null == (t = e.ownerDocument) ? void 0 : t.body,
                s = bT(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
                o = bT(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
                a = -r.scrollLeft + ET(e),
                l = -r.scrollTop;
            return "rtl" === AT(i || n).direction && (a += bT(n.clientWidth, i ? i.clientWidth : 0) - s), {
                width: s,
                height: o,
                x: a,
                y: l
            }
        }(TT(e)))
    }

    function DE(e) {
        return Object.assign({}, {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }, e)
    }

    function OE(e, t) {
        return t.reduce((function(t, n) {
            return t[n] = e, t
        }), {})
    }

    function LE(e, t) {
        void 0 === t && (t = {});
        var n = t,
            r = n.placement,
            i = void 0 === r ? e.placement : r,
            s = n.boundary,
            o = void 0 === s ? WT : s,
            a = n.rootBoundary,
            l = void 0 === a ? KT : a,
            c = n.elementContext,
            u = void 0 === c ? XT : c,
            p = n.altBoundary,
            h = void 0 !== p && p,
            d = n.padding,
            f = void 0 === d ? 0 : d,
            _ = DE("number" != typeof f ? f : OE(f, VT)),
            m = u === XT ? qT : XT,
            g = e.rects.popper,
            v = e.elements[h ? m : u],
            b = function(e, t, n) {
                var r = "clippingParents" === t ? function(e) {
                        var t = OT(PT(e)),
                            n = ["absolute", "fixed"].indexOf(AT(e).position) >= 0 && gT(e) ? FT(e) : e;
                        return mT(n) ? t.filter((function(e) {
                            return mT(e) && RE(e, n) && "body" !== MT(e)
                        })) : []
                    }(e) : [].concat(t),
                    i = [].concat(r, [n]),
                    s = i[0],
                    o = i.reduce((function(t, n) {
                        var r = PE(e, n);
                        return t.top = bT(r.top, t.top), t.right = xT(r.right, t.right), t.bottom = xT(r.bottom, t.bottom), t.left = bT(r.left, t.left), t
                    }), PE(e, s));
                return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o
            }(mT(v) ? v : v.contextElement || TT(e.elements.popper), o, l),
            x = wT(e.elements.reference),
            y = vE({
                reference: x,
                element: g,
                strategy: "absolute",
                placement: i
            }),
            w = kE(Object.assign({}, g, y)),
            S = u === XT ? w : x,
            M = {
                top: b.top - S.top + _.top,
                bottom: S.bottom - b.bottom + _.bottom,
                left: b.left - S.left + _.left,
                right: S.right - b.right + _.right
            },
            T = e.modifiersData.offset;
        if (u === XT && T) {
            var E = T[i];
            Object.keys(M).forEach((function(e) {
                var t = [BT, UT].indexOf(e) >= 0 ? 1 : -1,
                    n = [NT, UT].indexOf(e) >= 0 ? "y" : "x";
                M[e] += E[n] * t
            }))
        }
        return M
    }
    var IE = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function(e) {
            var t = e.state,
                n = e.options,
                r = e.name;
            if (!t.modifiersData[r]._skip) {
                for (var i = n.mainAxis, s = void 0 === i || i, o = n.altAxis, a = void 0 === o || o, l = n.fallbackPlacements, c = n.padding, u = n.boundary, p = n.rootBoundary, h = n.altBoundary, d = n.flipVariations, f = void 0 === d || d, _ = n.allowedAutoPlacements, m = t.options.placement, g = _E(m), v = l || (g !== m && f ? function(e) {
                        if (_E(e) === zT) return [];
                        var t = EE(e);
                        return [CE(e), t, CE(t)]
                    }(m) : [EE(m)]), b = [m].concat(v).reduce((function(e, n) {
                        return e.concat(_E(n) === zT ? function(e, t) {
                            void 0 === t && (t = {});
                            var n = t,
                                r = n.placement,
                                i = n.boundary,
                                s = n.rootBoundary,
                                o = n.padding,
                                a = n.flipVariations,
                                l = n.allowedAutoPlacements,
                                c = void 0 === l ? ZT : l,
                                u = mE(r),
                                p = u ? a ? YT : YT.filter((function(e) {
                                    return mE(e) === u
                                })) : VT,
                                h = p.filter((function(e) {
                                    return c.indexOf(e) >= 0
                                }));
                            0 === h.length && (h = p);
                            var d = h.reduce((function(t, n) {
                                return t[n] = LE(e, {
                                    placement: n,
                                    boundary: i,
                                    rootBoundary: s,
                                    padding: o
                                })[_E(n)], t
                            }), {});
                            return Object.keys(d).sort((function(e, t) {
                                return d[e] - d[t]
                            }))
                        }(t, {
                            placement: n,
                            boundary: u,
                            rootBoundary: p,
                            padding: c,
                            flipVariations: f,
                            allowedAutoPlacements: _
                        }) : n)
                    }), []), x = t.rects.reference, y = t.rects.popper, w = new Map, S = !0, M = b[0], T = 0; T < b.length; T++) {
                    var E = b[T],
                        A = _E(E),
                        C = mE(E) === GT,
                        R = [NT, UT].indexOf(A) >= 0,
                        k = R ? "width" : "height",
                        P = LE(t, {
                            placement: E,
                            boundary: u,
                            rootBoundary: p,
                            altBoundary: h,
                            padding: c
                        }),
                        D = R ? C ? BT : jT : C ? UT : NT;
                    x[k] > y[k] && (D = EE(D));
                    var O = EE(D),
                        L = [];
                    if (s && L.push(P[A] <= 0), a && L.push(P[D] <= 0, P[O] <= 0), L.every((function(e) {
                            return e
                        }))) {
                        M = E, S = !1;
                        break
                    }
                    w.set(E, L)
                }
                if (S)
                    for (var I = function(e) {
                            var t = b.find((function(t) {
                                var n = w.get(t);
                                if (n) return n.slice(0, e).every((function(e) {
                                    return e
                                }))
                            }));
                            if (t) return M = t, "break"
                        }, F = f ? 3 : 1; F > 0 && "break" !== I(F); F--);
                t.placement !== M && (t.modifiersData[r]._skip = !0, t.placement = M, t.reset = !0)
            }
        },
        requiresIfExists: ["offset"],
        data: {
            _skip: !1
        }
    };

    function FE(e, t, n) {
        return bT(e, xT(t, n))
    }
    var NE = {
            name: "preventOverflow",
            enabled: !0,
            phase: "main",
            fn: function(e) {
                var t = e.state,
                    n = e.options,
                    r = e.name,
                    i = n.mainAxis,
                    s = void 0 === i || i,
                    o = n.altAxis,
                    a = void 0 !== o && o,
                    l = n.boundary,
                    c = n.rootBoundary,
                    u = n.altBoundary,
                    p = n.padding,
                    h = n.tether,
                    d = void 0 === h || h,
                    f = n.tetherOffset,
                    _ = void 0 === f ? 0 : f,
                    m = LE(t, {
                        boundary: l,
                        rootBoundary: c,
                        padding: p,
                        altBoundary: u
                    }),
                    g = _E(t.placement),
                    v = mE(t.placement),
                    b = !v,
                    x = gE(g),
                    y = "x" === x ? "y" : "x",
                    w = t.modifiersData.popperOffsets,
                    S = t.rects.reference,
                    M = t.rects.popper,
                    T = "function" == typeof _ ? _(Object.assign({}, t.rects, {
                        placement: t.placement
                    })) : _,
                    E = "number" == typeof T ? {
                        mainAxis: T,
                        altAxis: T
                    } : Object.assign({
                        mainAxis: 0,
                        altAxis: 0
                    }, T),
                    A = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
                    C = {
                        x: 0,
                        y: 0
                    };
                if (w) {
                    if (s) {
                        var R, k = "y" === x ? NT : jT,
                            P = "y" === x ? UT : BT,
                            D = "y" === x ? "height" : "width",
                            O = w[x],
                            L = O + m[k],
                            I = O - m[P],
                            F = d ? -M[D] / 2 : 0,
                            N = v === GT ? S[D] : M[D],
                            U = v === GT ? -M[D] : -S[D],
                            B = t.elements.arrow,
                            j = d && B ? kT(B) : {
                                width: 0,
                                height: 0
                            },
                            z = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 0
                            },
                            V = z[k],
                            G = z[P],
                            H = FE(0, S[D], j[D]),
                            W = b ? S[D] / 2 - F - H - V - E.mainAxis : N - H - V - E.mainAxis,
                            K = b ? -S[D] / 2 + F + H + G + E.mainAxis : U + H + G + E.mainAxis,
                            X = t.elements.arrow && FT(t.elements.arrow),
                            q = X ? "y" === x ? X.clientTop || 0 : X.clientLeft || 0 : 0,
                            Y = null != (R = null == A ? void 0 : A[x]) ? R : 0,
                            Z = O + K - Y,
                            J = FE(d ? xT(L, O + W - Y - q) : L, O, d ? bT(I, Z) : I);
                        w[x] = J, C[x] = J - O
                    }
                    if (a) {
                        var $, Q = "x" === x ? NT : jT,
                            ee = "x" === x ? UT : BT,
                            te = w[y],
                            ne = "y" === y ? "height" : "width",
                            re = te + m[Q],
                            ie = te - m[ee],
                            se = -1 !== [NT, jT].indexOf(g),
                            oe = null != ($ = null == A ? void 0 : A[y]) ? $ : 0,
                            ae = se ? re : te - S[ne] - M[ne] - oe + E.altAxis,
                            le = se ? te + S[ne] + M[ne] - oe - E.altAxis : ie,
                            ce = d && se ? function(e, t, n) {
                                var r = FE(e, t, n);
                                return r > n ? n : r
                            }(ae, te, le) : FE(d ? ae : re, te, d ? le : ie);
                        w[y] = ce, C[y] = ce - te
                    }
                    t.modifiersData[r] = C
                }
            },
            requiresIfExists: ["offset"]
        },
        UE = {
            name: "arrow",
            enabled: !0,
            phase: "main",
            fn: function(e) {
                var t, n = e.state,
                    r = e.name,
                    i = e.options,
                    s = n.elements.arrow,
                    o = n.modifiersData.popperOffsets,
                    a = _E(n.placement),
                    l = gE(a),
                    c = [jT, BT].indexOf(a) >= 0 ? "height" : "width";
                if (s && o) {
                    var u = function(e, t) {
                            return DE("number" != typeof(e = "function" == typeof e ? e(Object.assign({}, t.rects, {
                                placement: t.placement
                            })) : e) ? e : OE(e, VT))
                        }(i.padding, n),
                        p = kT(s),
                        h = "y" === l ? NT : jT,
                        d = "y" === l ? UT : BT,
                        f = n.rects.reference[c] + n.rects.reference[l] - o[l] - n.rects.popper[c],
                        _ = o[l] - n.rects.reference[l],
                        m = FT(s),
                        g = m ? "y" === l ? m.clientHeight || 0 : m.clientWidth || 0 : 0,
                        v = f / 2 - _ / 2,
                        b = u[h],
                        x = g - p[c] - u[d],
                        y = g / 2 - p[c] / 2 + v,
                        w = FE(b, y, x),
                        S = l;
                    n.modifiersData[r] = ((t = {})[S] = w, t.centerOffset = w - y, t)
                }
            },
            effect: function(e) {
                var t = e.state,
                    n = e.options.element,
                    r = void 0 === n ? "[data-popper-arrow]" : n;
                null != r && ("string" != typeof r || (r = t.elements.popper.querySelector(r))) && RE(t.elements.popper, r) && (t.elements.arrow = r)
            },
            requires: ["popperOffsets"],
            requiresIfExists: ["preventOverflow"]
        };

    function BE(e, t, n) {
        return void 0 === n && (n = {
            x: 0,
            y: 0
        }), {
            top: e.top - t.height - n.y,
            right: e.right - t.width + n.x,
            bottom: e.bottom - t.height + n.y,
            left: e.left - t.width - n.x
        }
    }

    function jE(e) {
        return [NT, BT, UT, jT].some((function(t) {
            return e[t] >= 0
        }))
    }
    var zE = {
            name: "hide",
            enabled: !0,
            phase: "main",
            requiresIfExists: ["preventOverflow"],
            fn: function(e) {
                var t = e.state,
                    n = e.name,
                    r = t.rects.reference,
                    i = t.rects.popper,
                    s = t.modifiersData.preventOverflow,
                    o = LE(t, {
                        elementContext: "reference"
                    }),
                    a = LE(t, {
                        altBoundary: !0
                    }),
                    l = BE(o, r),
                    c = BE(a, i, s),
                    u = jE(l),
                    p = jE(c);
                t.modifiersData[n] = {
                    referenceClippingOffsets: l,
                    popperEscapeOffsets: c,
                    isReferenceHidden: u,
                    hasPopperEscaped: p
                }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
                    "data-popper-reference-hidden": u,
                    "data-popper-escaped": p
                })
            }
        },
        VE = pE({
            defaultModifiers: [fE, bE, wE, SE, ME, IE, NE, UE, zE]
        }),
        GE = "tippy-content",
        HE = "tippy-arrow",
        WE = "tippy-svg-arrow",
        KE = {
            passive: !0,
            capture: !0
        },
        XE = function() {
            return document.body
        };

    function qE(e, t, n) {
        if (Array.isArray(e)) {
            var r = e[t];
            return null == r ? Array.isArray(n) ? n[t] : n : r
        }
        return e
    }

    function YE(e, t) {
        var n = {}.toString.call(e);
        return 0 === n.indexOf("[object") && n.indexOf(t + "]") > -1
    }

    function ZE(e, t) {
        return "function" == typeof e ? e.apply(void 0, t) : e
    }

    function JE(e, t) {
        return 0 === t ? e : function(r) {
            clearTimeout(n), n = setTimeout((function() {
                e(r)
            }), t)
        };
        var n
    }

    function $E(e) {
        return [].concat(e)
    }

    function QE(e, t) {
        -1 === e.indexOf(t) && e.push(t)
    }

    function eA(e) {
        return [].slice.call(e)
    }

    function tA(e) {
        return Object.keys(e).reduce((function(t, n) {
            return void 0 !== e[n] && (t[n] = e[n]), t
        }), {})
    }

    function nA() {
        return document.createElement("div")
    }

    function rA(e) {
        return ["Element", "Fragment"].some((function(t) {
            return YE(e, t)
        }))
    }

    function iA(e, t) {
        e.forEach((function(e) {
            e && (e.style.transitionDuration = t + "ms")
        }))
    }

    function sA(e, t) {
        e.forEach((function(e) {
            e && e.setAttribute("data-state", t)
        }))
    }

    function oA(e, t, n) {
        var r = t + "EventListener";
        ["transitionend", "webkitTransitionEnd"].forEach((function(t) {
            e[r](t, n)
        }))
    }

    function aA(e, t) {
        for (var n = t; n;) {
            var r;
            if (e.contains(n)) return !0;
            n = null == n.getRootNode || null == (r = n.getRootNode()) ? void 0 : r.host
        }
        return !1
    }
    var lA = {
            isTouch: !1
        },
        cA = 0;

    function uA() {
        lA.isTouch || (lA.isTouch = !0, window.performance && document.addEventListener("mousemove", pA))
    }

    function pA() {
        var e = performance.now();
        e - cA < 20 && (lA.isTouch = !1, document.removeEventListener("mousemove", pA)), cA = e
    }

    function hA() {
        var e, t = document.activeElement;
        if ((e = t) && e._tippy && e._tippy.reference === e) {
            var n = t._tippy;
            t.blur && !n.state.isVisible && t.blur()
        }
    }
    var dA = !("undefined" == typeof window || "undefined" == typeof document || !window.msCrypto),
        fA = Object.assign({
            appendTo: XE,
            aria: {
                content: "auto",
                expanded: "auto"
            },
            delay: 0,
            duration: [300, 250],
            getReferenceClientRect: null,
            hideOnClick: !0,
            ignoreAttributes: !1,
            interactive: !1,
            interactiveBorder: 2,
            interactiveDebounce: 0,
            moveTransition: "",
            offset: [0, 10],
            onAfterUpdate: function() {},
            onBeforeUpdate: function() {},
            onCreate: function() {},
            onDestroy: function() {},
            onHidden: function() {},
            onHide: function() {},
            onMount: function() {},
            onShow: function() {},
            onShown: function() {},
            onTrigger: function() {},
            onUntrigger: function() {},
            onClickOutside: function() {},
            placement: "top",
            plugins: [],
            popperOptions: {},
            render: null,
            showOnCreate: !1,
            touch: !0,
            trigger: "mouseenter focus",
            triggerTarget: null
        }, {
            animateFill: !1,
            followCursor: !1,
            inlinePositioning: !1,
            sticky: !1
        }, {
            allowHTML: !1,
            animation: "fade",
            arrow: !0,
            content: "",
            inertia: !1,
            maxWidth: 350,
            role: "tooltip",
            theme: "",
            zIndex: 9999
        }),
        _A = Object.keys(fA);

    function mA(e) {
        var t = (e.plugins || []).reduce((function(t, n) {
            var r, i = n.name,
                s = n.defaultValue;
            return i && (t[i] = void 0 !== e[i] ? e[i] : null != (r = fA[i]) ? r : s), t
        }), {});
        return Object.assign({}, e, t)
    }

    function gA(e, t) {
        var n = Object.assign({}, t, {
            content: ZE(t.content, [e])
        }, t.ignoreAttributes ? {} : function(e, t) {
            return (t ? Object.keys(mA(Object.assign({}, fA, {
                plugins: t
            }))) : _A).reduce((function(t, n) {
                var r = (e.getAttribute("data-tippy-" + n) || "").trim();
                if (!r) return t;
                if ("content" === n) t[n] = r;
                else try {
                    t[n] = JSON.parse(r)
                } catch (e) {
                    t[n] = r
                }
                return t
            }), {})
        }(e, t.plugins));
        return n.aria = Object.assign({}, fA.aria, n.aria), n.aria = {
            expanded: "auto" === n.aria.expanded ? t.interactive : n.aria.expanded,
            content: "auto" === n.aria.content ? t.interactive ? null : "describedby" : n.aria.content
        }, n
    }

    function vA(e, t) {
        e.innerHTML = t
    }

    function bA(e) {
        var t = nA();
        return !0 === e ? t.className = HE : (t.className = WE, rA(e) ? t.appendChild(e) : vA(t, e)), t
    }

    function xA(e, t) {
        rA(t.content) ? (vA(e, ""), e.appendChild(t.content)) : "function" != typeof t.content && (t.allowHTML ? vA(e, t.content) : e.textContent = t.content)
    }

    function yA(e) {
        var t = e.firstElementChild,
            n = eA(t.children);
        return {
            box: t,
            content: n.find((function(e) {
                return e.classList.contains(GE)
            })),
            arrow: n.find((function(e) {
                return e.classList.contains(HE) || e.classList.contains(WE)
            })),
            backdrop: n.find((function(e) {
                return e.classList.contains("tippy-backdrop")
            }))
        }
    }

    function wA(e) {
        var t = nA(),
            n = nA();
        n.className = "tippy-box", n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
        var r = nA();

        function i(n, r) {
            var i = yA(t),
                s = i.box,
                o = i.content,
                a = i.arrow;
            r.theme ? s.setAttribute("data-theme", r.theme) : s.removeAttribute("data-theme"), "string" == typeof r.animation ? s.setAttribute("data-animation", r.animation) : s.removeAttribute("data-animation"), r.inertia ? s.setAttribute("data-inertia", "") : s.removeAttribute("data-inertia"), s.style.maxWidth = "number" == typeof r.maxWidth ? r.maxWidth + "px" : r.maxWidth, r.role ? s.setAttribute("role", r.role) : s.removeAttribute("role"), n.content === r.content && n.allowHTML === r.allowHTML || xA(o, e.props), r.arrow ? a ? n.arrow !== r.arrow && (s.removeChild(a), s.appendChild(bA(r.arrow))) : s.appendChild(bA(r.arrow)) : a && s.removeChild(a)
        }
        return r.className = GE, r.setAttribute("data-state", "hidden"), xA(r, e.props), t.appendChild(n), n.appendChild(r), i(e.props, e.props), {
            popper: t,
            onUpdate: i
        }
    }
    wA.$$tippy = !0;
    var SA = 1,
        MA = [],
        TA = [];

    function EA(e, t) {
        var n, r, i, s, o, a, l, c, u = gA(e, Object.assign({}, fA, mA(tA(t)))),
            p = !1,
            h = !1,
            d = !1,
            f = !1,
            _ = [],
            m = JE(X, u.interactiveDebounce),
            g = SA++,
            v = (c = u.plugins).filter((function(e, t) {
                return c.indexOf(e) === t
            })),
            b = {
                id: g,
                reference: e,
                popper: nA(),
                popperInstance: null,
                props: u,
                state: {
                    isEnabled: !0,
                    isVisible: !1,
                    isDestroyed: !1,
                    isMounted: !1,
                    isShown: !1
                },
                plugins: v,
                clearDelayTimeouts: function() {
                    clearTimeout(n), clearTimeout(r), cancelAnimationFrame(i)
                },
                setProps: function(t) {
                    if (!b.state.isDestroyed) {
                        O("onBeforeUpdate", [b, t]), W();
                        var n = b.props,
                            r = gA(e, Object.assign({}, n, tA(t), {
                                ignoreAttributes: !0
                            }));
                        b.props = r, H(), n.interactiveDebounce !== r.interactiveDebounce && (F(), m = JE(X, r.interactiveDebounce)), n.triggerTarget && !r.triggerTarget ? $E(n.triggerTarget).forEach((function(e) {
                            e.removeAttribute("aria-expanded")
                        })) : r.triggerTarget && e.removeAttribute("aria-expanded"), I(), D(), w && w(n, r), b.popperInstance && (J(), Q().forEach((function(e) {
                            requestAnimationFrame(e._tippy.popperInstance.forceUpdate)
                        }))), O("onAfterUpdate", [b, t])
                    }
                },
                setContent: function(e) {
                    b.setProps({
                        content: e
                    })
                },
                show: function() {
                    var e = b.state.isVisible,
                        t = b.state.isDestroyed,
                        n = !b.state.isEnabled,
                        r = lA.isTouch && !b.props.touch,
                        i = qE(b.props.duration, 0, fA.duration);
                    if (!(e || t || n || r || C().hasAttribute("disabled") || (O("onShow", [b], !1), !1 === b.props.onShow(b)))) {
                        if (b.state.isVisible = !0, A() && (y.style.visibility = "visible"), D(), j(), b.state.isMounted || (y.style.transition = "none"), A()) {
                            var s = k();
                            iA([s.box, s.content], 0)
                        }
                        var o, l, c;
                        a = function() {
                            var e;
                            if (b.state.isVisible && !f) {
                                if (f = !0, y.offsetHeight, y.style.transition = b.props.moveTransition, A() && b.props.animation) {
                                    var t = k(),
                                        n = t.box,
                                        r = t.content;
                                    iA([n, r], i), sA([n, r], "visible")
                                }
                                L(), I(), QE(TA, b), null == (e = b.popperInstance) || e.forceUpdate(), O("onMount", [b]), b.props.animation && A() && function(e, t) {
                                    V(e, (function() {
                                        b.state.isShown = !0, O("onShown", [b])
                                    }))
                                }(i)
                            }
                        }, l = b.props.appendTo, c = C(), (o = b.props.interactive && l === XE || "parent" === l ? c.parentNode : ZE(l, [c])).contains(y) || o.appendChild(y), b.state.isMounted = !0, J()
                    }
                },
                hide: function() {
                    var e = !b.state.isVisible,
                        t = b.state.isDestroyed,
                        n = !b.state.isEnabled,
                        r = qE(b.props.duration, 1, fA.duration);
                    if (!(e || t || n) && (O("onHide", [b], !1), !1 !== b.props.onHide(b))) {
                        if (b.state.isVisible = !1, b.state.isShown = !1, f = !1, p = !1, A() && (y.style.visibility = "hidden"), F(), z(), D(!0), A()) {
                            var i = k(),
                                s = i.box,
                                o = i.content;
                            b.props.animation && (iA([s, o], r), sA([s, o], "hidden"))
                        }
                        L(), I(), b.props.animation ? A() && function(e, t) {
                            V(e, (function() {
                                !b.state.isVisible && y.parentNode && y.parentNode.contains(y) && t()
                            }))
                        }(r, b.unmount) : b.unmount()
                    }
                },
                hideWithInteractivity: function(e) {
                    R().addEventListener("mousemove", m), QE(MA, m), m(e)
                },
                enable: function() {
                    b.state.isEnabled = !0
                },
                disable: function() {
                    b.hide(), b.state.isEnabled = !1
                },
                unmount: function() {
                    b.state.isVisible && b.hide(), b.state.isMounted && ($(), Q().forEach((function(e) {
                        e._tippy.unmount()
                    })), y.parentNode && y.parentNode.removeChild(y), TA = TA.filter((function(e) {
                        return e !== b
                    })), b.state.isMounted = !1, O("onHidden", [b]))
                },
                destroy: function() {
                    b.state.isDestroyed || (b.clearDelayTimeouts(), b.unmount(), W(), delete e._tippy, b.state.isDestroyed = !0, O("onDestroy", [b]))
                }
            };
        if (!u.render) return b;
        var x = u.render(b),
            y = x.popper,
            w = x.onUpdate;
        y.setAttribute("data-tippy-root", ""), y.id = "tippy-" + b.id, b.popper = y, e._tippy = b, y._tippy = b;
        var S = v.map((function(e) {
                return e.fn(b)
            })),
            M = e.hasAttribute("aria-expanded");
        return H(), I(), D(), O("onCreate", [b]), u.showOnCreate && ee(), y.addEventListener("mouseenter", (function() {
            b.props.interactive && b.state.isVisible && b.clearDelayTimeouts()
        })), y.addEventListener("mouseleave", (function() {
            b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && R().addEventListener("mousemove", m)
        })), b;

        function T() {
            var e = b.props.touch;
            return Array.isArray(e) ? e : [e, 0]
        }

        function E() {
            return "hold" === T()[0]
        }

        function A() {
            var e;
            return !(null == (e = b.props.render) || !e.$$tippy)
        }

        function C() {
            return l || e
        }

        function R() {
            var e, t, n = C().parentNode;
            return n ? null != (t = $E(n)[0]) && null != (e = t.ownerDocument) && e.body ? t.ownerDocument : document : document
        }

        function k() {
            return yA(y)
        }

        function P(e) {
            return b.state.isMounted && !b.state.isVisible || lA.isTouch || s && "focus" === s.type ? 0 : qE(b.props.delay, e ? 0 : 1, fA.delay)
        }

        function D(e) {
            void 0 === e && (e = !1), y.style.pointerEvents = b.props.interactive && !e ? "" : "none", y.style.zIndex = "" + b.props.zIndex
        }

        function O(e, t, n) {
            var r;
            void 0 === n && (n = !0), S.forEach((function(n) {
                n[e] && n[e].apply(n, t)
            })), n && (r = b.props)[e].apply(r, t)
        }

        function L() {
            var t = b.props.aria;
            if (t.content) {
                var n = "aria-" + t.content,
                    r = y.id;
                $E(b.props.triggerTarget || e).forEach((function(e) {
                    var t = e.getAttribute(n);
                    if (b.state.isVisible) e.setAttribute(n, t ? t + " " + r : r);
                    else {
                        var i = t && t.replace(r, "").trim();
                        i ? e.setAttribute(n, i) : e.removeAttribute(n)
                    }
                }))
            }
        }

        function I() {
            !M && b.props.aria.expanded && $E(b.props.triggerTarget || e).forEach((function(e) {
                b.props.interactive ? e.setAttribute("aria-expanded", b.state.isVisible && e === C() ? "true" : "false") : e.removeAttribute("aria-expanded")
            }))
        }

        function F() {
            R().removeEventListener("mousemove", m), MA = MA.filter((function(e) {
                return e !== m
            }))
        }

        function N(t) {
            if (!lA.isTouch || !d && "mousedown" !== t.type) {
                var n = t.composedPath && t.composedPath()[0] || t.target;
                if (!b.props.interactive || !aA(y, n)) {
                    if ($E(b.props.triggerTarget || e).some((function(e) {
                            return aA(e, n)
                        }))) {
                        if (lA.isTouch) return;
                        if (b.state.isVisible && b.props.trigger.indexOf("click") >= 0) return
                    } else O("onClickOutside", [b, t]);
                    !0 === b.props.hideOnClick && (b.clearDelayTimeouts(), b.hide(), h = !0, setTimeout((function() {
                        h = !1
                    })), b.state.isMounted || z())
                }
            }
        }

        function U() {
            d = !0
        }

        function B() {
            d = !1
        }

        function j() {
            var e = R();
            e.addEventListener("mousedown", N, !0), e.addEventListener("touchend", N, KE), e.addEventListener("touchstart", B, KE), e.addEventListener("touchmove", U, KE)
        }

        function z() {
            var e = R();
            e.removeEventListener("mousedown", N, !0), e.removeEventListener("touchend", N, KE), e.removeEventListener("touchstart", B, KE), e.removeEventListener("touchmove", U, KE)
        }

        function V(e, t) {
            var n = k().box;

            function r(e) {
                e.target === n && (oA(n, "remove", r), t())
            }
            if (0 === e) return t();
            oA(n, "remove", o), oA(n, "add", r), o = r
        }

        function G(t, n, r) {
            void 0 === r && (r = !1), $E(b.props.triggerTarget || e).forEach((function(e) {
                e.addEventListener(t, n, r), _.push({
                    node: e,
                    eventType: t,
                    handler: n,
                    options: r
                })
            }))
        }

        function H() {
            var e;
            E() && (G("touchstart", K, {
                passive: !0
            }), G("touchend", q, {
                passive: !0
            })), (e = b.props.trigger, e.split(/\s+/).filter(Boolean)).forEach((function(e) {
                if ("manual" !== e) switch (G(e, K), e) {
                    case "mouseenter":
                        G("mouseleave", q);
                        break;
                    case "focus":
                        G(dA ? "focusout" : "blur", Y);
                        break;
                    case "focusin":
                        G("focusout", Y)
                }
            }))
        }

        function W() {
            _.forEach((function(e) {
                var t = e.node,
                    n = e.eventType,
                    r = e.handler,
                    i = e.options;
                t.removeEventListener(n, r, i)
            })), _ = []
        }

        function K(e) {
            var t, n = !1;
            if (b.state.isEnabled && !Z(e) && !h) {
                var r = "focus" === (null == (t = s) ? void 0 : t.type);
                s = e, l = e.currentTarget, I(), !b.state.isVisible && YE(e, "MouseEvent") && MA.forEach((function(t) {
                    return t(e)
                })), "click" === e.type && (b.props.trigger.indexOf("mouseenter") < 0 || p) && !1 !== b.props.hideOnClick && b.state.isVisible ? n = !0 : ee(e), "click" === e.type && (p = !n), n && !r && te(e)
            }
        }

        function X(e) {
            var t = e.target,
                n = C().contains(t) || y.contains(t);
            "mousemove" === e.type && n || function(e, t) {
                var n = t.clientX,
                    r = t.clientY;
                return e.every((function(e) {
                    var t = e.popperRect,
                        i = e.popperState,
                        s = e.props.interactiveBorder,
                        o = i.placement.split("-")[0],
                        a = i.modifiersData.offset;
                    if (!a) return !0;
                    var l = "bottom" === o ? a.top.y : 0,
                        c = "top" === o ? a.bottom.y : 0,
                        u = "right" === o ? a.left.x : 0,
                        p = "left" === o ? a.right.x : 0,
                        h = t.top - r + l > s,
                        d = r - t.bottom - c > s,
                        f = t.left - n + u > s,
                        _ = n - t.right - p > s;
                    return h || d || f || _
                }))
            }(Q().concat(y).map((function(e) {
                var t, n = null == (t = e._tippy.popperInstance) ? void 0 : t.state;
                return n ? {
                    popperRect: e.getBoundingClientRect(),
                    popperState: n,
                    props: u
                } : null
            })).filter(Boolean), e) && (F(), te(e))
        }

        function q(e) {
            Z(e) || b.props.trigger.indexOf("click") >= 0 && p || (b.props.interactive ? b.hideWithInteractivity(e) : te(e))
        }

        function Y(e) {
            b.props.trigger.indexOf("focusin") < 0 && e.target !== C() || b.props.interactive && e.relatedTarget && y.contains(e.relatedTarget) || te(e)
        }

        function Z(e) {
            return !!lA.isTouch && E() !== e.type.indexOf("touch") >= 0
        }

        function J() {
            $();
            var t = b.props,
                n = t.popperOptions,
                r = t.placement,
                i = t.offset,
                s = t.getReferenceClientRect,
                o = t.moveTransition,
                l = A() ? yA(y).arrow : null,
                c = s ? {
                    getBoundingClientRect: s,
                    contextElement: s.contextElement || C()
                } : e,
                u = [{
                    name: "offset",
                    options: {
                        offset: i
                    }
                }, {
                    name: "preventOverflow",
                    options: {
                        padding: {
                            top: 2,
                            bottom: 2,
                            left: 5,
                            right: 5
                        }
                    }
                }, {
                    name: "flip",
                    options: {
                        padding: 5
                    }
                }, {
                    name: "computeStyles",
                    options: {
                        adaptive: !o
                    }
                }, {
                    name: "$$tippy",
                    enabled: !0,
                    phase: "beforeWrite",
                    requires: ["computeStyles"],
                    fn: function(e) {
                        var t = e.state;
                        if (A()) {
                            var n = k().box;
                            ["placement", "reference-hidden", "escaped"].forEach((function(e) {
                                "placement" === e ? n.setAttribute("data-placement", t.placement) : t.attributes.popper["data-popper-" + e] ? n.setAttribute("data-" + e, "") : n.removeAttribute("data-" + e)
                            })), t.attributes.popper = {}
                        }
                    }
                }];
            A() && l && u.push({
                name: "arrow",
                options: {
                    element: l,
                    padding: 3
                }
            }), u.push.apply(u, (null == n ? void 0 : n.modifiers) || []), b.popperInstance = VE(c, y, Object.assign({}, n, {
                placement: r,
                onFirstUpdate: a,
                modifiers: u
            }))
        }

        function $() {
            b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null)
        }

        function Q() {
            return eA(y.querySelectorAll("[data-tippy-root]"))
        }

        function ee(e) {
            b.clearDelayTimeouts(), e && O("onTrigger", [b, e]), j();
            var t = P(!0),
                r = T(),
                i = r[0],
                s = r[1];
            lA.isTouch && "hold" === i && s && (t = s), t ? n = setTimeout((function() {
                b.show()
            }), t) : b.show()
        }

        function te(e) {
            if (b.clearDelayTimeouts(), O("onUntrigger", [b, e]), b.state.isVisible) {
                if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e.type) >= 0 && p)) {
                    var t = P(!1);
                    t ? r = setTimeout((function() {
                        b.state.isVisible && b.hide()
                    }), t) : i = requestAnimationFrame((function() {
                        b.hide()
                    }))
                }
            } else z()
        }
    }

    function AA(e, t) {
        void 0 === t && (t = {});
        var n = fA.plugins.concat(t.plugins || []);
        document.addEventListener("touchstart", uA, KE), window.addEventListener("blur", hA);
        var r, i = Object.assign({}, t, {
                plugins: n
            }),
            s = (r = e, rA(r) ? [r] : function(e) {
                return YE(e, "NodeList")
            }(r) ? eA(r) : Array.isArray(r) ? r : eA(document.querySelectorAll(r))).reduce((function(e, t) {
                var n = t && EA(t, i);
                return n && e.push(n), e
            }), []);
        return rA(e) ? s[0] : s
    }
    AA.defaultProps = fA, AA.setDefaultProps = function(e) {
        Object.keys(e).forEach((function(t) {
            fA[t] = e[t]
        }))
    }, AA.currentInput = lA, Object.assign({}, SE, {
        effect: function(e) {
            var t = e.state,
                n = {
                    popper: {
                        position: t.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
            Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow)
        }
    }), AA.setDefaultProps({
        render: wA
    });
    var CA = AA;
    class RA extends lT {
        async _refreshUi() {
            var e;
            if (!await super._refreshUi()) return !1;
            fT.RemoveAll(RA.PluginType);
            for (const e of this.variations) fT.Create(RA.PluginType, e.title, 5, 20, 0, e.materials.map((t => {
                let n;
                if (e.preview.startsWith("generate:")) n = this._previewGenerator.generate(t, e.preview.split(":")[1]);
                else {
                    const r = t[e.preview] || "#ff00ff";
                    n = r.image ? Et(r.image, 100) : void 0, n || (n = uT(r, !0))
                }
                return {
                    id: t.uuid,
                    image: n,
                    onClick: t => this.applyVariation(e, t),
                    tooltip: t.name || t.uuid
                }
            })), ((e, t) => CA(e, {
                placement: "bottom",
                content: t.tooltip
            })));
            return fT.RebuildUi(null === (e = this._viewer) || void 0 === e ? void 0 : e.container), !0
        }
    }
    RA.PluginType = "MaterialConfiguratorPlugin";
    class kA extends Gs {
        constructor() {
            super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this._refreshUiConfig = () => {
                var e, t;
                this.enabled && (null === (t = null === (e = this.uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0))
            }, this.dependencies = [Vs], this._selectedObject = () => {
                var e;
                return (null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject()) || void 0
            }, this._selectedMaterial = () => {
                var e, t;
                return (null === (t = null === (e = this._selectedObject()) || void 0 === e ? void 0 : e.modelObject) || void 0 === t ? void 0 : t.material) || void 0
            }
        }
        async onAdded(e) {
            var t, n;
            await super.onAdded(e), this.refreshUi = this.refreshUi.bind(this), this._refreshUi = this._refreshUi.bind(this), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), this._previewGenerator = new aT(this._viewer), null === (n = this._picking) || void 0 === n || n.addEventListener("selectedObjectChanged", this._refreshUiConfig), e.addEventListener("preFrame", this._refreshUi), this.addEventListener("deserialize", this.refreshUi)
        }
        async onRemove(e) {
            var t, n;
            return null === (t = this._previewGenerator) || void 0 === t || t.dispose(), this._previewGenerator = void 0, null === (n = this._picking) || void 0 === n || n.removeEventListener("selectedObjectChanged", this._refreshUiConfig), this.removeEventListener("deserialize", this.refreshUi), e.removeEventListener("preFrame", this._refreshUi), this._picking = void 0, super.onRemove(e)
        }
        refreshUi() {
            this.enabled && (this._uiNeedRefresh = !0)
        }
        async _refreshUi() {
            return this._uiNeedRefresh && this.enabled && this._refreshUiConfig(), this._uiNeedRefresh = !1, !1
        }
    }
    kA.PluginType = "MaterialLibraryBasePlugin",
        function(e, t, n, r) {
            var i, s = arguments.length,
                o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
            else
                for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
            s > 3 && o && Object.defineProperty(t, n, o)
        }([Ve("Enabled")], kA.prototype, "enabled", void 0);
    class PA extends kA {
        constructor() {
            super(...arguments), this.replaceMaterial = !1, this.uiConfig = {
                type: "folder",
                label: "Material Library",
                uuid: Be(),
                children: [...Je(this), () => {
                    var e;
                    return {
                        type: "dropdown",
                        label: "Apply Material",
                        limitedUi: !0,
                        hidden: () => !this._selectedObject(),
                        children: [{
                                label: "select one",
                                value: ""
                            },
                            [...this._viewer.getPlugin(Vs).materials.getMaterialsOfType(null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.typeSlug).map((e => ({
                                label: e.name || e.uuid,
                                value: e.uuid
                            }))) || []]
                        ],
                        getValue: () => {
                            var e;
                            return null === (e = this._selectedMaterial()) || void 0 === e ? void 0 : e.uuid
                        },
                        setValue: e => {
                            var t, n, r, i, s;
                            const o = null === (r = null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(Vs)) || void 0 === n ? void 0 : n.materials) || void 0 === r ? void 0 : r.findMaterial(e);
                            if (o)
                                if (this.replaceMaterial) null === (s = null === (i = this._selectedObject()) || void 0 === i ? void 0 : i.modelObject) || void 0 === s || s.userData.setMaterial(o);
                                else {
                                    const e = this._selectedMaterial();
                                    if (e) {
                                        const t = e.name,
                                            n = e.uuid;
                                        e.copyProps(o), e.name = t, e.uuid = n, e.userData.uuid && (e.userData.uuid = n)
                                    }
                                }
                            this._refreshUi()
                        }
                    }
                }]
            }
        }
        async _refreshUi() {
            var e, t, n, r;
            if (!await super._refreshUi()) return !1;
            const i = [Kt.TypeSlug, Fo.TypeSlug],
                s = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials,
                o = i.map((e => [e, null == s ? void 0 : s.getMaterialsOfType(e)]));
            fT.RemoveAll(PA.PluginType);
            for (const [e, t] of o) fT.Create(PA.PluginType, e, 5, 20, 0, null === (n = t) || void 0 === n ? void 0 : n.filter((e => !e.userData.__runtimeMaterial)).map((e => {
                let t;
                const n = "generate:sphere";
                if (n.startsWith("generate:")) t = this._previewGenerator.generate(e, n.split(":")[1]);
                else {
                    const r = e[n] || "#ff00ff";
                    t = r.image ? Et(r.image, 100) : void 0, t || (t = cT(r, !0))
                }
                return {
                    id: e.uuid,
                    image: t,
                    onClick: e => {
                        const t = null == s ? void 0 : s.findMaterial(e);
                        if (console.log(null == t ? void 0 : t.name), t) {
                            const e = t.userData.appliedMeshes;
                            if (null == e ? void 0 : e.size) {
                                const t = e.keys().next().value;
                                t.dispatchEvent({
                                    type: "select",
                                    value: t
                                })
                            }
                        }
                    },
                    tooltip: e.name || e.uuid
                }
            })), ((e, t) => CA(e, {
                placement: "bottom",
                content: t.tooltip
            })));
            return fT.RebuildUi(null === (r = this._viewer) || void 0 === r ? void 0 : r.container), !0
        }
    }

    function DA(e, t, n, r) {
        e.traverse((e => {
            if (!e) return;
            e.userData.cloneRotI = t, e.userData.rotationCount = n, e.userData.rotationAxis = r;
            const s = e;
            if (s.isMesh && s.material && t > 0) {
                const e = s.material;
                e.extraUniformsToUpload || (e.extraUniformsToUpload = {}), e.extraUniformsToUpload.uvTransform || (e.extraUniformsToUpload.uvTransform = {
                    value: new i.Vkp
                })
            }
        }))
    }

    function OA(e, t, n, r = "x") {
        var i;
        if (e.userData.rotationCount > 1 && !e.userData.rotationRoot) return e;
        const s = e.parent;
        if (!s) throw new Error("No parent");
        if (e.userData.cloneParent) {
            const t = e.userData.cloneParent;
            if (!(e = s.children.find((e => t === e.uuid)))) return console.error("Couldn't find clone root, cannot rotate. maybe a serialization issue?", t, s), e
        }
        let o = s.children.filter((t => {
            var n;
            return (null === (n = t.userData) || void 0 === n ? void 0 : n.cloneParent) === e.uuid
        })).sort(((e, t) => e.userData.cloneRotI - t.userData.cloneRotI));
        if (e.userData.rotationCount === t && t === o.length && void 0 === n && e.userData.rotationAxis === r) return e;
        if (null == n && (n = null !== (i = e.userData.rotationSkips) && void 0 !== i ? i : []), n !== e.userData.rotationSkips && (e.userData.rotationSkips = [...n]), DA(e, 0, t, r), e.userData.rotationRoot = !0, e.visible = !0, t <= o.length) {
            for (let e = t - 1; e < o.length; e++) s.remove(o[e]), o[e].traverse((e => e.userData = {
                __disposed: !0
            }));
            o = o.slice(0, t)
        }
        for (let i = 1; i < t; i++) {
            const a = i <= o.length ? o[i - 1] : e.clone();
            a.rotation.copy(e.rotation), a.rotation[r] += i / t * Math.PI * 2, DA(a, i, t, r), i > o.length && s.add(a), a.visible = !n.includes(i)
        }
        return e.visible = !n.includes(0), e
    }
    PA.PluginType = "MaterialLibraryPlugin",
        function(e, t, n, r) {
            var i, s = arguments.length,
                o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
            else
                for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
            s > 3 && o && Object.defineProperty(t, n, o)
        }([Ve("Replace Material")], PA.prototype, "replaceMaterial", void 0);
    var LA, IA = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let FA = LA = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.rotations = 1, this.axis = "x", this.skips = "", this._selectedObjectChanged = this._selectedObjectChanged.bind(this)
        }
        async onAdded(e) {
            var t;
            await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("selectedObjectChanged", this._selectedObjectChanged)
        }
        _selectedObjectChanged() {
            var e, t, n, r, i, s, o, a, l;
            if (!this.enabled) return;
            const c = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();
            if (!c) return void(null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0));
            const u = c.userData.rotationRoot && null !== (i = c.userData.rotationCount) && void 0 !== i ? i : 1;
            this.rotations = u, this.skips = null !== (o = null === (s = c.userData.rotationSkips) || void 0 === s ? void 0 : s.join(",")) && void 0 !== o ? o : "", this.axis = c.userData.rotationAxis || "x", null === (l = (a = this.uiConfig).uiRefresh) || void 0 === l || l.call(a, "postFrame", !0)
        }
        _paramsChanged() {
            var e, t, n, r, s, o;
            if (!this.enabled) return;
            const a = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject();
            if (a) {
                if (this.rotations > 1 || a.userData.rotationCount) {
                    const e = a.userData.rotationCount,
                        t = OA(a, this.rotations, this.skips.split(",").map((e => parseInt(e))).filter((e => isFinite(e))), this.axis),
                        o = null == t ? void 0 : t.userData.rotationCount;
                    if (o && o !== e) {
                        const e = [];
                        null == t || t.traverseAncestors((t => {
                            e.push(t)
                        }));
                        for (const t of e)
                            if (t.userData.autoScaled) {
                                X(t), null === (n = this._viewer) || void 0 === n || n.resetCamera({
                                    rootObject: t,
                                    centerOffset: new i.Pa4(4, 4, 4)
                                });
                                break
                            }
                    }
                    a.parent && !a.userData.__disposed || null === (s = null === (r = this._viewer) || void 0 === r ? void 0 : r.getPluginByType("Picking")) || void 0 === s || s.setSelectedObject(t, !0)
                }
                null === (o = this._viewer) || void 0 === o || o.scene.setDirty({
                    frameFade: !1,
                    sceneUpdate: !0
                })
            }
        }
    };
    FA.PluginType = "ObjectRotationPlugin", IA([xe(), Ve("Enabled"), C(LA.prototype._paramsChanged)], FA.prototype, "enabled", void 0), IA([He("Rotation Count", [1, 100], 1, (e => ({
        hidden: () => {
            var t, n;
            return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n ? void 0 : n.getSelectedObject()) || !e.rotations
        }
    }))), C(LA.prototype._paramsChanged)], FA.prototype, "rotations", void 0), IA([Ke("Axis", ["x", "y", "z"].map((e => ({
        label: e
    }))), (e => ({
        hidden: () => {
            var t, n;
            return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n ? void 0 : n.getSelectedObject()) || !e.rotations
        }
    }))), C(LA.prototype._paramsChanged)], FA.prototype, "axis", void 0), IA([qe("Rotation Skips", (e => ({
        hidden: () => {
            var t, n;
            return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n ? void 0 : n.getSelectedObject()) || !e.rotations
        }
    }))), C(LA.prototype._paramsChanged)], FA.prototype, "skips", void 0), FA = LA = IA([Qe("Object Rotations")], FA);
    var NA, UA = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let BA = NA = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.debugNormals = !1, this.debugHitHeight = !1, this._defines = {
                PARALLAX_NORMAL_MAP_QUALITY: 0
            }, this.stepCount = 12, this.binaryStepCount = 3, this._bumpMapExtension = {
                shaderExtender: (e, t, n) => {
                    if (t.materialObject.bumpMap && this.enabled) {
                        e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_begin>", ""), e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_maps>", ""), e.fragmentShader = e.fragmentShader.replace("#include <map_fragment>", "#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <map_fragment>");
                        for (const t of ["map_fragment", "alphamap_fragment", "roughnessmap_fragment", "metalnessmap_fragment", "emissivemap_fragment", "transmission_fragment"]) e.fragmentShader = e.fragmentShader.replace(`#include <${t}>`, i.WdD[t].replace("vUv", "parallaxUv.xy"));
                        (this.debugNormals || this.debugHitHeight) && (e.fragmentShader = e.fragmentShader.replace("texture2D( map, parallaxUv.xy )", this.debugNormals ? "vec4(normal, 1.); normal = geometryNormal" : "vec4(parallaxUv.z,0., 0., 1.)")), e.fragmentShader = e.fragmentShader.replace("#include <normal_fragment_maps>", i.WdD.normal_fragment_maps.replace("#elif defined( TANGENTSPACE_NORMALMAP )", "#elif defined( TANGENTSPACE_NORMALMAP ) && !defined( USE_BUMPMAP )").replace("normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );", "vec3 parallaxUv = reliefParallaxPerturbNormal(faceDirection, normal);"))
                    }
                },
                parsFragmentSnippet: () => this.enabled ? "#ifdef USE_BUMPMAP\nmat3 mat3_inverse(mat3 A){mat3 M_t=mat3(vec3(A[0][0],A[1][0],A[2][0]),vec3(A[0][1],A[1][1],A[2][1]),vec3(A[0][2],A[1][2],A[2][2]));float det=dot(cross(M_t[0],M_t[1]),M_t[2]);mat3 adjugate=mat3(cross(M_t[1],M_t[2]),cross(M_t[2],M_t[0]),cross(M_t[0],M_t[1]));return adjugate/det;}float CalculateHeight(in vec2 texCoords){float height=texture2D(bumpMap,texCoords).x;return clamp(height,0.,1.);}const vec2 bumpMapSize=vec2(512,512);vec3 CalculateNormal(in vec2 texCoords){\n#if defined( TANGENTSPACE_NORMALMAP ) && 0 \nvec3 mapN=texture2D(normalMap,texCoords).xyz;mapN.xy*=normalScale;return normalize(mapN);\n#else\nvec2 texOffs=1./bumpMapSize;\n#if PARALLAX_NORMAL_MAP_QUALITY > 0\nfloat hx[9];hx[0]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,-1.)).r;hx[1]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;hx[2]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,-1.)).r;hx[3]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;hx[4]=texture2D(bumpMap,texCoords.st).r;hx[5]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;hx[6]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,1.)).r;hx[7]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;hx[8]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,1.)).r;vec2 deltaH=vec2(hx[0]-hx[2]+2.*(hx[3]-hx[5])+hx[6]-hx[8],hx[0]-hx[6]+2.*(hx[1]-hx[7])+hx[2]-hx[8]);\n#else\nfloat h_xa=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;float h_xb=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;float h_ya=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;float h_yb=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;vec2 deltaH=vec2(h_xa-h_xb,h_ya-h_yb);\n#endif\nreturn normalize(vec3(deltaH/texOffs,1.));\n#endif\n}vec3 ReliefParallax(in float frontFace,in vec3 texDir3D,in vec2 texCoord){float surf_sign=frontFace;float back_face=step(0.,-surf_sign);vec2 texStep=surf_sign*texDir3D.xy/abs(texDir3D.z);vec2 texC=texCoord.st+surf_sign*texStep+back_face*texStep.xy;float mapHeight=1.;float bumpHeightStep=1./float(PARALLAX_MAP_STEPS);float bestBumpHeight=mapHeight+bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_STEPS;i++){if(mapHeight<bestBumpHeight){bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);}}\n#pragma unroll_loop_end\nbestBumpHeight+=bumpHeightStep;\n#pragma unroll_loop_start\nfor(int i=0;i<PARALLAX_MAP_B_STEPS;i++){bumpHeightStep*=0.5;bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);bestBumpHeight+=(bestBumpHeight<mapHeight)?bumpHeightStep:0.;}\n#pragma unroll_loop_end\nbestBumpHeight-=bumpHeightStep*clamp((bestBumpHeight-mapHeight)/bumpHeightStep,0.,1.);mapHeight=bestBumpHeight;texC-=mapHeight*texStep;return vec3(texC.xy,mapHeight);}vec3 reliefParallaxPerturbNormal(in float faceDirection,inout vec3 normal){if(abs(bumpScale)<0.001)return vec3(vUv,0.);float parallaxHeight;vec2 texCoords=vUv;float face_sign=sign(dot(normal,vViewPosition));vec3 N=normalize(normal);vec3 dp1=dFdx(-vViewPosition);vec3 dp2=dFdy(-vViewPosition);vec2 duv1=dFdx(vUv);vec2 duv2=dFdy(vUv);vec3 dp2perp=cross(dp2,N);vec3 dp1perp=cross(N,dp1);vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(T,T),dot(B,B)));mat3 tbnMat=mat3(T*invmax,B*invmax,N*bumpScale);vec3 tangentPos=normalize(mat3_inverse(tbnMat)*-vViewPosition);vec3 parallaxUv=ReliefParallax(face_sign,tangentPos,vUv);tbnMat[2]=face_sign*N/bumpScale;normal=normalize(tbnMat*CalculateNormal(parallaxUv.xy).xyz);\n#ifdef FLIP_SIDED\nnormal=-normal;\n#endif\nreturn parallaxUv;}\n#endif \n\n".replaceAll("PARALLAX_MAP_STEPS", this._defines.PARALLAX_MAP_STEPS).replaceAll("PARALLAX_MAP_B_STEPS", this._defines.PARALLAX_MAP_B_STEPS) : "",
                isCompatible: e => e.isMeshStandardMaterial2,
                computeCacheKey: e => {
                    var t;
                    return this.enabled + " " + (null === (t = e.materialObject.bumpMap) || void 0 === t ? void 0 : t.uuid) + " " + this.debugNormals + " " + this.debugHitHeight + "  "
                },
                onObjectRender: (e, {
                    materialObject: t
                }, n) => {
                    for (const [e, n] of Object.entries(this._defines)) {
                        const r = "number" == typeof n ? n : n ? 1 : 0;
                        t.defines[e] !== r && (t.defines[e] = r, t.needsUpdate = !0)
                    }
                }
            }, this.dependencies = [Vs], this._updateExtension = this._updateExtension.bind(this)
        }
        _updateExtension() {
            var e, t, n;
            null === (t = null === (e = this._bumpMapExtension) || void 0 === e ? void 0 : e.setDirty) || void 0 === t || t.call(e), null === (n = this._viewer) || void 0 === n || n.setDirty()
        }
        async onAdded(e) {
            var t, n;
            return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.registerMaterialExtension(this._bumpMapExtension), super.onAdded(e)
        }
        async onRemove(e) {
            var t, n;
            return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.materials) || void 0 === n || n.unregisterMaterialExtension(this._bumpMapExtension), super.onRemove(e)
        }
    };
    BA.PluginType = "ReliefParallaxMapping", UA([C(NA.prototype._updateExtension), Ve("Enabled")], BA.prototype, "enabled", void 0), UA([C(NA.prototype._updateExtension), Ve("Debug Normals")], BA.prototype, "debugNormals", void 0), UA([C(NA.prototype._updateExtension), Ve("Debug Hit Height")], BA.prototype, "debugHitHeight", void 0), UA([G("PARALLAX_MAP_STEPS", void 0, !0, NA.prototype._updateExtension), He("Step count", [1, 32], 1), xe()], BA.prototype, "stepCount", void 0), UA([G("PARALLAX_MAP_B_STEPS", void 0, !0, NA.prototype._updateExtension), He("Binary search steps", [1, 8], 1), xe()], BA.prototype, "binaryStepCount", void 0), BA = NA = UA([Qe("Parallax Mapping")], BA);
    class jA extends Gs {
        constructor() {
            super(...arguments), this.enabled = !0, this._uiNeedRefresh = !1, this.dependencies = [Vs], this.variations = [], this._selectedSwitchNode = () => {
                var e;
                const t = null === (e = this._picking) || void 0 === e ? void 0 : e.getSelectedObject();
                if (!t) return;
                const n = this.variations.map((e => e.name));
                let r;
                return t.traverseAncestors((e => {
                    r || n.includes(e.name) && (r = e)
                })), r
            }, this.uiConfig = {
                label: "Switch Node",
                type: "folder",
                children: [() => [{
                    type: "folder",
                    label: "All nodes",
                    expanded: !0,
                    children: [this.variations.map((e => ({
                        type: "input",
                        label: e.title,
                        property: [e, "name"],
                        onChange: () => this.refreshUi()
                    })))]
                }, {
                    type: "button",
                    label: "Add Node",
                    value: () => {
                        this.variations.push({
                            name: "switch_node",
                            selected: "",
                            title: "Switch Node",
                            camView: "front",
                            camDistance: 1
                        }), this.refreshUi()
                    }
                }, {
                    type: "button",
                    label: "Refresh UI",
                    value: () => this.refreshUi()
                }, {
                    type: "input",
                    label: "Selected node title",
                    hidden: () => !this._selectedSwitchNode(),
                    property: () => {
                        const e = this._selectedSwitchNode();
                        return e ? [this.variations.find((t => t.name === e.name)), "title"] : []
                    },
                    onChange: () => this.refreshUi()
                }, {
                    type: "slider",
                    bounds: [.01, 2],
                    stepSize: .01,
                    label: "Cam Distance",
                    hidden: () => !this._selectedSwitchNode(),
                    property: () => {
                        const e = this._selectedSwitchNode();
                        return e ? [this.variations.find((t => t.name === e.name)), "camDistance"] : []
                    }
                }, {
                    type: "dropdown",
                    label: "Cam View",
                    hidden: () => !this._selectedSwitchNode(),
                    property: () => {
                        const e = this._selectedSwitchNode();
                        return e ? [this.variations.find((t => t.name === e.name)), "camView"] : []
                    },
                    onChange: () => this.refreshUi(),
                    children: ["top", "bottom", "front", "back", "left", "right"].map((e => ({
                        label: e,
                        value: e
                    })))
                }]]
            }
        }
        async onAdded(e) {
            var t, n;
            await super.onAdded(e), this._picking = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking"), null === (n = this._picking) || void 0 === n || n.addEventListener("selectedObjectChanged", (() => {
                var e, t;
                null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e)
            })), e.addEventListener("postFrame", (() => {
                this._uiNeedRefresh && this._refreshUi()
            })), e.addEventListener("preRender", (() => {
                if (this._viewer)
                    for (const e of this.variations) {
                        const t = this._viewer.scene.getObjectByName(e.name);
                        if (!t || t.children.length < 1) return;
                        e.selected || (e.selected = t.children[0].name || t.children[0].uuid);
                        for (const n of t.children) n.visible = (n.name || n.uuid) === e.selected
                    }
            })), e.addEventListener("postRender", (() => {
                if (this._viewer)
                    for (const e of this.variations) {
                        const t = this._viewer.scene.getObjectByName(e.name);
                        if (!t || t.children.length < 1) return;
                        for (const e of t.children) e.visible = !0
                    }
            })), this.addEventListener("deserialize", (async () => {
                await _c(200), this.refreshUi()
            }))
        }
        refreshUi() {
            this.enabled && (this._uiNeedRefresh = !0)
        }
        _refreshUi() {
            var e, t, n;
            if (this.enabled && this._viewer) {
                this._uiNeedRefresh = !1, fT.RemoveAll(jA.PluginType);
                for (const e of this.variations) {
                    const t = this._viewer.scene.getObjectByName(e.name);
                    t ? (t.children.length < 1 && console.warn("SwitchNode does not have enough children", e), fT.Create(jA.PluginType, e.title, Math.min(5, t.children.length), 20, 0, t.children.map((t => {
                        const n = e.camView,
                            r = new i.Pa4((n.includes("right") ? 1 : 0) - (n.includes("left") ? 1 : 0), (n.includes("top") ? 1 : 0) - (n.includes("bottom") ? 1 : 0), (n.includes("front") ? 1 : 0) - (n.includes("back") ? 1 : 0));
                        e.camDistance || (e.camDistance = 1);
                        const s = oT(this._viewer, t, void 0, 7, r.multiplyScalar(.5 * e.camDistance));
                        return {
                            id: t.uuid,
                            image: s,
                            onClick: () => {
                                var n;
                                e.selected = t.name || t.uuid, null === (n = this._viewer) || void 0 === n || n.scene.setDirty({
                                    sceneUpdate: !0,
                                    frameFade: !0
                                })
                            },
                            tooltip: t.name || t.uuid
                        }
                    })), ((e, t) => CA(e, {
                        placement: "bottom",
                        content: t.tooltip
                    })))) : console.warn("no object found for variation, skipping", e)
                }
                fT.RebuildUi(null === (e = this._viewer) || void 0 === e ? void 0 : e.container), null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t)
            }
        }
    }
    jA.PluginType = "SwitchNodePlugin",
        function(e, t, n, r) {
            var i, s = arguments.length,
                o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
            else
                for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
            s > 3 && o && Object.defineProperty(t, n, o)
        }([xe()], jA.prototype, "variations", void 0);
    class zA extends i.u9r {
        constructor(e, t, n = 32, r = 64, s = !1, o = new i.FM8(1, 1), a = "shape") {
            super(), this.type = "TubeShapeGeometry", this.parameters = {
                path: t,
                shape: e,
                shapeSegments: n,
                tubularSegments: r,
                closed: s,
                primary: a,
                shapeScale: o.clone()
            };
            const l = t.computeFrenetFrames(r, s);
            this.frames = l;
            const c = new i.Pa4,
                u = new i.Pa4,
                p = new i.Pa4,
                h = new i.FM8;
            let d = new i.Pa4;
            const f = [],
                _ = [],
                m = [],
                g = e.getSpacedPoints(n);
            for (const e of g) e.multiply(o);
            ! function() {
                for (let e = 0; e < r; e++) b(e);
                b(!1 === s ? r : 0),
                    function() {
                        for (let e = 0; e <= r; e++)
                            for (let t = 0; t <= n; t++) h.x = e / r, h.y = t / n, _.push(h.x, h.y)
                    }(),
                    function() {
                        const e = "shape" === a,
                            t = e ? n : r,
                            i = e ? r : n;
                        for (let r = 1; r <= t; r++)
                            for (let t = 1; t <= i; t++) {
                                const [i, s] = e ? [t, r] : [r, t], o = (n + 1) * (i - 1) + (s - 1), a = (n + 1) * i + (s - 1), l = (n + 1) * i + s, c = (n + 1) * (i - 1) + s;
                                m.push(o, a, c), m.push(a, l, c)
                            }
                    }()
            }(), this.setIndex(m), this.setAttribute("position", new i.a$l(f, 3)), this.setAttribute("uv", new i.a$l(_, 2)), this.computeVertexNormals();
            const v = this.attributes.normal;

            function b(e) {
                d = t.getPointAt(e / r, d);
                const i = l.normals[e],
                    s = l.binormals[e];
                for (let e = 0; e <= n; e++) {
                    const t = g[e % n];
                    u.set(0, 0, 0).addScaledVector(i, t.x).addScaledVector(s, t.y), c.copy(d).add(u), f.push(c.x, c.y, c.z)
                }
            }! function() {
                for (let e = 1; e < n; e++) {
                    const t = e + r * (n + 1);
                    u.fromBufferAttribute(v, e), p.fromBufferAttribute(v, t), u.add(p).normalize(), v.setXYZ(e, u.x, u.y, u.z), v.setXYZ(t, u.x, u.y, u.z)
                }
                for (let e = 1; e < r; e++) {
                    const t = e * (n + 1),
                        r = t + n;
                    u.fromBufferAttribute(v, t), p.fromBufferAttribute(v, r), u.add(p).normalize(), v.setXYZ(t, u.x, u.y, u.z), v.setXYZ(r, u.x, u.y, u.z)
                }
                u.fromBufferAttribute(v, 0), p.fromBufferAttribute(v, n), u.add(p);
                const e = r * (n + 1);
                p.fromBufferAttribute(v, e), u.add(p), p.fromBufferAttribute(v, e + n), u.add(p), u.normalize(), v.setXYZ(0, u.x, u.y, u.z), v.setXYZ(n, u.x, u.y, u.z), v.setXYZ(e, u.x, u.y, u.z), v.setXYZ(e + n, u.x, u.y, u.z), v.needsUpdate = !0
            }()
        }
        createSplits(e) {
            this.clearGroups();
            const t = "shape" === this.parameters.primary ? this.parameters.shapeSegments : this.parameters.tubularSegments,
                n = this.index.count,
                r = [...e, 1].sort();
            let i = 0,
                s = 0;
            for (const e of r) {
                const r = Math.round(t * e) * n / t;
                this.addGroup(i, r - i, s++), i = r
            }
            return this.groups.length
        }
        toJSON() {
            const e = super.toJSON();
            return e.path = this.parameters.path.toJSON(), e.shape = this.parameters.shape.toJSON(), e
        }
    }
    var VA, GA = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    let HA = VA = class extends Gs {
        constructor() {
            super(...arguments), this.enabled = !0, this.shapeSegments = 32, this.tubularSegments = 32, this.shapeScale = new i.FM8(1, 1), this.materialSplits = "0.3, 0.6", this.horizontalSplits = !0, this.extrudeCirceTube = async () => {
                var e, t;
                const n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Ca)) || void 0 === t ? void 0 : t.getSelectedObject();
                if (!n) return;
                let r = prompt("Radius", "1");
                if (!r) return;
                r = parseFloat(r);
                const i = new WA(0, 0, r, r, 0, 2 * Math.PI, !0, 0);
                await this.extrudeObject(n, i)
            }
        }
        async onAdded(e) {
            await super.onAdded(e)
        }
        static CreateCurve(e, t) {
            var n, r;
            if ("circle" === e) return new WA(0, 0, null !== (n = t.radius) && void 0 !== n ? n : 1, null !== (r = t.radius) && void 0 !== r ? r : 1, 0, 2 * Math.PI, !0, 0);
            throw new Error("Unknown curve type")
        }
        async extrudeObject(e, t, n = this.shapeSegments, r = this.tubularSegments, s = this.shapeScale, o = this.materialSplits.split(",").map((e => parseFloat(e.trim()))), a = this.horizontalSplits) {
            var l, c, u, p, h, d;
            if (e.userData.isExtrudedTube, e.userData._extrudeSource) {
                const t = e.userData._extrudeSource;
                if (!(e = null === (l = e.parent) || void 0 === l ? void 0 : l.children.find((e => t === e.uuid)))) return void console.warn("Could not find extrude source with uuid", t)
            }
            if (e.userData.extrudedObject) {
                const t = e.userData.extrudedObject,
                    n = null === (c = e.parent) || void 0 === c ? void 0 : c.children.find((e => t === e.uuid));
                n && (n.removeFromParent(), n.geometry.dispose(), n.geometry = null, n.material = null), delete e.userData.extrudedObject
            }
            const f = e.geometry;
            if (!f) return void alert("no geometry to extrude");
            const _ = [e.material];
            let m;
            try {
                const e = VA.ConvertGeometryToFlatShape(f);
                m = new zA(e, t, n, r, !0, s, a ? "shape" : "path"), m.computeBoundingBox(), m.createSplits(o)
            } catch (e) {
                return void alert("string" == typeof e ? e : null == e ? void 0 : e.message)
            }
            _[0].color.set(16777215);
            for (let e = _.length; e < m.groups.length; e++) {
                const e = _[0].clone();
                _.push(e), e.color.set(16777215 * Math.random())
            }
            const g = new i.Kj0(m, _);
            g.userData._extrudeSource = e.uuid, g.userData.isExtrudedTube = !0, e.visible = !1, e.userData.bboxVisible = !1, g.name = e.name + "_extruded";
            const v = lt(g),
                b = await (null === (h = null === (p = null === (u = this._viewer) || void 0 === u ? void 0 : u.getManager()) || void 0 === p ? void 0 : p.importer) || void 0 === h ? void 0 : h.processImportedSingle(v, {
                    pseudoCenter: !1,
                    autoScale: !1
                }));
            b && (null === (d = e.parent) || void 0 === d || d.add(b.modelObject), e.userData.extrudedObject = b.modelObject.uuid, b.dispatchEvent({
                type: "select",
                ui: !0,
                value: b
            }))
        }
        static ExtrudeShape(e, t, n, r, s, o, a, l) {
            const c = new zA(e, r, t, n, !0, new i.FM8(s, o), l ? "shape" : "path");
            c.computeBoundingBox(), c.createSplits(a);
            const u = lt(new i.Kj0(c, []));
            return u.userData.isExtrudedTube = !0, u
        }
        static ConvertGeometryToFlatShape(e, t = !0) {
            if (e.userData.__planarShape) return e.userData.__planarShape;
            let n = e.attributes.position;
            if (!n) throw "no position attribute";
            if (n.count > 500) throw "too large to extrude";
            const r = e;
            n = r.attributes.position, r.boundingBox || r.computeBoundingBox();
            const s = r.boundingBox.getSize(new i.Pa4),
                o = s.x < .001 ? "x" : s.y < .001 ? "y" : s.z < .001 ? "z" : null;
            if (!o) throw "geometry is not axis aligned not planar";
            let a = [];
            for (let e = 0; e < n.count; e++) {
                const t = new i.FM8;
                "x" === o ? t.set(n.getY(e), n.getZ(e)) : "y" === o ? t.set(n.getX(e), n.getZ(e)) : t.set(n.getX(e), n.getY(e)), a.push(t)
            }
            if (t) {
                let e = 0;
                for (let t = 0; t < a.length; t++)(a[t].x < a[e].x || a[t].x === a[e].x && a[t].y < a[e].y) && (e = t);
                0 !== e && (a = a.slice(e).concat(a.slice(0, e)))
            }
            const l = new i.bnF(a);
            return e.userData.__planarShape = l, l
        }
    };
    HA.PluginType = "ShapeTubeExtrudePlugin", GA([Ve("Enabled")], HA.prototype, "enabled", void 0), GA([He("Shape Segments (X)", [1, 100], 1, (e => ({
        hidden: () => {
            var t, n;
            return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject())
        }
    })))], HA.prototype, "shapeSegments", void 0), GA([He("Tube Segments (Y)", [1, 100], 1, (e => ({
        hidden: () => {
            var t, n;
            return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject())
        }
    })))], HA.prototype, "tubularSegments", void 0), GA([We("Shape scale", [.01, 10], .01, (e => ({
        hidden: () => {
            var t, n;
            return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject())
        }
    })))], HA.prototype, "shapeScale", void 0), GA([qe("Material Splits", (e => ({
        hidden: () => {
            var t, n;
            return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject())
        }
    })))], HA.prototype, "materialSplits", void 0), GA([Ve("Horizontal Splits", (e => ({
        hidden: () => {
            var t, n;
            return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject())
        }
    })))], HA.prototype, "horizontalSplits", void 0), GA([Xe("Extrude Circle Tube", (e => ({
        hidden: () => {
            var t, n;
            return !(null === (n = null === (t = e._viewer) || void 0 === t ? void 0 : t.getPlugin(Ca)) || void 0 === n ? void 0 : n.getSelectedObject())
        }
    })))], HA.prototype, "extrudeCirceTube", void 0), HA = VA = GA([Qe("Extrude Tube Shapes")], HA);
    class WA extends i.Ny0 {
        getPoint(e, t) {
            return super.getPoint(e, t || new i.Pa4)
        }
    }
    class KA extends Gs {
        constructor(e = !0) {
            super(), this.enabled = !0, this.toJSON = void 0, this.fromJSON = void 0, this._lastFrameTime = 0, this._updaters = [], this.dependencies = [], this._fadeDisabled = !1, this.disableFrameFade = !0, this._postFrame = () => {
                var e, t;
                if (!this._viewer) return;
                if (!this.enabled || Object.keys(this.animations).length < 1) return this._lastFrameTime = 0, void(this._fadeDisabled && (null === (e = this._viewer.getPluginByType("FrameFade")) || void 0 === e || e.enable(KA.PluginType), this._fadeDisabled = !1));
                const n = Ct() / 1e3;
                this._lastFrameTime < 1 && (this._lastFrameTime = n - 1 / 60);
                let r = n - this._lastFrameTime;
                this._lastFrameTime = n;
                const i = null === (t = this._viewer.getPluginByType("Progressive")) || void 0 === t ? void 0 : t.postFrameConvergedRecordingDelta();
                if (i && i > 0 && (r = i), 0 !== i && (r *= 1e3, !(r <= .001) && (this._updaters.forEach((e => {
                        let t = r;
                        e.time + t < 0 && (t = -e.time), e.time += t, Math.abs(t) > .001 && e.u(t)
                    })), !this._fadeDisabled && this.disableFrameFade))) {
                    const e = this._viewer.getPluginByType("FrameFade");
                    e && (e.disable(KA.PluginType), this._fadeDisabled = !0)
                }
            }, this.defaultDriver = e => ({
                start: () => this._updaters.push({
                    u: e,
                    time: 0
                }),
                stop: () => this._updaters.splice(this._updaters.findIndex((t => t.u === e)), 1)
            }), this.animations = {}, this.enabled = e, this._postFrame = this._postFrame.bind(this)
        }
        async onAdded(e) {
            await super.onAdded(e), e.addEventListener("postFrame", this._postFrame)
        }
        async onRemove(e) {
            return e.removeEventListener("postFrame", this._postFrame), super.onRemove(e)
        }
        animate(e) {
            const t = Be(),
                n = {
                    id: t,
                    options: e,
                    stop: () => {
                        var e, n, r;
                        (null === (e = this.animations[t]) || void 0 === e ? void 0 : e._stop) ? null === (r = null === (n = this.animations[t]) || void 0 === n ? void 0 : n._stop) || void 0 === r || r.call(n): console.warn("Animation not started")
                    }
                };
            return this.animations[t] = n, n.promise = new Promise(((n, r) => {
                const i = {
                        driver: this.defaultDriver,
                        onComplete: () => {
                            var t;
                            null === (t = e.onComplete) || void 0 === t || t.call(e), n()
                        },
                        onStop: () => {
                            var t;
                            null === (t = e.onStop) || void 0 === t || t.call(e), n()
                        },
                        ...e
                    },
                    s = dc(i);
                this.animations[t]._stop = s.stop, this.animations[t].options = i
            })).then((() => (delete this.animations[t], t))), this.animations[t]
        }
        async animateAsync(e) {
            return this.animate(e).promise
        }
    }
    KA.PluginType = "PopmotionPlugin";
    const XA = async e => bt(await (await fetch(e)).blob());
    async function qA(e, t = XA) {
        const n = e.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
        if (n)
            for (const r of n) {
                const n = await t(r);
                e = e.replace(r, n)
            }
        return e
    }

    function YA(e, t, {
        width: n,
        height: r
    }, i = !0) {
        const s = `\n<svg viewBox="0 0 ${n} ${r}" xmlns="http://www.w3.org/2000/svg">\n    <style>\n    ${t}\n    </style>\n    <foreignObject x="0" y="0" width="100%" height="100%">\n        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">\n            ${e}\n        </div>\n    </foreignObject>\n</svg>\n    `;
        return i ? A(s) : s
    }
    async function ZA(e, t, n) {
        const r = YA(e, t, n);
        return await hT(r, n)
    }
    async function JA(e, t, n) {
        const r = YA(e, t, n);
        return await dT(r, n)
    }
    var $A, QA, eC = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    const tC = e => ({
        onChange: t => {
            t.last && e.onChange()
        }
    });
    let nC = $A = class {
        constructor() {
            this.text = "Custom Text", this.fontSize = 100, this.width = 1024, this.height = 1024, this.xOffset = 0, this.yOffset = 0, this.boxWidth = 1024, this.boxHeight = 1024, this.fontFamily = "", this.fontPath = "", this.maskText = !1, this.innerShadow = !1, this.textColor = "#000000", this.bgFillColor = "#ffffff", this.svgBackground = "#ffffff", this.onChange = () => {}
        }
        set(e) {
            Object.assign(this, e)
        }
        reset() {
            const e = this.onChange;
            Object.assign(this, new $A), this.onChange = e
        }
        toJSON() {
            return {
                text: this.text,
                fontFamily: this.fontFamily,
                fontPath: this.fontPath,
                svgBackground: this.svgBackground,
                width: this.width,
                height: this.height,
                xOffset: this.xOffset,
                yOffset: this.yOffset,
                boxWidth: this.boxWidth,
                boxHeight: this.boxHeight,
                fontSize: this.fontSize,
                maskText: this.maskText,
                innerShadow: this.innerShadow,
                bgFillColor: this.bgFillColor,
                textColor: this.textColor
            }
        }
    };
    eC([qe("Text", tC)], nC.prototype, "text", void 0), eC([He("Font Size", [2, 400], 1, tC)], nC.prototype, "fontSize", void 0), eC([He("Width", [2, 4096], 1, tC)], nC.prototype, "width", void 0), eC([He("Height", [2, 4096], 1, tC)], nC.prototype, "height", void 0), eC([He("X Offset", [-1024, 1024], 1, tC)], nC.prototype, "xOffset", void 0), eC([He("Y Offset", [-1024, 1024], 1, tC)], nC.prototype, "yOffset", void 0), eC([He("V-Width", [2, 4096], 1, tC)], nC.prototype, "boxWidth", void 0), eC([He("V-Height", [2, 4096], 1, tC)], nC.prototype, "boxHeight", void 0), eC([qe("Font", tC)], nC.prototype, "fontFamily", void 0), eC([qe("Font Url", tC)], nC.prototype, "fontPath", void 0), eC([Ve("Mask Text", tC)], nC.prototype, "maskText", void 0), eC([Ve("Inner Shadow", tC)], nC.prototype, "innerShadow", void 0), eC([Ye("Text Color", tC)], nC.prototype, "textColor", void 0), eC([Ye("BG Fill", tC)], nC.prototype, "bgFillColor", void 0), eC([Ye("SVG BG", tC)], nC.prototype, "svgBackground", void 0), nC = $A = eC([Qe("Text SVG Options")], nC);
    const rC = {
            woff: "woff",
            woff2: "woff2",
            ttf: "truetype",
            otf: "opentype",
            eot: "embedded-opentype"
        },
        iC = e => ({
            hidden: () => {
                const t = e.getSelected();
                return !t || !t.userData[sC.PluginType]
            }
        });
    let sC = QA = class extends Gs {
        constructor() {
            super(), this.enabled = !0, this.getSelected = () => {
                var e, t;
                return null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPluginByType("Picking")) || void 0 === t ? void 0 : t.getSelectedObject()
            }, this.options = new nC, this.applyToMap = !0, this.applyToBumpMap = !1, this.applyToAlphaMap = !0, this.inverseAlphaMap = !1, this._lastMeta = void 0, this.fonts = {
                roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2"
            }, this._assetLoadOptions = void 0, this._selectedObjectChanged = this._selectedObjectChanged.bind(this), this.addTextToSelected = this.addTextToSelected.bind(this), this._paramsChanged = this._paramsChanged.bind(this), this.options.onChange = this._paramsChanged
        }
        async onAdded(e) {
            var t;
            await super.onAdded(e), null === (t = e.getPluginByType("Picking")) || void 0 === t || t.addEventListener("selectedObjectChanged", this._selectedObjectChanged)
        }
        _selectedObjectChanged() {
            var e, t, n, r, i, s;
            if (!this.enabled) return;
            const o = this.getSelected();
            if (!o) return void(null === (t = (e = this.uiConfig).uiRefresh) || void 0 === t || t.call(e, "postFrame", !0));
            const a = o.userData[QA.PluginType];
            if (!a) return this.options.reset(), this._lastMeta = void 0, void(null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0));
            this._lastMeta !== a && (this.options.set(a), this._lastMeta = a), null === (s = (i = this.uiConfig).uiRefresh) || void 0 === s || s.call(i, "postFrame", !0)
        }
        _paramsChanged() {
            if (!this.enabled) return;
            const e = this.getSelected();
            e && e.isMesh && e.userData[QA.PluginType] && this.updateText(e, this.options.toJSON())
        }
        addTextToSelected() {
            const e = this.getSelected();
            if (e && e.isMesh)
                if (e.material) {
                    if (e.userData[QA.PluginType] || !e.material.map || confirm("This mesh already has a texture. Adding text will replace the texture. Continue?")) return this.addText(e)
                } else console.error("no material on mesh");
            else console.error("no mesh is selected")
        }
        async addText(e, t) {
            return this.updateText(e, Object.assign(this.options.toJSON(), t))
        }
        async updateText(e, t) {
            var n, r;
            if (!e.isMesh) return;
            if (!e.material) return void console.error("updateText: no material on mesh");
            let i = e.userData[QA.PluginType];
            i || (e.userData[QA.PluginType] = i = {}), Object.assign(i, t);
            const s = e.material;
            s.map && (s.map._isSimpleTextTexture && s.map.dispose(), s.map = void 0), s.alphaMap && (s.alphaMap._isSimpleTextTexture && s.alphaMap.dispose(), s.alphaMap = void 0), s.bumpMap && (s.bumpMap._isSimpleTextTexture && s.bumpMap.dispose(), s.bumpMap = void 0);
            const o = await this.makeTextSvg(i);
            this.applyToMap && (s.map = o), this.applyToAlphaMap && (s.alphaMap = o, s.transparent = !0), this.applyToBumpMap && (s.bumpMap = o), s.userData.inverseAlphaMap = this.inverseAlphaMap, s.userData.setDirty(), s.needsUpdate = !0, null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0)
        }
        async makeTextSvg(e) {
            const t = e.fontFamily || "Arial",
                n = e.fontPath || this.fonts[t] || "";
            let r = e.style;
            if (n.length > 0) {
                const e = n.split("?")[0].split(".").pop() || "woff";
                r += "\n" + (n.length > 0 ? `\n            @font-face {\n                font-family: ${t};\n                src: url(${n}) format(${rC[e]||e});\n            }` : "")
            }
            let s = function({
                text: e = "Custom Text",
                svgBackground: t = "#ffffff",
                xOffset: n = 0,
                yOffset: r = 0,
                width: i = 1024,
                height: s = 1024,
                boxWidth: o = 1024,
                boxHeight: a = 1024,
                fontFamily: l = "",
                fontSize: c = 32,
                maskText: u = !0,
                innerShadow: p = !0,
                bgFillColor: h = "#000000",
                textColor: d = "#ffffff",
                style: f = ""
            }) {
                return `\n<svg style="background-color:${t}" width="${i}" height="${s}" viewBox="0 0 ${o} ${a}"\n xmlns="http://www.w3.org/2000/svg"\n xmlns:xlink="http://www.w3.org/1999/xlink">\n     <defs>\n        <style>\n        ${f}\n        </style>\n    </defs>\n\n    <g style="overflow:hidden; text-anchor: middle; font-size: ${c}px; font-family: ${l||"Arial"}">\n        <defs>\n\n` + (u ? `\n<mask id="textMask">\n<text style="fill:white; font-size: ${c}px;" x="${n+o/2}" y="${a/2+r+c/4}" > ${e} </text>\n</mask>\n` : "") + "\n\n" + (p ? '\n<filter id="innerShadow" x="-20%" y="-20%" width="140%" height="140%">\n<feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur"/>\n<feOffset in="blur" dx="1.5" dy="1.5"/>\n</filter>\n' : "") + "\n\n        </defs>\n\n" + (u ? '\n        <g mask="url(#textMask)">\n' : "") + `\n\n        <rect x="0" y="0" width="${o}" height="${a}" style="fill:${h}"/>\n        <text style="${p?"filter: url(#innerShadow);":""} fill:${d};" x="${n+o/2}" y="${a/2+r+c/4}"> ${e} </text>\n\n` + (u ? "\n        </g>\n" : "") + "\n\n    </g>\n</svg>\n"
            }({ ...e,
                fontFamily: t,
                style: r
            });
            s = await qA(s, (async e => this._getAssetData(e))), s = A(s);
            const o = await this._viewer.getManager().importer.importSinglePath(s, {
                generateMipmaps: !1,
                minFilter: i.wem
            });
            return o._isSimpleTextTexture = !0, o.flipY = !1, o.needsUpdate = !0, o
        }
        async _getAssetData(e) {
            var t, n;
            if (e.startsWith("http://www.w3.org")) return e;
            const r = null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getManager()) || void 0 === n ? void 0 : n.importer;
            if (!r) throw new Error("no importer");
            this._assetLoadOptions = this._assetLoadOptions || {
                fileHandler: new ox(r.loadingManager),
                processImported: !1
            };
            try {
                return await r.importPath(e, this._assetLoadOptions)
            } catch (e) {
                return console.error(e), ""
            }
        }
    };
    sC.PluginType = "SimpleTextPlugin", eC([ze(void 0, {
        params: iC
    })], sC.prototype, "options", void 0), eC([Ve("Apply Map", iC), C(QA.prototype._paramsChanged)], sC.prototype, "applyToMap", void 0), eC([Ve("Apply Bump Map", iC), C(QA.prototype._paramsChanged)], sC.prototype, "applyToBumpMap", void 0), eC([Ve("Apply Alpha Map", iC), C(QA.prototype._paramsChanged)], sC.prototype, "applyToAlphaMap", void 0), eC([Ve("Invert Alpha Map", iC), C(QA.prototype._paramsChanged)], sC.prototype, "inverseAlphaMap", void 0), eC([Xe("Add Text", (e => ({
        hidden: () => !e.getSelected()
    })))], sC.prototype, "addTextToSelected", null), sC = QA = eC([Qe("Simple Text")], sC);
    var oC = __webpackgi_require__(819);
    class aC {
        static _initialize() {
            this._inited = !0, Mt(T `
          #customContextMenu {
            background: #2c2c2e99;
            backdrop-filter: blur(8px);
            border: 0.5px solid rgba(20, 20, 20, 0.3);
            width: auto;
            height: auto;
            position: absolute;
            display: flex;
            flex-direction: column;
            z-index: 9999;
            padding: 0.35rem 0.20rem;
            border-radius: 0.375rem;
            min-width: 6rem;
            pointer-events: auto;
            box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);
          }

          .customContextMenuItems {
            color: white;
            font-size: 0.65rem;
            font-family: "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
            background-color: transparent;
            cursor: pointer;
            padding: 0.12rem 0.35rem;
            border-radius: 0.25rem;
            line-height: 1rem;
            font-weight: 500;
          }

          .customContextMenuItems:hover {
            color: white;
            background-color: #017AFF;
          }
        `), document.addEventListener("mouseup", (e => {
                this.Element && !this.Element.contains(e.target) && this.Remove()
            }))
        }
        static Create(e, t, n) {
            this._inited || this._initialize(), this.Element && this.Remove();
            const r = wt({
                id: "customContextMenu",
                addToBody: !1
            });
            r.style.top = n + "px", r.style.left = t + "px";
            for (const [t, n] of Object.entries(e)) {
                const e = wt({
                    classList: ["customContextMenuItems"],
                    addToBody: !1,
                    innerHTML: t
                });
                r.appendChild(e), e.onclick = n
            }
            return this.Element = r, r
        }
        static Remove() {
            var e;
            null === (e = this.Element) || void 0 === e || e.remove(), this.Element = void 0
        }
    }
    aC.Element = void 0, aC._inited = !1;
    var lC = __webpackgi_require__(665),
        cC = __webpackgi_require__(532),
        uC = {};
    uC.styleTagTransform = Am(), uC.setAttributes = Sm(), uC.insert = ym().bind(null, "head"), uC.domAPI = bm(), uC.insertStyleElement = Tm(), gm()(cC.Z, uC), cC.Z && cC.Z.locals && cC.Z.locals;
    const pC = (e, t, n) => {
            var r, i, s;
            const o = e.controller_,
                a = null === (i = null === (r = o.parent) || void 0 === r ? void 0 : r.children) || void 0 === i ? void 0 : i.indexOf(o);
            return !(((e, t) => t.controller_.rackController.rack === e.controller_.parent)(e, t) && a === n || (void 0 !== a && a >= 0 && (null === (s = o.parent) || void 0 === s || s.remove(e)), t.add(e, n), 0))
        },
        hC = (e, t, n, r) => {
            var i, s, o, a, l;
            let c = t.uiRef;
            const u = null == c ? void 0 : c.expanded;
            if (c || (c = e.addFolder({
                    title: ""
                }), c.on("fold", (e => {
                    var n, r, i;
                    let s = c.expanded;
                    g(t, "expanded", s, !0), s = null !== (n = x(t.expanded)) && void 0 !== n ? n : s, s !== c.expanded && (c.expanded = s), null === (r = t.uiRefresh) || void 0 === r || r.call(t, "postFrame", !0), s && (null === (i = t.onExpand) || void 0 === i || i.call(t, t))
                }))), !c) return c;
            c.expanded = null !== (s = null !== (i = x(t.expanded)) && void 0 !== i ? i : u) && void 0 !== s && s;
            const p = (null !== (o = t.children) && void 0 !== o ? o : []).map((e => e && x(e))).flat(2).filter((e => e));
            let h = 0;
            for (const e of p) {
                let t = e.uiRef;
                t && t.controller_.viewProps.get("disposed") && (e.uiRef = void 0), t = e.uiRef, t || (n.appendUiObject({
                    uiConfig: e
                }, c), t = e.uiRef), t && pC(t, c, h++) && n.appendUiObject({
                    uiConfig: e
                }, c)
            }
            let d = c.children;
            for (; d.length > h;) {
                const e = d[d.length - 1];
                c.remove(e), d = c.children
            }
            c.controller_.props.set("title", null !== (a = x(t.label)) && void 0 !== a ? a : "");
            const f = c.controller_.view.containerElement,
                _ = x(t.domChildren, []);
            if (void 0 !== (null == _ ? void 0 : _.length)) {
                const e = [];
                for (let t = 0; t < f.children.length; t++) {
                    const n = f.children[t];
                    (null === (l = n.dataset) || void 0 === l ? void 0 : l.tpCustomDOM) && e.push(n)
                }
                for (const t of e) f.removeChild(t);
                for (const e of _) e.parentElement !== f && (f.appendChild(e), e.dataset.tpCustomDOM = "true");
                c.controller_.foldable.cleanUpTransition()
            }
            return c
        },
        dC = (e, t, n, r) => {
            var i, s;
            const [o, a] = null !== (i = t.property) && void 0 !== i ? i : [void 0, void 0], l = null !== (s = x(t.label)) && void 0 !== s ? s : a;
            let c = t.uiRef;
            return c || (c = e.addButton({
                title: ""
            }), c.on("click", (() => {
                var e;
                const r = null !== (e = o && a ? o[a] : void 0) && void 0 !== e ? e : t.value;
                if ("function" == typeof r) {
                    const e = () => {
                        n.removeEventListener("postFrame", e), r()
                    };
                    n.addEventListener("postFrame", e)
                } else console.warn("Invalid action type for button")
            }))), c && (c.title = null != l ? l : "click me"), c
        },
        fC = (e, t, n, r) => {
            var i;
            const s = Object.fromEntries((null !== (i = x(t.children)) && void 0 !== i ? i : []).map((e => x(e))).flat(2).filter((e => e)).map((e => {
                var t;
                const n = x(e.label);
                return [n, null !== (t = e.value) && void 0 !== t ? t : n]
            })));
            return vC(e, t, n, {
                options: s,
                ...null != r ? r : {}
            })
        },
        _C = (e, t, n, r) => {
            var i, s, o, a;
            const l = (null !== (s = null === (i = t.bounds) || void 0 === i ? void 0 : i.length) && void 0 !== s ? s : 0) >= 2 ? t.bounds[1] : 1,
                c = (null !== (a = null === (o = t.bounds) || void 0 === o ? void 0 : o.length) && void 0 !== a ? a : 0) >= 1 ? t.bounds[0] : 0,
                u = t.stepSize || void 0;
            return vC(e, t, n, {
                min: c,
                max: l,
                step: u,
                ...null != r ? r : {}
            })
        },
        mC = (e, t, n, r) => {
            var s, o, a;
            if (!t.bounds || t.bounds.length < 1) return vC(e, t, n, { ...null != r ? r : {}
            });
            const l = (null !== (s = t.bounds.length) && void 0 !== s ? s : 0) >= 2 ? t.bounds[1] : 1,
                c = (null !== (o = t.bounds.length) && void 0 !== o ? o : 0) >= 1 ? t.bounds[0] : 0,
                u = {
                    min: c,
                    max: l,
                    step: null !== (a = t.stepSize) && void 0 !== a ? a : (l - c) / 100
                },
                p = {
                    x: u,
                    y: u
                };
            "vec3" !== t.type && "vec4" !== t.type || (p.z = u), "vec4" === t.type && (p.w = u);
            const h = t.property;
            if (void 0 === t.value && h && h[0] && "object" == typeof h[0] && h[0][h[1]] && Array.isArray(h[0][h[1]])) {
                const [e, n] = h, r = e[n], s = r.length, o = (new(2 === s ? i.FM8 : 3 === s ? i.Pa4 : i.Ltg)).fromArray(r);
                t.value = o, t.property = void 0, t.onChange = [() => {
                    e[n] = o.toArray()
                }, ...Array.isArray(t.onChange) ? t.onChange : [t.onChange]].filter((e => e)), void 0 === t.label && (t.label = n)
            }
            return vC(e, t, n, { ...p,
                ...null != r ? r : {}
            })
        },
        gC = (e, t, n, r) => {
            var i;
            const s = t.property;
            if (void 0 === t.value && s && "object" == typeof s[0] && (null === (i = s[0][s[1]]) || void 0 === i ? void 0 : i.isColor)) {
                const [e, n] = s, r = (new ve).set(e[n]).convertSRGBToLinear();
                Object.defineProperty(t, "value", {
                    get: () => {
                        const t = e[n];
                        return t ? r.set(t).convertLinearToSRGB().getHex() : 0
                    },
                    set: t => {
                        var i;
                        const s = e[n];
                        r.setHex(t).convertSRGBToLinear(), s.isColor ? s.copy(r) : "number" == typeof s ? e[n] = r.getHex() : "string" == typeof s && (e[n] = "#" + r.getHexString()), "function" == typeof(null === (i = null == e ? void 0 : e.userData) || void 0 === i ? void 0 : i.setDirty) && e.userData.setDirty()
                    }
                }), t.property = void 0, t.onChange = [...Array.isArray(t.onChange) ? t.onChange : [t.onChange]].filter((e => e)), void 0 === t.label && (t.label = n)
            }
            return (r = null != r ? r : {}).view = "color", x(t.inlinePicker) && (r.picker = "inline"), vC(e, t, n, r)
        },
        vC = (e, t, n, r) => {
            var i;
            let s = x(t.property);
            if ((t.getValue || t.setValue) && s && console.error("specify either property or value, or getValue and setValue", t), s) t.value && console.warn("Both property and value are defined, value will be ignored", t);
            else if (void 0 === t.value && (t.getValue || t.setValue) && (Object.defineProperty(t, "value", {
                    get: () => {
                        var e;
                        return null === (e = t.getValue) || void 0 === e ? void 0 : e.call(t)
                    },
                    set: e => {
                        var n;
                        return null === (n = t.setValue) || void 0 === n ? void 0 : n.call(t, e)
                    }
                }), s = [t, "value"]), s || void 0 === t.value || (s = [t, "value"]), !s) return void console.error("cannot determine property", t);
            r = null != r ? r : {};
            const o = {
                label: null !== (i = x(t.label)) && void 0 !== i ? i : s[1],
                ...r
            };
            let a = t.uiRef;
            if (!a && "object" == typeof s[0] && s[0]) {
                const [n, r] = s;
                try {
                    a = t.isMonitor ? e.addMonitor(n, r, o) : e.addInput(n, r, o).on("change", (e => {
                        var r;
                        [t.onChange].flat().forEach((t => "function" == typeof t && (null == t ? void 0 : t(e)))), "function" == typeof(null === (r = null == n ? void 0 : n.userData) || void 0 === r ? void 0 : r.setDirty) && n.userData.setDirty(e)
                    }))
                } catch (e) {
                    if (!e.message.startsWith("No matching controller for")) throw e;
                    a = void 0
                }
            }
            if (a) {
                for (const [e, t] of Object.entries(o)) {
                    const n = a.controller_.props.value(e);
                    void 0 !== n && n.rawValue !== t && a.controller_.props.set(e, t)
                }
                a.refresh()
            }
            return a
        };
    class bC extends r {
        constructor(e = !1, t = !1, n = !1, r = !0) {
            super(), this._refreshQueue = {
                preRender: [],
                postRender: [],
                preFrame: [],
                postFrame: []
            }, this._typeGenerators = {
                folder: hC,
                input: vC,
                slider: _C,
                dropdown: fC,
                checkbox: vC,
                color: gC,
                vec: mC,
                vec2: mC,
                vec3: mC,
                vec4: mC,
                button: dC,
                monitor: (e, t, n, r) => (t.isMonitor = !0, vC(e, t, n, r)),
                dummy: (e, t, n, r) => vC(e, t, n, r)
            }, this._expand = e, this._limitedOptions = n;
            const i = this._createUiContainer();
            this._pane = new lC.Pane({
                title: "Configuration",
                container: i
            }), this._pane.expanded = this._expand, r && (this.addEventListener("postFrame", (() => this.refreshQueue("postFrame"))), setTimeout((() => {
                this.dispatchEvent({
                    type: "postFrame"
                })
            }), 32))
        }
        refreshQueue(e) {
            const t = this._refreshQueue[e];
            this._refreshQueue[e] = [], t.forEach((e => this._refreshUiObject(e[0], e[1], e[2])))
        }
        addToRefreshQueue(e, t) {
            var n;
            const r = null === (n = t[0]) || void 0 === n ? void 0 : n.uiConfig,
                i = null == r ? void 0 : r.uuid,
                s = this._refreshQueue[e];
            s.findIndex((e => e[3] === i)) < 0 && s.push([...t, i]), this._refreshQueue[e] = s
        }
        dispose() {
            var e;
            null === (e = this._pane) || void 0 === e || e.dispose(), this._pane = void 0
        }
        appendUiObject(e, t) {
            e && this._appendUiObject(e, t)
        }
        _appendUiObject(e, t) {
            var n, r, i, s;
            const {
                uiConfig: o
            } = null != e ? e : {};
            if (o && (!this._limitedOptions || o.limitedUi) && (t = null != t ? t : this._pane, o.type)) {
                o.uuid || (o.uuid = Be()), o.uiRef && o.uiRefType !== o.type && (console.log("Removing UI object because of type mismatch", o.uiRef), this.removeUiConfig(o));
                const a = null === (r = (n = this._typeGenerators)[o.type]) || void 0 === r ? void 0 : r.call(n, t, o, this);
                a && (a.hidden = null !== (i = x(o.hidden)) && void 0 !== i && i, a.disabled = null !== (s = x(o.disabled)) && void 0 !== s && s), o.uiRef = a, o.uiRefType = a ? o.type : void 0, o.uiRefresh = (n = "postFrame", r = !1, i = 0) => {
                    var s;
                    return this._uiObjectRefresh(n, null !== (s = null == e ? void 0 : e.uiConfig) && void 0 !== s ? s : o, t, r, i)
                }
            }
        }
        removeUiObject(e) {
            this.removeUiConfig(null == e ? void 0 : e.uiConfig)
        }
        removeUiConfig(e) {
            var t, n;
            e && e.uiRef && e.uiRefType !== e.type && (null === (n = (t = e.uiRef).dispose) || void 0 === n || n.call(t), e.uiRefType = void 0, e.uiRefresh = void 0)
        }
        _uiObjectRefresh(e, t, n, r, i) {
            (r ? xC(t, n) : [{
                uiConfig: t,
                parentFolder: n
            }]).forEach((t => {
                const n = [{
                    uiConfig: t.uiConfig
                }, t.parentFolder, i];
                "immediate" === e ? this._refreshUiObject(...n) : this.addToRefreshQueue(e, n)
            }))
        }
        _refreshUiObject(e, t, n = 0) {
            this._appendUiObject(e, t), n > 1e-4 && console.error("no support for immediate delay")
        }
        _createUiContainer() {
            const e = wt({
                id: "tweakpaneUiContainer"
            });
            return Mt(T `
          #tweakpaneUiContainer {
            position: fixed;
            top: 0px;
            padding-right: 4px;
            padding-bottom: 10px;
            right: 10px;
            width: max(20%, 300px);
            height: auto;
            overflow-y: scroll;
            z-index: 100;
            pointer-events: auto;
            max-height: calc(100% - 6rem);
            border-radius: 0.5rem;
          }
        `), e
        }
    }

    function xC(e, t, n) {
        var r;
        return n = null != n ? n : [], e ? (n.push({
            uiConfig: e,
            parentFolder: t
        }), null === (r = e.children) || void 0 === r || r.forEach((t => n = xC(t, e.uiRef, n))), n) : n
    }
    class yC {
        constructor() {
            yC.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
        }
        set(e, t, n, r, i, s, o, a, l) {
            const c = this.elements;
            return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = i, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }
        copy(e) {
            const t = this.elements,
                n = e.elements;
            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        }
        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements,
                r = t.elements,
                i = this.elements,
                s = n[0],
                o = n[3],
                a = n[6],
                l = n[1],
                c = n[4],
                u = n[7],
                p = n[2],
                h = n[5],
                d = n[8],
                f = r[0],
                _ = r[3],
                m = r[6],
                g = r[1],
                v = r[4],
                b = r[7],
                x = r[2],
                y = r[5],
                w = r[8];
            return i[0] = s * f + o * g + a * x, i[3] = s * _ + o * v + a * y, i[6] = s * m + o * b + a * w, i[1] = l * f + c * g + u * x, i[4] = l * _ + c * v + u * y, i[7] = l * m + c * b + u * w, i[2] = p * f + h * g + d * x, i[5] = p * _ + h * v + d * y, i[8] = p * m + h * b + d * w, this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        }
        determinant() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                r = e[2],
                i = e[3],
                s = e[4],
                o = e[5],
                a = e[6],
                l = e[7],
                c = e[8];
            return t * s * c - t * o * l - n * i * c + n * o * a + r * i * l - r * s * a
        }
        invert() {
            const e = this.elements,
                t = e[0],
                n = e[1],
                r = e[2],
                i = e[3],
                s = e[4],
                o = e[5],
                a = e[6],
                l = e[7],
                c = e[8],
                u = c * s - o * l,
                p = o * a - c * i,
                h = l * i - s * a,
                d = t * u + n * p + r * h;
            if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / d;
            return e[0] = u * f, e[1] = (r * l - c * n) * f, e[2] = (o * n - r * s) * f, e[3] = p * f, e[4] = (c * t - r * a) * f, e[5] = (r * i - o * t) * f, e[6] = h * f, e[7] = (n * a - l * t) * f, e[8] = (s * t - n * i) * f, this
        }
        transpose() {
            let e;
            const t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose()
        }
        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        }
        setUvTransform(e, t, n, r, i, s, o) {
            const a = Math.cos(i),
                l = Math.sin(i);
            return this.set(n * a, n * l, -n * (a * s + l * o) + s + e, -r * l, r * a, -r * (-l * s + a * o) + o + t, 0, 0, 1), this
        }
        scale(e, t) {
            const n = this.elements;
            return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
        }
        rotate(e) {
            const t = Math.cos(e),
                n = Math.sin(e),
                r = this.elements,
                i = r[0],
                s = r[3],
                o = r[6],
                a = r[1],
                l = r[4],
                c = r[7];
            return r[0] = t * i + n * a, r[3] = t * s + n * l, r[6] = t * o + n * c, r[1] = -n * i + t * a, r[4] = -n * s + t * l, r[7] = -n * o + t * c, this
        }
        translate(e, t) {
            const n = this.elements;
            return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
        }
        equals(e) {
            const t = this.elements,
                n = e.elements;
            for (let e = 0; e < 9; e++)
                if (t[e] !== n[e]) return !1;
            return !0
        }
        fromArray(e, t = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
            return this
        }
        toArray(e = [], t = 0) {
            const n = this.elements;
            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
        }
        clone() {
            return (new this.constructor).fromArray(this.elements)
        }
    }

    function wC(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e)
    }
    let SC;
    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
    class MC {
        constructor(e = null) {
            this.isSource = !0, this.uuid = $(), this.data = e, this.version = 0
        }
        set needsUpdate(e) {
            !0 === e && this.version++
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
            const n = {
                    uuid: this.uuid,
                    url: ""
                },
                r = this.data;
            if (null !== r) {
                let e;
                if (Array.isArray(r)) {
                    e = [];
                    for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(TC(r[t].image)) : e.push(TC(r[t]))
                } else e = TC(r);
                n.url = e
            }
            return t || (e.images[this.uuid] = n), n
        }
    }

    function TC(e) {
        return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? class {
            static getDataURL(e) {
                if (/^data:/i.test(e.src)) return e.src;
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                let t;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    void 0 === SC && (SC = wC("canvas")), SC.width = e.width, SC.height = e.height;
                    const n = SC.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = SC
                }
                return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
            }
            static sRGBToLinear(e) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    const t = wC("canvas");
                    t.width = e.width, t.height = e.height;
                    const n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    const r = n.getImageData(0, 0, e.width, e.height),
                        i = r.data;
                    for (let e = 0; e < i.length; e++) i[e] = 255 * le(i[e] / 255);
                    return n.putImageData(r, 0, 0), t
                }
                if (e.data) {
                    const t = e.data.slice(0);
                    for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * le(t[e] / 255)) : t[e] = le(t[e]);
                    return {
                        data: t,
                        width: e.width,
                        height: e.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
            }
        }.getDataURL(e) : e.data ? {
            data: Array.from(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
    }
    let EC = 0;
    class AC extends class {
        addEventListener(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
        }
        hasEventListener(e, t) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        }
        removeEventListener(e, t) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[e];
            if (void 0 !== n) {
                const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
            }
        }
        dispatchEvent(e) {
            if (void 0 === this._listeners) return;
            const t = this._listeners[e.type];
            if (void 0 !== t) {
                e.target = this;
                const n = t.slice(0);
                for (let t = 0, r = n.length; t < r; t++) n[t].call(this, e);
                e.target = null
            }
        }
    } {
        constructor(e = AC.DEFAULT_IMAGE, t = AC.DEFAULT_MAPPING, n = 1001, r = 1001, i = se, s = 1008, o = 1023, a = 1009, l = 1, c = 3e3) {
            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                value: EC++
            }), this.uuid = $(), this.name = "", this.source = new MC(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new k(0, 0), this.repeat = new k(1, 1), this.center = new k(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new yC, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
        }
        get image() {
            return this.source.data
        }
        set image(e) {
            this.source.data = e
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(e).uuid,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(e) {
            if (300 !== this.mapping) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                case 1e3:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case 1001:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                case 1e3:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case 1001:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
        set needsUpdate(e) {
            !0 === e && (this.version++, this.source.needsUpdate = !0)
        }
    }
    AC.DEFAULT_IMAGE = null, AC.DEFAULT_MAPPING = 300;
    class CC extends bC {
        constructor(e = !1, t = !1, n = !1) {
            super(e, t, n, !1), this.dependencies = [Vs], this._preRender = () => this.refreshQueue("preRender"), this._postRender = () => this.refreshQueue("postRender"), this._postFrame = e => {
                this.dispatchEvent(e), this.refreshQueue("postFrame")
            }, this._preFrame = () => this.refreshQueue("preFrame"), this._plugins = [], this._pane.registerPlugin(oC)
        }
        async onAdded(e) {
            this._viewer = e, this._typeGenerators.image = (e => (t, n, r, s) => {
                const o = n.property,
                    a = "placeholder";
                if (void 0 === n.value && o && "object" == typeof o[0]) {
                    const [t, r] = o, s = pT("Render Target"), l = pT("Data Texture"), c = pT("Compressed Texture"), u = {}, p = {};
                    Object.defineProperty(n, "value", {
                        get: () => {
                            var e;
                            let n, i = t[r];
                            if ((null == i ? void 0 : i.get) && (i = i.get()), !i) return a;
                            if (i.isRenderTargetTexture && !i.image.tp_src && (i.image.tp_src = s), i.isDataTexture && !i.image.tp_src && (i.image.tp_src = l), i.isCompressedTexture && !i.image.tp_src && (i.image.tp_src = c), i.isTexture ? (i.image && (i.image instanceof ImageBitmap || i.image instanceof HTMLImageElement || i.image instanceof HTMLVideoElement) && !i.image.tp_src && (i.image.tp_src = Et(i.image, 160)), i.image && (n = i.image.tp_src_uuid, n = n ? u[n] : void 0, n || (n = i.image.tp_src || i.image.src))) : "string" == typeof i ? n = i : i && console.error("unknown value", i), n || (n = a), i.image && !i.image.tp_src_uuid) {
                                const e = Be();
                                i.image.tp_src_uuid = e, p[n] = e
                            }
                            return "string" == typeof n && (n = null !== (e = u[n]) && void 0 !== e ? e : n), n
                        },
                        set: s => {
                            var o, l, c, h, d, f, _, m, g, v, b, x, y;
                            const w = t[r],
                                S = e => {
                                    var n;
                                    t[r] = e, (null == e ? void 0 : e.isTexture) && (e.flipY = e.isDataTexture ? e.flipY : null === (n = null == w ? void 0 : w.flipY) || void 0 === n || n)
                                };
                            if ("string" == typeof s) return void("string" == typeof w && S(s));
                            let M = s.tp_src_uuid;
                            if (M || (M = null !== (o = s.src) && void 0 !== o ? o : s.tp_src, M = null !== (l = p[M]) && void 0 !== l ? l : M, delete p[M], s.tp_src_uuid = M), M && (u[M] = s), s)
                                if (s.isPlaceholder) w && (S("string" == typeof w ? "" : null), "function" == typeof(null === (c = null == t ? void 0 : t.userData) || void 0 === c ? void 0 : c.setDirty) && t.userData.setDirty());
                                else if ("string" != typeof w) {
                                if (!((null == w ? void 0 : w.image) === s || (null === (h = null == w ? void 0 : w.image) || void 0 === h ? void 0 : h.src) === s.src || (null === (d = null == w ? void 0 : w.image) || void 0 === d ? void 0 : d.tp_src) === s.tp_src && null != s.tp_src || (null === (f = null == w ? void 0 : w.image) || void 0 === f ? void 0 : f.tp_src) === s.src && null != s.src || (null === (_ = null == w ? void 0 : w.image) || void 0 === _ ? void 0 : _.src) === s.tp_src && null != s.tp_src))
                                    if (s instanceof File) {
                                        const r = null == e ? void 0 : e.getPlugin(Vs);
                                        if (!r) throw "Viewer or AssetManagerPlugin not found";
                                        null === (m = r.importer) || void 0 === m || m.importSingle({
                                            file: s,
                                            path: s.src
                                        }).then((e => {
                                            var r, i, o, a, l;
                                            if (e) {
                                                e.isDataTexture && (e.needsUpdate = !0);
                                                const c = null === (o = null === (i = null === (r = s.src) || void 0 === r ? void 0 : r.split("?")) || void 0 === i ? void 0 : i[0]) || void 0 === o ? void 0 : o.split(".").pop();
                                                e.userData.mimeType || (e.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(c) ? "jpeg" : "png")), S(e), [n.onChange].flat().forEach((e => "function" == typeof e && (null == e ? void 0 : e()))), "function" == typeof(null === (a = null == t ? void 0 : t.userData) || void 0 === a ? void 0 : a.setDirty) && t.userData.setDirty(), null === (l = n.uiRefresh) || void 0 === l || l.call(n, "postFrame", !1)
                                            }
                                        }))
                                    } else {
                                        const e = new AC(s);
                                        e.assetType = "texture", e.needsUpdate = !0;
                                        const o = null === (b = null === (v = null === (g = s.src) || void 0 === g ? void 0 : g.split("?")) || void 0 === v ? void 0 : v[0]) || void 0 === b ? void 0 : b.split(".").pop();
                                        e.userData.mimeType || (e.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(o) ? "jpeg" : "png")), S(e);
                                        const a = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(r);
                                        e.encoding = a ? i.rnI : i.knz, e.wrapS = i.rpg, e.wrapT = i.rpg, [n.onChange].flat().forEach((e => "function" == typeof e && (null == e ? void 0 : e()))), "function" == typeof(null === (x = null == t ? void 0 : t.userData) || void 0 === x ? void 0 : x.setDirty) && t.userData.setDirty(), null === (y = n.uiRefresh) || void 0 === y || y.call(n, "postFrame", !1)
                                    }
                            } else S(M);
                            else n.value = a
                        }
                    }), n.property = void 0, void 0 === n.label && (n.label = r)
                }
                return (s = null != s ? s : {}).extensions = [".jpg", ".png", ".svg", ".hdr", ".exr", ".jpeg", ".bmp", ".gif", ".webp"], void 0 === s.imageFit && (s.imageFit = "contain"), void 0 === s.clickCallback && (s.clickCallback = (t, r) => {
                    var i;
                    const s = null == t ? void 0 : t.target,
                        l = null == s ? void 0 : s.getBoundingClientRect();
                    if (!l) return void r.click();
                    const c = n.uiRef.controller_.valueController.value.rawValue;
                    if (c === a || (null == c ? void 0 : c.isPlaceholder)) r.click();
                    else {
                        const t = aC.Create({
                            "remove image": () => {
                                var e, t;
                                n.uiRef.controller_.valueController.value.setRawValue("");
                                const [r, i] = o || [n, "value"], s = "string" == typeof r[i];
                                r[i] = s ? "" : null, [n.onChange].flat().forEach((e => "function" == typeof e && (null == e ? void 0 : e()))), "function" == typeof(null === (e = null == r ? void 0 : r.userData) || void 0 === e ? void 0 : e.setDirty) && r.userData.setDirty(), null === (t = n.uiRefresh) || void 0 === t || t.call(n, "postFrame", !1), aC.Remove()
                            },
                            "replace image": () => {
                                r.click(), aC.Remove()
                            },
                            "download image": () => {
                                var e, t, r;
                                const [i, s] = o || [n, "value"];
                                let a = null !== (t = null === (e = i[s]) || void 0 === e ? void 0 : e.image) && void 0 !== t ? t : n.uiRef.controller_.valueController.value.rawValue;
                                a && (a instanceof ImageBitmap || a instanceof HTMLImageElement || a instanceof HTMLVideoElement) && !a.src && (a = Et(a));
                                const l = document.createElement("a");
                                document.body.appendChild(l), l.style.display = "none", l.href = null !== (r = null == a ? void 0 : a.src) && void 0 !== r ? r : a, l.download = "image.png", l.click(), document.body.removeChild(l), aC.Remove()
                            },
                            "from url": async () => {
                                var t, r, i;
                                let s = "";
                                if (s && (s.startsWith("http") || s.startsWith("data:image")) || (s = ""), s = prompt("enter image url", s), !s || !s.startsWith("http") && !s.startsWith("data:image")) return null !== s && alert("invalid url"), void aC.Remove();
                                const [a, l] = o || [n, "value"], c = a[l];
                                if ("string" == typeof c) a[l] = s, [n.onChange].flat().forEach((e => "function" == typeof e && (null == e ? void 0 : e()))), "function" == typeof(null === (t = null == a ? void 0 : a.userData) || void 0 === t ? void 0 : t.setDirty) && a.userData.setDirty(), null === (r = n.uiRefresh) || void 0 === r || r.call(n, "postFrame", !1);
                                else {
                                    const t = null == e ? void 0 : e.getPlugin(Vs);
                                    if (!t) throw "Viewer or AssetManagerPlugin not found";
                                    null === (i = t.importer) || void 0 === i || i.importSinglePath(s).then((e => {
                                        var t, r;
                                        e && (e.isDataTexture ? e.needsUpdate = !0 : e && void 0 !== (null == c ? void 0 : c.flipY) && (e.flipY = c.flipY), a[l] = e, [n.onChange].flat().forEach((e => "function" == typeof e && (null == e ? void 0 : e()))), "function" == typeof(null === (t = null == a ? void 0 : a.userData) || void 0 === t ? void 0 : t.setDirty) && a.userData.setDirty(), null === (r = n.uiRefresh) || void 0 === r || r.call(n, "postFrame", !1))
                                    }))
                                }
                                aC.Remove()
                            },
                            cancel: () => {
                                aC.Remove()
                            }
                        }, 2, l.height + 8);
                        null === (i = s.parentElement) || void 0 === i || i.appendChild(t), l.y > .7 * document.body.clientHeight && (t.style.top = "auto", t.style.bottom = l.height + 8 + "px")
                    }
                }), s.view = "input-image", vC(t, n, r, s)
            })(this._viewer), e.addEventListener("preRender", this._preRender), e.addEventListener("postRender", this._postRender), e.addEventListener("preFrame", this._preFrame), e.addEventListener("postFrame", this._postFrame)
        }
        async onDispose(e) {
            this.dispose()
        }
        async onRemove(e) {
            this._viewer = void 0, e.removeEventListener("preRender", this._preRender), e.removeEventListener("postRender", this._postRender), e.removeEventListener("preFrame", this._preFrame), e.removeEventListener("postFrame", this._postFrame), this.dispose()
        }
        setupPluginUi(e) {
            var t;
            const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPlugin(e);
            if (!n) return void console.warn("plugin not found:", e);
            this._plugins.push(n), n.uiConfig && (n.uiConfig.limitedUi = !0), n.uiConfig && void 0 === n.uiConfig.hidden && (n.uiConfig.hidden = !1), this._appendUiObject(n);
            const r = n.uiConfig;
            if ((null == r ? void 0 : r.uiRef) && n.toJSON) {
                const e = r.uiRef.controller_.view.element,
                    t = wt({
                        innerHTML: "&#8942;",
                        classList: ["pluginOptionsButton"],
                        elementTag: "button"
                    });
                t.onclick = t => {
                    const r = {};
                    "function" == typeof n.toJSON && (r["download preset"] = async () => {
                        var e, t;
                        const r = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Vs)) || void 0 === t ? void 0 : t.exportPluginPreset(n);
                        await vt(new Blob([JSON.stringify(r, null, 2)], {
                            type: "application/json"
                        }), "preset." + n.constructor.PluginType + ".json"), aC.Remove()
                    }), "function" == typeof n.fromJSON && (r["upload preset"] = async () => {
                        var e, t;
                        aC.Remove();
                        const r = await yt(!1, !1);
                        if (0 === r.length) return;
                        const i = r[0],
                            s = await i.text(),
                            o = JSON.parse(s);
                        await (null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importPluginPreset(o, n))
                    });
                    const i = aC.Create(r, e.clientWidth - 120, 12);
                    e.append(i), t.preventDefault()
                }, e.appendChild(t)
            }
            return r
        }
        setupPlugins(...e) {
            e.forEach((e => this.setupPluginUi(e)))
        }
        refreshPluginsEnabled() {
            this._plugins.forEach((e => {
                var t;
                const n = e.uiConfig;
                n && (!0 !== x(n.hidden) ? null === (t = n.uiRefresh) || void 0 === t || t.call(n, "postFrame", !0) : n.uiRef && (n.uiRef.hidden = !0))
            }))
        }
    }
    CC.PluginType = "TweakpaneUi";
    class RC extends Gs {
        constructor() {
            super(...arguments), this.enabled = !0, this.toJSON = void 0, this.bgUIConfig = {
                label: "Color",
                type: "color",
                inlinePicker: !0,
                onChange: () => {
                    if (!this._viewer) return;
                    const e = new ve(this.bgUIConfig.value || 16777215).convertSRGBToLinear();
                    this._viewer.setBackground(e.getHex())
                },
                expanded: !0,
                limitedUi: !0
            }, this.uiConfig = {
                label: "Background / Environment",
                type: "folder",
                expanded: !1,
                limitedUi: !0,
                children: [this.bgUIConfig, {
                    label: "Image",
                    property: [this, "sceneBackground"],
                    type: "image",
                    limitedUi: !0
                }, {
                    label: "EnvMap BG",
                    type: "checkbox",
                    property: [this, "envmapBg"]
                }, () => ({
                    type: "slider",
                    label: "BG Intensity",
                    property: [this._viewer, "backgroundIntensity"],
                    bounds: [0, 16]
                }), {
                    label: "Set Transparent BG",
                    type: "button",
                    hidden: () => !this._viewer || this._viewer.useRgbm,
                    value: () => {
                        var e;
                        null === (e = this._viewer) || void 0 === e || e.setBackground(null)
                    }
                }, {
                    label: "Environment",
                    property: [this, "sceneEnvironment"],
                    type: "image",
                    limitedUi: !0
                }, {
                    type: "slider",
                    label: "Env Rotation",
                    property: [this, "sceneEnvironmentRotation"],
                    bounds: [0, 2 * Math.PI],
                    limitedUi: !0
                }, {
                    type: "slider",
                    label: "Env Intensity",
                    property: [this, "sceneEnvironmentIntensity"],
                    bounds: [0, 4],
                    limitedUi: !0
                }]
            }
        }
        get sceneBackground() {
            var e;
            const t = null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground();
            return t && (t.isTexture || "texture" === t.assetType) ? t : null
        }
        set sceneBackground(e) {
            var t, n;
            e ? null === (t = this._viewer) || void 0 === t || t.setBackground(e) : null === (n = this._viewer) || void 0 === n || n.setBackground(this.bgUIConfig.value)
        }
        get sceneEnvironment() {
            var e;
            return null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment()
        }
        set sceneEnvironment(e) {
            var t;
            null === (t = this._viewer) || void 0 === t || t.scene.setEnvironment(e)
        }
        get sceneEnvironmentRotation() {
            var e, t, n;
            return null !== (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.getEnvironment()) || void 0 === t ? void 0 : t.rotation) && void 0 !== n ? n : 0
        }
        set sceneEnvironmentRotation(e) {
            var t, n;
            const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.getEnvironment();
            r && (r.rotation = e, null === (n = this._viewer) || void 0 === n || n.scene.setDirty())
        }
        get sceneEnvironmentIntensity() {
            var e, t;
            return null !== (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.envMapIntensity) && void 0 !== t ? t : 1
        }
        set sceneEnvironmentIntensity(e) {
            var t;
            (null === (t = this._viewer) || void 0 === t ? void 0 : t.scene) && (this._viewer.scene.envMapIntensity = e)
        }
        get envmapBg() {
            var e;
            return (null === (e = this._viewer) || void 0 === e ? void 0 : e.getBackground(!0)) === io
        }
        set envmapBg(e) {
            if (this._viewer)
                if (e) {
                    const e = this._viewer.getBackground(!0);
                    e && e !== io && (this.lastBgVal = e), this._viewer.setBackground(io)
                } else this._viewer.getBackground() === this._viewer.scene.getEnvironment() && this._viewer.setBackground(this.lastBgVal || this.bgUIConfig.value)
        }
        async onAdded(e) {
            var t;
            await super.onAdded(e);
            const n = e.getBackground();
            this.bgUIConfig.value = "string" == typeof n && n !== io || "number" == typeof n || (null === (t = n) || void 0 === t ? void 0 : t.isColor) ? "#" + new ve(n).getHexString() : "#000000", this.lastBgVal = n
        }
    }
    RC.PluginType = "SimpleBackgroundEnvUiPlugin1";
    class kC extends Gs {
        constructor() {
            super(), this.enabled = !0, this.toJSON = void 0, this._uiConfig = {
                type: "folder",
                label: "Scene",
                children: [],
                onExpand: () => {
                    var e, t;
                    null === (t = (e = this._uiConfig).uiRefresh) || void 0 === t || t.call(e, "postFrame", !0)
                }
            }, this._onSelect = e => {
                var t, n;
                e.value ? null === (n = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("Picking")) || void 0 === n || n.setSelectedObject(e.value, !0) : console.warn("e.value must be set for picking")
            }, this._sceneUpdate = this._sceneUpdate.bind(this)
        }
        async onAdded(e) {
            await super.onAdded(e), e.scene.addEventListener("sceneUpdate", this._sceneUpdate)
        }
        async onRemove(e) {
            return e.scene.removeEventListener("sceneUpdate", this._sceneUpdate), super.onRemove(e)
        }
        setDirty() {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setDirty()
        }
        get uiConfig() {
            var e, t, n, r, i;
            return this._viewer ? (this._uiConfig.children = [], this._uiConfig.children.push(this._viewer.scene.activeCamera.uiConfig), this._uiConfig.children.push(...null !== (n = null === (t = null === (e = this._viewer) || void 0 === e ? void 0 : e.scene.modelRoot.modelObject.children) || void 0 === t ? void 0 : t.map((e => "light" === e.assetType ? null : e.uiConfig)).filter((e => null != e))) && void 0 !== n ? n : []), null === (i = null === (r = this._viewer) || void 0 === r ? void 0 : r.scene.modelRoot.modelObject.children) || void 0 === i || i.forEach((e => {
                e.addEventListener("select", this._onSelect)
            })), this._uiConfig) : this._uiConfig
        }
        _sceneUpdate() {
            var e, t;
            null === (t = null === (e = this._uiConfig) || void 0 === e ? void 0 : e.uiRefresh) || void 0 === t || t.call(e, "postFrame", !0)
        }
    }
    kC.PluginType = "SimpleUi";
    var PC = __webpackgi_require__(466);
    class DC extends Gs {
        constructor(e = !0) {
            super(), this.enabled = !0, this.toJSON = void 0, this.treeView = void 0, this.hierarchyDiv = wt({
                innerHTML: "",
                id: "tpHierarchyContainer"
            }), this._uiConfig = {
                type: "folder",
                label: "Hierarchy",
                children: []
            }, this._buildData = (e, t) => (e.push({
                text: t.name || "unnamed",
                id: t.uuid,
                children: t.children.reduce(this._buildData, [])
            }), e), this._findVisible = (e, t) => t.visible ? (t.children.length < 1 ? e.push(t.uuid) : e.push(...t.children.reduce(this._findVisible, [])), e) : e, this._setVisible = e => {
                var t, n, r;
                const i = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot;
                if (!i || null == e) return;
                const s = new Set;
                i.traverse((t => {
                    t !== i && (t.visible = e.includes(t.uuid), t.visible && t.traverseAncestors((e => s.add(e))))
                })), s.forEach((e => e.visible = !0)), null === (r = null === (n = this._viewer) || void 0 === n ? void 0 : n.scene) || void 0 === r || r.setDirty({
                    sceneUpdate: !0,
                    fromHierarchyPlugin: !0,
                    updateGround: !1
                })
            }, this.enabled = e, this.reset = this.reset.bind(this), Mt(T `
#tpHierarchyContainer{
  width: 100%;
  height: auto;
  background-color: transparent;
  color: #e9e9ed;
  margin-top: 0;
}
`)
        }
        reset(e) {
            var t;
            if (null == e ? void 0 : e.fromHierarchyPlugin) return;
            for (; this.hierarchyDiv.firstChild;) this.hierarchyDiv.firstChild.remove();
            const n = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot;
            if (!n) return;
            const r = n.children.reduce(this._buildData, []),
                i = n.children.reduce(this._findVisible, []);
            let s = !1;
            return new Promise(((e, t) => {
                this.treeView = new PC("#tpHierarchyContainer", {
                    closeDepth: 1,
                    data: r,
                    loaded: function() {
                        this.values = i, e()
                    },
                    onChange: () => {
                        s ? _c(200).then((() => {
                            this.treeView && this._setVisible(this.treeView.values)
                        })) : s = !0
                    },
                    onItemLabelClick: e => {
                        var t;
                        const r = null === (t = this._viewer) || void 0 === t ? void 0 : t.scene.modelRoot.modelObject.getObjectByProperty("uuid", e);
                        r && n.visible && r.dispatchEvent({
                            type: "select",
                            value: r
                        })
                    }
                })
            }))
        }
        async onAdded(e) {
            await super.onAdded(e), this.reset(), e.scene.addEventListener("sceneUpdate", this.reset)
        }
        async onRemove(e) {
            return e.scene.removeEventListener("sceneUpdate", this.reset), super.onRemove(e)
        }
        async onDispose(e) {
            return super.onDispose(e)
        }
        get uiConfig() {
            return this._uiConfig.domChildren || (this._uiConfig.domChildren = [this.hierarchyDiv]), this._uiConfig
        }
    }
    DC.PluginType = "HierarchyUiPlugin";
    var OC = pE({
            defaultModifiers: [fE, bE, wE, SE]
        }),
        LC = __webpackgi_require__(388),
        IC = __webpackgi_require__.n(LC);

    function FC(e) {
        const t = [];
        e.traverse((e => {
            e.geometry && t.push(e)
        }));
        const n = {},
            r = {};
        t.forEach((e => {
            var t;
            if (!n[e.geometry.uuid]) {
                const t = e.geometry.toJSON().data,
                    r = t ? IC()({
                        a: t.attributes || {},
                        b: t.index || []
                    }) : "";
                n[e.geometry.uuid] = r
            }
            const i = n[e.geometry.uuid],
                s = null !== (t = r[i]) && void 0 !== t ? t : r[i] = [];
            s.includes(e) || s.push(e)
        })), Object.values(r).forEach((e => {
            if (e.length < 2) return;
            const t = e[0].geometry;
            e.forEach(((e, n) => {
                n < 1 || (e.geometry.dispose(), e.geometry = t)
            }))
        }))
    }
    const NC = new i.Pa4,
        UC = new i.Pa4,
        BC = new i.Pa4,
        jC = new i.Pa4,
        zC = new i.Pa4,
        VC = new i.Pa4;
    let GC = 1;
    const HC = new i.Pa4(0, 1, 0);
    class WC extends Pe {
        constructor(e, t) {
            super(e, t), this.targetOffset = new i.Pa4(0, 0, 0);
            const n = this.update;
            this.update = () => this._update(n)
        }
        _update(e) {
            this.target.add(this.targetOffset), NC.copy(this.object.position).sub(this.target), GC = NC.length(), VC.copy(this.target);
            const t = e();
            return VC.sub(this.target), NC.copy(this.object.position).sub(this.target), GC /= NC.length(), this.target.add(VC), this.object.position.copy(this.target).add(NC), NC.normalize(), UC.crossVectors(HC, NC).normalize(), BC.crossVectors(NC, UC).normalize(), jC.crossVectors(UC, BC).normalize().negate(), UC.length() > .1 && this.object.up.crossVectors(NC.clone().normalize(), UC), this.enablePan && (zC.set(0, 0, 0).addScaledVector(UC, VC.x).addScaledVector(BC, VC.y).addScaledVector(jC, VC.z), this.targetOffset.add(zC), this.targetOffset.multiplyScalar(1 / GC)), zC.set(0, 0, 0).addScaledVector(UC, -this.targetOffset.x).addScaledVector(BC, -this.targetOffset.y).addScaledVector(jC, -this.targetOffset.z), this.object.lookAt(zC.add(this.target)), this.object.updateMatrixWorld(), this.object.isCamera && this.object.updateProjectionMatrix(), this.target.sub(this.targetOffset), t
        }
    }
    class KC extends Ma {
        constructor(e) {
            super(e), this.boundingScaleMultiplier = 1.2, this._initGeometry(new i.cJO(1, 0))
        }
    }

    function XC(e, t) {
        var n, r;
        const i = Array.from((null !== (n = e.access) && void 0 !== n ? n : "").split(".")),
            s = i.pop();
        let o = null !== (r = e.targetObject) && void 0 !== r ? r : t;
        if (!s || 0 === s.length) return {
            key: void 0,
            tar: o
        };
        if (o = v(i, o), o && !(s in o)) throw console.error("invalid key", s, o, t, e), "";
        return {
            key: s,
            tar: o
        }
    }

    function qC(e, t, n, r) {
        const {
            key: i,
            tar: s
        } = XC(e, t);
        return i && s ? mc(s, i, (() => {
            var t;
            n && (null === (t = e.updater) || void 0 === t ? void 0 : t.length) && e.updater.forEach((e => n[e]())), null == r || r()
        })) : n => console.warn("Unable to set ", n, i, s, e, t)
    }
    async function YC(e, t, n) {
        var r, i, s, o;
        const {
            key: a,
            tar: l
        } = XC(t, e), c = t.animSet ? [ZC(l, t.animSet, n, null !== (r = t.animSetParallel) && void 0 !== r && r)] : [];
        if (a && l) {
            const e = null !== (o = t.updater) && void 0 !== o ? o : [],
                r = async () => vc(l, a, { ...t,
                    onUpdate: r => {
                        var i;
                        null === (i = t.onUpdate) || void 0 === i || i.call(t, r), e.forEach((e => {
                            var t;
                            return null === (t = n[e]) || void 0 === t ? void 0 : t.call(n)
                        }))
                    }
                });
            t.delay ? c.push(_c(t.delay).then(r)) : c.push(r())
        } else(t.duration || t.delay) && c.push(_c((null !== (i = t.delay) && void 0 !== i ? i : 0) + (null !== (s = t.duration) && void 0 !== s ? s : 0)));
        return 1 === c.length ? c[0] : Promise.all(c)
    }
    async function ZC(e, t, n, r = !1) {
        if (r) return Promise.all(t.map((async t => YC(e, t, n))));
        for (const r of t) await YC(e, r, n)
    }

    function JC(e, t, n, r) {
        var i, s, o, a, l, c, u;
        if (!e) return;
        t || (t = []);
        const p = null != r ? r : {},
            h = e;
        for (let e = 0, d = t.length; e < d; e++) {
            const d = t[e];
            if (d.uiRef) {
                const t = null !== (l = null == h ? void 0 : h.indexOf(d.uiRef)) && void 0 !== l ? l : -1;
                t !== e && (t >= 0 && (null == h || h.splice(t, 1)), null == h || h.splice(e, 0, d.uiRef))
            } else {
                d.uiRef = {
                    type: "folder",
                    label: null !== (i = d.name) && void 0 !== i ? i : "Animation " + e,
                    children: []
                };
                const t = [{
                    type: "button",
                    label: "animate",
                    value: () => {
                        YC(n, d, p).then((() => {
                            var e;
                            return console.log((null === (e = d.uiRef) || void 0 === e ? void 0 : e.label) + " finished")
                        }))
                    }
                }];
                void 0 !== d.access && t.push({
                    type: "input",
                    property: [d, "access"]
                }), void 0 !== d.from && t.push({
                    type: null !== (s = d.uiObjectType) && void 0 !== s ? s : "input",
                    property: [d, "from"],
                    onChange: () => {
                        var e;
                        qC(d, n)(d.from), null === (e = d.updater) || void 0 === e || e.forEach((e => e in p && p[e]()))
                    }
                }), void 0 !== d.to && t.push({
                    type: null !== (o = d.uiObjectType) && void 0 !== o ? o : "input",
                    property: [d, "to"],
                    onChange: () => {
                        var e;
                        qC(d, n)(d.to), null === (e = d.updater) || void 0 === e || e.forEach((e => e in p && p[e]()))
                    }
                }), void 0 !== d.duration && t.push({
                    type: "input",
                    property: [d, "duration"]
                }), d.animSet && (d.animSetParallel || (d.animSetParallel = !1), t.push({
                    type: "input",
                    label: "run parallel",
                    property: [d, "animSetParallel"]
                })), d.animSet && t.push({
                    type: "folder",
                    label: "AnimSet",
                    expanded: !1,
                    children: [],
                    animSetContainer: !0
                }), null === (a = d.uiRef.children) || void 0 === a || a.push(...t), null == h || h.splice(e, 0, d.uiRef)
            }
            const f = null === (c = d.uiRef.children) || void 0 === c ? void 0 : c.map((e => x(e))).flat(2).find((e => null == e ? void 0 : e.animSetContainer));
            d.animSet && f && JC(f.children, d.animSet, null !== (u = d.targetObject) && void 0 !== u ? u : n, r)
        }
    }
    class $C extends Gs {
        constructor() {
            super(), this.enabled = !0, this.uiConfig = {
                type: "folder",
                label: "Lights",
                children: [{
                    type: "button",
                    label: "Add Directional Light",
                    value: () => {
                        if (!this._viewer) return;
                        const e = new Is;
                        e.position.set(0, 0, 0), e.target.position.set(0, 0, -1).normalize(), e.intensity = 2, e.shadow.mapSize.set(1024, 1024), this._viewer.scene.addLight(e), this._processor(e, {})
                    }
                }],
                limitedUi: !0
            }, this.dependencies = [Vs], this._processor = (e, t) => {
                const n = e;
                return e.modelObject.traverse((e => {
                    var t, n, r;
                    if (!e.lightObject) return;
                    const i = e.uiConfig;
                    i && !(null === (t = this.uiConfig.children) || void 0 === t ? void 0 : t.includes(i)) && (this.uiConfig.children.push(i), null === (r = (n = this.uiConfig).uiRefresh) || void 0 === r || r.call(n, "postFrame", !0))
                })), n
            }
        }
        async onAdded(e) {
            var t, n, r, i;
            await super.onAdded(e), null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.processors.add("model", {
                forAssetType: "model",
                process: this._processor
            }), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.processors.add("light", {
                forAssetType: "light",
                process: this._processor
            })
        }
        async onRemove(e) {
            var t, n, r, i;
            return null === (n = null === (t = e.getPlugin(Vs)) || void 0 === t ? void 0 : t.importer) || void 0 === n || n.processors.remove("model", {
                forAssetType: "model",
                process: this._processor
            }), null === (i = null === (r = e.getPlugin(Vs)) || void 0 === r ? void 0 : r.importer) || void 0 === i || i.processors.remove("light", {
                forAssetType: "light",
                process: this._processor
            }), super.onRemove(e)
        }
    }
    $C.PluginType = "SimpleLightsUi";
    var QC = function(e, t, n, r) {
        var i, s = arguments.length,
            o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
        else
            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
        return s > 3 && o && Object.defineProperty(t, n, o), o
    };
    class eR extends Ft {
        constructor(e, t, n, r = !1) {
            super({
                vertexShader: _o,
                fragmentShader: `\n\n${go}\n${mo}\n${vo}\n${bo}\n${n}\n\n${xo}\n\nvarying vec2 vUv;uniform float intensity;uniform float objectRadius;uniform float rayCount;uniform float power;uniform float bias;uniform float falloff;uniform float tolerance;uniform bool autoRadius;uniform vec2 screenSize;vec3 ComputeUniformL(vec3 N,vec2 E){vec3 L;L.xy=E;L.z=interleavedGradientNoise(gl_FragCoord.xy,frameCount*5.);L=L*2.-1.;return L;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=random3(vec3(gl_FragCoord.xy,frameCount+seed));rand_e.y=random3(vec3(gl_FragCoord.yx,rand_e.x+(frameCount)*7.));return rand_e;}vec4 calculateGI(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeUniformL(normal,E);L=normalize(L);L*=sign(dot(L,normal));float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?length(viewPos-screenToView(screenPos.xy+objectRadius/10.,screenPos.z)):mix((cameraNearFar.y)+viewPos.z,-viewPos.z-cameraNearFar.x,L.z*0.5+0.5)*objectRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount*14.+seed)+0.05;rayLen=max(rayLen,0.001);vec3 state=vec3(1.,(r+0.5)/float(RTAO_STEP_COUNT),2.);viewPos+=normal*max(-0.01*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,RTAO_STEP_COUNT);vec3 viewHitP=screenToView(screenHitP.xy,screenHitP.z);vec3 LRes=viewHitP-viewPos;if(state.z>1.)LRes=vec3(9999999.);float dist=length(LRes)*falloff;float EPS=0.01;float zBias=(viewPos.z)*bias;float ao=(max(dot(normal,L)+zBias,0.))/(dist*dist+EPS);\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\nvec3 hitColor=tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy)).rgb;vec3 hitNormal=getViewNormal(screenHitP.xy);float giWeight=1.;giWeight=saturate2(giWeight/(dist+EPS),1.);giWeight*=saturate2((dot(normal,L)),1.);giWeight*=saturate2((dot(hitNormal,-L)),1.);return vec4(hitColor*giWeight,ao);\n#endif\nreturn vec4(0,0,0,ao);}float normpdf(in float x,in float sigma){return exp(-0.5*x*x/(sigma*sigma));}vec4 getLastThis(sampler2D tex,float depth,vec3 normal){vec2 direction=vec2(1,1);vec4 color=clamp(tLastThisTexelToLinear(texture2D(tex,vUv.xy)),0.,5.);return color;}void main(){float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>0.99){discard;gl_FragColor=getLastThis(tLastThis,depth,normal);return;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec4 gi=vec4(0.);gi+=calculateGI(8.,screenPos,normal,1.);if(rayCount>1.5)gi=max(gi,calculateGI(2.,screenPos,normal,0.4));if(rayCount>2.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.5));if(rayCount>3.5)gi=max(gi,calculateGI(1.,screenPos,normal,0.6));if(rayCount>4.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.));gi.a=min(1.,gi.a);gi.a=max(0.,gi.a);gi.rgb=min(vec3(3.),gi.rgb);gi.rgb=max(vec3(0.),gi.rgb);if(frameCount<3.){gl_FragColor=gi;return;}gl_FragColor=(texture2D(tLastThis,vUv));gl_FragColor=((gi+(gl_FragColor)*frameCount)/(frameCount+1.));}\n\n            `,
                uniforms: {
                    tLastThis: {
                        value: null
                    },
                    tDiffuse: {
                        value: null
                    },
                    tNormalDepth: {
                        value: null
                    },
                    tLastFrame: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    },
                    intensity: {
                        value: 2.14
                    },
                    rayCount: {
                        value: .1
                    },
                    objectRadius: {
                        value: 1
                    },
                    autoRadius: {
                        value: !r
                    },
                    power: {
                        value: 1.1
                    },
                    bias: {
                        value: .015
                    },
                    falloff: {
                        value: .7
                    },
                    tolerance: {
                        value: 1.5
                    },
                    frameCount: {
                        value: 0
                    },
                    projection: {
                        value: new i.yGw
                    },
                    screenSize: {
                        value: new i.FM8
                    },
                    cameraPositionWorld: {
                        value: new i.Pa4
                    },
                    cameraNearFar: {
                        value: new i.FM8(.1, 1e3)
                    }
                },
                defines: {
                    PERSPECTIVE_CAMERA: 1,
                    SSGI_ENABLED: r ? 1 : 0
                }
            }, "tDiffuse", "tLastFrame", "tLastThis"), this.materialExtension = {
                shaderExtender: (e, t, n) => {
                    if (!e.defines.SSRTAO_ENABLED) return;
                    const r = "vec3 totalDiffuse =";
                    e.fragmentShader = e.fragmentShader.replace(r, `\n\n            \n            #if defined(SSRTAO_ENABLED) && SSRTAO_ENABLED > 0\nvec4 ssgi=tSSGIMapTexelToLinear(texture2D(tSSGIMap,viewToScreen(vViewPosition.xyz).xy));float ambientOcclusion=1.-ssgi.a;ambientOcclusion=max(0.,ambientOcclusion);ambientOcclusion=pow(ambientOcclusion,ssaoPower);ambientOcclusion=min(1.,ambientOcclusion);reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\nvec3 ssgiColor=ssgi.rgb*ssgiIntensity;reflectedLight.indirectDiffuse+=ssgiColor*(material.diffuseColor.rgb);\n#endif\n#if defined( USE_ENVMAP )\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));float specularOcclusion=saturate(pow(dotNV+ambientOcclusion,exp2(-16.*material.roughness-1.))-1.+ambientOcclusion);reflectedLight.indirectSpecular*=specularOcclusion;\n#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0\n#if !defined(SSR_ENABLED) || SSR_ENABLED < 1\nreflectedLight.indirectSpecular+=ssgiColor*material.specularColor;\n#endif\n#endif\n#endif\n#endif\n\n            \n            // reflectedLight.directDiffuse = vec3(0.);\n            // reflectedLight.indirectDiffuse = vec3(0.);\n            // reflectedLight.directSpecular = vec3(0.);\n            // reflectedLight.indirectSpecular = vec3(0.);\n            \n            \n${r}`), e.fragmentShader = e.fragmentShader.replace("#include <aomap_fragment>", ""), e.vertexUvs = !0
                },
                onObjectRender: (e, t, n) => {
                    var r, i, s;
                    this.materialExtension.extraUniforms.tSSGIMap.value = null === (r = this._target) || void 0 === r ? void 0 : r.texture;
                    const o = t.materialObject,
                        a = !o.transparent && o.transmission < .001;
                    let l = this.enabled && a && (this.renderWithCamera || this._renderer.frameCount > 1) && !1 !== n.userData.screenSpaceRendering && !(null === (i = o.userData) || void 0 === i ? void 0 : i.ssrtaoDisabled) && !(null === (s = o.userData) || void 0 === s ? void 0 : s.ssaoDisabled) ? 1 : 0;
                    o.defines.SSRTAO_ENABLED !== l && (o.defines.SSRTAO_ENABLED = l, o.needsUpdate = !0), l = this.material.defines.SSGI_ENABLED, o.defines.SSGI_ENABLED !== l && (o.defines.SSGI_ENABLED = l, o.needsUpdate = !0), l = this._target.texture, this.materialExtension.extraUniforms.tSSGIMap.value !== l && (this.materialExtension.extraUniforms.tSSGIMap.value = l, o.needsUpdate = !0)
                },
                parsFragmentSnippet: e => {
                    var t;
                    return M `
            uniform float ssaoPower;
            uniform float ssgiIntensity;
            uniform sampler2D tSSGIMap;
            ${U("tSSGIMap",null===(t=this._target)||void 0===t?void 0:t.texture,e.capabilities.isWebGL2)}

            ${wo}

        `
                },
                extraUniforms: {
                    tSSGIMap: {
                        value: null
                    },
                    ssaoPower: this.material.uniforms.power,
                    ssgiIntensity: this.material.uniforms.intensity
                },
                computeCacheKey: e => {
                    var t, n;
                    return this.enabled ? "1" : "0" + (null === (n = null === (t = this._target) || void 0 === t ? void 0 : t.texture) || void 0 === n ? void 0 : n.encoding)
                },
                isCompatible: e => {
                    var t;
                    return !(null === (t = e.materialObject.userData) || void 0 === t ? void 0 : t.ssaoDisabled) && e.isMeshStandardMaterial2
                }
            }, this.intensity = 2, this.power = 1.1, this.autoRadius = !0, this.objectRadius = 2, this.tolerance = 1, this.bias = .15, this.falloff = .7, this.rayCount = 2, this.stepCount = 4, this.smoothEnabled = !0, this.renderWithCamera = !0, this.uiConfig = {
                type: "folder",
                label: "SS Global illumination (Dev)",
                children: [...Je(this), {
                    type: "checkbox",
                    label: "GI Enabled",
                    hidden: () => !this._giActivated,
                    property: [this, "ssgiEnabled"]
                }]
            }, this._renderer = e, this._target = t, this.needsSwap = !0, this._giActivated = r, this.ssgiEnabled = r, this.bilateralPass = new Ao(this._target, n, "rgba")
        }
        get ssgiEnabled() {
            return parseInt(this.material.defines.SSGI_ENABLED) > .5
        }
        set ssgiEnabled(e) {
            e = e && this._giActivated, this.material.defines.SSGI_ENABLED = e ? 1 : 0, this.material.needsUpdate = !0
        }
        render(e, t, n, r, i) {
            this.needsSwap = !1, !this.renderWithCamera && this._renderer.frameCount < 2 || (this._renderer.blit(this._target.texture, t), this.uniforms.tLastThis.value = t.texture, super.render(e, this._target, n, r, i), this.smoothEnabled && this.bilateralPass.render(e, t, n, r, i))
        }
    }
    QC([xe()], eR.prototype, "bilateralPass", void 0), QC([He("Intensity", [0, 4]), xe(), V()], eR.prototype, "intensity", void 0), QC([He("Power", [0, 3]), xe(), V()], eR.prototype, "power", void 0), QC([Ve("Auto radius"), xe(), V()], eR.prototype, "autoRadius", void 0), QC([He("Object Radius", [.01, 10]), xe(), V()], eR.prototype, "objectRadius", void 0), QC([He("Tolerance", [.1, 5]), xe(), V()], eR.prototype, "tolerance", void 0), QC([He("Bias", [-.3, .3]), xe(), V()], eR.prototype, "bias", void 0), QC([He("Falloff", [1e-4, 4]), xe(), V()], eR.prototype, "falloff", void 0), QC([He("Ray Count", [1, 5], 1), xe(), V()], eR.prototype, "rayCount", void 0), QC([He("Step count", [1, 16], 1), xe(), G("RTAO_STEP_COUNT")], eR.prototype, "stepCount", void 0), QC([Ve("Smooth Enabled"), xe()], eR.prototype, "smoothEnabled", void 0), QC([Ve("Render with Camera")], eR.prototype, "renderWithCamera", void 0);
    class tR extends oo {
        constructor(e = !0) {
            super(), this.dependencies = [Vs, Ys, co], this._initEnabled = !1, this.setDirty = this.setDirty.bind(this), this._initEnabled = e
        }
        get rtgiTarget() {
            return this._rtgiTarget
        }
        async onAdded(e) {
            var t, n;
            await super.onAdded(e), this.enabled = this._initEnabled, null === (n = (t = this.uiConfig).uiRefresh) || void 0 === n || n.call(t, "postFrame", !0)
        }
        get enabled() {
            var e, t;
            return (null === (t = null === (e = this.passes.ssrtgi) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.enabled) || !1
        }
        set enabled(e) {
            var t;
            (null === (t = this.passes.ssrtgi) || void 0 === t ? void 0 : t.passObject) && (this.passes.ssrtgi.passObject.enabled = e)
        }
        createPasses(e) {
            var t, n, r;
            this._rtgiTarget = e.renderer.createTarget({
                sizeMultiplier: 1
            });
            let i = !1;
            const s = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("debug");
            return s && s.addTexture("SSRTGI", (() => {
                var e;
                return null === (e = this._rtgiTarget) || void 0 === e ? void 0 : e.texture
            }), [40, 100, 400, 200]), [Hs(e, {
                passId: "ssrtgi",
                after: ["gbuffer"],
                before: ["render"],
                required: ["render", "gbuffer", "progressive"],
                passObject: new eR(e.renderer, this._rtgiTarget, null !== (r = null === (n = e.getPlugin(Ys)) || void 0 === n ? void 0 : n.getUnpackSnippet()) && void 0 !== r ? r : "", !0),
                update: () => {
                    var t;
                    let n = this.enabled;
                    if (n && !i) {
                        const e = null === (t = this._viewer) || void 0 === t ? void 0 : t.getPluginByType("SSAO");
                        (null == e ? void 0 : e.enabled) && (confirm("SSAO Plugin needs to be disabled to enable SSRTGI or SSRTAO. Disable now?") ? e.enabled = !1 : (this.enabled = !1, n = !1))
                    }
                    i = n, n && this.passes.ssrtgi.passObject.bilateralPass.updateShaderProperties([e.getPlugin(Ys)])
                }
            }, (() => [e.getPlugin(Ys), e.getPlugin(co), e.scene.activeCamera, e.renderer]))]
        }
        async onRemove(e) {
            return e.renderer.disposeTarget(this._rtgiTarget), super.onRemove(e)
        }
        setDirty() {
            var e;
            null === (e = this._viewer) || void 0 === e || e.setDirty()
        }
        get uiConfig() {
            var e, t, n, r, i;
            const s = null !== (n = null === (t = null === (e = this.passes.ssrtgi) || void 0 === e ? void 0 : e.passObject) || void 0 === t ? void 0 : t.uiConfig) && void 0 !== n ? n : {};
            return null === (i = null === (r = s.children) || void 0 === r ? void 0 : r.map((e => x(e)))) || void 0 === i || i.flat(2).forEach((e => e && (e.onChange = this.setDirty))), s
        }
    }
    async function nR(e, {
        debug: t = !1,
        ground: n = !0,
        bloom: r = !0,
        depthTonemap: i = !1,
        importPopup: s = !0
    }) {
        const o = new ro(e);
        o.enabled = !1, t && await o.addPlugin(j_), await o.addPlugin(Vs, void 0, void 0, {
            storage: caches ? await caches.open("webgi-cache-storage") : void 0
        }), await o.addPlugin(jx), await o.addPlugin(bM), s && await o.addPlugin(Dm), await o.addPlugin(tx), await o.addPlugin(Ob), await o.addPlugin(Ub), await o.addPlugin(zb), await o.addPlugin(ab), await o.addPlugin(ix), await o.addPlugin(Bb), await o.addPlugin(um), await o.addPlugin(Ca, Ta, !1, !0), await Om(o, {
            ground: n,
            bloom: r,
            depthTonemap: i
        }), await o.addPlugin(tR, !1), await o.addPlugin(BA, !1), await o.addPlugin(FA), await o.addPlugin(HA), await o.addPlugin(sC), await o.addPlugin(RA), await o.addPlugin(jA), await o.addPlugin(PA), await o.addPlugin(eT), await o.addPlugin(Nc), await o.addPlugin(DC), await o.addPlugin(kC), await o.addPlugin($C), await o.addPlugin(RC);
        const a = await o.addPlugin(new CC(!Rt()));
        return o.renderer.refreshPipeline(), o.scene.addEventListener("textureAdded", (e => {
            e.texture && o.scene.setEnvironment(e.texture)
        })), a.setupPluginUi($_), a.setupPluginUi(um), a.setupPluginUi(RC), a.setupPluginUi(jx), a.setupPluginUi(wc), a.setupPluginUi($c), a.setupPluginUi(jA), a.setupPluginUi(RA), a.setupPluginUi(DC), a.setupPluginUi(PA), a.setupPluginUi(Pa), a.setupPluginUi(Ca), n && a.setupPluginUi(Z_), a.setupPluginUi(To), a.setupPluginUi(zc), a.setupPluginUi(eT), a.setupPluginUi(fo), a.setupPluginUi(vu), a.setupPluginUi(ko), a.setupPluginUi(kC), a.setupPluginUi(FA), a.setupPluginUi(HA), a.setupPluginUi(co), a.setupPluginUi($C), a.setupPluginUi(ru), a.setupPluginUi(xu), r && a.setupPluginUi(Cc), a.setupPluginUi(Nc), a.setupPluginUi(kc), a.setupPluginUi(Lc), a.setupPluginUi(tu), a.setupPluginUi(tR), a.setupPluginUi(sC), a.setupPluginUi(Ea), a.setupPluginUi(B_), a.setupPluginUi(lm), a.setupPluginUi(dm), a.setupPluginUi(BA), a.setupPluginUi(Dm), o.enabled = !0, o
    }
    tR.PluginType = "SSGI"
}();
var __webpackgi_exports__ACESFilmicToneMapping = __webpackgi_exports__.LY2,
    __webpackgi_exports__AMaterialManager = __webpackgi_exports__.HRj,
    __webpackgi_exports__ARPlacementBox = __webpackgi_exports__.li4,
    __webpackgi_exports__ARPlugin = __webpackgi_exports__.FO5,
    __webpackgi_exports__ARTouchInputHelper = __webpackgi_exports__.Nlh,
    __webpackgi_exports__AViewerPlugin = __webpackgi_exports__.QvI,
    __webpackgi_exports__AddBlendPass = __webpackgi_exports__.JHp,
    __webpackgi_exports__AddEquation = __webpackgi_exports__.bGH,
    __webpackgi_exports__AddOperation = __webpackgi_exports__.NDo,
    __webpackgi_exports__AdditiveAnimationBlendMode = __webpackgi_exports__.gSk,
    __webpackgi_exports__AdditiveBlending = __webpackgi_exports__.WMw,
    __webpackgi_exports__AlphaFormat = __webpackgi_exports__.OTo,
    __webpackgi_exports__AlwaysDepth = __webpackgi_exports__.Se2,
    __webpackgi_exports__AlwaysStencilFunc = __webpackgi_exports__.cum,
    __webpackgi_exports__AmbientLight = __webpackgi_exports__.Mig,
    __webpackgi_exports__AmbientLight2 = __webpackgi_exports__.B$7,
    __webpackgi_exports__AmbientLightProbe = __webpackgi_exports__.i_9,
    __webpackgi_exports__AnimationClip = __webpackgi_exports__.m7l,
    __webpackgi_exports__AnimationLoader = __webpackgi_exports__.sYA,
    __webpackgi_exports__AnimationMixer = __webpackgi_exports__.Xcj,
    __webpackgi_exports__AnimationObjectGroup = __webpackgi_exports__.mzJ,
    __webpackgi_exports__AnimationUtils = __webpackgi_exports__.ZZA,
    __webpackgi_exports__AnisotropyPlugin = __webpackgi_exports__.$Ph,
    __webpackgi_exports__ArcCurve = __webpackgi_exports__.T__,
    __webpackgi_exports__ArrayCamera = __webpackgi_exports__.HkE,
    __webpackgi_exports__ArrowHelper = __webpackgi_exports__.tGC,
    __webpackgi_exports__AssetExporter = __webpackgi_exports__.g1S,
    __webpackgi_exports__AssetExporterPlugin = __webpackgi_exports__.I$C,
    __webpackgi_exports__AssetImportBasicPopupPlugin = __webpackgi_exports__._HT,
    __webpackgi_exports__AssetImporter = __webpackgi_exports__.QIH,
    __webpackgi_exports__AssetManagerPlugin = __webpackgi_exports__.ksm,
    __webpackgi_exports__AsyncCompress = __webpackgi_exports__.jl_,
    __webpackgi_exports__AsyncDecompress = __webpackgi_exports__.b7R,
    __webpackgi_exports__AsyncDeflate = __webpackgi_exports__.BDV,
    __webpackgi_exports__AsyncGunzip = __webpackgi_exports__.Ea_,
    __webpackgi_exports__AsyncGzip = __webpackgi_exports__.qff,
    __webpackgi_exports__AsyncInflate = __webpackgi_exports__.tmC,
    __webpackgi_exports__AsyncUnzipInflate = __webpackgi_exports__.BON,
    __webpackgi_exports__AsyncUnzlib = __webpackgi_exports__.P40,
    __webpackgi_exports__AsyncZipDeflate = __webpackgi_exports__.wLL,
    __webpackgi_exports__AsyncZlib = __webpackgi_exports__.iHO,
    __webpackgi_exports__Audio = __webpackgi_exports__.BbS,
    __webpackgi_exports__AudioAnalyser = __webpackgi_exports__.kqm,
    __webpackgi_exports__AudioContext = __webpackgi_exports__.Hmr,
    __webpackgi_exports__AudioListener = __webpackgi_exports__.SJI,
    __webpackgi_exports__AudioLoader = __webpackgi_exports__.mTL,
    __webpackgi_exports__AxesHelper = __webpackgi_exports__.y8_,
    __webpackgi_exports__BackSide = __webpackgi_exports__._Li,
    __webpackgi_exports__BaseGroundPlugin = __webpackgi_exports__.g56,
    __webpackgi_exports__BaseRenderer = __webpackgi_exports__.bj3,
    __webpackgi_exports__BasicDepthPacking = __webpackgi_exports__.z81,
    __webpackgi_exports__BasicShadowMap = __webpackgi_exports__._MY,
    __webpackgi_exports__BlobLoader = __webpackgi_exports__.yEv,
    __webpackgi_exports__BloomPlugin = __webpackgi_exports__.dFZ,
    __webpackgi_exports__Bone = __webpackgi_exports__.N$j,
    __webpackgi_exports__BooleanKeyframeTrack = __webpackgi_exports__._YM,
    __webpackgi_exports__Box2 = __webpackgi_exports__.TUj,
    __webpackgi_exports__Box3 = __webpackgi_exports__.ZzF,
    __webpackgi_exports__Box3B = __webpackgi_exports__.qzb,
    __webpackgi_exports__Box3Helper = __webpackgi_exports__.GQ,
    __webpackgi_exports__BoxBufferGeometry = __webpackgi_exports__.nvb,
    __webpackgi_exports__BoxGeometry = __webpackgi_exports__.DvJ,
    __webpackgi_exports__BoxHelper = __webpackgi_exports__.fQA,
    __webpackgi_exports__BoxSelectionWidget = __webpackgi_exports__.cPz,
    __webpackgi_exports__BufferAttribute = __webpackgi_exports__.TlE,
    __webpackgi_exports__BufferGeometry = __webpackgi_exports__.u9r,
    __webpackgi_exports__BufferGeometryLoader = __webpackgi_exports__.s4_,
    __webpackgi_exports__ByteType = __webpackgi_exports__.T95,
    __webpackgi_exports__Cache = __webpackgi_exports__.CtF,
    __webpackgi_exports__Camera = __webpackgi_exports__.V1s,
    __webpackgi_exports__CameraController = __webpackgi_exports__.jOv,
    __webpackgi_exports__CameraHelper = __webpackgi_exports__.Rki,
    __webpackgi_exports__CameraView = __webpackgi_exports__.itZ,
    __webpackgi_exports__CameraViewPlugin = __webpackgi_exports__.qKx,
    __webpackgi_exports__CanvasRecorder = __webpackgi_exports__.vlJ,
    __webpackgi_exports__CanvasRecorderPlugin = __webpackgi_exports__.nPO,
    __webpackgi_exports__CanvasSnipper = __webpackgi_exports__.zcQ,
    __webpackgi_exports__CanvasSnipperPlugin = __webpackgi_exports__.GH1,
    __webpackgi_exports__CanvasTexture = __webpackgi_exports__.ROQ,
    __webpackgi_exports__CapsuleBufferGeometry = __webpackgi_exports__.YN5,
    __webpackgi_exports__CapsuleGeometry = __webpackgi_exports__.BVQ,
    __webpackgi_exports__CatmullRomCurve3 = __webpackgi_exports__.YT8,
    __webpackgi_exports__CineonToneMapping = __webpackgi_exports__.YGz,
    __webpackgi_exports__CircleBufferGeometry = __webpackgi_exports__.trn,
    __webpackgi_exports__CircleGeometry = __webpackgi_exports__.zf8,
    __webpackgi_exports__ClampToEdgeWrapping = __webpackgi_exports__.uWy,
    __webpackgi_exports__Clock = __webpackgi_exports__.SUY,
    __webpackgi_exports__Color = __webpackgi_exports__.Ilk,
    __webpackgi_exports__ColorKeyframeTrack = __webpackgi_exports__.R2R,
    __webpackgi_exports__ColorManagement = __webpackgi_exports__.epp,
    __webpackgi_exports__Compress = __webpackgi_exports__.GD$,
    __webpackgi_exports__CompressedTexture = __webpackgi_exports__.EB7,
    __webpackgi_exports__CompressedTextureLoader = __webpackgi_exports__.DqL,
    __webpackgi_exports__ConeBufferGeometry = __webpackgi_exports__._3,
    __webpackgi_exports__ConeGeometry = __webpackgi_exports__.b_z,
    __webpackgi_exports__ContactShadowGroundPlugin = __webpackgi_exports__.OCn,
    __webpackgi_exports__CubeCamera = __webpackgi_exports__._am,
    __webpackgi_exports__CubeNormalsCaptureHelper = __webpackgi_exports__.kB7,
    __webpackgi_exports__CubeReflectionMapping = __webpackgi_exports__.fY$,
    __webpackgi_exports__CubeRefractionMapping = __webpackgi_exports__.vxC,
    __webpackgi_exports__CubeTexture = __webpackgi_exports__.BtG,
    __webpackgi_exports__CubeTextureLoader = __webpackgi_exports__.cBK,
    __webpackgi_exports__CubeUVReflectionMapping = __webpackgi_exports__.g8_,
    __webpackgi_exports__CubicBezierCurve = __webpackgi_exports__.AXT,
    __webpackgi_exports__CubicBezierCurve3 = __webpackgi_exports__.yj7,
    __webpackgi_exports__CubicInterpolant = __webpackgi_exports__.dYG,
    __webpackgi_exports__CullFaceBack = __webpackgi_exports__.tm_,
    __webpackgi_exports__CullFaceFront = __webpackgi_exports__.S2y,
    __webpackgi_exports__CullFaceFrontBack = __webpackgi_exports__.B02,
    __webpackgi_exports__CullFaceNone = __webpackgi_exports__.PeU,
    __webpackgi_exports__Curve = __webpackgi_exports__.Hyl,
    __webpackgi_exports__CurvePath = __webpackgi_exports__.Wqd,
    __webpackgi_exports__CustomBlending = __webpackgi_exports__.Xaj,
    __webpackgi_exports__CustomBumpMapPlugin = __webpackgi_exports__.DUb,
    __webpackgi_exports__CustomToneMapping = __webpackgi_exports__.dZ3,
    __webpackgi_exports__CylinderBufferGeometry = __webpackgi_exports__.m_w,
    __webpackgi_exports__CylinderGeometry = __webpackgi_exports__.fHI,
    __webpackgi_exports__Cylindrical = __webpackgi_exports__.LBq,
    __webpackgi_exports__DECAY_MILLISECONDS = __webpackgi_exports__.dHf,
    __webpackgi_exports__DRACOLoader2 = __webpackgi_exports__.Qww,
    __webpackgi_exports__Damper = __webpackgi_exports__.CGV,
    __webpackgi_exports__Data3DTexture = __webpackgi_exports__.JUT,
    __webpackgi_exports__DataArrayTexture = __webpackgi_exports__.p3g,
    __webpackgi_exports__DataTexture = __webpackgi_exports__.IEO,
    __webpackgi_exports__DataTexture2DArray = __webpackgi_exports__.CN8,
    __webpackgi_exports__DataTexture3D = __webpackgi_exports__.zob,
    __webpackgi_exports__DataTextureLoader = __webpackgi_exports__.yxD,
    __webpackgi_exports__DataUrlLoader = __webpackgi_exports__.CUS,
    __webpackgi_exports__DataUtils = __webpackgi_exports__.A5E,
    __webpackgi_exports__DebugPlugin = __webpackgi_exports__.zqG,
    __webpackgi_exports__DecodeUTF8 = __webpackgi_exports__.PfX,
    __webpackgi_exports__Decompress = __webpackgi_exports__.Q1o,
    __webpackgi_exports__DecrementStencilOp = __webpackgi_exports__.jfJ,
    __webpackgi_exports__DecrementWrapStencilOp = __webpackgi_exports__.T_J,
    __webpackgi_exports__DefaultLoadingManager = __webpackgi_exports__.tEQ,
    __webpackgi_exports__Deflate = __webpackgi_exports__.gb4,
    __webpackgi_exports__DepthFormat = __webpackgi_exports__.qkB,
    __webpackgi_exports__DepthOfFieldPass = __webpackgi_exports__.cvk,
    __webpackgi_exports__DepthOfFieldPlugin = __webpackgi_exports__.HWo,
    __webpackgi_exports__DepthStencilFormat = __webpackgi_exports__.brP,
    __webpackgi_exports__DepthTexture = __webpackgi_exports__.$YQ,
    __webpackgi_exports__DiamondMaterial = __webpackgi_exports__.yNB,
    __webpackgi_exports__DiamondPlugin = __webpackgi_exports__.h7x,
    __webpackgi_exports__DirectionalLight = __webpackgi_exports__.Ox3,
    __webpackgi_exports__DirectionalLight2 = __webpackgi_exports__.qtn,
    __webpackgi_exports__DirectionalLightHelper = __webpackgi_exports__.cBI,
    __webpackgi_exports__DiscreteInterpolant = __webpackgi_exports__.cU9,
    __webpackgi_exports__DodecahedronBufferGeometry = __webpackgi_exports__.DT1,
    __webpackgi_exports__DodecahedronGeometry = __webpackgi_exports__.Kgo,
    __webpackgi_exports__DoubleSide = __webpackgi_exports__.ehD,
    __webpackgi_exports__Dropzone = __webpackgi_exports__.fhJ,
    __webpackgi_exports__DropzonePlugin = __webpackgi_exports__.y1s,
    __webpackgi_exports__DstAlphaFactor = __webpackgi_exports__.fSK,
    __webpackgi_exports__DstColorFactor = __webpackgi_exports__.Vdb,
    __webpackgi_exports__DynamicCopyUsage = __webpackgi_exports__.l8J,
    __webpackgi_exports__DynamicDrawUsage = __webpackgi_exports__.dj0,
    __webpackgi_exports__DynamicReadUsage = __webpackgi_exports__.QM0,
    __webpackgi_exports__EXRLoadPlugin = __webpackgi_exports__.OIS,
    __webpackgi_exports__EasingFunctions = __webpackgi_exports__.q8b,
    __webpackgi_exports__EdgesGeometry = __webpackgi_exports__.TOt,
    __webpackgi_exports__EffectComposer2 = __webpackgi_exports__.xaN,
    __webpackgi_exports__EllipseCurve = __webpackgi_exports__.Ny0,
    __webpackgi_exports__EncodeUTF8 = __webpackgi_exports__.Zof,
    __webpackgi_exports__EqualDepth = __webpackgi_exports__.eD,
    __webpackgi_exports__EqualStencilFunc = __webpackgi_exports__.jwo,
    __webpackgi_exports__EquirectangularReflectionMapping = __webpackgi_exports__.dSO,
    __webpackgi_exports__EquirectangularRefractionMapping = __webpackgi_exports__.Bf4,
    __webpackgi_exports__Euler = __webpackgi_exports__.USm,
    __webpackgi_exports__EventDispatcher = __webpackgi_exports__.pBf,
    __webpackgi_exports__ExtrudeBufferGeometry = __webpackgi_exports__.$Vf,
    __webpackgi_exports__ExtrudeGeometry = __webpackgi_exports__.O7d,
    __webpackgi_exports__FBXLoadPlugin = __webpackgi_exports__.ksq,
    __webpackgi_exports__FSShadowMaterial = __webpackgi_exports__.gXf,
    __webpackgi_exports__FileLoader = __webpackgi_exports__.hH6,
    __webpackgi_exports__FlatShading = __webpackgi_exports__.esl,
    __webpackgi_exports__Float16BufferAttribute = __webpackgi_exports__.e62,
    __webpackgi_exports__Float32BufferAttribute = __webpackgi_exports__.a$l,
    __webpackgi_exports__Float64BufferAttribute = __webpackgi_exports__.OM3,
    __webpackgi_exports__FloatType = __webpackgi_exports__.VzW,
    __webpackgi_exports__Fog = __webpackgi_exports__.ybr,
    __webpackgi_exports__FogExp2 = __webpackgi_exports__.yo9,
    __webpackgi_exports__Font = __webpackgi_exports__.Zxw,
    __webpackgi_exports__FontLoader = __webpackgi_exports__.JfN,
    __webpackgi_exports__FrameFadePlugin = __webpackgi_exports__.$Bt,
    __webpackgi_exports__FramebufferTexture = __webpackgi_exports__.Wzm,
    __webpackgi_exports__FrontSide = __webpackgi_exports__.Wl3,
    __webpackgi_exports__Frustum = __webpackgi_exports__.iWj,
    __webpackgi_exports__FullScreenPlugin = __webpackgi_exports__.DNz,
    __webpackgi_exports__GBufferPlugin = __webpackgi_exports__.m1M,
    __webpackgi_exports__GLBufferAttribute = __webpackgi_exports__.ylh,
    __webpackgi_exports__GLSL1 = __webpackgi_exports__.v9Y,
    __webpackgi_exports__GLSL3 = __webpackgi_exports__.LSk,
    __webpackgi_exports__GLTFAnimationPlugin = __webpackgi_exports__.LHE,
    __webpackgi_exports__GLTFDracoExportPlugin = __webpackgi_exports__.KE0,
    __webpackgi_exports__GLTFDracoExporter = __webpackgi_exports__.KCF,
    __webpackgi_exports__GLTFExporter2 = __webpackgi_exports__.a4n,
    __webpackgi_exports__GLTFLoader2 = __webpackgi_exports__.zIH,
    __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName = __webpackgi_exports__.Hfk,
    __webpackgi_exports__GLTFMaterialsBumpMapExtensionName = __webpackgi_exports__.png,
    __webpackgi_exports__GLTFMaterialsLightMapExtensionName = __webpackgi_exports__.Eb_,
    __webpackgi_exports__GLTFMeshOptPlugin = __webpackgi_exports__.BT2,
    __webpackgi_exports__GLTFWriter2 = __webpackgi_exports__._8p,
    __webpackgi_exports__GenericBlendTexturePass = __webpackgi_exports__.hkn,
    __webpackgi_exports__GenericFilterPlugin = __webpackgi_exports__.GFY,
    __webpackgi_exports__GreaterDepth = __webpackgi_exports__.w$m,
    __webpackgi_exports__GreaterEqualDepth = __webpackgi_exports__.ksN,
    __webpackgi_exports__GreaterEqualStencilFunc = __webpackgi_exports__.j4z,
    __webpackgi_exports__GreaterStencilFunc = __webpackgi_exports__.OAl,
    __webpackgi_exports__GridHelper = __webpackgi_exports__.VLJ,
    __webpackgi_exports__GroundPlugin = __webpackgi_exports__.C73,
    __webpackgi_exports__Group = __webpackgi_exports__.ZAu,
    __webpackgi_exports__Gunzip = __webpackgi_exports__.ibP,
    __webpackgi_exports__Gzip = __webpackgi_exports__._fI,
    __webpackgi_exports__HDRiGroundPlugin = __webpackgi_exports__.hUN,
    __webpackgi_exports__HalfFloatType = __webpackgi_exports__.cLu,
    __webpackgi_exports__HemisphereLight = __webpackgi_exports__.vmT,
    __webpackgi_exports__HemisphereLightHelper = __webpackgi_exports__.Qpg,
    __webpackgi_exports__HemisphereLightProbe = __webpackgi_exports__.So8,
    __webpackgi_exports__HierarchyUiPlugin = __webpackgi_exports__.eOv,
    __webpackgi_exports__IcosahedronBufferGeometry = __webpackgi_exports__.Wjw,
    __webpackgi_exports__IcosahedronGeometry = __webpackgi_exports__.cJO,
    __webpackgi_exports__ImageBitmapLoader = __webpackgi_exports__.QRU,
    __webpackgi_exports__ImageLoader = __webpackgi_exports__.S3k,
    __webpackgi_exports__ImageUtils = __webpackgi_exports__.PpQ,
    __webpackgi_exports__ImmediateRenderObject = __webpackgi_exports__.AHu,
    __webpackgi_exports__Importer = __webpackgi_exports__.q_9,
    __webpackgi_exports__IncrementStencilOp = __webpackgi_exports__.ZRs,
    __webpackgi_exports__IncrementWrapStencilOp = __webpackgi_exports__.oqc,
    __webpackgi_exports__Inflate = __webpackgi_exports__.T_x,
    __webpackgi_exports__InstancedBufferAttribute = __webpackgi_exports__.lb7,
    __webpackgi_exports__InstancedBufferGeometry = __webpackgi_exports__.L5s,
    __webpackgi_exports__InstancedInterleavedBuffer = __webpackgi_exports__.$TI,
    __webpackgi_exports__InstancedMesh = __webpackgi_exports__.SPe,
    __webpackgi_exports__Int16BufferAttribute = __webpackgi_exports__.aVm,
    __webpackgi_exports__Int32BufferAttribute = __webpackgi_exports__.j87,
    __webpackgi_exports__Int8BufferAttribute = __webpackgi_exports__.RNb,
    __webpackgi_exports__IntType = __webpackgi_exports__.Kz5,
    __webpackgi_exports__InterleavedBuffer = __webpackgi_exports__.vpT,
    __webpackgi_exports__InterleavedBufferAttribute = __webpackgi_exports__.kB5,
    __webpackgi_exports__Interpolant = __webpackgi_exports__._C8,
    __webpackgi_exports__InterpolateDiscrete = __webpackgi_exports__.Syv,
    __webpackgi_exports__InterpolateLinear = __webpackgi_exports__.NMF,
    __webpackgi_exports__InterpolateSmooth = __webpackgi_exports__.pIN,
    __webpackgi_exports__InvertStencilOp = __webpackgi_exports__.eMJ,
    __webpackgi_exports__KHR_TEXTURE_BASISU = __webpackgi_exports__.rN7,
    __webpackgi_exports__KTX2LoadPlugin = __webpackgi_exports__.iUp,
    __webpackgi_exports__KTXLoadPlugin = __webpackgi_exports__.GFd,
    __webpackgi_exports__KeepStencilOp = __webpackgi_exports__.x5V,
    __webpackgi_exports__KeyframeTrack = __webpackgi_exports__.tUh,
    __webpackgi_exports__LOD = __webpackgi_exports__.z8B,
    __webpackgi_exports__LatheBufferGeometry = __webpackgi_exports__.GZb,
    __webpackgi_exports__LatheGeometry = __webpackgi_exports__.p7y,
    __webpackgi_exports__Layers = __webpackgi_exports__.S9g,
    __webpackgi_exports__LessDepth = __webpackgi_exports__.Zr5,
    __webpackgi_exports__LessEqualDepth = __webpackgi_exports__.vCF,
    __webpackgi_exports__LessEqualStencilFunc = __webpackgi_exports__.yt0,
    __webpackgi_exports__LessStencilFunc = __webpackgi_exports__.uXU,
    __webpackgi_exports__Light = __webpackgi_exports__._kC,
    __webpackgi_exports__LightProbe = __webpackgi_exports__.lk7,
    __webpackgi_exports__Line = __webpackgi_exports__.x12,
    __webpackgi_exports__Line3 = __webpackgi_exports__.Zzh,
    __webpackgi_exports__LineBasicMaterial = __webpackgi_exports__.nls,
    __webpackgi_exports__LineCurve = __webpackgi_exports__.g_z,
    __webpackgi_exports__LineCurve3 = __webpackgi_exports__.U7,
    __webpackgi_exports__LineDashedMaterial = __webpackgi_exports__.FT0,
    __webpackgi_exports__LineLoop = __webpackgi_exports__.blk,
    __webpackgi_exports__LineSegments = __webpackgi_exports__.ejS,
    __webpackgi_exports__LinearEncoding = __webpackgi_exports__.rnI,
    __webpackgi_exports__LinearFilter = __webpackgi_exports__.wem,
    __webpackgi_exports__LinearInterpolant = __webpackgi_exports__.lfu,
    __webpackgi_exports__LinearMipMapLinearFilter = __webpackgi_exports__.FDw,
    __webpackgi_exports__LinearMipMapNearestFilter = __webpackgi_exports__.lRj,
    __webpackgi_exports__LinearMipmapLinearFilter = __webpackgi_exports__.D1R,
    __webpackgi_exports__LinearMipmapNearestFilter = __webpackgi_exports__.qyh,
    __webpackgi_exports__LinearSRGBColorSpace = __webpackgi_exports__.GUF,
    __webpackgi_exports__LinearToneMapping = __webpackgi_exports__.EoG,
    __webpackgi_exports__Loader = __webpackgi_exports__.aNw,
    __webpackgi_exports__LoaderUtils = __webpackgi_exports__.Zp0,
    __webpackgi_exports__LoadingManager = __webpackgi_exports__.lLk,
    __webpackgi_exports__LoopOnce = __webpackgi_exports__.jAl,
    __webpackgi_exports__LoopPingPong = __webpackgi_exports__.uEv,
    __webpackgi_exports__LoopRepeat = __webpackgi_exports__.YKA,
    __webpackgi_exports__LuminanceAlphaFormat = __webpackgi_exports__.cRx,
    __webpackgi_exports__LuminanceFormat = __webpackgi_exports__.Y8D,
    __webpackgi_exports__MOUSE = __webpackgi_exports__.RsA,
    __webpackgi_exports__MTLLoader2 = __webpackgi_exports__.Y0m,
    __webpackgi_exports__Material = __webpackgi_exports__.F5T,
    __webpackgi_exports__MaterialConfiguratorBasePlugin = __webpackgi_exports__.EDU,
    __webpackgi_exports__MaterialConfiguratorPlugin = __webpackgi_exports__.z$Q,
    __webpackgi_exports__MaterialExtender = __webpackgi_exports__.KA8,
    __webpackgi_exports__MaterialLibraryBasePlugin = __webpackgi_exports__.XUj,
    __webpackgi_exports__MaterialLibraryPlugin = __webpackgi_exports__.Me$,
    __webpackgi_exports__MaterialLoader = __webpackgi_exports__.u7G,
    __webpackgi_exports__MaterialManager = __webpackgi_exports__.PEk,
    __webpackgi_exports__MaterialPreviewGenerator = __webpackgi_exports__.BG4,
    __webpackgi_exports__MathUtils = __webpackgi_exports__.M8C,
    __webpackgi_exports__Matrix3 = __webpackgi_exports__.Vkp,
    __webpackgi_exports__Matrix4 = __webpackgi_exports__.yGw,
    __webpackgi_exports__MaxEquation = __webpackgi_exports__.Sm8,
    __webpackgi_exports__Mesh = __webpackgi_exports__.Kj0,
    __webpackgi_exports__MeshBasicMaterial = __webpackgi_exports__.vBJ,
    __webpackgi_exports__MeshDepthMaterial = __webpackgi_exports__.lRF,
    __webpackgi_exports__MeshDistanceMaterial = __webpackgi_exports__.Lun,
    __webpackgi_exports__MeshLambertMaterial = __webpackgi_exports__.YBo,
    __webpackgi_exports__MeshMatcapMaterial = __webpackgi_exports__.kaV,
    __webpackgi_exports__MeshNormalMaterial = __webpackgi_exports__.RSm,
    __webpackgi_exports__MeshPhongMaterial = __webpackgi_exports__.xoR,
    __webpackgi_exports__MeshPhysicalMaterial = __webpackgi_exports__.EJi,
    __webpackgi_exports__MeshStandardMaterial = __webpackgi_exports__.Wid,
    __webpackgi_exports__MeshStandardMaterial2 = __webpackgi_exports__.iuj,
    __webpackgi_exports__MeshToonMaterial = __webpackgi_exports__.IKL,
    __webpackgi_exports__MinEquation = __webpackgi_exports__.r_,
    __webpackgi_exports__MirroredRepeatWrapping = __webpackgi_exports__.OoA,
    __webpackgi_exports__MixOperation = __webpackgi_exports__.qhX,
    __webpackgi_exports__MultiFilterPlugin = __webpackgi_exports__.qPT,
    __webpackgi_exports__MultiplyBlending = __webpackgi_exports__.M5h,
    __webpackgi_exports__MultiplyOperation = __webpackgi_exports__.Ns1,
    __webpackgi_exports__NearestFilter = __webpackgi_exports__.TyD,
    __webpackgi_exports__NearestMipMapLinearFilter = __webpackgi_exports__.vZf,
    __webpackgi_exports__NearestMipMapNearestFilter = __webpackgi_exports__.HTd,
    __webpackgi_exports__NearestMipmapLinearFilter = __webpackgi_exports__.aH4,
    __webpackgi_exports__NearestMipmapNearestFilter = __webpackgi_exports__.YLQ,
    __webpackgi_exports__NeverDepth = __webpackgi_exports__.BVF,
    __webpackgi_exports__NeverStencilFunc = __webpackgi_exports__.MyG,
    __webpackgi_exports__NoBlending = __webpackgi_exports__.jFi,
    __webpackgi_exports__NoColorSpace = __webpackgi_exports__.aCh,
    __webpackgi_exports__NoToneMapping = __webpackgi_exports__.uL9,
    __webpackgi_exports__NoiseBumpMaterialPlugin = __webpackgi_exports__.TNj,
    __webpackgi_exports__NormalAnimationBlendMode = __webpackgi_exports__.IFH,
    __webpackgi_exports__NormalBlending = __webpackgi_exports__.bdR,
    __webpackgi_exports__NormalCaptureMaterial = __webpackgi_exports__.kM_,
    __webpackgi_exports__NotEqualDepth = __webpackgi_exports__.M6v,
    __webpackgi_exports__NotEqualStencilFunc = __webpackgi_exports__.RvT,
    __webpackgi_exports__NumberKeyframeTrack = __webpackgi_exports__.dUE,
    __webpackgi_exports__OBJLoader2 = __webpackgi_exports__.oe_,
    __webpackgi_exports__ObjMtlLoadPlugin = __webpackgi_exports__.BuN,
    __webpackgi_exports__Object3D = __webpackgi_exports__.Tme,
    __webpackgi_exports__Object3DModel = __webpackgi_exports__.N9P,
    __webpackgi_exports__ObjectLoader = __webpackgi_exports__.Gql,
    __webpackgi_exports__ObjectLoader2 = __webpackgi_exports__.$XY,
    __webpackgi_exports__ObjectPicker = __webpackgi_exports__.O9d,
    __webpackgi_exports__ObjectProcessorMap = __webpackgi_exports__.zEO,
    __webpackgi_exports__ObjectRotationPlugin = __webpackgi_exports__.qfx,
    __webpackgi_exports__ObjectSpaceNormalMap = __webpackgi_exports__.PA7,
    __webpackgi_exports__OctahedronBufferGeometry = __webpackgi_exports__.REq,
    __webpackgi_exports__OctahedronGeometry = __webpackgi_exports__.pQR,
    __webpackgi_exports__OneFactor = __webpackgi_exports__.ghN,
    __webpackgi_exports__OneMinusDstAlphaFactor = __webpackgi_exports__.Hy8,
    __webpackgi_exports__OneMinusDstColorFactor = __webpackgi_exports__.Wpd,
    __webpackgi_exports__OneMinusSrcAlphaFactor = __webpackgi_exports__.LgZ,
    __webpackgi_exports__OneMinusSrcColorFactor = __webpackgi_exports__.iWC,
    __webpackgi_exports__OrbitControls2 = __webpackgi_exports__.mqn,
    __webpackgi_exports__OrthographicCamera = __webpackgi_exports__.iKG,
    __webpackgi_exports__PCFShadowMap = __webpackgi_exports__._iA,
    __webpackgi_exports__PCFSoftShadowMap = __webpackgi_exports__.ntZ,
    __webpackgi_exports__PMREMGenerator = __webpackgi_exports__.anP,
    __webpackgi_exports__PMREMGeneratorPlugin = __webpackgi_exports__.X2e,
    __webpackgi_exports__ParallaxMappingPlugin = __webpackgi_exports__.FCo,
    __webpackgi_exports__ParametricGeometry = __webpackgi_exports__.jjw,
    __webpackgi_exports__Path = __webpackgi_exports__.y$t,
    __webpackgi_exports__PerspectiveCamera = __webpackgi_exports__.cPb,
    __webpackgi_exports__PickingPlugin = __webpackgi_exports__.lmx,
    __webpackgi_exports__Plane = __webpackgi_exports__.JOQ,
    __webpackgi_exports__PlaneBufferGeometry = __webpackgi_exports__.BKK,
    __webpackgi_exports__PlaneGeometry = __webpackgi_exports__._12,
    __webpackgi_exports__PlaneHelper = __webpackgi_exports__.tJx,
    __webpackgi_exports__PointLight = __webpackgi_exports__.cek,
    __webpackgi_exports__PointLightHelper = __webpackgi_exports__.xG9,
    __webpackgi_exports__Points = __webpackgi_exports__.woe,
    __webpackgi_exports__PointsMaterial = __webpackgi_exports__.UY4,
    __webpackgi_exports__PolarGridHelper = __webpackgi_exports__.aq0,
    __webpackgi_exports__PolyhedronBufferGeometry = __webpackgi_exports__.ujx,
    __webpackgi_exports__PolyhedronGeometry = __webpackgi_exports__.Uol,
    __webpackgi_exports__PopmotionPlugin = __webpackgi_exports__.JiH,
    __webpackgi_exports__PositionalAudio = __webpackgi_exports__.VYz,
    __webpackgi_exports__ProgressivePlugin = __webpackgi_exports__.EsW,
    __webpackgi_exports__PropertyBinding = __webpackgi_exports__.iUV,
    __webpackgi_exports__PropertyMixer = __webpackgi_exports__.tf,
    __webpackgi_exports__QuadraticBezierCurve = __webpackgi_exports__.ZQ6,
    __webpackgi_exports__QuadraticBezierCurve3 = __webpackgi_exports__.mXe,
    __webpackgi_exports__Quaternion = __webpackgi_exports__._fP,
    __webpackgi_exports__QuaternionKeyframeTrack = __webpackgi_exports__.iLg,
    __webpackgi_exports__QuaternionLinearInterpolant = __webpackgi_exports__.zbs,
    __webpackgi_exports__REVISION = __webpackgi_exports__.UZH,
    __webpackgi_exports__RGBADepthPacking = __webpackgi_exports__.mSO,
    __webpackgi_exports__RGBAFormat = __webpackgi_exports__.wk1,
    __webpackgi_exports__RGBAIntegerFormat = __webpackgi_exports__.E2K,
    __webpackgi_exports__RGBA_ASTC_10x10_Format = __webpackgi_exports__.FUD,
    __webpackgi_exports__RGBA_ASTC_10x5_Format = __webpackgi_exports__.pKu,
    __webpackgi_exports__RGBA_ASTC_10x6_Format = __webpackgi_exports__.GG6,
    __webpackgi_exports__RGBA_ASTC_10x8_Format = __webpackgi_exports__.Gih,
    __webpackgi_exports__RGBA_ASTC_12x10_Format = __webpackgi_exports__.iiP,
    __webpackgi_exports__RGBA_ASTC_12x12_Format = __webpackgi_exports__.SvJ,
    __webpackgi_exports__RGBA_ASTC_4x4_Format = __webpackgi_exports__.ptH,
    __webpackgi_exports__RGBA_ASTC_5x4_Format = __webpackgi_exports__.jZA,
    __webpackgi_exports__RGBA_ASTC_5x5_Format = __webpackgi_exports__.y2t,
    __webpackgi_exports__RGBA_ASTC_6x5_Format = __webpackgi_exports__.gi4,
    __webpackgi_exports__RGBA_ASTC_6x6_Format = __webpackgi_exports__.Djp,
    __webpackgi_exports__RGBA_ASTC_8x5_Format = __webpackgi_exports__.BG$,
    __webpackgi_exports__RGBA_ASTC_8x6_Format = __webpackgi_exports__.NYV,
    __webpackgi_exports__RGBA_ASTC_8x8_Format = __webpackgi_exports__.xJs,
    __webpackgi_exports__RGBA_BPTC_Format = __webpackgi_exports__.bsb,
    __webpackgi_exports__RGBA_ETC2_EAC_Format = __webpackgi_exports__.ekQ,
    __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__.CaW,
    __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__.eaV,
    __webpackgi_exports__RGBA_S3TC_DXT1_Format = __webpackgi_exports__.BFQ,
    __webpackgi_exports__RGBA_S3TC_DXT3_Format = __webpackgi_exports__.v3W,
    __webpackgi_exports__RGBA_S3TC_DXT5_Format = __webpackgi_exports__.ILR,
    __webpackgi_exports__RGBFormat = __webpackgi_exports__.UCm,
    __webpackgi_exports__RGBM16Encoding = __webpackgi_exports__.Inb,
    __webpackgi_exports__RGBM7Encoding = __webpackgi_exports__.LgE,
    __webpackgi_exports__RGB_ETC1_Format = __webpackgi_exports__.fto,
    __webpackgi_exports__RGB_ETC2_Format = __webpackgi_exports__.l0P,
    __webpackgi_exports__RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__.vCx,
    __webpackgi_exports__RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__._AM,
    __webpackgi_exports__RGB_S3TC_DXT1_Format = __webpackgi_exports__.wuA,
    __webpackgi_exports__RGFormat = __webpackgi_exports__.av9,
    __webpackgi_exports__RGIntegerFormat = __webpackgi_exports__.CtA,
    __webpackgi_exports__RandomizedDirectionalLight = __webpackgi_exports__.BvQ,
    __webpackgi_exports__RandomizedDirectionalLightPlugin = __webpackgi_exports__.FZJ,
    __webpackgi_exports__RawShaderMaterial = __webpackgi_exports__.FIo,
    __webpackgi_exports__Ray = __webpackgi_exports__.zHn,
    __webpackgi_exports__Raycaster = __webpackgi_exports__.iMs,
    __webpackgi_exports__RectAreaLight = __webpackgi_exports__.T_f,
    __webpackgi_exports__RedFormat = __webpackgi_exports__.hEm,
    __webpackgi_exports__RedIntegerFormat = __webpackgi_exports__.D9w,
    __webpackgi_exports__Reflector2 = __webpackgi_exports__.sHH,
    __webpackgi_exports__ReinhardToneMapping = __webpackgi_exports__.CdI,
    __webpackgi_exports__RepeatWrapping = __webpackgi_exports__.rpg,
    __webpackgi_exports__ReplaceStencilOp = __webpackgi_exports__.ce8,
    __webpackgi_exports__ReverseSubtractEquation = __webpackgi_exports__.rOj,
    __webpackgi_exports__Rhino3dmLoadPlugin = __webpackgi_exports__.P6m,
    __webpackgi_exports__Rhino3dmLoader2 = __webpackgi_exports__.JA6,
    __webpackgi_exports__RingBufferGeometry = __webpackgi_exports__.V4E,
    __webpackgi_exports__RingGeometry = __webpackgi_exports__.o8S,
    __webpackgi_exports__RootScene = __webpackgi_exports__.flB,
    __webpackgi_exports__SETTLING_TIME = __webpackgi_exports__.DUH,
    __webpackgi_exports__SRGBColorSpace = __webpackgi_exports__.KI_,
    __webpackgi_exports__SSAOPlugin = __webpackgi_exports__.iLN,
    __webpackgi_exports__SSContactShadows = __webpackgi_exports__.jsw,
    __webpackgi_exports__SSRPlugin = __webpackgi_exports__.i6Z,
    __webpackgi_exports__STLLoadPlugin = __webpackgi_exports__.vfv,
    __webpackgi_exports__Scene = __webpackgi_exports__.xsS,
    __webpackgi_exports__SelectionWidget = __webpackgi_exports__.ov0,
    __webpackgi_exports__SerializableOrbitControls = __webpackgi_exports__.cQH,
    __webpackgi_exports__ShaderChunk = __webpackgi_exports__.WdD,
    __webpackgi_exports__ShaderLib = __webpackgi_exports__.Vj0,
    __webpackgi_exports__ShaderMaterial = __webpackgi_exports__.jyz,
    __webpackgi_exports__ShaderMaterialEncodingSupport = __webpackgi_exports__.Mn1,
    __webpackgi_exports__ShaderPass2 = __webpackgi_exports__.Hlq,
    __webpackgi_exports__ShadowMapBaker = __webpackgi_exports__.Fi7,
    __webpackgi_exports__ShadowMaterial = __webpackgi_exports__.Tn7,
    __webpackgi_exports__Shape = __webpackgi_exports__.bnF,
    __webpackgi_exports__ShapeBufferGeometry = __webpackgi_exports__.HW6,
    __webpackgi_exports__ShapeGeometry = __webpackgi_exports__.oa8,
    __webpackgi_exports__ShapePath = __webpackgi_exports__.T_1,
    __webpackgi_exports__ShapeTubeExtrudePlugin = __webpackgi_exports__.zHJ,
    __webpackgi_exports__ShapeUtils = __webpackgi_exports__.iDF,
    __webpackgi_exports__ShortType = __webpackgi_exports__.iAb,
    __webpackgi_exports__SimpleAssetList = __webpackgi_exports__.d4E,
    __webpackgi_exports__SimpleBackgroundEnvUiPlugin = __webpackgi_exports__.lBg,
    __webpackgi_exports__SimpleDataSource = __webpackgi_exports__.JeJ,
    __webpackgi_exports__SimpleEventDispatcher = __webpackgi_exports__.FKY,
    __webpackgi_exports__SimpleJSONExporter = __webpackgi_exports__.zlZ,
    __webpackgi_exports__SimpleJSONLoader = __webpackgi_exports__.vkg,
    __webpackgi_exports__SimpleTextExporter = __webpackgi_exports__.brh,
    __webpackgi_exports__SimpleTextPlugin = __webpackgi_exports__.kZK,
    __webpackgi_exports__SimpleViewerUi = __webpackgi_exports__.puG,
    __webpackgi_exports__Skeleton = __webpackgi_exports__.OdW,
    __webpackgi_exports__SkeletonHelper = __webpackgi_exports__._YX,
    __webpackgi_exports__SkinnedMesh = __webpackgi_exports__.TUv,
    __webpackgi_exports__SmoothShading = __webpackgi_exports__.wcA,
    __webpackgi_exports__Source = __webpackgi_exports__.Hw6,
    __webpackgi_exports__Sphere = __webpackgi_exports__.aLr,
    __webpackgi_exports__SphereBufferGeometry = __webpackgi_exports__.Aip,
    __webpackgi_exports__SphereGeometry = __webpackgi_exports__.xo$,
    __webpackgi_exports__SphereSelectionWidget = __webpackgi_exports__.bIn,
    __webpackgi_exports__Spherical = __webpackgi_exports__.$V,
    __webpackgi_exports__SphericalHarmonics3 = __webpackgi_exports__.lDi,
    __webpackgi_exports__SplineCurve = __webpackgi_exports__.gti,
    __webpackgi_exports__SpotLight = __webpackgi_exports__.PMe,
    __webpackgi_exports__SpotLight2 = __webpackgi_exports__.iwP,
    __webpackgi_exports__SpotLightHelper = __webpackgi_exports__.FvO,
    __webpackgi_exports__Sprite = __webpackgi_exports__.jyi,
    __webpackgi_exports__SpriteMaterial = __webpackgi_exports__.xeV,
    __webpackgi_exports__SrcAlphaFactor = __webpackgi_exports__.k74,
    __webpackgi_exports__SrcAlphaSaturateFactor = __webpackgi_exports__.RlZ,
    __webpackgi_exports__SrcColorFactor = __webpackgi_exports__.KhW,
    __webpackgi_exports__StaticCopyUsage = __webpackgi_exports__.HgB,
    __webpackgi_exports__StaticDrawUsage = __webpackgi_exports__.W2J,
    __webpackgi_exports__StaticReadUsage = __webpackgi_exports__.JWc,
    __webpackgi_exports__StereoCamera = __webpackgi_exports__.u37,
    __webpackgi_exports__StreamCopyUsage = __webpackgi_exports__.Z6B,
    __webpackgi_exports__StreamDrawUsage = __webpackgi_exports__.QZ1,
    __webpackgi_exports__StreamReadUsage = __webpackgi_exports__.Ir4,
    __webpackgi_exports__StringKeyframeTrack = __webpackgi_exports__.NwF,
    __webpackgi_exports__SubtractEquation = __webpackgi_exports__.Wbm,
    __webpackgi_exports__SubtractiveBlending = __webpackgi_exports__.N4l,
    __webpackgi_exports__SwitchNodePlugin = __webpackgi_exports__.ej9,
    __webpackgi_exports__TOUCH = __webpackgi_exports__.QmN,
    __webpackgi_exports__TangentSpaceNormalMap = __webpackgi_exports__.IOt,
    __webpackgi_exports__TemporalAAPlugin = __webpackgi_exports__.NOD,
    __webpackgi_exports__TetrahedronBufferGeometry = __webpackgi_exports__.L5g,
    __webpackgi_exports__TetrahedronGeometry = __webpackgi_exports__.H$k,
    __webpackgi_exports__TextGeometry = __webpackgi_exports__.MP$,
    __webpackgi_exports__TextSVGOptions = __webpackgi_exports__.cuP,
    __webpackgi_exports__Texture = __webpackgi_exports__.xEZ,
    __webpackgi_exports__TextureLoader = __webpackgi_exports__.dpR,
    __webpackgi_exports__ThinFilmLayerPlugin = __webpackgi_exports__.wOD,
    __webpackgi_exports__ThreeMaterialLoader = __webpackgi_exports__.KNb,
    __webpackgi_exports__TonemapPass = __webpackgi_exports__.Rk2,
    __webpackgi_exports__TonemapPlugin = __webpackgi_exports__.IiN,
    __webpackgi_exports__TorusBufferGeometry = __webpackgi_exports__.Cne,
    __webpackgi_exports__TorusGeometry = __webpackgi_exports__.XvJ,
    __webpackgi_exports__TorusKnotBufferGeometry = __webpackgi_exports__.XZw,
    __webpackgi_exports__TorusKnotGeometry = __webpackgi_exports__.FE5,
    __webpackgi_exports__TransformControls2 = __webpackgi_exports__.lVp,
    __webpackgi_exports__Triangle = __webpackgi_exports__.CJI,
    __webpackgi_exports__TriangleFanDrawMode = __webpackgi_exports__.z$h,
    __webpackgi_exports__TriangleStripDrawMode = __webpackgi_exports__.UlW,
    __webpackgi_exports__TrianglesDrawMode = __webpackgi_exports__.WwZ,
    __webpackgi_exports__TubeBufferGeometry = __webpackgi_exports__.Lcc,
    __webpackgi_exports__TubeGeometry = __webpackgi_exports__.WXh,
    __webpackgi_exports__TubeShapeGeometry = __webpackgi_exports__.Vjr,
    __webpackgi_exports__TweakpaneUiPlugin = __webpackgi_exports__.LuM,
    __webpackgi_exports__TweakpaneWrapper = __webpackgi_exports__.LP5,
    __webpackgi_exports__UVMapping = __webpackgi_exports__.xfE,
    __webpackgi_exports__Uint16BufferAttribute = __webpackgi_exports__.qlB,
    __webpackgi_exports__Uint32BufferAttribute = __webpackgi_exports__.lCJ,
    __webpackgi_exports__Uint8BufferAttribute = __webpackgi_exports__.WTc,
    __webpackgi_exports__Uint8ClampedBufferAttribute = __webpackgi_exports__.rAo,
    __webpackgi_exports__Uncharted2Tonemapping = __webpackgi_exports__.LZj,
    __webpackgi_exports__Uniform = __webpackgi_exports__.xWb,
    __webpackgi_exports__UniformsGroup = __webpackgi_exports__.gH0,
    __webpackgi_exports__UniformsLib = __webpackgi_exports__.rBU,
    __webpackgi_exports__UniformsUtils = __webpackgi_exports__.rDY,
    __webpackgi_exports__UnsignedByteType = __webpackgi_exports__.ywz,
    __webpackgi_exports__UnsignedInt248Type = __webpackgi_exports__.wJv,
    __webpackgi_exports__UnsignedIntType = __webpackgi_exports__.JQ4,
    __webpackgi_exports__UnsignedShort4444Type = __webpackgi_exports__.k0A,
    __webpackgi_exports__UnsignedShort5551Type = __webpackgi_exports__.irR,
    __webpackgi_exports__UnsignedShortType = __webpackgi_exports__.LsT,
    __webpackgi_exports__Unzip = __webpackgi_exports__.q5h,
    __webpackgi_exports__UnzipInflate = __webpackgi_exports__.TKh,
    __webpackgi_exports__UnzipPassThrough = __webpackgi_exports__.tyg,
    __webpackgi_exports__Unzlib = __webpackgi_exports__.Ro5,
    __webpackgi_exports__VSMShadowMap = __webpackgi_exports__.dwk,
    __webpackgi_exports__Vector2 = __webpackgi_exports__.FM8,
    __webpackgi_exports__Vector3 = __webpackgi_exports__.Pa4,
    __webpackgi_exports__Vector4 = __webpackgi_exports__.Ltg,
    __webpackgi_exports__VectorKeyframeTrack = __webpackgi_exports__.yC1,
    __webpackgi_exports__VelocityBufferPlugin = __webpackgi_exports__.lHq,
    __webpackgi_exports__VideoTexture = __webpackgi_exports__.fO1,
    __webpackgi_exports__ViewerApp = __webpackgi_exports__.oMA,
    __webpackgi_exports__ViewerState = __webpackgi_exports__.JzW,
    __webpackgi_exports__WebGL1Renderer = __webpackgi_exports__.b5g,
    __webpackgi_exports__WebGL3DRenderTarget = __webpackgi_exports__.Ywn,
    __webpackgi_exports__WebGLArrayRenderTarget = __webpackgi_exports__.GVz,
    __webpackgi_exports__WebGLCubeRenderTarget = __webpackgi_exports__.oAp,
    __webpackgi_exports__WebGLMultipleRenderTargets = __webpackgi_exports__.kFz,
    __webpackgi_exports__WebGLMultisampleRenderTarget = __webpackgi_exports__.p7A,
    __webpackgi_exports__WebGLRenderTarget = __webpackgi_exports__.dd2,
    __webpackgi_exports__WebGLRenderer = __webpackgi_exports__.CP7,
    __webpackgi_exports__WebGLUtils = __webpackgi_exports__.fQK,
    __webpackgi_exports__WebGiViewerElement = __webpackgi_exports__.Wd$,
    __webpackgi_exports__WireframeGeometry = __webpackgi_exports__.Uk6,
    __webpackgi_exports__WrapAroundEnding = __webpackgi_exports__._sL,
    __webpackgi_exports__ZeroCurvatureEnding = __webpackgi_exports__.Pnf,
    __webpackgi_exports__ZeroFactor = __webpackgi_exports__.c8b,
    __webpackgi_exports__ZeroSlopeEnding = __webpackgi_exports__._lf,
    __webpackgi_exports__ZeroStencilOp = __webpackgi_exports__.ad5,
    __webpackgi_exports__Zip = __webpackgi_exports__.sZV,
    __webpackgi_exports__ZipDeflate = __webpackgi_exports__.TfA,
    __webpackgi_exports__ZipLoader = __webpackgi_exports__.sKX,
    __webpackgi_exports__ZipPassThrough = __webpackgi_exports__.UdM,
    __webpackgi_exports__Zlib = __webpackgi_exports__.P0y,
    __webpackgi_exports___SRGBAFormat = __webpackgi_exports__.L_r,
    __webpackgi_exports__addBasePlugins = __webpackgi_exports__.Bve,
    __webpackgi_exports__addDracoLoader = __webpackgi_exports__.UeO,
    __webpackgi_exports__addGLTFExporter = __webpackgi_exports__.$nx,
    __webpackgi_exports__addGLTFLoader = __webpackgi_exports__.Bk6,
    __webpackgi_exports__addRGBELoader = __webpackgi_exports__.y4l,
    __webpackgi_exports__addZipLoader = __webpackgi_exports__.pQ0,
    __webpackgi_exports__afterMain = __webpackgi_exports__.wXW,
    __webpackgi_exports__afterRead = __webpackgi_exports__.r5x,
    __webpackgi_exports__afterWrite = __webpackgi_exports__.MSI,
    __webpackgi_exports__animate = __webpackgi_exports__.jtH,
    __webpackgi_exports__animateAsync = __webpackgi_exports__.T0T,
    __webpackgi_exports__animateObject = __webpackgi_exports__.gAb,
    __webpackgi_exports__animatePromise = __webpackgi_exports__.iwT,
    __webpackgi_exports__animateSet = __webpackgi_exports__.je_,
    __webpackgi_exports__animateTarget = __webpackgi_exports__.wBP,
    __webpackgi_exports__applyStyles = __webpackgi_exports__.Zs7,
    __webpackgi_exports__arrow = __webpackgi_exports__.x7s,
    __webpackgi_exports__auto = __webpackgi_exports__.d73,
    __webpackgi_exports__autoScaleObject3D = __webpackgi_exports__.RG9,
    __webpackgi_exports__basePlacements = __webpackgi_exports__.mvg,
    __webpackgi_exports__beforeMain = __webpackgi_exports__.XMc,
    __webpackgi_exports__beforeRead = __webpackgi_exports__.N7M,
    __webpackgi_exports__beforeWrite = __webpackgi_exports__.iv,
    __webpackgi_exports__blobToDataURL = __webpackgi_exports__.n55,
    __webpackgi_exports__bottom = __webpackgi_exports__.IaC,
    __webpackgi_exports__cLinearToRGBM = __webpackgi_exports__.$MY,
    __webpackgi_exports__cRGBMToLinear = __webpackgi_exports__.wJl,
    __webpackgi_exports__clippingParents = __webpackgi_exports__.zVI,
    __webpackgi_exports__combineDofShader = __webpackgi_exports__.DpF,
    __webpackgi_exports__compress = __webpackgi_exports__.nNb,
    __webpackgi_exports__compressSync = __webpackgi_exports__.cqZ,
    __webpackgi_exports__computeOffsetMatrix = __webpackgi_exports__.KlC,
    __webpackgi_exports__computeScreenSpaceBoundingBox = __webpackgi_exports__.KVn,
    __webpackgi_exports__computeStyles = __webpackgi_exports__.oau,
    __webpackgi_exports__copyMaterialUserData = __webpackgi_exports__.aw9,
    __webpackgi_exports__copyObjectUserData = __webpackgi_exports__.leS,
    __webpackgi_exports__copyProps = __webpackgi_exports__.Dxg,
    __webpackgi_exports__createCanvasElement = __webpackgi_exports__.O5A,
    __webpackgi_exports__createDiv = __webpackgi_exports__.wCn,
    __webpackgi_exports__createImage = __webpackgi_exports__.Bi6,
    __webpackgi_exports__createPopper = __webpackgi_exports__.fi_,
    __webpackgi_exports__createPopperBase = __webpackgi_exports__.TT,
    __webpackgi_exports__createPopperLite = __webpackgi_exports__.q2Z,
    __webpackgi_exports__createRenderTargetKey = __webpackgi_exports__.NyK,
    __webpackgi_exports__createScriptFromURL = __webpackgi_exports__.bgu,
    __webpackgi_exports__createStyles = __webpackgi_exports__.kcS,
    __webpackgi_exports__css = __webpackgi_exports__.ivY,
    __webpackgi_exports__dataTextureFromColor = __webpackgi_exports__._HO,
    __webpackgi_exports__dataTextureFromVec4 = __webpackgi_exports__.tpL,
    __webpackgi_exports__decompress = __webpackgi_exports__.LjN,
    __webpackgi_exports__decompressSync = __webpackgi_exports__.iFs,
    __webpackgi_exports__deepAccessObject = __webpackgi_exports__.qTg,
    __webpackgi_exports__deflate = __webpackgi_exports__.Wtl,
    __webpackgi_exports__deflateSync = __webpackgi_exports__.DmK,
    __webpackgi_exports__deserializeObject = __webpackgi_exports__.Hx7,
    __webpackgi_exports__deserializers = __webpackgi_exports__.imt,
    __webpackgi_exports__detectOverflow = __webpackgi_exports__.US6,
    __webpackgi_exports__diamondMaterialPropList = __webpackgi_exports__.vZs,
    __webpackgi_exports__downloadBlob = __webpackgi_exports__.lmu,
    __webpackgi_exports__downloadFile = __webpackgi_exports__.SvO,
    __webpackgi_exports__embedUrlRefs = __webpackgi_exports__.omp,
    __webpackgi_exports__end = __webpackgi_exports__.utz,
    __webpackgi_exports__envMapBackground = __webpackgi_exports__.TFV,
    __webpackgi_exports__escapeRegExp = __webpackgi_exports__.hrz,
    __webpackgi_exports__eventListeners = __webpackgi_exports__.JKM,
    __webpackgi_exports__extractAnimationKey = __webpackgi_exports__.jZf,
    __webpackgi_exports__flattenUiConfig = __webpackgi_exports__.RjL,
    __webpackgi_exports__flip = __webpackgi_exports__.RRI,
    __webpackgi_exports__fontFormatExtensionMap = __webpackgi_exports__.RUq,
    __webpackgi_exports__generateUiConfig = __webpackgi_exports__._t4,
    __webpackgi_exports__generateUiFolder = __webpackgi_exports__.YHh,
    __webpackgi_exports__getEncodingComponents = __webpackgi_exports__.R8g,
    __webpackgi_exports__getFilenameFromPath = __webpackgi_exports__.Bbl,
    __webpackgi_exports__getKeyByValue = __webpackgi_exports__.V9r,
    __webpackgi_exports__getOrCall = __webpackgi_exports__.PZ2,
    __webpackgi_exports__getPropertyDescriptor = __webpackgi_exports__.w7A,
    __webpackgi_exports__getTexelDecoding = __webpackgi_exports__.N6S,
    __webpackgi_exports__getTexelDecoding2 = __webpackgi_exports__.Uxp,
    __webpackgi_exports__getTexelDecodingFunction = __webpackgi_exports__.tAz,
    __webpackgi_exports__getTexelEncoding = __webpackgi_exports__.R$F,
    __webpackgi_exports__getTexelEncodingFunction = __webpackgi_exports__.N33,
    __webpackgi_exports__getTextureDataType = __webpackgi_exports__.gw2,
    __webpackgi_exports__getTextureEncodingFromMap = __webpackgi_exports__.KlU,
    __webpackgi_exports__getUrlQueryParam = __webpackgi_exports__.wo6,
    __webpackgi_exports__glsl = __webpackgi_exports__.H4P,
    __webpackgi_exports__gunzip = __webpackgi_exports__.swA,
    __webpackgi_exports__gunzipSync = __webpackgi_exports__._Z3,
    __webpackgi_exports__gzip = __webpackgi_exports__.ivc,
    __webpackgi_exports__gzipSync = __webpackgi_exports__.rZ1,
    __webpackgi_exports__hide = __webpackgi_exports__.CpZ,
    __webpackgi_exports__html = __webpackgi_exports__.dyc,
    __webpackgi_exports__htmlToCanvas = __webpackgi_exports__.MxZ,
    __webpackgi_exports__htmlToPng = __webpackgi_exports__.btp,
    __webpackgi_exports__htmlToSvg = __webpackgi_exports__.mXy,
    __webpackgi_exports__iGeometryIgnoredUserData = __webpackgi_exports__.Ej0,
    __webpackgi_exports__iMaterialIgnoredUserData = __webpackgi_exports__.ep4,
    __webpackgi_exports__iModelIgnoredUserData = __webpackgi_exports__.DQP,
    __webpackgi_exports__imageBitmapToBase64 = __webpackgi_exports__.V7q,
    __webpackgi_exports__imageToCanvas = __webpackgi_exports__.zEk,
    __webpackgi_exports__imageUrlToImageData = __webpackgi_exports__.qfq,
    __webpackgi_exports__includesAll = __webpackgi_exports__.piB,
    __webpackgi_exports__inflate = __webpackgi_exports__.rrF,
    __webpackgi_exports__inflateSync = __webpackgi_exports__.naq,
    __webpackgi_exports__isAnimatableType = __webpackgi_exports__.p5I,
    __webpackgi_exports__isPropertyWritable = __webpackgi_exports__.GpE,
    __webpackgi_exports__left = __webpackgi_exports__.t$v,
    __webpackgi_exports__lerpAngle = __webpackgi_exports__.tdn,
    __webpackgi_exports__lerpAngle2 = __webpackgi_exports__.Y9t,
    __webpackgi_exports__main = __webpackgi_exports__.DH3,
    __webpackgi_exports__makeColorSvg = __webpackgi_exports__.uxM,
    __webpackgi_exports__makeColorSvgCircle = __webpackgi_exports__.zH3,
    __webpackgi_exports__makeFilter = __webpackgi_exports__.MLs,
    __webpackgi_exports__makeGeometryUiConfig = __webpackgi_exports__.le6,
    __webpackgi_exports__makeObject3DUiConfig = __webpackgi_exports__.s6f,
    __webpackgi_exports__makeSetterFor = __webpackgi_exports__.YM4,
    __webpackgi_exports__makeSetterForAnimObject = __webpackgi_exports__.B3r,
    __webpackgi_exports__makeTextSvg = __webpackgi_exports__.iAx,
    __webpackgi_exports__matDefine = __webpackgi_exports__.lDn,
    __webpackgi_exports__mobileAndTabletCheck = __webpackgi_exports__.TIc,
    __webpackgi_exports__modifierPhases = __webpackgi_exports__.xsC,
    __webpackgi_exports__now = __webpackgi_exports__.zOc,
    __webpackgi_exports__offset = __webpackgi_exports__.r46,
    __webpackgi_exports__onChange = __webpackgi_exports__.z2C,
    __webpackgi_exports__parseFileExtension = __webpackgi_exports__._X$,
    __webpackgi_exports__patchShaderEncodingSupport = __webpackgi_exports__._yn,
    __webpackgi_exports__pathJoin = __webpackgi_exports__.Dyg,
    __webpackgi_exports__physicalMaterialPropList = __webpackgi_exports__.cUc,
    __webpackgi_exports__placements = __webpackgi_exports__.Ctq,
    __webpackgi_exports__popper = __webpackgi_exports__.k5b,
    __webpackgi_exports__popperGenerator = __webpackgi_exports__.kZl,
    __webpackgi_exports__popperOffsets = __webpackgi_exports__.OCg,
    __webpackgi_exports__preventOverflow = __webpackgi_exports__.YjH,
    __webpackgi_exports__processViewer = __webpackgi_exports__.Ui8,
    __webpackgi_exports__read = __webpackgi_exports__.ij3,
    __webpackgi_exports__reference = __webpackgi_exports__.YPW,
    __webpackgi_exports__removeDuplicateGeometries = __webpackgi_exports__.Bg1,
    __webpackgi_exports__replaceAll = __webpackgi_exports__.kon,
    __webpackgi_exports__right = __webpackgi_exports__.F2z,
    __webpackgi_exports__rotateDuplicatedMesh = __webpackgi_exports__.pJF,
    __webpackgi_exports__sRGBEncoding = __webpackgi_exports__.knz,
    __webpackgi_exports__safeSetProperty = __webpackgi_exports__.Ejo,
    __webpackgi_exports__serializable = __webpackgi_exports__.BgY,
    __webpackgi_exports__serialize = __webpackgi_exports__.qCG,
    __webpackgi_exports__serializeObject = __webpackgi_exports__.HD9,
    __webpackgi_exports__serializers = __webpackgi_exports__.fEB,
    __webpackgi_exports__setMeshGeometry = __webpackgi_exports__.Udc,
    __webpackgi_exports__setMeshMaterial = __webpackgi_exports__.ZQg,
    __webpackgi_exports__setThreeRendererMode = __webpackgi_exports__.ofC,
    __webpackgi_exports__setUrlQueryParam = __webpackgi_exports__.yRy,
    __webpackgi_exports__setupCoreWebGiViewer = __webpackgi_exports__._NL,
    __webpackgi_exports__setupIModel = __webpackgi_exports__.LCA,
    __webpackgi_exports__setupObject3dModel = __webpackgi_exports__.j1w,
    __webpackgi_exports__setupSandboxWebGiEditor = __webpackgi_exports__.i8J,
    __webpackgi_exports__shaderReplaceString = __webpackgi_exports__.p7C,
    __webpackgi_exports__slerp = __webpackgi_exports__.ZAS,
    __webpackgi_exports__snapObject = __webpackgi_exports__.VWG,
    __webpackgi_exports__sphericalFromObject = __webpackgi_exports__.pQ7,
    __webpackgi_exports__standardMaterialPropList = __webpackgi_exports__.jc8,
    __webpackgi_exports__start = __webpackgi_exports__.BL_,
    __webpackgi_exports__strFromU8 = __webpackgi_exports__.T8U,
    __webpackgi_exports__strToU8 = __webpackgi_exports__.TD6,
    __webpackgi_exports__svgToCanvas = __webpackgi_exports__.akS,
    __webpackgi_exports__svgToPng = __webpackgi_exports__.QKE,
    __webpackgi_exports__svgUrl = __webpackgi_exports__.dKx,
    __webpackgi_exports__syncAnimSetUi = __webpackgi_exports__.OvX,
    __webpackgi_exports__timeout = __webpackgi_exports__.VsW,
    __webpackgi_exports__toIndexedGeometry = __webpackgi_exports__.aPg,
    __webpackgi_exports__toTitleCase = __webpackgi_exports__.LFn,
    __webpackgi_exports__top = __webpackgi_exports__.wey,
    __webpackgi_exports__uiButton = __webpackgi_exports__.MaE,
    __webpackgi_exports__uiColor = __webpackgi_exports__.s4x,
    __webpackgi_exports__uiConfig = __webpackgi_exports__.FJA,
    __webpackgi_exports__uiDropdown = __webpackgi_exports__.vIA,
    __webpackgi_exports__uiFolder = __webpackgi_exports__.Spv,
    __webpackgi_exports__uiImage = __webpackgi_exports__.w8l,
    __webpackgi_exports__uiInput = __webpackgi_exports__.riG,
    __webpackgi_exports__uiMonitor = __webpackgi_exports__.Kbh,
    __webpackgi_exports__uiSlider = __webpackgi_exports__.t8K,
    __webpackgi_exports__uiToggle = __webpackgi_exports__.Q7n,
    __webpackgi_exports__uiVector = __webpackgi_exports__.KGF,
    __webpackgi_exports__uniform = __webpackgi_exports__.e5,
    __webpackgi_exports__unzip = __webpackgi_exports__.Rik,
    __webpackgi_exports__unzipSync = __webpackgi_exports__.GZo,
    __webpackgi_exports__unzlib = __webpackgi_exports__.Bds,
    __webpackgi_exports__unzlibSync = __webpackgi_exports__.HTu,
    __webpackgi_exports__uploadFile = __webpackgi_exports__.cTq,
    __webpackgi_exports__vLinearToRGBM = __webpackgi_exports__.X_Y,
    __webpackgi_exports__vRGBMToLinear = __webpackgi_exports__.dA8,
    __webpackgi_exports__variationPlacements = __webpackgi_exports__.bwS,
    __webpackgi_exports__verifyPermission = __webpackgi_exports__.P4F,
    __webpackgi_exports__viewerGLTFExtension = __webpackgi_exports__.Pd0,
    __webpackgi_exports__viewport = __webpackgi_exports__.Pjo,
    __webpackgi_exports__webgiLightExtrasExtension = __webpackgi_exports__.Tum,
    __webpackgi_exports__webgiMaterialExtrasExtension = __webpackgi_exports__.dRH,
    __webpackgi_exports__webgiObject3DExtrasExtension = __webpackgi_exports__.RX0,
    __webpackgi_exports__write = __webpackgi_exports__.cWm,
    __webpackgi_exports__writeFile = __webpackgi_exports__.NC9,
    __webpackgi_exports__zip = __webpackgi_exports__.$Re,
    __webpackgi_exports__zipSync = __webpackgi_exports__.Xo9,
    __webpackgi_exports__zlib = __webpackgi_exports__.LNO,
    __webpackgi_exports__zlibSync = __webpackgi_exports__.iZP;
export {
    __webpackgi_exports__ACESFilmicToneMapping as ACESFilmicToneMapping, __webpackgi_exports__AMaterialManager as AMaterialManager, __webpackgi_exports__ARPlacementBox as ARPlacementBox, __webpackgi_exports__ARPlugin as ARPlugin, __webpackgi_exports__ARTouchInputHelper as ARTouchInputHelper, __webpackgi_exports__AViewerPlugin as AViewerPlugin, __webpackgi_exports__AddBlendPass as AddBlendPass, __webpackgi_exports__AddEquation as AddEquation, __webpackgi_exports__AddOperation as AddOperation, __webpackgi_exports__AdditiveAnimationBlendMode as AdditiveAnimationBlendMode, __webpackgi_exports__AdditiveBlending as AdditiveBlending, __webpackgi_exports__AlphaFormat as AlphaFormat, __webpackgi_exports__AlwaysDepth as AlwaysDepth, __webpackgi_exports__AlwaysStencilFunc as AlwaysStencilFunc, __webpackgi_exports__AmbientLight as AmbientLight, __webpackgi_exports__AmbientLight2 as AmbientLight2, __webpackgi_exports__AmbientLightProbe as AmbientLightProbe, __webpackgi_exports__AnimationClip as AnimationClip, __webpackgi_exports__AnimationLoader as AnimationLoader, __webpackgi_exports__AnimationMixer as AnimationMixer, __webpackgi_exports__AnimationObjectGroup as AnimationObjectGroup, __webpackgi_exports__AnimationUtils as AnimationUtils, __webpackgi_exports__AnisotropyPlugin as AnisotropyPlugin, __webpackgi_exports__ArcCurve as ArcCurve, __webpackgi_exports__ArrayCamera as ArrayCamera, __webpackgi_exports__ArrowHelper as ArrowHelper, __webpackgi_exports__AssetExporter as AssetExporter, __webpackgi_exports__AssetExporterPlugin as AssetExporterPlugin, __webpackgi_exports__AssetImportBasicPopupPlugin as AssetImportBasicPopupPlugin, __webpackgi_exports__AssetImporter as AssetImporter, __webpackgi_exports__AssetManagerPlugin as AssetManagerPlugin, __webpackgi_exports__AsyncCompress as AsyncCompress, __webpackgi_exports__AsyncDecompress as AsyncDecompress, __webpackgi_exports__AsyncDeflate as AsyncDeflate, __webpackgi_exports__AsyncGunzip as AsyncGunzip, __webpackgi_exports__AsyncGzip as AsyncGzip, __webpackgi_exports__AsyncInflate as AsyncInflate, __webpackgi_exports__AsyncUnzipInflate as AsyncUnzipInflate, __webpackgi_exports__AsyncUnzlib as AsyncUnzlib, __webpackgi_exports__AsyncZipDeflate as AsyncZipDeflate, __webpackgi_exports__AsyncZlib as AsyncZlib, __webpackgi_exports__Audio as Audio, __webpackgi_exports__AudioAnalyser as AudioAnalyser, __webpackgi_exports__AudioContext as AudioContext, __webpackgi_exports__AudioListener as AudioListener, __webpackgi_exports__AudioLoader as AudioLoader, __webpackgi_exports__AxesHelper as AxesHelper, __webpackgi_exports__BackSide as BackSide, __webpackgi_exports__BaseGroundPlugin as BaseGroundPlugin, __webpackgi_exports__BaseRenderer as BaseRenderer, __webpackgi_exports__BasicDepthPacking as BasicDepthPacking, __webpackgi_exports__BasicShadowMap as BasicShadowMap, __webpackgi_exports__BlobLoader as BlobLoader, __webpackgi_exports__BloomPlugin as BloomPlugin, __webpackgi_exports__Bone as Bone, __webpackgi_exports__BooleanKeyframeTrack as BooleanKeyframeTrack, __webpackgi_exports__Box2 as Box2, __webpackgi_exports__Box3 as Box3, __webpackgi_exports__Box3B as Box3B, __webpackgi_exports__Box3Helper as Box3Helper, __webpackgi_exports__BoxBufferGeometry as BoxBufferGeometry, __webpackgi_exports__BoxGeometry as BoxGeometry, __webpackgi_exports__BoxHelper as BoxHelper, __webpackgi_exports__BoxSelectionWidget as BoxSelectionWidget, __webpackgi_exports__BufferAttribute as BufferAttribute, __webpackgi_exports__BufferGeometry as BufferGeometry, __webpackgi_exports__BufferGeometryLoader as BufferGeometryLoader, __webpackgi_exports__ByteType as ByteType, __webpackgi_exports__Cache as Cache, __webpackgi_exports__Camera as Camera, __webpackgi_exports__CameraController as CameraController, __webpackgi_exports__CameraHelper as CameraHelper, __webpackgi_exports__CameraView as CameraView, __webpackgi_exports__CameraViewPlugin as CameraViewPlugin, __webpackgi_exports__CanvasRecorder as CanvasRecorder, __webpackgi_exports__CanvasRecorderPlugin as CanvasRecorderPlugin, __webpackgi_exports__CanvasSnipper as CanvasSnipper, __webpackgi_exports__CanvasSnipperPlugin as CanvasSnipperPlugin, __webpackgi_exports__CanvasTexture as CanvasTexture, __webpackgi_exports__CapsuleBufferGeometry as CapsuleBufferGeometry, __webpackgi_exports__CapsuleGeometry as CapsuleGeometry, __webpackgi_exports__CatmullRomCurve3 as CatmullRomCurve3, __webpackgi_exports__CineonToneMapping as CineonToneMapping, __webpackgi_exports__CircleBufferGeometry as CircleBufferGeometry, __webpackgi_exports__CircleGeometry as CircleGeometry, __webpackgi_exports__ClampToEdgeWrapping as ClampToEdgeWrapping, __webpackgi_exports__Clock as Clock, __webpackgi_exports__Color as Color, __webpackgi_exports__ColorKeyframeTrack as ColorKeyframeTrack, __webpackgi_exports__ColorManagement as ColorManagement, __webpackgi_exports__Compress as Compress, __webpackgi_exports__CompressedTexture as CompressedTexture, __webpackgi_exports__CompressedTextureLoader as CompressedTextureLoader, __webpackgi_exports__ConeBufferGeometry as ConeBufferGeometry, __webpackgi_exports__ConeGeometry as ConeGeometry, __webpackgi_exports__ContactShadowGroundPlugin as ContactShadowGroundPlugin, __webpackgi_exports__CubeCamera as CubeCamera, __webpackgi_exports__CubeNormalsCaptureHelper as CubeNormalsCaptureHelper, __webpackgi_exports__CubeReflectionMapping as CubeReflectionMapping, __webpackgi_exports__CubeRefractionMapping as CubeRefractionMapping, __webpackgi_exports__CubeTexture as CubeTexture, __webpackgi_exports__CubeTextureLoader as CubeTextureLoader, __webpackgi_exports__CubeUVReflectionMapping as CubeUVReflectionMapping, __webpackgi_exports__CubicBezierCurve as CubicBezierCurve, __webpackgi_exports__CubicBezierCurve3 as CubicBezierCurve3, __webpackgi_exports__CubicInterpolant as CubicInterpolant, __webpackgi_exports__CullFaceBack as CullFaceBack, __webpackgi_exports__CullFaceFront as CullFaceFront, __webpackgi_exports__CullFaceFrontBack as CullFaceFrontBack, __webpackgi_exports__CullFaceNone as CullFaceNone, __webpackgi_exports__Curve as Curve, __webpackgi_exports__CurvePath as CurvePath, __webpackgi_exports__CustomBlending as CustomBlending, __webpackgi_exports__CustomBumpMapPlugin as CustomBumpMapPlugin, __webpackgi_exports__CustomToneMapping as CustomToneMapping, __webpackgi_exports__CylinderBufferGeometry as CylinderBufferGeometry, __webpackgi_exports__CylinderGeometry as CylinderGeometry, __webpackgi_exports__Cylindrical as Cylindrical, __webpackgi_exports__DECAY_MILLISECONDS as DECAY_MILLISECONDS, __webpackgi_exports__DRACOLoader2 as DRACOLoader2, __webpackgi_exports__Damper as Damper, __webpackgi_exports__Data3DTexture as Data3DTexture, __webpackgi_exports__DataArrayTexture as DataArrayTexture, __webpackgi_exports__DataTexture as DataTexture, __webpackgi_exports__DataTexture2DArray as DataTexture2DArray, __webpackgi_exports__DataTexture3D as DataTexture3D, __webpackgi_exports__DataTextureLoader as DataTextureLoader, __webpackgi_exports__DataUrlLoader as DataUrlLoader, __webpackgi_exports__DataUtils as DataUtils, __webpackgi_exports__DebugPlugin as DebugPlugin, __webpackgi_exports__DecodeUTF8 as DecodeUTF8, __webpackgi_exports__Decompress as Decompress, __webpackgi_exports__DecrementStencilOp as DecrementStencilOp, __webpackgi_exports__DecrementWrapStencilOp as DecrementWrapStencilOp, __webpackgi_exports__DefaultLoadingManager as DefaultLoadingManager, __webpackgi_exports__Deflate as Deflate, __webpackgi_exports__DepthFormat as DepthFormat, __webpackgi_exports__DepthOfFieldPass as DepthOfFieldPass, __webpackgi_exports__DepthOfFieldPlugin as DepthOfFieldPlugin, __webpackgi_exports__DepthStencilFormat as DepthStencilFormat, __webpackgi_exports__DepthTexture as DepthTexture, __webpackgi_exports__DiamondMaterial as DiamondMaterial, __webpackgi_exports__DiamondPlugin as DiamondPlugin, __webpackgi_exports__DirectionalLight as DirectionalLight, __webpackgi_exports__DirectionalLight2 as DirectionalLight2, __webpackgi_exports__DirectionalLightHelper as DirectionalLightHelper, __webpackgi_exports__DiscreteInterpolant as DiscreteInterpolant, __webpackgi_exports__DodecahedronBufferGeometry as DodecahedronBufferGeometry, __webpackgi_exports__DodecahedronGeometry as DodecahedronGeometry, __webpackgi_exports__DoubleSide as DoubleSide, __webpackgi_exports__Dropzone as Dropzone, __webpackgi_exports__DropzonePlugin as DropzonePlugin, __webpackgi_exports__DstAlphaFactor as DstAlphaFactor, __webpackgi_exports__DstColorFactor as DstColorFactor, __webpackgi_exports__DynamicCopyUsage as DynamicCopyUsage, __webpackgi_exports__DynamicDrawUsage as DynamicDrawUsage, __webpackgi_exports__DynamicReadUsage as DynamicReadUsage, __webpackgi_exports__EXRLoadPlugin as EXRLoadPlugin, __webpackgi_exports__EasingFunctions as EasingFunctions, __webpackgi_exports__EdgesGeometry as EdgesGeometry, __webpackgi_exports__EffectComposer2 as EffectComposer2, __webpackgi_exports__EllipseCurve as EllipseCurve, __webpackgi_exports__EncodeUTF8 as EncodeUTF8, __webpackgi_exports__EqualDepth as EqualDepth, __webpackgi_exports__EqualStencilFunc as EqualStencilFunc, __webpackgi_exports__EquirectangularReflectionMapping as EquirectangularReflectionMapping, __webpackgi_exports__EquirectangularRefractionMapping as EquirectangularRefractionMapping, __webpackgi_exports__Euler as Euler, __webpackgi_exports__EventDispatcher as EventDispatcher, __webpackgi_exports__ExtrudeBufferGeometry as ExtrudeBufferGeometry, __webpackgi_exports__ExtrudeGeometry as ExtrudeGeometry, __webpackgi_exports__FBXLoadPlugin as FBXLoadPlugin, __webpackgi_exports__FSShadowMaterial as FSShadowMaterial, __webpackgi_exports__FileLoader as FileLoader, __webpackgi_exports__FlatShading as FlatShading, __webpackgi_exports__Float16BufferAttribute as Float16BufferAttribute, __webpackgi_exports__Float32BufferAttribute as Float32BufferAttribute, __webpackgi_exports__Float64BufferAttribute as Float64BufferAttribute, __webpackgi_exports__FloatType as FloatType, __webpackgi_exports__Fog as Fog, __webpackgi_exports__FogExp2 as FogExp2, __webpackgi_exports__Font as Font, __webpackgi_exports__FontLoader as FontLoader, __webpackgi_exports__FrameFadePlugin as FrameFadePlugin, __webpackgi_exports__FramebufferTexture as FramebufferTexture, __webpackgi_exports__FrontSide as FrontSide, __webpackgi_exports__Frustum as Frustum, __webpackgi_exports__FullScreenPlugin as FullScreenPlugin, __webpackgi_exports__GBufferPlugin as GBufferPlugin, __webpackgi_exports__GLBufferAttribute as GLBufferAttribute, __webpackgi_exports__GLSL1 as GLSL1, __webpackgi_exports__GLSL3 as GLSL3, __webpackgi_exports__GLTFAnimationPlugin as GLTFAnimationPlugin, __webpackgi_exports__GLTFDracoExportPlugin as GLTFDracoExportPlugin, __webpackgi_exports__GLTFDracoExporter as GLTFDracoExporter, __webpackgi_exports__GLTFExporter2 as GLTFExporter2, __webpackgi_exports__GLTFLoader2 as GLTFLoader2, __webpackgi_exports__GLTFMaterialsAlphaMapExtensionName as GLTFMaterialsAlphaMapExtensionName, __webpackgi_exports__GLTFMaterialsBumpMapExtensionName as GLTFMaterialsBumpMapExtensionName, __webpackgi_exports__GLTFMaterialsLightMapExtensionName as GLTFMaterialsLightMapExtensionName, __webpackgi_exports__GLTFMeshOptPlugin as GLTFMeshOptPlugin, __webpackgi_exports__GLTFWriter2 as GLTFWriter2, __webpackgi_exports__GenericBlendTexturePass as GenericBlendTexturePass, __webpackgi_exports__GenericFilterPlugin as GenericFilterPlugin, __webpackgi_exports__GreaterDepth as GreaterDepth, __webpackgi_exports__GreaterEqualDepth as GreaterEqualDepth, __webpackgi_exports__GreaterEqualStencilFunc as GreaterEqualStencilFunc, __webpackgi_exports__GreaterStencilFunc as GreaterStencilFunc, __webpackgi_exports__GridHelper as GridHelper, __webpackgi_exports__GroundPlugin as GroundPlugin, __webpackgi_exports__Group as Group, __webpackgi_exports__Gunzip as Gunzip, __webpackgi_exports__Gzip as Gzip, __webpackgi_exports__HDRiGroundPlugin as HDRiGroundPlugin, __webpackgi_exports__HalfFloatType as HalfFloatType, __webpackgi_exports__HemisphereLight as HemisphereLight, __webpackgi_exports__HemisphereLightHelper as HemisphereLightHelper, __webpackgi_exports__HemisphereLightProbe as HemisphereLightProbe, __webpackgi_exports__HierarchyUiPlugin as HierarchyUiPlugin, __webpackgi_exports__IcosahedronBufferGeometry as IcosahedronBufferGeometry, __webpackgi_exports__IcosahedronGeometry as IcosahedronGeometry, __webpackgi_exports__ImageBitmapLoader as ImageBitmapLoader, __webpackgi_exports__ImageLoader as ImageLoader, __webpackgi_exports__ImageUtils as ImageUtils, __webpackgi_exports__ImmediateRenderObject as ImmediateRenderObject, __webpackgi_exports__Importer as Importer, __webpackgi_exports__IncrementStencilOp as IncrementStencilOp, __webpackgi_exports__IncrementWrapStencilOp as IncrementWrapStencilOp, __webpackgi_exports__Inflate as Inflate, __webpackgi_exports__InstancedBufferAttribute as InstancedBufferAttribute, __webpackgi_exports__InstancedBufferGeometry as InstancedBufferGeometry, __webpackgi_exports__InstancedInterleavedBuffer as InstancedInterleavedBuffer, __webpackgi_exports__InstancedMesh as InstancedMesh, __webpackgi_exports__Int16BufferAttribute as Int16BufferAttribute, __webpackgi_exports__Int32BufferAttribute as Int32BufferAttribute, __webpackgi_exports__Int8BufferAttribute as Int8BufferAttribute, __webpackgi_exports__IntType as IntType, __webpackgi_exports__InterleavedBuffer as InterleavedBuffer, __webpackgi_exports__InterleavedBufferAttribute as InterleavedBufferAttribute, __webpackgi_exports__Interpolant as Interpolant, __webpackgi_exports__InterpolateDiscrete as InterpolateDiscrete, __webpackgi_exports__InterpolateLinear as InterpolateLinear, __webpackgi_exports__InterpolateSmooth as InterpolateSmooth, __webpackgi_exports__InvertStencilOp as InvertStencilOp, __webpackgi_exports__KHR_TEXTURE_BASISU as KHR_TEXTURE_BASISU, __webpackgi_exports__KTX2LoadPlugin as KTX2LoadPlugin, __webpackgi_exports__KTXLoadPlugin as KTXLoadPlugin, __webpackgi_exports__KeepStencilOp as KeepStencilOp, __webpackgi_exports__KeyframeTrack as KeyframeTrack, __webpackgi_exports__LOD as LOD, __webpackgi_exports__LatheBufferGeometry as LatheBufferGeometry, __webpackgi_exports__LatheGeometry as LatheGeometry, __webpackgi_exports__Layers as Layers, __webpackgi_exports__LessDepth as LessDepth, __webpackgi_exports__LessEqualDepth as LessEqualDepth, __webpackgi_exports__LessEqualStencilFunc as LessEqualStencilFunc, __webpackgi_exports__LessStencilFunc as LessStencilFunc, __webpackgi_exports__Light as Light, __webpackgi_exports__LightProbe as LightProbe, __webpackgi_exports__Line as Line, __webpackgi_exports__Line3 as Line3, __webpackgi_exports__LineBasicMaterial as LineBasicMaterial, __webpackgi_exports__LineCurve as LineCurve, __webpackgi_exports__LineCurve3 as LineCurve3, __webpackgi_exports__LineDashedMaterial as LineDashedMaterial, __webpackgi_exports__LineLoop as LineLoop, __webpackgi_exports__LineSegments as LineSegments, __webpackgi_exports__LinearEncoding as LinearEncoding, __webpackgi_exports__LinearFilter as LinearFilter, __webpackgi_exports__LinearInterpolant as LinearInterpolant, __webpackgi_exports__LinearMipMapLinearFilter as LinearMipMapLinearFilter, __webpackgi_exports__LinearMipMapNearestFilter as LinearMipMapNearestFilter, __webpackgi_exports__LinearMipmapLinearFilter as LinearMipmapLinearFilter, __webpackgi_exports__LinearMipmapNearestFilter as LinearMipmapNearestFilter, __webpackgi_exports__LinearSRGBColorSpace as LinearSRGBColorSpace, __webpackgi_exports__LinearToneMapping as LinearToneMapping, __webpackgi_exports__Loader as Loader, __webpackgi_exports__LoaderUtils as LoaderUtils, __webpackgi_exports__LoadingManager as LoadingManager, __webpackgi_exports__LoopOnce as LoopOnce, __webpackgi_exports__LoopPingPong as LoopPingPong, __webpackgi_exports__LoopRepeat as LoopRepeat, __webpackgi_exports__LuminanceAlphaFormat as LuminanceAlphaFormat, __webpackgi_exports__LuminanceFormat as LuminanceFormat, __webpackgi_exports__MOUSE as MOUSE, __webpackgi_exports__MTLLoader2 as MTLLoader2, __webpackgi_exports__Material as Material, __webpackgi_exports__MaterialConfiguratorBasePlugin as MaterialConfiguratorBasePlugin, __webpackgi_exports__MaterialConfiguratorPlugin as MaterialConfiguratorPlugin, __webpackgi_exports__MaterialExtender as MaterialExtender, __webpackgi_exports__MaterialLibraryBasePlugin as MaterialLibraryBasePlugin, __webpackgi_exports__MaterialLibraryPlugin as MaterialLibraryPlugin, __webpackgi_exports__MaterialLoader as MaterialLoader, __webpackgi_exports__MaterialManager as MaterialManager, __webpackgi_exports__MaterialPreviewGenerator as MaterialPreviewGenerator, __webpackgi_exports__MathUtils as MathUtils, __webpackgi_exports__Matrix3 as Matrix3, __webpackgi_exports__Matrix4 as Matrix4, __webpackgi_exports__MaxEquation as MaxEquation, __webpackgi_exports__Mesh as Mesh, __webpackgi_exports__MeshBasicMaterial as MeshBasicMaterial, __webpackgi_exports__MeshDepthMaterial as MeshDepthMaterial, __webpackgi_exports__MeshDistanceMaterial as MeshDistanceMaterial, __webpackgi_exports__MeshLambertMaterial as MeshLambertMaterial, __webpackgi_exports__MeshMatcapMaterial as MeshMatcapMaterial, __webpackgi_exports__MeshNormalMaterial as MeshNormalMaterial, __webpackgi_exports__MeshPhongMaterial as MeshPhongMaterial, __webpackgi_exports__MeshPhysicalMaterial as MeshPhysicalMaterial, __webpackgi_exports__MeshStandardMaterial as MeshStandardMaterial, __webpackgi_exports__MeshStandardMaterial2 as MeshStandardMaterial2, __webpackgi_exports__MeshToonMaterial as MeshToonMaterial, __webpackgi_exports__MinEquation as MinEquation, __webpackgi_exports__MirroredRepeatWrapping as MirroredRepeatWrapping, __webpackgi_exports__MixOperation as MixOperation, __webpackgi_exports__MultiFilterPlugin as MultiFilterPlugin, __webpackgi_exports__MultiplyBlending as MultiplyBlending, __webpackgi_exports__MultiplyOperation as MultiplyOperation, __webpackgi_exports__NearestFilter as NearestFilter, __webpackgi_exports__NearestMipMapLinearFilter as NearestMipMapLinearFilter, __webpackgi_exports__NearestMipMapNearestFilter as NearestMipMapNearestFilter, __webpackgi_exports__NearestMipmapLinearFilter as NearestMipmapLinearFilter, __webpackgi_exports__NearestMipmapNearestFilter as NearestMipmapNearestFilter, __webpackgi_exports__NeverDepth as NeverDepth, __webpackgi_exports__NeverStencilFunc as NeverStencilFunc, __webpackgi_exports__NoBlending as NoBlending, __webpackgi_exports__NoColorSpace as NoColorSpace, __webpackgi_exports__NoToneMapping as NoToneMapping, __webpackgi_exports__NoiseBumpMaterialPlugin as NoiseBumpMaterialPlugin, __webpackgi_exports__NormalAnimationBlendMode as NormalAnimationBlendMode, __webpackgi_exports__NormalBlending as NormalBlending, __webpackgi_exports__NormalCaptureMaterial as NormalCaptureMaterial, __webpackgi_exports__NotEqualDepth as NotEqualDepth, __webpackgi_exports__NotEqualStencilFunc as NotEqualStencilFunc, __webpackgi_exports__NumberKeyframeTrack as NumberKeyframeTrack, __webpackgi_exports__OBJLoader2 as OBJLoader2, __webpackgi_exports__ObjMtlLoadPlugin as ObjMtlLoadPlugin, __webpackgi_exports__Object3D as Object3D, __webpackgi_exports__Object3DModel as Object3DModel, __webpackgi_exports__ObjectLoader as ObjectLoader, __webpackgi_exports__ObjectLoader2 as ObjectLoader2, __webpackgi_exports__ObjectPicker as ObjectPicker, __webpackgi_exports__ObjectProcessorMap as ObjectProcessorMap, __webpackgi_exports__ObjectRotationPlugin as ObjectRotationPlugin, __webpackgi_exports__ObjectSpaceNormalMap as ObjectSpaceNormalMap, __webpackgi_exports__OctahedronBufferGeometry as OctahedronBufferGeometry, __webpackgi_exports__OctahedronGeometry as OctahedronGeometry, __webpackgi_exports__OneFactor as OneFactor, __webpackgi_exports__OneMinusDstAlphaFactor as OneMinusDstAlphaFactor, __webpackgi_exports__OneMinusDstColorFactor as OneMinusDstColorFactor, __webpackgi_exports__OneMinusSrcAlphaFactor as OneMinusSrcAlphaFactor, __webpackgi_exports__OneMinusSrcColorFactor as OneMinusSrcColorFactor, __webpackgi_exports__OrbitControls2 as OrbitControls2, __webpackgi_exports__OrthographicCamera as OrthographicCamera, __webpackgi_exports__PCFShadowMap as PCFShadowMap, __webpackgi_exports__PCFSoftShadowMap as PCFSoftShadowMap, __webpackgi_exports__PMREMGenerator as PMREMGenerator, __webpackgi_exports__PMREMGeneratorPlugin as PMREMGeneratorPlugin, __webpackgi_exports__ParallaxMappingPlugin as ParallaxMappingPlugin, __webpackgi_exports__ParametricGeometry as ParametricGeometry, __webpackgi_exports__Path as Path, __webpackgi_exports__PerspectiveCamera as PerspectiveCamera, __webpackgi_exports__PickingPlugin as PickingPlugin, __webpackgi_exports__Plane as Plane, __webpackgi_exports__PlaneBufferGeometry as PlaneBufferGeometry, __webpackgi_exports__PlaneGeometry as PlaneGeometry, __webpackgi_exports__PlaneHelper as PlaneHelper, __webpackgi_exports__PointLight as PointLight, __webpackgi_exports__PointLightHelper as PointLightHelper, __webpackgi_exports__Points as Points, __webpackgi_exports__PointsMaterial as PointsMaterial, __webpackgi_exports__PolarGridHelper as PolarGridHelper, __webpackgi_exports__PolyhedronBufferGeometry as PolyhedronBufferGeometry, __webpackgi_exports__PolyhedronGeometry as PolyhedronGeometry, __webpackgi_exports__PopmotionPlugin as PopmotionPlugin, __webpackgi_exports__PositionalAudio as PositionalAudio, __webpackgi_exports__ProgressivePlugin as ProgressivePlugin, __webpackgi_exports__PropertyBinding as PropertyBinding, __webpackgi_exports__PropertyMixer as PropertyMixer, __webpackgi_exports__QuadraticBezierCurve as QuadraticBezierCurve, __webpackgi_exports__QuadraticBezierCurve3 as QuadraticBezierCurve3, __webpackgi_exports__Quaternion as Quaternion, __webpackgi_exports__QuaternionKeyframeTrack as QuaternionKeyframeTrack, __webpackgi_exports__QuaternionLinearInterpolant as QuaternionLinearInterpolant, __webpackgi_exports__REVISION as REVISION, __webpackgi_exports__RGBADepthPacking as RGBADepthPacking, __webpackgi_exports__RGBAFormat as RGBAFormat, __webpackgi_exports__RGBAIntegerFormat as RGBAIntegerFormat, __webpackgi_exports__RGBA_ASTC_10x10_Format as RGBA_ASTC_10x10_Format, __webpackgi_exports__RGBA_ASTC_10x5_Format as RGBA_ASTC_10x5_Format, __webpackgi_exports__RGBA_ASTC_10x6_Format as RGBA_ASTC_10x6_Format, __webpackgi_exports__RGBA_ASTC_10x8_Format as RGBA_ASTC_10x8_Format, __webpackgi_exports__RGBA_ASTC_12x10_Format as RGBA_ASTC_12x10_Format, __webpackgi_exports__RGBA_ASTC_12x12_Format as RGBA_ASTC_12x12_Format, __webpackgi_exports__RGBA_ASTC_4x4_Format as RGBA_ASTC_4x4_Format, __webpackgi_exports__RGBA_ASTC_5x4_Format as RGBA_ASTC_5x4_Format, __webpackgi_exports__RGBA_ASTC_5x5_Format as RGBA_ASTC_5x5_Format, __webpackgi_exports__RGBA_ASTC_6x5_Format as RGBA_ASTC_6x5_Format, __webpackgi_exports__RGBA_ASTC_6x6_Format as RGBA_ASTC_6x6_Format, __webpackgi_exports__RGBA_ASTC_8x5_Format as RGBA_ASTC_8x5_Format, __webpackgi_exports__RGBA_ASTC_8x6_Format as RGBA_ASTC_8x6_Format, __webpackgi_exports__RGBA_ASTC_8x8_Format as RGBA_ASTC_8x8_Format, __webpackgi_exports__RGBA_BPTC_Format as RGBA_BPTC_Format, __webpackgi_exports__RGBA_ETC2_EAC_Format as RGBA_ETC2_EAC_Format, __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format as RGBA_PVRTC_2BPPV1_Format, __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format as RGBA_PVRTC_4BPPV1_Format, __webpackgi_exports__RGBA_S3TC_DXT1_Format as RGBA_S3TC_DXT1_Format, __webpackgi_exports__RGBA_S3TC_DXT3_Format as RGBA_S3TC_DXT3_Format, __webpackgi_exports__RGBA_S3TC_DXT5_Format as RGBA_S3TC_DXT5_Format, __webpackgi_exports__RGBFormat as RGBFormat, __webpackgi_exports__RGBM16Encoding as RGBM16Encoding, __webpackgi_exports__RGBM7Encoding as RGBM7Encoding, __webpackgi_exports__RGB_ETC1_Format as RGB_ETC1_Format, __webpackgi_exports__RGB_ETC2_Format as RGB_ETC2_Format, __webpackgi_exports__RGB_PVRTC_2BPPV1_Format as RGB_PVRTC_2BPPV1_Format, __webpackgi_exports__RGB_PVRTC_4BPPV1_Format as RGB_PVRTC_4BPPV1_Format, __webpackgi_exports__RGB_S3TC_DXT1_Format as RGB_S3TC_DXT1_Format, __webpackgi_exports__RGFormat as RGFormat, __webpackgi_exports__RGIntegerFormat as RGIntegerFormat, __webpackgi_exports__RandomizedDirectionalLight as RandomizedDirectionalLight, __webpackgi_exports__RandomizedDirectionalLightPlugin as RandomizedDirectionalLightPlugin, __webpackgi_exports__RawShaderMaterial as RawShaderMaterial, __webpackgi_exports__Ray as Ray, __webpackgi_exports__Raycaster as Raycaster, __webpackgi_exports__RectAreaLight as RectAreaLight, __webpackgi_exports__RedFormat as RedFormat, __webpackgi_exports__RedIntegerFormat as RedIntegerFormat, __webpackgi_exports__Reflector2 as Reflector2, __webpackgi_exports__ReinhardToneMapping as ReinhardToneMapping, __webpackgi_exports__RepeatWrapping as RepeatWrapping, __webpackgi_exports__ReplaceStencilOp as ReplaceStencilOp, __webpackgi_exports__ReverseSubtractEquation as ReverseSubtractEquation, __webpackgi_exports__Rhino3dmLoadPlugin as Rhino3dmLoadPlugin, __webpackgi_exports__Rhino3dmLoader2 as Rhino3dmLoader2, __webpackgi_exports__RingBufferGeometry as RingBufferGeometry, __webpackgi_exports__RingGeometry as RingGeometry, __webpackgi_exports__RootScene as RootScene, __webpackgi_exports__SETTLING_TIME as SETTLING_TIME, __webpackgi_exports__SRGBColorSpace as SRGBColorSpace, __webpackgi_exports__SSAOPlugin as SSAOPlugin, __webpackgi_exports__SSContactShadows as SSContactShadows, __webpackgi_exports__SSRPlugin as SSRPlugin, __webpackgi_exports__STLLoadPlugin as STLLoadPlugin, __webpackgi_exports__Scene as Scene, __webpackgi_exports__SelectionWidget as SelectionWidget, __webpackgi_exports__SerializableOrbitControls as SerializableOrbitControls, __webpackgi_exports__ShaderChunk as ShaderChunk, __webpackgi_exports__ShaderLib as ShaderLib, __webpackgi_exports__ShaderMaterial as ShaderMaterial, __webpackgi_exports__ShaderMaterialEncodingSupport as ShaderMaterialEncodingSupport, __webpackgi_exports__ShaderPass2 as ShaderPass2, __webpackgi_exports__ShadowMapBaker as ShadowMapBaker, __webpackgi_exports__ShadowMaterial as ShadowMaterial, __webpackgi_exports__Shape as Shape, __webpackgi_exports__ShapeBufferGeometry as ShapeBufferGeometry, __webpackgi_exports__ShapeGeometry as ShapeGeometry, __webpackgi_exports__ShapePath as ShapePath, __webpackgi_exports__ShapeTubeExtrudePlugin as ShapeTubeExtrudePlugin, __webpackgi_exports__ShapeUtils as ShapeUtils, __webpackgi_exports__ShortType as ShortType, __webpackgi_exports__SimpleAssetList as SimpleAssetList, __webpackgi_exports__SimpleBackgroundEnvUiPlugin as SimpleBackgroundEnvUiPlugin, __webpackgi_exports__SimpleDataSource as SimpleDataSource, __webpackgi_exports__SimpleEventDispatcher as SimpleEventDispatcher, __webpackgi_exports__SimpleJSONExporter as SimpleJSONExporter, __webpackgi_exports__SimpleJSONLoader as SimpleJSONLoader, __webpackgi_exports__SimpleTextExporter as SimpleTextExporter, __webpackgi_exports__SimpleTextPlugin as SimpleTextPlugin, __webpackgi_exports__SimpleViewerUi as SimpleViewerUi, __webpackgi_exports__Skeleton as Skeleton, __webpackgi_exports__SkeletonHelper as SkeletonHelper, __webpackgi_exports__SkinnedMesh as SkinnedMesh, __webpackgi_exports__SmoothShading as SmoothShading, __webpackgi_exports__Source as Source, __webpackgi_exports__Sphere as Sphere, __webpackgi_exports__SphereBufferGeometry as SphereBufferGeometry, __webpackgi_exports__SphereGeometry as SphereGeometry, __webpackgi_exports__SphereSelectionWidget as SphereSelectionWidget, __webpackgi_exports__Spherical as Spherical, __webpackgi_exports__SphericalHarmonics3 as SphericalHarmonics3, __webpackgi_exports__SplineCurve as SplineCurve, __webpackgi_exports__SpotLight as SpotLight, __webpackgi_exports__SpotLight2 as SpotLight2, __webpackgi_exports__SpotLightHelper as SpotLightHelper, __webpackgi_exports__Sprite as Sprite, __webpackgi_exports__SpriteMaterial as SpriteMaterial, __webpackgi_exports__SrcAlphaFactor as SrcAlphaFactor, __webpackgi_exports__SrcAlphaSaturateFactor as SrcAlphaSaturateFactor, __webpackgi_exports__SrcColorFactor as SrcColorFactor, __webpackgi_exports__StaticCopyUsage as StaticCopyUsage, __webpackgi_exports__StaticDrawUsage as StaticDrawUsage, __webpackgi_exports__StaticReadUsage as StaticReadUsage, __webpackgi_exports__StereoCamera as StereoCamera, __webpackgi_exports__StreamCopyUsage as StreamCopyUsage, __webpackgi_exports__StreamDrawUsage as StreamDrawUsage, __webpackgi_exports__StreamReadUsage as StreamReadUsage, __webpackgi_exports__StringKeyframeTrack as StringKeyframeTrack, __webpackgi_exports__SubtractEquation as SubtractEquation, __webpackgi_exports__SubtractiveBlending as SubtractiveBlending, __webpackgi_exports__SwitchNodePlugin as SwitchNodePlugin, __webpackgi_exports__TOUCH as TOUCH, __webpackgi_exports__TangentSpaceNormalMap as TangentSpaceNormalMap, __webpackgi_exports__TemporalAAPlugin as TemporalAAPlugin, __webpackgi_exports__TetrahedronBufferGeometry as TetrahedronBufferGeometry, __webpackgi_exports__TetrahedronGeometry as TetrahedronGeometry, __webpackgi_exports__TextGeometry as TextGeometry, __webpackgi_exports__TextSVGOptions as TextSVGOptions, __webpackgi_exports__Texture as Texture, __webpackgi_exports__TextureLoader as TextureLoader, __webpackgi_exports__ThinFilmLayerPlugin as ThinFilmLayerPlugin, __webpackgi_exports__ThreeMaterialLoader as ThreeMaterialLoader, __webpackgi_exports__TonemapPass as TonemapPass, __webpackgi_exports__TonemapPlugin as TonemapPlugin, __webpackgi_exports__TorusBufferGeometry as TorusBufferGeometry, __webpackgi_exports__TorusGeometry as TorusGeometry, __webpackgi_exports__TorusKnotBufferGeometry as TorusKnotBufferGeometry, __webpackgi_exports__TorusKnotGeometry as TorusKnotGeometry, __webpackgi_exports__TransformControls2 as TransformControls2, __webpackgi_exports__Triangle as Triangle, __webpackgi_exports__TriangleFanDrawMode as TriangleFanDrawMode, __webpackgi_exports__TriangleStripDrawMode as TriangleStripDrawMode, __webpackgi_exports__TrianglesDrawMode as TrianglesDrawMode, __webpackgi_exports__TubeBufferGeometry as TubeBufferGeometry, __webpackgi_exports__TubeGeometry as TubeGeometry, __webpackgi_exports__TubeShapeGeometry as TubeShapeGeometry, __webpackgi_exports__TweakpaneUiPlugin as TweakpaneUiPlugin, __webpackgi_exports__TweakpaneWrapper as TweakpaneWrapper, __webpackgi_exports__UVMapping as UVMapping, __webpackgi_exports__Uint16BufferAttribute as Uint16BufferAttribute, __webpackgi_exports__Uint32BufferAttribute as Uint32BufferAttribute, __webpackgi_exports__Uint8BufferAttribute as Uint8BufferAttribute, __webpackgi_exports__Uint8ClampedBufferAttribute as Uint8ClampedBufferAttribute, __webpackgi_exports__Uncharted2Tonemapping as Uncharted2Tonemapping, __webpackgi_exports__Uniform as Uniform, __webpackgi_exports__UniformsGroup as UniformsGroup, __webpackgi_exports__UniformsLib as UniformsLib, __webpackgi_exports__UniformsUtils as UniformsUtils, __webpackgi_exports__UnsignedByteType as UnsignedByteType, __webpackgi_exports__UnsignedInt248Type as UnsignedInt248Type, __webpackgi_exports__UnsignedIntType as UnsignedIntType, __webpackgi_exports__UnsignedShort4444Type as UnsignedShort4444Type, __webpackgi_exports__UnsignedShort5551Type as UnsignedShort5551Type, __webpackgi_exports__UnsignedShortType as UnsignedShortType, __webpackgi_exports__Unzip as Unzip, __webpackgi_exports__UnzipInflate as UnzipInflate, __webpackgi_exports__UnzipPassThrough as UnzipPassThrough, __webpackgi_exports__Unzlib as Unzlib, __webpackgi_exports__VSMShadowMap as VSMShadowMap, __webpackgi_exports__Vector2 as Vector2, __webpackgi_exports__Vector3 as Vector3, __webpackgi_exports__Vector4 as Vector4, __webpackgi_exports__VectorKeyframeTrack as VectorKeyframeTrack, __webpackgi_exports__VelocityBufferPlugin as VelocityBufferPlugin, __webpackgi_exports__VideoTexture as VideoTexture, __webpackgi_exports__ViewerApp as ViewerApp, __webpackgi_exports__ViewerState as ViewerState, __webpackgi_exports__WebGL1Renderer as WebGL1Renderer, __webpackgi_exports__WebGL3DRenderTarget as WebGL3DRenderTarget, __webpackgi_exports__WebGLArrayRenderTarget as WebGLArrayRenderTarget, __webpackgi_exports__WebGLCubeRenderTarget as WebGLCubeRenderTarget, __webpackgi_exports__WebGLMultipleRenderTargets as WebGLMultipleRenderTargets, __webpackgi_exports__WebGLMultisampleRenderTarget as WebGLMultisampleRenderTarget, __webpackgi_exports__WebGLRenderTarget as WebGLRenderTarget, __webpackgi_exports__WebGLRenderer as WebGLRenderer, __webpackgi_exports__WebGLUtils as WebGLUtils, __webpackgi_exports__WebGiViewerElement as WebGiViewerElement, __webpackgi_exports__WireframeGeometry as WireframeGeometry, __webpackgi_exports__WrapAroundEnding as WrapAroundEnding, __webpackgi_exports__ZeroCurvatureEnding as ZeroCurvatureEnding, __webpackgi_exports__ZeroFactor as ZeroFactor, __webpackgi_exports__ZeroSlopeEnding as ZeroSlopeEnding, __webpackgi_exports__ZeroStencilOp as ZeroStencilOp, __webpackgi_exports__Zip as Zip, __webpackgi_exports__ZipDeflate as ZipDeflate, __webpackgi_exports__ZipLoader as ZipLoader, __webpackgi_exports__ZipPassThrough as ZipPassThrough, __webpackgi_exports__Zlib as Zlib, __webpackgi_exports___SRGBAFormat as _SRGBAFormat, __webpackgi_exports__addBasePlugins as addBasePlugins, __webpackgi_exports__addDracoLoader as addDracoLoader, __webpackgi_exports__addGLTFExporter as addGLTFExporter, __webpackgi_exports__addGLTFLoader as addGLTFLoader, __webpackgi_exports__addRGBELoader as addRGBELoader, __webpackgi_exports__addZipLoader as addZipLoader, __webpackgi_exports__afterMain as afterMain, __webpackgi_exports__afterRead as afterRead, __webpackgi_exports__afterWrite as afterWrite, __webpackgi_exports__animate as animate, __webpackgi_exports__animateAsync as animateAsync, __webpackgi_exports__animateObject as animateObject, __webpackgi_exports__animatePromise as animatePromise, __webpackgi_exports__animateSet as animateSet, __webpackgi_exports__animateTarget as animateTarget, __webpackgi_exports__applyStyles as applyStyles, __webpackgi_exports__arrow as arrow, __webpackgi_exports__auto as auto, __webpackgi_exports__autoScaleObject3D as autoScaleObject3D, __webpackgi_exports__basePlacements as basePlacements, __webpackgi_exports__beforeMain as beforeMain, __webpackgi_exports__beforeRead as beforeRead, __webpackgi_exports__beforeWrite as beforeWrite, __webpackgi_exports__blobToDataURL as blobToDataURL, __webpackgi_exports__bottom as bottom, __webpackgi_exports__cLinearToRGBM as cLinearToRGBM, __webpackgi_exports__cRGBMToLinear as cRGBMToLinear, __webpackgi_exports__clippingParents as clippingParents, __webpackgi_exports__combineDofShader as combineDofShader, __webpackgi_exports__compress as compress, __webpackgi_exports__compressSync as compressSync, __webpackgi_exports__computeOffsetMatrix as computeOffsetMatrix, __webpackgi_exports__computeScreenSpaceBoundingBox as computeScreenSpaceBoundingBox, __webpackgi_exports__computeStyles as computeStyles, __webpackgi_exports__copyMaterialUserData as copyMaterialUserData, __webpackgi_exports__copyObjectUserData as copyObjectUserData, __webpackgi_exports__copyProps as copyProps, __webpackgi_exports__createCanvasElement as createCanvasElement, __webpackgi_exports__createDiv as createDiv, __webpackgi_exports__createImage as createImage, __webpackgi_exports__createPopper as createPopper, __webpackgi_exports__createPopperBase as createPopperBase, __webpackgi_exports__createPopperLite as createPopperLite, __webpackgi_exports__createRenderTargetKey as createRenderTargetKey, __webpackgi_exports__createScriptFromURL as createScriptFromURL, __webpackgi_exports__createStyles as createStyles, __webpackgi_exports__css as css, __webpackgi_exports__dataTextureFromColor as dataTextureFromColor, __webpackgi_exports__dataTextureFromVec4 as dataTextureFromVec4, __webpackgi_exports__decompress as decompress, __webpackgi_exports__decompressSync as decompressSync, __webpackgi_exports__deepAccessObject as deepAccessObject, __webpackgi_exports__deflate as deflate, __webpackgi_exports__deflateSync as deflateSync, __webpackgi_exports__deserializeObject as deserializeObject, __webpackgi_exports__deserializers as deserializers, __webpackgi_exports__detectOverflow as detectOverflow, __webpackgi_exports__diamondMaterialPropList as diamondMaterialPropList, __webpackgi_exports__downloadBlob as downloadBlob, __webpackgi_exports__downloadFile as downloadFile, __webpackgi_exports__embedUrlRefs as embedUrlRefs, __webpackgi_exports__end as end, __webpackgi_exports__envMapBackground as envMapBackground, __webpackgi_exports__escapeRegExp as escapeRegExp, __webpackgi_exports__eventListeners as eventListeners, __webpackgi_exports__extractAnimationKey as extractAnimationKey, __webpackgi_exports__flattenUiConfig as flattenUiConfig, __webpackgi_exports__flip as flip, __webpackgi_exports__fontFormatExtensionMap as fontFormatExtensionMap, __webpackgi_exports__generateUiConfig as generateUiConfig, __webpackgi_exports__generateUiFolder as generateUiFolder, __webpackgi_exports__getEncodingComponents as getEncodingComponents, __webpackgi_exports__getFilenameFromPath as getFilenameFromPath, __webpackgi_exports__getKeyByValue as getKeyByValue, __webpackgi_exports__getOrCall as getOrCall, __webpackgi_exports__getPropertyDescriptor as getPropertyDescriptor, __webpackgi_exports__getTexelDecoding as getTexelDecoding, __webpackgi_exports__getTexelDecoding2 as getTexelDecoding2, __webpackgi_exports__getTexelDecodingFunction as getTexelDecodingFunction, __webpackgi_exports__getTexelEncoding as getTexelEncoding, __webpackgi_exports__getTexelEncodingFunction as getTexelEncodingFunction, __webpackgi_exports__getTextureDataType as getTextureDataType, __webpackgi_exports__getTextureEncodingFromMap as getTextureEncodingFromMap, __webpackgi_exports__getUrlQueryParam as getUrlQueryParam, __webpackgi_exports__glsl as glsl, __webpackgi_exports__gunzip as gunzip, __webpackgi_exports__gunzipSync as gunzipSync, __webpackgi_exports__gzip as gzip, __webpackgi_exports__gzipSync as gzipSync, __webpackgi_exports__hide as hide, __webpackgi_exports__html as html, __webpackgi_exports__htmlToCanvas as htmlToCanvas, __webpackgi_exports__htmlToPng as htmlToPng, __webpackgi_exports__htmlToSvg as htmlToSvg, __webpackgi_exports__iGeometryIgnoredUserData as iGeometryIgnoredUserData, __webpackgi_exports__iMaterialIgnoredUserData as iMaterialIgnoredUserData, __webpackgi_exports__iModelIgnoredUserData as iModelIgnoredUserData, __webpackgi_exports__imageBitmapToBase64 as imageBitmapToBase64, __webpackgi_exports__imageToCanvas as imageToCanvas, __webpackgi_exports__imageUrlToImageData as imageUrlToImageData, __webpackgi_exports__includesAll as includesAll, __webpackgi_exports__inflate as inflate, __webpackgi_exports__inflateSync as inflateSync, __webpackgi_exports__isAnimatableType as isAnimatableType, __webpackgi_exports__isPropertyWritable as isPropertyWritable, __webpackgi_exports__left as left, __webpackgi_exports__lerpAngle as lerpAngle, __webpackgi_exports__lerpAngle2 as lerpAngle2, __webpackgi_exports__main as main, __webpackgi_exports__makeColorSvg as makeColorSvg, __webpackgi_exports__makeColorSvgCircle as makeColorSvgCircle, __webpackgi_exports__makeFilter as makeFilter, __webpackgi_exports__makeGeometryUiConfig as makeGeometryUiConfig, __webpackgi_exports__makeObject3DUiConfig as makeObject3DUiConfig, __webpackgi_exports__makeSetterFor as makeSetterFor, __webpackgi_exports__makeSetterForAnimObject as makeSetterForAnimObject, __webpackgi_exports__makeTextSvg as makeTextSvg, __webpackgi_exports__matDefine as matDefine, __webpackgi_exports__mobileAndTabletCheck as mobileAndTabletCheck, __webpackgi_exports__modifierPhases as modifierPhases, __webpackgi_exports__now as now, __webpackgi_exports__offset as offset, __webpackgi_exports__onChange as onChange, __webpackgi_exports__parseFileExtension as parseFileExtension, __webpackgi_exports__patchShaderEncodingSupport as patchShaderEncodingSupport, __webpackgi_exports__pathJoin as pathJoin, __webpackgi_exports__physicalMaterialPropList as physicalMaterialPropList, __webpackgi_exports__placements as placements, __webpackgi_exports__popper as popper, __webpackgi_exports__popperGenerator as popperGenerator, __webpackgi_exports__popperOffsets as popperOffsets, __webpackgi_exports__preventOverflow as preventOverflow, __webpackgi_exports__processViewer as processViewer, __webpackgi_exports__read as read, __webpackgi_exports__reference as reference, __webpackgi_exports__removeDuplicateGeometries as removeDuplicateGeometries, __webpackgi_exports__replaceAll as replaceAll, __webpackgi_exports__right as right, __webpackgi_exports__rotateDuplicatedMesh as rotateDuplicatedMesh, __webpackgi_exports__sRGBEncoding as sRGBEncoding, __webpackgi_exports__safeSetProperty as safeSetProperty, __webpackgi_exports__serializable as serializable, __webpackgi_exports__serialize as serialize, __webpackgi_exports__serializeObject as serializeObject, __webpackgi_exports__serializers as serializers, __webpackgi_exports__setMeshGeometry as setMeshGeometry, __webpackgi_exports__setMeshMaterial as setMeshMaterial, __webpackgi_exports__setThreeRendererMode as setThreeRendererMode, __webpackgi_exports__setUrlQueryParam as setUrlQueryParam, __webpackgi_exports__setupCoreWebGiViewer as setupCoreWebGiViewer, __webpackgi_exports__setupIModel as setupIModel, __webpackgi_exports__setupObject3dModel as setupObject3dModel, __webpackgi_exports__setupSandboxWebGiEditor as setupSandboxWebGiEditor, __webpackgi_exports__shaderReplaceString as shaderReplaceString, __webpackgi_exports__slerp as slerp, __webpackgi_exports__snapObject as snapObject, __webpackgi_exports__sphericalFromObject as sphericalFromObject, __webpackgi_exports__standardMaterialPropList as standardMaterialPropList, __webpackgi_exports__start as start, __webpackgi_exports__strFromU8 as strFromU8, __webpackgi_exports__strToU8 as strToU8, __webpackgi_exports__svgToCanvas as svgToCanvas, __webpackgi_exports__svgToPng as svgToPng, __webpackgi_exports__svgUrl as svgUrl, __webpackgi_exports__syncAnimSetUi as syncAnimSetUi, __webpackgi_exports__timeout as timeout, __webpackgi_exports__toIndexedGeometry as toIndexedGeometry, __webpackgi_exports__toTitleCase as toTitleCase, __webpackgi_exports__top as top, __webpackgi_exports__uiButton as uiButton, __webpackgi_exports__uiColor as uiColor, __webpackgi_exports__uiConfig as uiConfig, __webpackgi_exports__uiDropdown as uiDropdown, __webpackgi_exports__uiFolder as uiFolder, __webpackgi_exports__uiImage as uiImage, __webpackgi_exports__uiInput as uiInput, __webpackgi_exports__uiMonitor as uiMonitor, __webpackgi_exports__uiSlider as uiSlider, __webpackgi_exports__uiToggle as uiToggle, __webpackgi_exports__uiVector as uiVector, __webpackgi_exports__uniform as uniform, __webpackgi_exports__unzip as unzip, __webpackgi_exports__unzipSync as unzipSync, __webpackgi_exports__unzlib as unzlib, __webpackgi_exports__unzlibSync as unzlibSync, __webpackgi_exports__uploadFile as uploadFile, __webpackgi_exports__vLinearToRGBM as vLinearToRGBM, __webpackgi_exports__vRGBMToLinear as vRGBMToLinear, __webpackgi_exports__variationPlacements as variationPlacements, __webpackgi_exports__verifyPermission as verifyPermission, __webpackgi_exports__viewerGLTFExtension as viewerGLTFExtension, __webpackgi_exports__viewport as viewport, __webpackgi_exports__webgiLightExtrasExtension as webgiLightExtrasExtension, __webpackgi_exports__webgiMaterialExtrasExtension as webgiMaterialExtrasExtension, __webpackgi_exports__webgiObject3DExtrasExtension as webgiObject3DExtrasExtension, __webpackgi_exports__write as write, __webpackgi_exports__writeFile as writeFile, __webpackgi_exports__zip as zip, __webpackgi_exports__zipSync as zipSync, __webpackgi_exports__zlib as zlib, __webpackgi_exports__zlibSync as zlibSync
};
//# sourceMappingURL=bundle.m.js.map